/*!
 * @maptalks/gl v0.81.2
 * LICENSE : UNLICENSED
 * (c) 2016-2023 maptalks.com
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('maptalks')) :
	typeof define === 'function' && define.amd ? define(['exports', 'maptalks'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.maptalksgl = {}, global.maptalks));
})(this, (function (exports, t$1) { 'use strict';

	function _interopNamespace(e) {
		if (e && e.__esModule) return e;
		var n = Object.create(null);
		if (e) {
			Object.keys(e).forEach(function (k) {
				if (k !== 'default') {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		}
		n["default"] = e;
		return Object.freeze(n);
	}

	var t__namespace = /*#__PURE__*/_interopNamespace(t$1);

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	var regl = {exports: {}};

	(function (module, exports) {
	(function (global, factory) {
	    module.exports = factory() ;
	}(commonjsGlobal, (function () {
	var isTypedArray = function (x) {
	  return (
	    x instanceof Uint8Array ||
	    x instanceof Uint16Array ||
	    x instanceof Uint32Array ||
	    x instanceof Int8Array ||
	    x instanceof Int16Array ||
	    x instanceof Int32Array ||
	    x instanceof Float32Array ||
	    x instanceof Float64Array ||
	    x instanceof Uint8ClampedArray
	  )
	};

	var extend = function (base, opts) {
	  var keys = Object.keys(opts);
	  for (var i = 0; i < keys.length; ++i) {
	    base[keys[i]] = opts[keys[i]];
	  }
	  return base
	};

	// Error checking and parameter validation.
	//
	// Statements for the form `check.someProcedure(...)` get removed by
	// a browserify transform for optimized/minified bundles.
	//
	/* globals atob */
	var endl = '\n';

	// only used for extracting shader names.  if atob not present, then errors
	// will be slightly crappier
	function decodeB64 (str) {
	  if (typeof atob !== 'undefined') {
	    return atob(str)
	  }
	  return 'base64:' + str
	}

	function raise (message) {
	  var error = new Error('(regl) ' + message);
	  console.error(error);
	  throw error
	}

	function check (pred, message) {
	  if (!pred) {
	    raise(message);
	  }
	}

	function encolon (message) {
	  if (message) {
	    return ': ' + message
	  }
	  return ''
	}

	function checkParameter (param, possibilities, message) {
	  if (!(param in possibilities)) {
	    raise('unknown parameter (' + param + ')' + encolon(message) +
	          '. possible values: ' + Object.keys(possibilities).join());
	  }
	}

	function checkIsTypedArray (data, message) {
	  if (!isTypedArray(data)) {
	    raise(
	      'invalid parameter type' + encolon(message) +
	      '. must be a typed array');
	  }
	}

	function standardTypeEh (value, type) {
	  switch (type) {
	    case 'number': return typeof value === 'number'
	    case 'object': return typeof value === 'object'
	    case 'string': return typeof value === 'string'
	    case 'boolean': return typeof value === 'boolean'
	    case 'function': return typeof value === 'function'
	    case 'undefined': return typeof value === 'undefined'
	    case 'symbol': return typeof value === 'symbol'
	  }
	}

	function checkTypeOf (value, type, message) {
	  if (!standardTypeEh(value, type)) {
	    raise(
	      'invalid parameter type' + encolon(message) +
	      '. expected ' + type + ', got ' + (typeof value));
	  }
	}

	function checkNonNegativeInt (value, message) {
	  if (!((value >= 0) &&
	        ((value | 0) === value))) {
	    raise('invalid parameter type, (' + value + ')' + encolon(message) +
	          '. must be a nonnegative integer');
	  }
	}

	function checkOneOf (value, list, message) {
	  if (list.indexOf(value) < 0) {
	    raise('invalid value' + encolon(message) + '. must be one of: ' + list);
	  }
	}

	var constructorKeys = [
	  'gl',
	  'canvas',
	  'container',
	  'attributes',
	  'pixelRatio',
	  'extensions',
	  'optionalExtensions',
	  'profile',
	  'onDone'
	];

	function checkConstructor (obj) {
	  Object.keys(obj).forEach(function (key) {
	    if (constructorKeys.indexOf(key) < 0) {
	      raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys);
	    }
	  });
	}

	function leftPad (str, n) {
	  str = str + '';
	  while (str.length < n) {
	    str = ' ' + str;
	  }
	  return str
	}

	function ShaderFile () {
	  this.name = 'unknown';
	  this.lines = [];
	  this.index = {};
	  this.hasErrors = false;
	}

	function ShaderLine (number, line) {
	  this.number = number;
	  this.line = line;
	  this.errors = [];
	}

	function ShaderError (fileNumber, lineNumber, message) {
	  this.file = fileNumber;
	  this.line = lineNumber;
	  this.message = message;
	}

	function guessCommand () {
	  var error = new Error();
	  var stack = (error.stack || error).toString();
	  var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack);
	  if (pat) {
	    return pat[1]
	  }
	  var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack);
	  if (pat2) {
	    return pat2[1]
	  }
	  return 'unknown'
	}

	function guessCallSite () {
	  var error = new Error();
	  var stack = (error.stack || error).toString();
	  var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack);
	  if (pat) {
	    return pat[1]
	  }
	  var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack);
	  if (pat2) {
	    return pat2[1]
	  }
	  return 'unknown'
	}

	function parseSource (source, command) {
	  var lines = source.split('\n');
	  var lineNumber = 1;
	  var fileNumber = 0;
	  var files = {
	    unknown: new ShaderFile(),
	    0: new ShaderFile()
	  };
	  files.unknown.name = files[0].name = command || guessCommand();
	  files.unknown.lines.push(new ShaderLine(0, ''));
	  for (var i = 0; i < lines.length; ++i) {
	    var line = lines[i];
	    var parts = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(line);
	    if (parts) {
	      switch (parts[1]) {
	        case 'line':
	          var lineNumberInfo = /(\d+)(\s+\d+)?/.exec(parts[2]);
	          if (lineNumberInfo) {
	            lineNumber = lineNumberInfo[1] | 0;
	            if (lineNumberInfo[2]) {
	              fileNumber = lineNumberInfo[2] | 0;
	              if (!(fileNumber in files)) {
	                files[fileNumber] = new ShaderFile();
	              }
	            }
	          }
	          break
	        case 'define':
	          var nameInfo = /SHADER_NAME(_B64)?\s+(.*)$/.exec(parts[2]);
	          if (nameInfo) {
	            files[fileNumber].name = (nameInfo[1]
	              ? decodeB64(nameInfo[2])
	              : nameInfo[2]);
	          }
	          break
	      }
	    }
	    files[fileNumber].lines.push(new ShaderLine(lineNumber++, line));
	  }
	  Object.keys(files).forEach(function (fileNumber) {
	    var file = files[fileNumber];
	    file.lines.forEach(function (line) {
	      file.index[line.number] = line;
	    });
	  });
	  return files
	}

	function parseErrorLog (errLog) {
	  var result = [];
	  errLog.split('\n').forEach(function (errMsg) {
	    if (errMsg.length < 5) {
	      return
	    }
	    var parts = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(errMsg);
	    if (parts) {
	      result.push(new ShaderError(
	        parts[1] | 0,
	        parts[2] | 0,
	        parts[3].trim()));
	    } else if (errMsg.length > 0) {
	      result.push(new ShaderError('unknown', 0, errMsg));
	    }
	  });
	  return result
	}

	function annotateFiles (files, errors) {
	  errors.forEach(function (error) {
	    var file = files[error.file];
	    if (file) {
	      var line = file.index[error.line];
	      if (line) {
	        line.errors.push(error);
	        file.hasErrors = true;
	        return
	      }
	    }
	    files.unknown.hasErrors = true;
	    files.unknown.lines[0].errors.push(error);
	  });
	}

	function checkShaderError (gl, shader, source, type, command) {
	  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
	    var errLog = gl.getShaderInfoLog(shader);
	    var typeName = type === gl.FRAGMENT_SHADER ? 'fragment' : 'vertex';
	    checkCommandType(source, 'string', typeName + ' shader source must be a string', command);
	    var files = parseSource(source, command);
	    var errors = parseErrorLog(errLog);
	    annotateFiles(files, errors);

	    Object.keys(files).forEach(function (fileNumber) {
	      var file = files[fileNumber];
	      if (!file.hasErrors) {
	        return
	      }

	      var strings = [''];
	      var styles = [''];

	      function push (str, style) {
	        strings.push(str);
	        styles.push(style || '');
	      }

	      push('file number ' + fileNumber + ': ' + file.name + '\n', 'color:red;text-decoration:underline;font-weight:bold');

	      file.lines.forEach(function (line) {
	        if (line.errors.length > 0) {
	          push(leftPad(line.number, 4) + '|  ', 'background-color:yellow; font-weight:bold');
	          push(line.line + endl, 'color:red; background-color:yellow; font-weight:bold');

	          // try to guess token
	          var offset = 0;
	          line.errors.forEach(function (error) {
	            var message = error.message;
	            var token = /^\s*'(.*)'\s*:\s*(.*)$/.exec(message);
	            if (token) {
	              var tokenPat = token[1];
	              message = token[2];
	              switch (tokenPat) {
	                case 'assign':
	                  tokenPat = '=';
	                  break
	              }
	              offset = Math.max(line.line.indexOf(tokenPat, offset), 0);
	            } else {
	              offset = 0;
	            }

	            push(leftPad('| ', 6));
	            push(leftPad('^^^', offset + 3) + endl, 'font-weight:bold');
	            push(leftPad('| ', 6));
	            push(message + endl, 'font-weight:bold');
	          });
	          push(leftPad('| ', 6) + endl);
	        } else {
	          push(leftPad(line.number, 4) + '|  ');
	          push(line.line + endl, 'color:red');
	        }
	      });
	      if (typeof document !== 'undefined' && !window.chrome) {
	        styles[0] = strings.join('%c');
	        console.log.apply(console, styles);
	      } else {
	        console.log(strings.join(''));
	      }
	    });

	    check.raise('Error compiling ' + typeName + ' shader, ' + files[0].name);
	  }
	}

	function checkLinkError (gl, program, fragShader, vertShader, command) {
	  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
	    var errLog = gl.getProgramInfoLog(program);
	    var fragParse = parseSource(fragShader, command);
	    var vertParse = parseSource(vertShader, command);

	    var header = 'Error linking program with vertex shader, "' +
	      vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"';

	    if (typeof document !== 'undefined') {
	      console.log('%c' + header + endl + '%c' + errLog,
	        'color:red;text-decoration:underline;font-weight:bold',
	        'color:red');
	    } else {
	      console.log(header + endl + errLog);
	    }
	    check.raise(header);
	  }
	}

	function saveCommandRef (object) {
	  object._commandRef = guessCommand();
	}

	function saveDrawCommandInfo (opts, uniforms, attributes, stringStore) {
	  saveCommandRef(opts);

	  function id (str) {
	    if (str) {
	      return stringStore.id(str)
	    }
	    return 0
	  }
	  opts._fragId = id(opts.static.frag);
	  opts._vertId = id(opts.static.vert);

	  function addProps (dict, set) {
	    Object.keys(set).forEach(function (u) {
	      dict[stringStore.id(u)] = true;
	    });
	  }

	  var uniformSet = opts._uniformSet = {};
	  addProps(uniformSet, uniforms.static);
	  addProps(uniformSet, uniforms.dynamic);

	  var attributeSet = opts._attributeSet = {};
	  addProps(attributeSet, attributes.static);
	  addProps(attributeSet, attributes.dynamic);

	  opts._hasCount = (
	    'count' in opts.static ||
	    'count' in opts.dynamic ||
	    'elements' in opts.static ||
	    'elements' in opts.dynamic);
	}

	function commandRaise (message, command) {
	  var callSite = guessCallSite();
	  raise(message +
	    ' in command ' + (command || guessCommand()) +
	    (callSite === 'unknown' ? '' : ' called from ' + callSite));
	}

	function checkCommand (pred, message, command) {
	  if (!pred) {
	    commandRaise(message, command || guessCommand());
	  }
	}

	function checkParameterCommand (param, possibilities, message, command) {
	  if (!(param in possibilities)) {
	    commandRaise(
	      'unknown parameter (' + param + ')' + encolon(message) +
	      '. possible values: ' + Object.keys(possibilities).join(),
	      command || guessCommand());
	  }
	}

	function checkCommandType (value, type, message, command) {
	  if (!standardTypeEh(value, type)) {
	    commandRaise(
	      'invalid parameter type' + encolon(message) +
	      '. expected ' + type + ', got ' + (typeof value),
	      command || guessCommand());
	  }
	}

	function checkOptional (block) {
	  block();
	}

	function checkFramebufferFormat (attachment, texFormats, rbFormats) {
	  if (attachment.texture) {
	    checkOneOf(
	      attachment.texture._texture.internalformat,
	      texFormats,
	      'unsupported texture format for attachment');
	  } else {
	    checkOneOf(
	      attachment.renderbuffer._renderbuffer.format,
	      rbFormats,
	      'unsupported renderbuffer format for attachment');
	  }
	}

	var GL_CLAMP_TO_EDGE = 0x812F;

	var GL_NEAREST = 0x2600;
	var GL_NEAREST_MIPMAP_NEAREST = 0x2700;
	var GL_LINEAR_MIPMAP_NEAREST = 0x2701;
	var GL_NEAREST_MIPMAP_LINEAR = 0x2702;
	var GL_LINEAR_MIPMAP_LINEAR = 0x2703;

	var GL_BYTE = 5120;
	var GL_UNSIGNED_BYTE = 5121;
	var GL_SHORT = 5122;
	var GL_UNSIGNED_SHORT = 5123;
	var GL_INT = 5124;
	var GL_UNSIGNED_INT = 5125;
	var GL_FLOAT = 5126;

	var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;
	var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;
	var GL_UNSIGNED_SHORT_5_6_5 = 0x8363;
	var GL_UNSIGNED_INT_24_8_WEBGL = 0x84FA;

	var GL_HALF_FLOAT_OES = 0x8D61;

	var TYPE_SIZE = {};

	TYPE_SIZE[GL_BYTE] =
	TYPE_SIZE[GL_UNSIGNED_BYTE] = 1;

	TYPE_SIZE[GL_SHORT] =
	TYPE_SIZE[GL_UNSIGNED_SHORT] =
	TYPE_SIZE[GL_HALF_FLOAT_OES] =
	TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] =
	TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] =
	TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2;

	TYPE_SIZE[GL_INT] =
	TYPE_SIZE[GL_UNSIGNED_INT] =
	TYPE_SIZE[GL_FLOAT] =
	TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4;

	function pixelSize (type, channels) {
	  if (type === GL_UNSIGNED_SHORT_5_5_5_1 ||
	      type === GL_UNSIGNED_SHORT_4_4_4_4 ||
	      type === GL_UNSIGNED_SHORT_5_6_5) {
	    return 2
	  } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {
	    return 4
	  } else {
	    return TYPE_SIZE[type] * channels
	  }
	}

	function isPow2 (v) {
	  return !(v & (v - 1)) && (!!v)
	}

	function checkTexture2D (info, mipData, limits) {
	  var i;
	  var w = mipData.width;
	  var h = mipData.height;
	  var c = mipData.channels;

	  // Check texture shape
	  check(w > 0 && w <= limits.maxTextureSize &&
	        h > 0 && h <= limits.maxTextureSize,
	  'invalid texture shape');

	  // check wrap mode
	  if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
	    check(isPow2(w) && isPow2(h),
	      'incompatible wrap mode for texture, both width and height must be power of 2');
	  }

	  if (mipData.mipmask === 1) {
	    if (w !== 1 && h !== 1) {
	      check(
	        info.minFilter !== GL_NEAREST_MIPMAP_NEAREST &&
	        info.minFilter !== GL_NEAREST_MIPMAP_LINEAR &&
	        info.minFilter !== GL_LINEAR_MIPMAP_NEAREST &&
	        info.minFilter !== GL_LINEAR_MIPMAP_LINEAR,
	        'min filter requires mipmap');
	    }
	  } else {
	    // texture must be power of 2
	    check(isPow2(w) && isPow2(h),
	      'texture must be a square power of 2 to support mipmapping');
	    check(mipData.mipmask === (w << 1) - 1,
	      'missing or incomplete mipmap data');
	  }

	  if (mipData.type === GL_FLOAT) {
	    if (limits.extensions.indexOf('oes_texture_float_linear') < 0) {
	      check(info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST,
	        'filter not supported, must enable oes_texture_float_linear');
	    }
	    check(!info.genMipmaps,
	      'mipmap generation not supported with float textures');
	  }

	  // check image complete
	  var mipimages = mipData.images;
	  for (i = 0; i < 16; ++i) {
	    if (mipimages[i]) {
	      var mw = w >> i;
	      var mh = h >> i;
	      check(mipData.mipmask & (1 << i), 'missing mipmap data');

	      var img = mipimages[i];

	      check(
	        img.width === mw &&
	        img.height === mh,
	        'invalid shape for mip images');

	      check(
	        img.format === mipData.format &&
	        img.internalformat === mipData.internalformat &&
	        img.type === mipData.type,
	        'incompatible type for mip image');

	      if (img.compressed) ; else if (img.data) {
	        // check(img.data.byteLength === mw * mh *
	        // Math.max(pixelSize(img.type, c), img.unpackAlignment),
	        var rowSize = Math.ceil(pixelSize(img.type, c) * mw / img.unpackAlignment) * img.unpackAlignment;
	        check(img.data.byteLength === rowSize * mh,
	          'invalid data for image, buffer size is inconsistent with image format');
	      } else if (img.element) ; else if (img.copy) ;
	    } else if (!info.genMipmaps) {
	      check((mipData.mipmask & (1 << i)) === 0, 'extra mipmap data');
	    }
	  }

	  if (mipData.compressed) {
	    check(!info.genMipmaps,
	      'mipmap generation for compressed images not supported');
	  }
	}

	function checkTextureCube (texture, info, faces, limits) {
	  var w = texture.width;
	  var h = texture.height;
	  var c = texture.channels;

	  // Check texture shape
	  check(
	    w > 0 && w <= limits.maxTextureSize && h > 0 && h <= limits.maxTextureSize,
	    'invalid texture shape');
	  check(
	    w === h,
	    'cube map must be square');
	  check(
	    info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE,
	    'wrap mode not supported by cube map');

	  for (var i = 0; i < faces.length; ++i) {
	    var face = faces[i];
	    check(
	      face.width === w && face.height === h,
	      'inconsistent cube map face shape');

	    if (info.genMipmaps) {
	      check(!face.compressed,
	        'can not generate mipmap for compressed textures');
	      check(face.mipmask === 1,
	        'can not specify mipmaps and generate mipmaps');
	    }

	    var mipmaps = face.images;
	    for (var j = 0; j < 16; ++j) {
	      var img = mipmaps[j];
	      if (img) {
	        var mw = w >> j;
	        var mh = h >> j;
	        check(face.mipmask & (1 << j), 'missing mipmap data');
	        check(
	          img.width === mw &&
	          img.height === mh,
	          'invalid shape for mip images');
	        check(
	          img.format === texture.format &&
	          img.internalformat === texture.internalformat &&
	          img.type === texture.type,
	          'incompatible type for mip image');

	        if (img.compressed) ; else if (img.data) {
	          check(img.data.byteLength === mw * mh *
	            Math.max(pixelSize(img.type, c), img.unpackAlignment),
	          'invalid data for image, buffer size is inconsistent with image format');
	        } else if (img.element) ; else if (img.copy) ;
	      }
	    }
	  }
	}

	var check$1 = extend(check, {
	  optional: checkOptional,
	  raise: raise,
	  commandRaise: commandRaise,
	  command: checkCommand,
	  parameter: checkParameter,
	  commandParameter: checkParameterCommand,
	  constructor: checkConstructor,
	  type: checkTypeOf,
	  commandType: checkCommandType,
	  isTypedArray: checkIsTypedArray,
	  nni: checkNonNegativeInt,
	  oneOf: checkOneOf,
	  shaderError: checkShaderError,
	  linkError: checkLinkError,
	  callSite: guessCallSite,
	  saveCommandRef: saveCommandRef,
	  saveDrawInfo: saveDrawCommandInfo,
	  framebufferFormat: checkFramebufferFormat,
	  guessCommand: guessCommand,
	  texture2D: checkTexture2D,
	  textureCube: checkTextureCube
	});

	var VARIABLE_COUNTER = 0;

	var DYN_FUNC = 0;
	var DYN_CONSTANT = 5;
	var DYN_ARRAY = 6;

	function DynamicVariable (type, data) {
	  this.id = (VARIABLE_COUNTER++);
	  this.type = type;
	  this.data = data;
	}

	function escapeStr (str) {
	  return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"')
	}

	function splitParts (str) {
	  if (str.length === 0) {
	    return []
	  }

	  var firstChar = str.charAt(0);
	  var lastChar = str.charAt(str.length - 1);

	  if (str.length > 1 &&
	      firstChar === lastChar &&
	      (firstChar === '"' || firstChar === "'")) {
	    return ['"' + escapeStr(str.substr(1, str.length - 2)) + '"']
	  }

	  var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str);
	  if (parts) {
	    return (
	      splitParts(str.substr(0, parts.index))
	        .concat(splitParts(parts[1]))
	        .concat(splitParts(str.substr(parts.index + parts[0].length)))
	    )
	  }

	  var subparts = str.split('.');
	  if (subparts.length === 1) {
	    return ['"' + escapeStr(str) + '"']
	  }

	  var result = [];
	  for (var i = 0; i < subparts.length; ++i) {
	    result = result.concat(splitParts(subparts[i]));
	  }
	  return result
	}

	function toAccessorString (str) {
	  return '[' + splitParts(str).join('][') + ']'
	}

	function defineDynamic (type, data) {
	  return new DynamicVariable(type, toAccessorString(data + ''))
	}

	function isDynamic (x) {
	  return (typeof x === 'function' && !x._reglType) || (x instanceof DynamicVariable)
	}

	function unbox (x, path) {
	  if (typeof x === 'function') {
	    return new DynamicVariable(DYN_FUNC, x)
	  } else if (typeof x === 'number' || typeof x === 'boolean') {
	    return new DynamicVariable(DYN_CONSTANT, x)
	  } else if (Array.isArray(x)) {
	    return new DynamicVariable(DYN_ARRAY, x.map(function (y, i) { return unbox(y, path + '[' + i + ']') }))
	  } else if (x instanceof DynamicVariable) {
	    return x
	  }
	  check$1(false, 'invalid option type in uniform ' + path);
	}

	var dynamic = {
	  DynamicVariable: DynamicVariable,
	  define: defineDynamic,
	  isDynamic: isDynamic,
	  unbox: unbox,
	  accessor: toAccessorString
	};

	/* globals requestAnimationFrame, cancelAnimationFrame */
	var raf = {
	  next: typeof requestAnimationFrame === 'function'
	    ? function (cb) { return requestAnimationFrame(cb) }
	    : function (cb) { return setTimeout(cb, 16) },
	  cancel: typeof cancelAnimationFrame === 'function'
	    ? function (raf) { return cancelAnimationFrame(raf) }
	    : clearTimeout
	};

	/* globals performance */
	var clock = (typeof performance !== 'undefined' && performance.now)
	    ? function () { return performance.now() }
	    : function () { return +(new Date()) };

	function createStringStore () {
	  var stringIds = { '': 0 };
	  var stringValues = [''];
	  return {
	    id: function (str) {
	      var result = stringIds[str];
	      if (result) {
	        return result
	      }
	      result = stringIds[str] = stringValues.length;
	      stringValues.push(str);
	      return result
	    },

	    str: function (id) {
	      return stringValues[id]
	    }
	  }
	}

	// Context and canvas creation helper functions
	function createCanvas (element, onDone, pixelRatio) {
	  var canvas = document.createElement('canvas');
	  extend(canvas.style, {
	    border: 0,
	    margin: 0,
	    padding: 0,
	    top: 0,
	    left: 0
	  });
	  element.appendChild(canvas);

	  if (element === document.body) {
	    canvas.style.position = 'absolute';
	    extend(element.style, {
	      margin: 0,
	      padding: 0
	    });
	  }

	  function resize () {
	    var w = window.innerWidth;
	    var h = window.innerHeight;
	    if (element !== document.body) {
	      var bounds = element.getBoundingClientRect();
	      w = bounds.right - bounds.left;
	      h = bounds.bottom - bounds.top;
	    }
	    canvas.width = pixelRatio * w;
	    canvas.height = pixelRatio * h;
	    extend(canvas.style, {
	      width: w + 'px',
	      height: h + 'px'
	    });
	  }

	  var resizeObserver;
	  if (element !== document.body && typeof ResizeObserver === 'function') {
	    // ignore 'ResizeObserver' is not defined
	    // eslint-disable-next-line
	    resizeObserver = new ResizeObserver(function () {
	      // setTimeout to avoid flicker
	      setTimeout(resize);
	    });
	    resizeObserver.observe(element);
	  } else {
	    window.addEventListener('resize', resize, false);
	  }

	  function onDestroy () {
	    if (resizeObserver) {
	      resizeObserver.disconnect();
	    } else {
	      window.removeEventListener('resize', resize);
	    }
	    element.removeChild(canvas);
	  }

	  resize();

	  return {
	    canvas: canvas,
	    onDestroy: onDestroy
	  }
	}

	function createContext (canvas, contextAttributes) {
	  function get (name) {
	    try {
	      return canvas.getContext(name, contextAttributes)
	    } catch (e) {
	      return null
	    }
	  }
	  return (
	    get('webgl') ||
	    get('experimental-webgl') ||
	    get('webgl-experimental')
	  )
	}

	function isHTMLElement (obj) {
	  return (
	    typeof obj.nodeName === 'string' &&
	    typeof obj.appendChild === 'function' &&
	    typeof obj.getBoundingClientRect === 'function'
	  )
	}

	function isWebGLContext (obj) {
	  return (
	    typeof obj.drawArrays === 'function' ||
	    typeof obj.drawElements === 'function'
	  )
	}

	function parseExtensions (input) {
	  if (typeof input === 'string') {
	    return input.split()
	  }
	  check$1(Array.isArray(input), 'invalid extension array');
	  return input
	}

	function getElement (desc) {
	  if (typeof desc === 'string') {
	    check$1(typeof document !== 'undefined', 'not supported outside of DOM');
	    return document.querySelector(desc)
	  }
	  return desc
	}

	function parseArgs (args_) {
	  var args = args_ || {};
	  var element, container, canvas, gl;
	  var contextAttributes = {};
	  var extensions = [];
	  var optionalExtensions = [];
	  var pixelRatio = (typeof window === 'undefined' ? 1 : window.devicePixelRatio);
	  var profile = false;
	  var onDone = function (err) {
	    if (err) {
	      check$1.raise(err);
	    }
	  };
	  var onDestroy = function () {};
	  if (typeof args === 'string') {
	    check$1(
	      typeof document !== 'undefined',
	      'selector queries only supported in DOM enviroments');
	    element = document.querySelector(args);
	    check$1(element, 'invalid query string for element');
	  } else if (typeof args === 'object') {
	    if (isHTMLElement(args)) {
	      element = args;
	    } else if (isWebGLContext(args)) {
	      gl = args;
	      canvas = gl.canvas;
	    } else {
	      check$1.constructor(args);
	      if ('gl' in args) {
	        gl = args.gl;
	      } else if ('canvas' in args) {
	        canvas = getElement(args.canvas);
	      } else if ('container' in args) {
	        container = getElement(args.container);
	      }
	      if ('attributes' in args) {
	        contextAttributes = args.attributes;
	        check$1.type(contextAttributes, 'object', 'invalid context attributes');
	      }
	      if ('extensions' in args) {
	        extensions = parseExtensions(args.extensions);
	      }
	      if ('optionalExtensions' in args) {
	        optionalExtensions = parseExtensions(args.optionalExtensions);
	      }
	      if ('onDone' in args) {
	        check$1.type(
	          args.onDone, 'function',
	          'invalid or missing onDone callback');
	        onDone = args.onDone;
	      }
	      if ('profile' in args) {
	        profile = !!args.profile;
	      }
	      if ('pixelRatio' in args) {
	        pixelRatio = +args.pixelRatio;
	        check$1(pixelRatio > 0, 'invalid pixel ratio');
	      }
	    }
	  } else {
	    check$1.raise('invalid arguments to regl');
	  }

	  if (element) {
	    if (element.nodeName.toLowerCase() === 'canvas') {
	      canvas = element;
	    } else {
	      container = element;
	    }
	  }

	  if (!gl) {
	    if (!canvas) {
	      check$1(
	        typeof document !== 'undefined',
	        'must manually specify webgl context outside of DOM environments');
	      var result = createCanvas(container || document.body, onDone, pixelRatio);
	      if (!result) {
	        return null
	      }
	      canvas = result.canvas;
	      onDestroy = result.onDestroy;
	    }
	    // workaround for chromium bug, premultiplied alpha value is platform dependent
	    if (contextAttributes.premultipliedAlpha === undefined) contextAttributes.premultipliedAlpha = true;
	    gl = createContext(canvas, contextAttributes);
	  }

	  if (!gl) {
	    onDestroy();
	    onDone('webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org');
	    return null
	  }

	  return {
	    gl: gl,
	    canvas: canvas,
	    container: container,
	    extensions: extensions,
	    optionalExtensions: optionalExtensions,
	    pixelRatio: pixelRatio,
	    profile: profile,
	    onDone: onDone,
	    onDestroy: onDestroy
	  }
	}

	function createExtensionCache (gl, config) {
	  var extensions = {};

	  function tryLoadExtension (name_) {
	    check$1.type(name_, 'string', 'extension name must be string');
	    var name = name_.toLowerCase();
	    var ext;
	    try {
	      ext = extensions[name] = gl.getExtension(name);
	    } catch (e) {}
	    return !!ext
	  }

	  for (var i = 0; i < config.extensions.length; ++i) {
	    var name = config.extensions[i];
	    if (!tryLoadExtension(name)) {
	      config.onDestroy();
	      config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser');
	      return null
	    }
	  }

	  config.optionalExtensions.forEach(tryLoadExtension);

	  return {
	    extensions: extensions,
	    restore: function () {
	      Object.keys(extensions).forEach(function (name) {
	        if (extensions[name] && !tryLoadExtension(name)) {
	          throw new Error('(regl): error restoring extension ' + name)
	        }
	      });
	    }
	  }
	}

	function loop (n, f) {
	  var result = Array(n);
	  for (var i = 0; i < n; ++i) {
	    result[i] = f(i);
	  }
	  return result
	}

	var GL_BYTE$1 = 5120;
	var GL_UNSIGNED_BYTE$2 = 5121;
	var GL_SHORT$1 = 5122;
	var GL_UNSIGNED_SHORT$1 = 5123;
	var GL_INT$1 = 5124;
	var GL_UNSIGNED_INT$1 = 5125;
	var GL_FLOAT$2 = 5126;

	function nextPow16 (v) {
	  for (var i = 16; i <= (1 << 28); i *= 16) {
	    if (v <= i) {
	      return i
	    }
	  }
	  return 0
	}

	function log2 (v) {
	  var r, shift;
	  r = (v > 0xFFFF) << 4;
	  v >>>= r;
	  shift = (v > 0xFF) << 3;
	  v >>>= shift; r |= shift;
	  shift = (v > 0xF) << 2;
	  v >>>= shift; r |= shift;
	  shift = (v > 0x3) << 1;
	  v >>>= shift; r |= shift;
	  return r | (v >> 1)
	}

	function createPool () {
	  var bufferPool = loop(8, function () {
	    return []
	  });

	  function alloc (n) {
	    var sz = nextPow16(n);
	    var bin = bufferPool[log2(sz) >> 2];
	    if (bin.length > 0) {
	      return bin.pop()
	    }
	    return new ArrayBuffer(sz)
	  }

	  function free (buf) {
	    bufferPool[log2(buf.byteLength) >> 2].push(buf);
	  }

	  function allocType (type, n) {
	    var result = null;
	    switch (type) {
	      case GL_BYTE$1:
	        result = new Int8Array(alloc(n), 0, n);
	        break
	      case GL_UNSIGNED_BYTE$2:
	        result = new Uint8Array(alloc(n), 0, n);
	        break
	      case GL_SHORT$1:
	        result = new Int16Array(alloc(2 * n), 0, n);
	        break
	      case GL_UNSIGNED_SHORT$1:
	        result = new Uint16Array(alloc(2 * n), 0, n);
	        break
	      case GL_INT$1:
	        result = new Int32Array(alloc(4 * n), 0, n);
	        break
	      case GL_UNSIGNED_INT$1:
	        result = new Uint32Array(alloc(4 * n), 0, n);
	        break
	      case GL_FLOAT$2:
	        result = new Float32Array(alloc(4 * n), 0, n);
	        break
	      default:
	        return null
	    }
	    if (result.length !== n) {
	      return result.subarray(0, n)
	    }
	    return result
	  }

	  function freeType (array) {
	    free(array.buffer);
	  }

	  return {
	    alloc: alloc,
	    free: free,
	    allocType: allocType,
	    freeType: freeType
	  }
	}

	var pool = createPool();

	// zero pool for initial zero data
	pool.zero = createPool();

	var GL_SUBPIXEL_BITS = 0x0D50;
	var GL_RED_BITS = 0x0D52;
	var GL_GREEN_BITS = 0x0D53;
	var GL_BLUE_BITS = 0x0D54;
	var GL_ALPHA_BITS = 0x0D55;
	var GL_DEPTH_BITS = 0x0D56;
	var GL_STENCIL_BITS = 0x0D57;

	var GL_ALIASED_POINT_SIZE_RANGE = 0x846D;
	var GL_ALIASED_LINE_WIDTH_RANGE = 0x846E;

	var GL_MAX_TEXTURE_SIZE = 0x0D33;
	var GL_MAX_VIEWPORT_DIMS = 0x0D3A;
	var GL_MAX_VERTEX_ATTRIBS = 0x8869;
	var GL_MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;
	var GL_MAX_VARYING_VECTORS = 0x8DFC;
	var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
	var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;
	var GL_MAX_TEXTURE_IMAGE_UNITS = 0x8872;
	var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;
	var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;
	var GL_MAX_RENDERBUFFER_SIZE = 0x84E8;

	var GL_VENDOR = 0x1F00;
	var GL_RENDERER = 0x1F01;
	var GL_VERSION = 0x1F02;
	var GL_SHADING_LANGUAGE_VERSION = 0x8B8C;

	var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;

	var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 0x8CDF;
	var GL_MAX_DRAW_BUFFERS_WEBGL = 0x8824;

	var GL_TEXTURE_2D = 0x0DE1;
	var GL_TEXTURE_CUBE_MAP = 0x8513;
	var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
	var GL_TEXTURE0 = 0x84C0;
	var GL_RGBA = 0x1908;
	var GL_FLOAT$1 = 0x1406;
	var GL_UNSIGNED_BYTE$1 = 0x1401;
	var GL_FRAMEBUFFER = 0x8D40;
	var GL_FRAMEBUFFER_COMPLETE = 0x8CD5;
	var GL_COLOR_ATTACHMENT0 = 0x8CE0;
	var GL_COLOR_BUFFER_BIT$1 = 0x4000;

	var wrapLimits = function (gl, extensions) {
	  var maxAnisotropic = 1;
	  if (extensions.ext_texture_filter_anisotropic) {
	    maxAnisotropic = gl.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
	  }

	  var maxDrawbuffers = 1;
	  var maxColorAttachments = 1;
	  if (extensions.webgl_draw_buffers) {
	    maxDrawbuffers = gl.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL);
	    maxColorAttachments = gl.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL);
	  }

	  // detect if reading float textures is available (Safari doesn't support)
	  var readFloat = !!extensions.oes_texture_float;
	  if (readFloat) {
	    var readFloatTexture = gl.createTexture();
	    gl.bindTexture(GL_TEXTURE_2D, readFloatTexture);
	    gl.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT$1, null);

	    var fbo = gl.createFramebuffer();
	    gl.bindFramebuffer(GL_FRAMEBUFFER, fbo);
	    gl.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0);
	    gl.bindTexture(GL_TEXTURE_2D, null);

	    if (gl.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE) readFloat = false;

	    else {
	      gl.viewport(0, 0, 1, 1);
	      gl.clearColor(1.0, 0.0, 0.0, 1.0);
	      gl.clear(GL_COLOR_BUFFER_BIT$1);
	      var pixels = pool.allocType(GL_FLOAT$1, 4);
	      gl.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT$1, pixels);

	      if (gl.getError()) readFloat = false;
	      else {
	        gl.deleteFramebuffer(fbo);
	        gl.deleteTexture(readFloatTexture);

	        readFloat = pixels[0] === 1.0;
	      }

	      pool.freeType(pixels);
	    }
	  }

	  // detect non power of two cube textures support (IE doesn't support)
	  var isIE = typeof navigator !== 'undefined' && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent));

	  var npotTextureCube = true;

	  if (!isIE) {
	    var cubeTexture = gl.createTexture();
	    var data = pool.allocType(GL_UNSIGNED_BYTE$1, 36);
	    gl.activeTexture(GL_TEXTURE0);
	    gl.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture);
	    gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE$1, data);
	    pool.freeType(data);
	    gl.bindTexture(GL_TEXTURE_CUBE_MAP, null);
	    gl.deleteTexture(cubeTexture);
	    npotTextureCube = !gl.getError();
	  }

	  return {
	    // drawing buffer bit depth
	    colorBits: [
	      gl.getParameter(GL_RED_BITS),
	      gl.getParameter(GL_GREEN_BITS),
	      gl.getParameter(GL_BLUE_BITS),
	      gl.getParameter(GL_ALPHA_BITS)
	    ],
	    depthBits: gl.getParameter(GL_DEPTH_BITS),
	    stencilBits: gl.getParameter(GL_STENCIL_BITS),
	    subpixelBits: gl.getParameter(GL_SUBPIXEL_BITS),

	    // supported extensions
	    extensions: Object.keys(extensions).filter(function (ext) {
	      return !!extensions[ext]
	    }),

	    // max aniso samples
	    maxAnisotropic: maxAnisotropic,

	    // max draw buffers
	    maxDrawbuffers: maxDrawbuffers,
	    maxColorAttachments: maxColorAttachments,

	    // point and line size ranges
	    pointSizeDims: gl.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
	    lineWidthDims: gl.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
	    maxViewportDims: gl.getParameter(GL_MAX_VIEWPORT_DIMS),
	    maxCombinedTextureUnits: gl.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
	    maxCubeMapSize: gl.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
	    maxRenderbufferSize: gl.getParameter(GL_MAX_RENDERBUFFER_SIZE),
	    maxTextureUnits: gl.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
	    maxTextureSize: gl.getParameter(GL_MAX_TEXTURE_SIZE),
	    maxAttributes: gl.getParameter(GL_MAX_VERTEX_ATTRIBS),
	    maxVertexUniforms: gl.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
	    maxVertexTextureUnits: gl.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
	    maxVaryingVectors: gl.getParameter(GL_MAX_VARYING_VECTORS),
	    maxFragmentUniforms: gl.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),

	    // vendor info
	    glsl: gl.getParameter(GL_SHADING_LANGUAGE_VERSION),
	    renderer: gl.getParameter(GL_RENDERER),
	    vendor: gl.getParameter(GL_VENDOR),
	    version: gl.getParameter(GL_VERSION),

	    // quirks
	    readFloat: readFloat,
	    npotTextureCube: npotTextureCube
	  }
	};

	function isNDArrayLike (obj) {
	  return (
	    !!obj &&
	    typeof obj === 'object' &&
	    Array.isArray(obj.shape) &&
	    Array.isArray(obj.stride) &&
	    typeof obj.offset === 'number' &&
	    obj.shape.length === obj.stride.length &&
	    (Array.isArray(obj.data) ||
	      isTypedArray(obj.data)))
	}

	var values = function (obj) {
	  return Object.keys(obj).map(function (key) { return obj[key] })
	};

	var flattenUtils = {
	  shape: arrayShape$1,
	  flatten: flattenArray
	};

	function flatten1D (array, nx, out) {
	  for (var i = 0; i < nx; ++i) {
	    out[i] = array[i];
	  }
	}

	function flatten2D (array, nx, ny, out) {
	  var ptr = 0;
	  for (var i = 0; i < nx; ++i) {
	    var row = array[i];
	    for (var j = 0; j < ny; ++j) {
	      out[ptr++] = row[j];
	    }
	  }
	}

	function flatten3D (array, nx, ny, nz, out, ptr_) {
	  var ptr = ptr_;
	  for (var i = 0; i < nx; ++i) {
	    var row = array[i];
	    for (var j = 0; j < ny; ++j) {
	      var col = row[j];
	      for (var k = 0; k < nz; ++k) {
	        out[ptr++] = col[k];
	      }
	    }
	  }
	}

	function flattenRec (array, shape, level, out, ptr) {
	  var stride = 1;
	  for (var i = level + 1; i < shape.length; ++i) {
	    stride *= shape[i];
	  }
	  var n = shape[level];
	  if (shape.length - level === 4) {
	    var nx = shape[level + 1];
	    var ny = shape[level + 2];
	    var nz = shape[level + 3];
	    for (i = 0; i < n; ++i) {
	      flatten3D(array[i], nx, ny, nz, out, ptr);
	      ptr += stride;
	    }
	  } else {
	    for (i = 0; i < n; ++i) {
	      flattenRec(array[i], shape, level + 1, out, ptr);
	      ptr += stride;
	    }
	  }
	}

	function flattenArray (array, shape, type, out_) {
	  var sz = 1;
	  if (shape.length) {
	    for (var i = 0; i < shape.length; ++i) {
	      sz *= shape[i];
	    }
	  } else {
	    sz = 0;
	  }
	  var out = out_ || pool.allocType(type, sz);
	  switch (shape.length) {
	    case 0:
	      break
	    case 1:
	      flatten1D(array, shape[0], out);
	      break
	    case 2:
	      flatten2D(array, shape[0], shape[1], out);
	      break
	    case 3:
	      flatten3D(array, shape[0], shape[1], shape[2], out, 0);
	      break
	    default:
	      flattenRec(array, shape, 0, out, 0);
	  }
	  return out
	}

	function arrayShape$1 (array_) {
	  var shape = [];
	  for (var array = array_; array.length; array = array[0]) {
	    shape.push(array.length);
	  }
	  return shape
	}

	var arrayTypes =  {
		"[object Int8Array]": 5120,
		"[object Int16Array]": 5122,
		"[object Int32Array]": 5124,
		"[object Uint8Array]": 5121,
		"[object Uint8ClampedArray]": 5121,
		"[object Uint16Array]": 5123,
		"[object Uint32Array]": 5125,
		"[object Float32Array]": 5126,
		"[object Float64Array]": 5121,
		"[object ArrayBuffer]": 5121
	};

	var int8 = 5120;
	var int16 = 5122;
	var int32 = 5124;
	var uint8 = 5121;
	var uint16 = 5123;
	var uint32 = 5125;
	var float = 5126;
	var float32 = 5126;
	var glTypes = {
		int8: int8,
		int16: int16,
		int32: int32,
		uint8: uint8,
		uint16: uint16,
		uint32: uint32,
		float: float,
		float32: float32
	};

	var dynamic$1 = 35048;
	var stream = 35040;
	var usageTypes = {
		dynamic: dynamic$1,
		stream: stream,
		"static": 35044
	};

	var arrayFlatten = flattenUtils.flatten;
	var arrayShape = flattenUtils.shape;

	var GL_STATIC_DRAW = 0x88E4;
	var GL_STREAM_DRAW = 0x88E0;

	var GL_UNSIGNED_BYTE$3 = 5121;
	var GL_FLOAT$3 = 5126;

	var DTYPES_SIZES = [];
	DTYPES_SIZES[5120] = 1; // int8
	DTYPES_SIZES[5122] = 2; // int16
	DTYPES_SIZES[5124] = 4; // int32
	DTYPES_SIZES[5121] = 1; // uint8
	DTYPES_SIZES[5123] = 2; // uint16
	DTYPES_SIZES[5125] = 4; // uint32
	DTYPES_SIZES[5126] = 4; // float32

	function typedArrayCode (data) {
	  return arrayTypes[Object.prototype.toString.call(data)] | 0
	}

	function copyArray (out, inp) {
	  for (var i = 0; i < inp.length; ++i) {
	    out[i] = inp[i];
	  }
	}

	function transpose (
	  result, data, shapeX, shapeY, strideX, strideY, offset) {
	  var ptr = 0;
	  for (var i = 0; i < shapeX; ++i) {
	    for (var j = 0; j < shapeY; ++j) {
	      result[ptr++] = data[strideX * i + strideY * j + offset];
	    }
	  }
	}

	function wrapBufferState (gl, stats, config, destroyBuffer) {
	  var bufferCount = 0;
	  var bufferSet = {};

	  function REGLBuffer (type) {
	    this.id = bufferCount++;
	    this.buffer = gl.createBuffer();
	    this.type = type;
	    this.usage = GL_STATIC_DRAW;
	    this.byteLength = 0;
	    this.dimension = 1;
	    this.dtype = GL_UNSIGNED_BYTE$3;

	    this.persistentData = null;

	    if (config.profile) {
	      this.stats = { size: 0 };
	    }
	  }

	  REGLBuffer.prototype.bind = function () {
	    gl.bindBuffer(this.type, this.buffer);
	  };

	  REGLBuffer.prototype.destroy = function () {
	    destroy(this);
	  };

	  var streamPool = [];

	  function createStream (type, data) {
	    var buffer = streamPool.pop();
	    if (!buffer) {
	      buffer = new REGLBuffer(type);
	    }
	    buffer.bind();
	    initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false);
	    return buffer
	  }

	  function destroyStream (stream$$1) {
	    streamPool.push(stream$$1);
	  }

	  function initBufferFromTypedArray (buffer, data, usage) {
	    buffer.byteLength = data.byteLength;
	    gl.bufferData(buffer.type, data, usage);
	  }

	  function initBufferFromData (buffer, data, usage, dtype, dimension, persist) {
	    var shape;
	    buffer.usage = usage;
	    if (Array.isArray(data)) {
	      buffer.dtype = dtype || GL_FLOAT$3;
	      if (data.length > 0) {
	        var flatData;
	        if (Array.isArray(data[0])) {
	          shape = arrayShape(data);
	          var dim = 1;
	          for (var i = 1; i < shape.length; ++i) {
	            dim *= shape[i];
	          }
	          buffer.dimension = dim;
	          flatData = arrayFlatten(data, shape, buffer.dtype);
	          initBufferFromTypedArray(buffer, flatData, usage);
	          if (persist) {
	            buffer.persistentData = flatData;
	          } else {
	            pool.freeType(flatData);
	          }
	        } else if (typeof data[0] === 'number') {
	          buffer.dimension = dimension;
	          var typedData = pool.allocType(buffer.dtype, data.length);
	          copyArray(typedData, data);
	          initBufferFromTypedArray(buffer, typedData, usage);
	          if (persist) {
	            buffer.persistentData = typedData;
	          } else {
	            pool.freeType(typedData);
	          }
	        } else if (isTypedArray(data[0])) {
	          buffer.dimension = data[0].length;
	          buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$3;
	          flatData = arrayFlatten(
	            data,
	            [data.length, data[0].length],
	            buffer.dtype);
	          initBufferFromTypedArray(buffer, flatData, usage);
	          if (persist) {
	            buffer.persistentData = flatData;
	          } else {
	            pool.freeType(flatData);
	          }
	        } else {
	          check$1.raise('invalid buffer data');
	        }
	      }
	    } else if (isTypedArray(data)) {
	      buffer.dtype = dtype || typedArrayCode(data);
	      buffer.dimension = dimension;
	      initBufferFromTypedArray(buffer, data, usage);
	      if (persist) {
	        buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer));
	      }
	    } else if (isNDArrayLike(data)) {
	      shape = data.shape;
	      var stride = data.stride;
	      var offset = data.offset;

	      var shapeX = 0;
	      var shapeY = 0;
	      var strideX = 0;
	      var strideY = 0;
	      if (shape.length === 1) {
	        shapeX = shape[0];
	        shapeY = 1;
	        strideX = stride[0];
	        strideY = 0;
	      } else if (shape.length === 2) {
	        shapeX = shape[0];
	        shapeY = shape[1];
	        strideX = stride[0];
	        strideY = stride[1];
	      } else {
	        check$1.raise('invalid shape');
	      }

	      buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$3;
	      buffer.dimension = shapeY;

	      var transposeData = pool.allocType(buffer.dtype, shapeX * shapeY);
	      transpose(transposeData,
	        data.data,
	        shapeX, shapeY,
	        strideX, strideY,
	        offset);
	      initBufferFromTypedArray(buffer, transposeData, usage);
	      if (persist) {
	        buffer.persistentData = transposeData;
	      } else {
	        pool.freeType(transposeData);
	      }
	    } else if (data instanceof ArrayBuffer) {
	      buffer.dtype = GL_UNSIGNED_BYTE$3;
	      buffer.dimension = dimension;
	      initBufferFromTypedArray(buffer, data, usage);
	      if (persist) {
	        buffer.persistentData = new Uint8Array(new Uint8Array(data));
	      }
	    } else {
	      check$1.raise('invalid buffer data');
	    }
	  }

	  function destroy (buffer) {
	    stats.bufferCount--;

	    // remove attribute link
	    destroyBuffer(buffer);

	    var handle = buffer.buffer;
	    check$1(handle, 'buffer must not be deleted already');
	    gl.deleteBuffer(handle);
	    buffer.buffer = null;
	    delete bufferSet[buffer.id];
	  }

	  function createBuffer (options, type, deferInit, persistent) {
	    stats.bufferCount++;

	    var buffer = new REGLBuffer(type);
	    bufferSet[buffer.id] = buffer;

	    function reglBuffer (options) {
	      var usage = GL_STATIC_DRAW;
	      var data = null;
	      var byteLength = 0;
	      var dtype = 0;
	      var dimension = 1;
	      if (Array.isArray(options) ||
	          isTypedArray(options) ||
	          isNDArrayLike(options) ||
	          options instanceof ArrayBuffer) {
	        data = options;
	      } else if (typeof options === 'number') {
	        byteLength = options | 0;
	      } else if (options) {
	        check$1.type(
	          options, 'object',
	          'buffer arguments must be an object, a number or an array');

	        if ('data' in options) {
	          check$1(
	            data === null ||
	            Array.isArray(data) ||
	            isTypedArray(data) ||
	            isNDArrayLike(data),
	            'invalid data for buffer');
	          data = options.data;
	        }

	        if ('usage' in options) {
	          check$1.parameter(options.usage, usageTypes, 'invalid buffer usage');
	          usage = usageTypes[options.usage];
	        }

	        if ('type' in options) {
	          check$1.parameter(options.type, glTypes, 'invalid buffer type');
	          dtype = glTypes[options.type];
	        }

	        if ('dimension' in options) {
	          check$1.type(options.dimension, 'number', 'invalid dimension');
	          dimension = options.dimension | 0;
	        }

	        if ('length' in options) {
	          check$1.nni(byteLength, 'buffer length must be a nonnegative integer');
	          byteLength = options.length | 0;
	        }
	      }

	      buffer.bind();
	      if (!data) {
	        // #475
	        if (byteLength) gl.bufferData(buffer.type, byteLength, usage);
	        buffer.dtype = dtype || GL_UNSIGNED_BYTE$3;
	        buffer.usage = usage;
	        buffer.dimension = dimension;
	        buffer.byteLength = byteLength;
	      } else {
	        initBufferFromData(buffer, data, usage, dtype, dimension, persistent);
	      }

	      if (config.profile) {
	        buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype];
	      }

	      return reglBuffer
	    }

	    function setSubData (data, offset) {
	      check$1(offset + data.byteLength <= buffer.byteLength,
	        'invalid buffer subdata call, buffer is too small. ' + ' Can\'t write data of size ' + data.byteLength + ' starting from offset ' + offset + ' to a buffer of size ' + buffer.byteLength);

	      gl.bufferSubData(buffer.type, offset, data);
	    }

	    function subdata (data, offset_) {
	      var offset = (offset_ || 0) | 0;
	      var shape;
	      buffer.bind();
	      if (isTypedArray(data) || data instanceof ArrayBuffer) {
	        setSubData(data, offset);
	      } else if (Array.isArray(data)) {
	        if (data.length > 0) {
	          if (typeof data[0] === 'number') {
	            var converted = pool.allocType(buffer.dtype, data.length);
	            copyArray(converted, data);
	            setSubData(converted, offset);
	            pool.freeType(converted);
	          } else if (Array.isArray(data[0]) || isTypedArray(data[0])) {
	            shape = arrayShape(data);
	            var flatData = arrayFlatten(data, shape, buffer.dtype);
	            setSubData(flatData, offset);
	            pool.freeType(flatData);
	          } else {
	            check$1.raise('invalid buffer data');
	          }
	        }
	      } else if (isNDArrayLike(data)) {
	        shape = data.shape;
	        var stride = data.stride;

	        var shapeX = 0;
	        var shapeY = 0;
	        var strideX = 0;
	        var strideY = 0;
	        if (shape.length === 1) {
	          shapeX = shape[0];
	          shapeY = 1;
	          strideX = stride[0];
	          strideY = 0;
	        } else if (shape.length === 2) {
	          shapeX = shape[0];
	          shapeY = shape[1];
	          strideX = stride[0];
	          strideY = stride[1];
	        } else {
	          check$1.raise('invalid shape');
	        }
	        var dtype = Array.isArray(data.data)
	          ? buffer.dtype
	          : typedArrayCode(data.data);

	        var transposeData = pool.allocType(dtype, shapeX * shapeY);
	        transpose(transposeData,
	          data.data,
	          shapeX, shapeY,
	          strideX, strideY,
	          data.offset);
	        setSubData(transposeData, offset);
	        pool.freeType(transposeData);
	      } else {
	        check$1.raise('invalid data for buffer subdata');
	      }
	      return reglBuffer
	    }

	    if (!deferInit) {
	      reglBuffer(options);
	    }

	    reglBuffer._reglType = 'buffer';
	    reglBuffer._buffer = buffer;
	    reglBuffer.subdata = subdata;
	    if (config.profile) {
	      reglBuffer.stats = buffer.stats;
	    }
	    reglBuffer.destroy = function () { destroy(buffer); };

	    return reglBuffer
	  }

	  function restoreBuffers () {
	    values(bufferSet).forEach(function (buffer) {
	      buffer.buffer = gl.createBuffer();
	      gl.bindBuffer(buffer.type, buffer.buffer);
	      gl.bufferData(
	        buffer.type, buffer.persistentData || buffer.byteLength, buffer.usage);
	    });
	  }

	  if (config.profile) {
	    stats.getTotalBufferSize = function () {
	      var total = 0;
	      // TODO: Right now, the streams are not part of the total count.
	      Object.keys(bufferSet).forEach(function (key) {
	        total += bufferSet[key].stats.size;
	      });
	      return total
	    };
	  }

	  return {
	    create: createBuffer,

	    createStream: createStream,
	    destroyStream: destroyStream,

	    clear: function () {
	      values(bufferSet).forEach(destroy);
	      streamPool.forEach(destroy);
	    },

	    getBuffer: function (wrapper) {
	      if (wrapper && wrapper._buffer instanceof REGLBuffer) {
	        return wrapper._buffer
	      }
	      return null
	    },

	    restore: restoreBuffers,

	    _initBuffer: initBufferFromData
	  }
	}

	var points = 0;
	var point = 0;
	var lines = 1;
	var line = 1;
	var triangles = 4;
	var triangle = 4;
	var primTypes = {
		points: points,
		point: point,
		lines: lines,
		line: line,
		triangles: triangles,
		triangle: triangle,
		"line loop": 2,
		"line strip": 3,
		"triangle strip": 5,
		"triangle fan": 6
	};

	var GL_POINTS = 0;
	var GL_LINES = 1;
	var GL_TRIANGLES = 4;

	var GL_BYTE$2 = 5120;
	var GL_UNSIGNED_BYTE$4 = 5121;
	var GL_SHORT$2 = 5122;
	var GL_UNSIGNED_SHORT$2 = 5123;
	var GL_INT$2 = 5124;
	var GL_UNSIGNED_INT$2 = 5125;

	var GL_ELEMENT_ARRAY_BUFFER = 34963;

	var GL_STREAM_DRAW$1 = 0x88E0;
	var GL_STATIC_DRAW$1 = 0x88E4;

	function wrapElementsState (gl, extensions, bufferState, stats) {
	  var elementSet = {};
	  var elementCount = 0;

	  var elementTypes = {
	    'uint8': GL_UNSIGNED_BYTE$4,
	    'uint16': GL_UNSIGNED_SHORT$2
	  };

	  if (extensions.oes_element_index_uint) {
	    elementTypes.uint32 = GL_UNSIGNED_INT$2;
	  }

	  function REGLElementBuffer (buffer) {
	    this.id = elementCount++;
	    elementSet[this.id] = this;
	    this.buffer = buffer;
	    this.primType = GL_TRIANGLES;
	    this.vertCount = 0;
	    this.type = 0;
	  }

	  REGLElementBuffer.prototype.bind = function () {
	    this.buffer.bind();
	  };

	  var bufferPool = [];

	  function createElementStream (data) {
	    var result = bufferPool.pop();
	    if (!result) {
	      result = new REGLElementBuffer(bufferState.create(
	        null,
	        GL_ELEMENT_ARRAY_BUFFER,
	        true,
	        false)._buffer);
	    }
	    initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0);
	    return result
	  }

	  function destroyElementStream (elements) {
	    bufferPool.push(elements);
	  }

	  function initElements (
	    elements,
	    data,
	    usage,
	    prim,
	    count,
	    byteLength,
	    type) {
	    elements.buffer.bind();
	    var dtype;
	    if (data) {
	      var predictedType = type;
	      if (!type && (
	        !isTypedArray(data) ||
	         (isNDArrayLike(data) && !isTypedArray(data.data)))) {
	        predictedType = extensions.oes_element_index_uint
	          ? GL_UNSIGNED_INT$2
	          : GL_UNSIGNED_SHORT$2;
	      }
	      bufferState._initBuffer(
	        elements.buffer,
	        data,
	        usage,
	        predictedType,
	        3);
	    } else {
	      gl.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage);
	      elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$4;
	      elements.buffer.usage = usage;
	      elements.buffer.dimension = 3;
	      elements.buffer.byteLength = byteLength;
	    }

	    dtype = type;
	    if (!type) {
	      switch (elements.buffer.dtype) {
	        case GL_UNSIGNED_BYTE$4:
	        case GL_BYTE$2:
	          dtype = GL_UNSIGNED_BYTE$4;
	          break

	        case GL_UNSIGNED_SHORT$2:
	        case GL_SHORT$2:
	          dtype = GL_UNSIGNED_SHORT$2;
	          break

	        case GL_UNSIGNED_INT$2:
	        case GL_INT$2:
	          dtype = GL_UNSIGNED_INT$2;
	          break

	        default:
	          check$1.raise('unsupported type for element array');
	      }
	      elements.buffer.dtype = dtype;
	    }
	    elements.type = dtype;

	    // Check oes_element_index_uint extension
	    check$1(
	      dtype !== GL_UNSIGNED_INT$2 ||
	      !!extensions.oes_element_index_uint,
	      '32 bit element buffers not supported, enable oes_element_index_uint first');

	    // try to guess default primitive type and arguments
	    var vertCount = count;
	    if (vertCount < 0) {
	      vertCount = elements.buffer.byteLength;
	      if (dtype === GL_UNSIGNED_SHORT$2) {
	        vertCount >>= 1;
	      } else if (dtype === GL_UNSIGNED_INT$2) {
	        vertCount >>= 2;
	      }
	    }
	    elements.vertCount = vertCount;

	    // try to guess primitive type from cell dimension
	    var primType = prim;
	    if (prim < 0) {
	      primType = GL_TRIANGLES;
	      var dimension = elements.buffer.dimension;
	      if (dimension === 1) primType = GL_POINTS;
	      if (dimension === 2) primType = GL_LINES;
	      if (dimension === 3) primType = GL_TRIANGLES;
	    }
	    elements.primType = primType;
	  }

	  function destroyElements (elements) {
	    stats.elementsCount--;

	    check$1(elements.buffer !== null, 'must not double destroy elements');
	    delete elementSet[elements.id];
	    elements.buffer.destroy();
	    elements.buffer = null;
	  }

	  function createElements (options, persistent) {
	    var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true);
	    var elements = new REGLElementBuffer(buffer._buffer);
	    stats.elementsCount++;

	    function reglElements (options) {
	      if (!options) {
	        buffer();
	        elements.primType = GL_TRIANGLES;
	        elements.vertCount = 0;
	        elements.type = GL_UNSIGNED_BYTE$4;
	      } else if (typeof options === 'number') {
	        buffer(options);
	        elements.primType = GL_TRIANGLES;
	        elements.vertCount = options | 0;
	        elements.type = GL_UNSIGNED_BYTE$4;
	      } else {
	        var data = null;
	        var usage = GL_STATIC_DRAW$1;
	        var primType = -1;
	        var vertCount = -1;
	        var byteLength = 0;
	        var dtype = 0;
	        if (Array.isArray(options) ||
	            isTypedArray(options) ||
	            isNDArrayLike(options)) {
	          data = options;
	        } else {
	          check$1.type(options, 'object', 'invalid arguments for elements');
	          if ('data' in options) {
	            data = options.data;
	            check$1(
	              Array.isArray(data) ||
	                isTypedArray(data) ||
	                isNDArrayLike(data),
	              'invalid data for element buffer');
	          }
	          if ('usage' in options) {
	            check$1.parameter(
	              options.usage,
	              usageTypes,
	              'invalid element buffer usage');
	            usage = usageTypes[options.usage];
	          }
	          if ('primitive' in options) {
	            check$1.parameter(
	              options.primitive,
	              primTypes,
	              'invalid element buffer primitive');
	            primType = primTypes[options.primitive];
	          }
	          if ('count' in options) {
	            check$1(
	              typeof options.count === 'number' && options.count >= 0,
	              'invalid vertex count for elements');
	            vertCount = options.count | 0;
	          }
	          if ('type' in options) {
	            check$1.parameter(
	              options.type,
	              elementTypes,
	              'invalid buffer type');
	            dtype = elementTypes[options.type];
	          }
	          if ('length' in options) {
	            byteLength = options.length | 0;
	          } else {
	            byteLength = vertCount;
	            if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {
	              byteLength *= 2;
	            } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {
	              byteLength *= 4;
	            }
	          }
	        }
	        initElements(
	          elements,
	          data,
	          usage,
	          primType,
	          vertCount,
	          byteLength,
	          dtype);
	      }

	      return reglElements
	    }

	    reglElements(options);

	    reglElements._reglType = 'elements';
	    reglElements._elements = elements;
	    reglElements.subdata = function (data, offset) {
	      buffer.subdata(data, offset);
	      return reglElements
	    };
	    reglElements.destroy = function () {
	      destroyElements(elements);
	    };

	    return reglElements
	  }

	  return {
	    create: createElements,
	    createStream: createElementStream,
	    destroyStream: destroyElementStream,
	    getElements: function (elements) {
	      if (typeof elements === 'function' &&
	          elements._elements instanceof REGLElementBuffer) {
	        return elements._elements
	      }
	      return null
	    },
	    clear: function () {
	      values(elementSet).forEach(destroyElements);
	    }
	  }
	}

	var FLOAT = new Float32Array(1);
	var INT = new Uint32Array(FLOAT.buffer);

	var GL_UNSIGNED_SHORT$4 = 5123;

	function convertToHalfFloat (array) {
	  var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array.length);

	  for (var i = 0; i < array.length; ++i) {
	    if (isNaN(array[i])) {
	      ushorts[i] = 0xffff;
	    } else if (array[i] === Infinity) {
	      ushorts[i] = 0x7c00;
	    } else if (array[i] === -Infinity) {
	      ushorts[i] = 0xfc00;
	    } else {
	      FLOAT[0] = array[i];
	      var x = INT[0];

	      var sgn = (x >>> 31) << 15;
	      var exp = ((x << 1) >>> 24) - 127;
	      var frac = (x >> 13) & ((1 << 10) - 1);

	      if (exp < -24) {
	        // round non-representable denormals to 0
	        ushorts[i] = sgn;
	      } else if (exp < -14) {
	        // handle denormals
	        var s = -14 - exp;
	        ushorts[i] = sgn + ((frac + (1 << 10)) >> s);
	      } else if (exp > 15) {
	        // round overflow to +/- Infinity
	        ushorts[i] = sgn + 0x7c00;
	      } else {
	        // otherwise convert directly
	        ushorts[i] = sgn + ((exp + 15) << 10) + frac;
	      }
	    }
	  }

	  return ushorts
	}

	function isArrayLike (s) {
	  return Array.isArray(s) || isTypedArray(s)
	}

	var isPow2$1 = function (v) {
	  return !(v & (v - 1)) && (!!v)
	};

	var GL_COMPRESSED_TEXTURE_FORMATS = 0x86A3;

	var GL_TEXTURE_2D$1 = 0x0DE1;
	var GL_TEXTURE_CUBE_MAP$1 = 0x8513;
	var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 0x8515;

	var GL_RGBA$1 = 0x1908;
	var GL_ALPHA = 0x1906;
	var GL_RGB = 0x1907;
	var GL_LUMINANCE = 0x1909;
	var GL_LUMINANCE_ALPHA = 0x190A;

	var GL_RGBA4 = 0x8056;
	var GL_RGB5_A1 = 0x8057;
	var GL_RGB565 = 0x8D62;

	var GL_UNSIGNED_SHORT_4_4_4_4$1 = 0x8033;
	var GL_UNSIGNED_SHORT_5_5_5_1$1 = 0x8034;
	var GL_UNSIGNED_SHORT_5_6_5$1 = 0x8363;
	var GL_UNSIGNED_INT_24_8_WEBGL$1 = 0x84FA;

	var GL_DEPTH_COMPONENT = 0x1902;
	var GL_DEPTH_STENCIL = 0x84F9;

	var GL_SRGB_EXT = 0x8C40;
	var GL_SRGB_ALPHA_EXT = 0x8C42;

	var GL_HALF_FLOAT_OES$1 = 0x8D61;

	var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;
	var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;
	var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;
	var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;

	var GL_COMPRESSED_RGB_ATC_WEBGL = 0x8C92;
	var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93;
	var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE;

	var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;
	var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;
	var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;
	var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;

	var GL_COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;

	var GL_UNSIGNED_BYTE$5 = 0x1401;
	var GL_UNSIGNED_SHORT$3 = 0x1403;
	var GL_UNSIGNED_INT$3 = 0x1405;
	var GL_FLOAT$4 = 0x1406;

	var GL_TEXTURE_WRAP_S = 0x2802;
	var GL_TEXTURE_WRAP_T = 0x2803;

	var GL_REPEAT = 0x2901;
	var GL_CLAMP_TO_EDGE$1 = 0x812F;
	var GL_MIRRORED_REPEAT = 0x8370;

	var GL_TEXTURE_MAG_FILTER = 0x2800;
	var GL_TEXTURE_MIN_FILTER = 0x2801;

	var GL_NEAREST$1 = 0x2600;
	var GL_LINEAR = 0x2601;
	var GL_NEAREST_MIPMAP_NEAREST$1 = 0x2700;
	var GL_LINEAR_MIPMAP_NEAREST$1 = 0x2701;
	var GL_NEAREST_MIPMAP_LINEAR$1 = 0x2702;
	var GL_LINEAR_MIPMAP_LINEAR$1 = 0x2703;

	var GL_GENERATE_MIPMAP_HINT = 0x8192;
	var GL_DONT_CARE = 0x1100;
	var GL_FASTEST = 0x1101;
	var GL_NICEST = 0x1102;

	var GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;

	var GL_UNPACK_ALIGNMENT = 0x0CF5;
	var GL_UNPACK_FLIP_Y_WEBGL = 0x9240;
	var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
	var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;

	var GL_BROWSER_DEFAULT_WEBGL = 0x9244;

	var GL_TEXTURE0$1 = 0x84C0;

	var MIPMAP_FILTERS = [
	  GL_NEAREST_MIPMAP_NEAREST$1,
	  GL_NEAREST_MIPMAP_LINEAR$1,
	  GL_LINEAR_MIPMAP_NEAREST$1,
	  GL_LINEAR_MIPMAP_LINEAR$1
	];

	var CHANNELS_FORMAT = [
	  0,
	  GL_LUMINANCE,
	  GL_LUMINANCE_ALPHA,
	  GL_RGB,
	  GL_RGBA$1
	];

	var FORMAT_CHANNELS = {};
	FORMAT_CHANNELS[GL_LUMINANCE] =
	FORMAT_CHANNELS[GL_ALPHA] =
	FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1;
	FORMAT_CHANNELS[GL_DEPTH_STENCIL] =
	FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2;
	FORMAT_CHANNELS[GL_RGB] =
	FORMAT_CHANNELS[GL_SRGB_EXT] = 3;
	FORMAT_CHANNELS[GL_RGBA$1] =
	FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4;

	function objectName (str) {
	  return '[object ' + str + ']'
	}

	var CANVAS_CLASS = objectName('HTMLCanvasElement');
	var OFFSCREENCANVAS_CLASS = objectName('OffscreenCanvas');
	var CONTEXT2D_CLASS = objectName('CanvasRenderingContext2D');
	var BITMAP_CLASS = objectName('ImageBitmap');
	var IMAGE_CLASS = objectName('HTMLImageElement');
	var VIDEO_CLASS = objectName('HTMLVideoElement');

	var PIXEL_CLASSES = Object.keys(arrayTypes).concat([
	  CANVAS_CLASS,
	  OFFSCREENCANVAS_CLASS,
	  CONTEXT2D_CLASS,
	  BITMAP_CLASS,
	  IMAGE_CLASS,
	  VIDEO_CLASS
	]);

	// for every texture type, store
	// the size in bytes.
	var TYPE_SIZES = [];
	TYPE_SIZES[GL_UNSIGNED_BYTE$5] = 1;
	TYPE_SIZES[GL_FLOAT$4] = 4;
	TYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2;

	TYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2;
	TYPE_SIZES[GL_UNSIGNED_INT$3] = 4;

	var FORMAT_SIZES_SPECIAL = [];
	FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2;
	FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2;
	FORMAT_SIZES_SPECIAL[GL_RGB565] = 2;
	FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4;

	FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5;
	FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5;
	FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1;
	FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1;

	FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5;
	FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1;
	FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1;

	FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5;
	FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25;
	FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5;
	FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25;

	FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5;

	function isNumericArray (arr) {
	  return (
	    Array.isArray(arr) &&
	    (arr.length === 0 ||
	    typeof arr[0] === 'number'))
	}

	function isRectArray (arr) {
	  if (!Array.isArray(arr)) {
	    return false
	  }
	  var width = arr.length;
	  if (width === 0 || !isArrayLike(arr[0])) {
	    return false
	  }
	  return true
	}

	function classString (x) {
	  return Object.prototype.toString.call(x)
	}

	function isCanvasElement (object) {
	  return classString(object) === CANVAS_CLASS
	}

	function isOffscreenCanvas (object) {
	  return classString(object) === OFFSCREENCANVAS_CLASS
	}

	function isContext2D (object) {
	  return classString(object) === CONTEXT2D_CLASS
	}

	function isBitmap (object) {
	  return classString(object) === BITMAP_CLASS
	}

	function isImageElement (object) {
	  return classString(object) === IMAGE_CLASS
	}

	function isVideoElement (object) {
	  return classString(object) === VIDEO_CLASS
	}

	function isPixelData (object) {
	  if (!object) {
	    return false
	  }
	  var className = classString(object);
	  if (PIXEL_CLASSES.indexOf(className) >= 0) {
	    return true
	  }
	  return (
	    isNumericArray(object) ||
	    isRectArray(object) ||
	    isNDArrayLike(object))
	}

	function typedArrayCode$1 (data) {
	  return arrayTypes[Object.prototype.toString.call(data)] | 0
	}

	function convertData (result, data) {
	  var n = data.length;
	  switch (result.type) {
	    case GL_UNSIGNED_BYTE$5:
	    case GL_UNSIGNED_SHORT$3:
	    case GL_UNSIGNED_INT$3:
	    case GL_FLOAT$4:
	      var converted = pool.allocType(result.type, n);
	      converted.set(data);
	      result.data = converted;
	      break

	    case GL_HALF_FLOAT_OES$1:
	      result.data = convertToHalfFloat(data);
	      break

	    default:
	      check$1.raise('unsupported texture type, must specify a typed array');
	  }
	}

	function preConvert (image, n) {
	  return pool.allocType(
	    image.type === GL_HALF_FLOAT_OES$1
	      ? GL_FLOAT$4
	      : image.type, n)
	}

	function postConvert (image, data) {
	  if (image.type === GL_HALF_FLOAT_OES$1) {
	    image.data = convertToHalfFloat(data);
	    pool.freeType(data);
	  } else {
	    image.data = data;
	  }
	}

	function transposeData (image, array, strideX, strideY, strideC, offset) {
	  var w = image.width;
	  var h = image.height;
	  var c = image.channels;
	  var n = w * h * c;
	  var data = preConvert(image, n);

	  var p = 0;
	  for (var i = 0; i < h; ++i) {
	    for (var j = 0; j < w; ++j) {
	      for (var k = 0; k < c; ++k) {
	        data[p++] = array[strideX * j + strideY * i + strideC * k + offset];
	      }
	    }
	  }

	  postConvert(image, data);
	}

	function getTextureSize (format, type, width, height, isMipmap, isCube) {
	  var s;
	  if (typeof FORMAT_SIZES_SPECIAL[format] !== 'undefined') {
	    // we have a special array for dealing with weird color formats such as RGB5A1
	    s = FORMAT_SIZES_SPECIAL[format];
	  } else {
	    s = FORMAT_CHANNELS[format] * TYPE_SIZES[type];
	  }

	  if (isCube) {
	    s *= 6;
	  }

	  if (isMipmap) {
	    // compute the total size of all the mipmaps.
	    var total = 0;

	    var w = width;
	    while (w >= 1) {
	      // we can only use mipmaps on a square image,
	      // so we can simply use the width and ignore the height:
	      total += s * w * w;
	      w /= 2;
	    }
	    return total
	  } else {
	    return s * width * height
	  }
	}

	function createTextureSet (
	  gl, extensions, limits, reglPoll, contextState, stats, config) {
	  // -------------------------------------------------------
	  // Initialize constants and parameter tables here
	  // -------------------------------------------------------
	  var mipmapHint = {
	    "don't care": GL_DONT_CARE,
	    'dont care': GL_DONT_CARE,
	    'nice': GL_NICEST,
	    'fast': GL_FASTEST
	  };

	  var wrapModes = {
	    'repeat': GL_REPEAT,
	    'clamp': GL_CLAMP_TO_EDGE$1,
	    'mirror': GL_MIRRORED_REPEAT
	  };

	  var magFilters = {
	    'nearest': GL_NEAREST$1,
	    'linear': GL_LINEAR
	  };

	  var minFilters = extend({
	    'mipmap': GL_LINEAR_MIPMAP_LINEAR$1,
	    'nearest mipmap nearest': GL_NEAREST_MIPMAP_NEAREST$1,
	    'linear mipmap nearest': GL_LINEAR_MIPMAP_NEAREST$1,
	    'nearest mipmap linear': GL_NEAREST_MIPMAP_LINEAR$1,
	    'linear mipmap linear': GL_LINEAR_MIPMAP_LINEAR$1
	  }, magFilters);

	  var colorSpace = {
	    'none': 0,
	    'browser': GL_BROWSER_DEFAULT_WEBGL
	  };

	  var textureTypes = {
	    'uint8': GL_UNSIGNED_BYTE$5,
	    'rgba4': GL_UNSIGNED_SHORT_4_4_4_4$1,
	    'rgb565': GL_UNSIGNED_SHORT_5_6_5$1,
	    'rgb5 a1': GL_UNSIGNED_SHORT_5_5_5_1$1
	  };

	  var textureFormats = {
	    'alpha': GL_ALPHA,
	    'luminance': GL_LUMINANCE,
	    'luminance alpha': GL_LUMINANCE_ALPHA,
	    'rgb': GL_RGB,
	    'rgba': GL_RGBA$1,
	    'rgba4': GL_RGBA4,
	    'rgb5 a1': GL_RGB5_A1,
	    'rgb565': GL_RGB565
	  };

	  var compressedTextureFormats = {};

	  if (extensions.ext_srgb) {
	    textureFormats.srgb = GL_SRGB_EXT;
	    textureFormats.srgba = GL_SRGB_ALPHA_EXT;
	  }

	  if (extensions.oes_texture_float) {
	    textureTypes.float32 = textureTypes.float = GL_FLOAT$4;
	  }

	  if (extensions.oes_texture_half_float) {
	    textureTypes['float16'] = textureTypes['half float'] = GL_HALF_FLOAT_OES$1;
	  }

	  if (extensions.webgl_depth_texture) {
	    extend(textureFormats, {
	      'depth': GL_DEPTH_COMPONENT,
	      'depth stencil': GL_DEPTH_STENCIL
	    });

	    extend(textureTypes, {
	      'uint16': GL_UNSIGNED_SHORT$3,
	      'uint32': GL_UNSIGNED_INT$3,
	      'depth stencil': GL_UNSIGNED_INT_24_8_WEBGL$1
	    });
	  }

	  if (extensions.webgl_compressed_texture_s3tc) {
	    extend(compressedTextureFormats, {
	      'rgb s3tc dxt1': GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
	      'rgba s3tc dxt1': GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
	      'rgba s3tc dxt3': GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
	      'rgba s3tc dxt5': GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
	    });
	  }

	  if (extensions.webgl_compressed_texture_atc) {
	    extend(compressedTextureFormats, {
	      'rgb atc': GL_COMPRESSED_RGB_ATC_WEBGL,
	      'rgba atc explicit alpha': GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
	      'rgba atc interpolated alpha': GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
	    });
	  }

	  if (extensions.webgl_compressed_texture_pvrtc) {
	    extend(compressedTextureFormats, {
	      'rgb pvrtc 4bppv1': GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
	      'rgb pvrtc 2bppv1': GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
	      'rgba pvrtc 4bppv1': GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
	      'rgba pvrtc 2bppv1': GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
	    });
	  }

	  if (extensions.webgl_compressed_texture_etc1) {
	    compressedTextureFormats['rgb etc1'] = GL_COMPRESSED_RGB_ETC1_WEBGL;
	  }

	  // Copy over all texture formats
	  var supportedCompressedFormats = Array.prototype.slice.call(
	    gl.getParameter(GL_COMPRESSED_TEXTURE_FORMATS));
	  Object.keys(compressedTextureFormats).forEach(function (name) {
	    var format = compressedTextureFormats[name];
	    if (supportedCompressedFormats.indexOf(format) >= 0) {
	      textureFormats[name] = format;
	    }
	  });

	  var supportedFormats = Object.keys(textureFormats);
	  limits.textureFormats = supportedFormats;

	  // associate with every format string its
	  // corresponding GL-value.
	  var textureFormatsInvert = [];
	  Object.keys(textureFormats).forEach(function (key) {
	    var val = textureFormats[key];
	    textureFormatsInvert[val] = key;
	  });

	  // associate with every type string its
	  // corresponding GL-value.
	  var textureTypesInvert = [];
	  Object.keys(textureTypes).forEach(function (key) {
	    var val = textureTypes[key];
	    textureTypesInvert[val] = key;
	  });

	  var magFiltersInvert = [];
	  Object.keys(magFilters).forEach(function (key) {
	    var val = magFilters[key];
	    magFiltersInvert[val] = key;
	  });

	  var minFiltersInvert = [];
	  Object.keys(minFilters).forEach(function (key) {
	    var val = minFilters[key];
	    minFiltersInvert[val] = key;
	  });

	  var wrapModesInvert = [];
	  Object.keys(wrapModes).forEach(function (key) {
	    var val = wrapModes[key];
	    wrapModesInvert[val] = key;
	  });

	  // colorFormats[] gives the format (channels) associated to an
	  // internalformat
	  var colorFormats = supportedFormats.reduce(function (color, key) {
	    var glenum = textureFormats[key];
	    if (glenum === GL_LUMINANCE ||
	        glenum === GL_ALPHA ||
	        glenum === GL_LUMINANCE ||
	        glenum === GL_LUMINANCE_ALPHA ||
	        glenum === GL_DEPTH_COMPONENT ||
	        glenum === GL_DEPTH_STENCIL ||
	        (extensions.ext_srgb &&
	                (glenum === GL_SRGB_EXT ||
	                 glenum === GL_SRGB_ALPHA_EXT))) {
	      color[glenum] = glenum;
	    } else if (glenum === GL_RGB5_A1 || key.indexOf('rgba') >= 0) {
	      color[glenum] = GL_RGBA$1;
	    } else {
	      color[glenum] = GL_RGB;
	    }
	    return color
	  }, {});

	  function TexFlags () {
	    // format info
	    this.internalformat = GL_RGBA$1;
	    this.format = GL_RGBA$1;
	    this.type = GL_UNSIGNED_BYTE$5;
	    this.compressed = false;

	    // pixel storage
	    this.premultiplyAlpha = false;
	    this.flipY = false;
	    this.unpackAlignment = 1;
	    this.colorSpace = GL_BROWSER_DEFAULT_WEBGL;

	    // shape info
	    this.width = 0;
	    this.height = 0;
	    this.channels = 0;
	  }

	  function copyFlags (result, other) {
	    result.internalformat = other.internalformat;
	    result.format = other.format;
	    result.type = other.type;
	    result.compressed = other.compressed;

	    result.premultiplyAlpha = other.premultiplyAlpha;
	    result.flipY = other.flipY;
	    result.unpackAlignment = other.unpackAlignment;
	    result.colorSpace = other.colorSpace;

	    result.width = other.width;
	    result.height = other.height;
	    result.channels = other.channels;
	  }

	  function parseFlags (flags, options) {
	    if (typeof options !== 'object' || !options) {
	      return
	    }

	    if ('premultiplyAlpha' in options) {
	      check$1.type(options.premultiplyAlpha, 'boolean',
	        'invalid premultiplyAlpha');
	      flags.premultiplyAlpha = options.premultiplyAlpha;
	    }

	    if ('flipY' in options) {
	      check$1.type(options.flipY, 'boolean',
	        'invalid texture flip');
	      flags.flipY = options.flipY;
	    }

	    if ('alignment' in options) {
	      check$1.oneOf(options.alignment, [1, 2, 4, 8],
	        'invalid texture unpack alignment');
	      flags.unpackAlignment = options.alignment;
	    }

	    if ('colorSpace' in options) {
	      check$1.parameter(options.colorSpace, colorSpace,
	        'invalid colorSpace');
	      flags.colorSpace = colorSpace[options.colorSpace];
	    }

	    if ('type' in options) {
	      var type = options.type;
	      check$1(extensions.oes_texture_float ||
	        !(type === 'float' || type === 'float32'),
	      'you must enable the OES_texture_float extension in order to use floating point textures.');
	      check$1(extensions.oes_texture_half_float ||
	        !(type === 'half float' || type === 'float16'),
	      'you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures.');
	      check$1(extensions.webgl_depth_texture ||
	        !(type === 'uint16' || type === 'uint32' || type === 'depth stencil'),
	      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.');
	      check$1.parameter(type, textureTypes,
	        'invalid texture type');
	      flags.type = textureTypes[type];
	    }

	    var w = flags.width;
	    var h = flags.height;
	    var c = flags.channels;
	    var hasChannels = false;
	    if ('shape' in options) {
	      check$1(Array.isArray(options.shape) && options.shape.length >= 2,
	        'shape must be an array');
	      w = options.shape[0];
	      h = options.shape[1];
	      if (options.shape.length === 3) {
	        c = options.shape[2];
	        check$1(c > 0 && c <= 4, 'invalid number of channels');
	        hasChannels = true;
	      }
	      check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width');
	      check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height');
	    } else {
	      if ('radius' in options) {
	        w = h = options.radius;
	        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid radius');
	      }
	      if ('width' in options) {
	        w = options.width;
	        check$1(w >= 0 && w <= limits.maxTextureSize, 'invalid width');
	      }
	      if ('height' in options) {
	        h = options.height;
	        check$1(h >= 0 && h <= limits.maxTextureSize, 'invalid height');
	      }
	      if ('channels' in options) {
	        c = options.channels;
	        check$1(c > 0 && c <= 4, 'invalid number of channels');
	        hasChannels = true;
	      }
	    }
	    flags.width = w | 0;
	    flags.height = h | 0;
	    flags.channels = c | 0;

	    var hasFormat = false;
	    if ('format' in options) {
	      var formatStr = options.format;
	      check$1(extensions.webgl_depth_texture ||
	        !(formatStr === 'depth' || formatStr === 'depth stencil'),
	      'you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.');
	      check$1.parameter(formatStr, textureFormats,
	        'invalid texture format');
	      var internalformat = flags.internalformat = textureFormats[formatStr];
	      flags.format = colorFormats[internalformat];
	      if (formatStr in textureTypes) {
	        if (!('type' in options)) {
	          flags.type = textureTypes[formatStr];
	        }
	      }
	      if (formatStr in compressedTextureFormats) {
	        flags.compressed = true;
	      }
	      hasFormat = true;
	    }

	    // Reconcile channels and format
	    if (!hasChannels && hasFormat) {
	      flags.channels = FORMAT_CHANNELS[flags.format];
	    } else if (hasChannels && !hasFormat) {
	      if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
	        flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels];
	      }
	    } else if (hasFormat && hasChannels) {
	      check$1(
	        flags.channels === FORMAT_CHANNELS[flags.format],
	        'number of channels inconsistent with specified format');
	    }
	  }

	  function setFlags (flags) {
	    gl.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY);
	    gl.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha);
	    gl.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace);
	    gl.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment);
	  }

	  // -------------------------------------------------------
	  // Tex image data
	  // -------------------------------------------------------
	  function TexImage () {
	    TexFlags.call(this);

	    this.xOffset = 0;
	    this.yOffset = 0;

	    // data
	    this.data = null;
	    this.needsFree = false;

	    // html element
	    this.element = null;

	    // copyTexImage info
	    this.needsCopy = false;
	  }

	  function parseImage (image, options) {
	    var data = null;
	    if (isPixelData(options)) {
	      data = options;
	    } else if (options) {
	      check$1.type(options, 'object', 'invalid pixel data type');
	      parseFlags(image, options);
	      if ('x' in options) {
	        image.xOffset = options.x | 0;
	      }
	      if ('y' in options) {
	        image.yOffset = options.y | 0;
	      }
	      if (isPixelData(options.data)) {
	        data = options.data;
	      }
	    }

	    check$1(
	      !image.compressed ||
	      data instanceof Uint8Array,
	      'compressed texture data must be stored in a uint8array');

	    if (options.copy) {
	      check$1(!data, 'can not specify copy and data field for the same texture');
	      var viewW = contextState.viewportWidth;
	      var viewH = contextState.viewportHeight;
	      image.width = image.width || (viewW - image.xOffset);
	      image.height = image.height || (viewH - image.yOffset);
	      image.needsCopy = true;
	      check$1(image.xOffset >= 0 && image.xOffset < viewW &&
	            image.yOffset >= 0 && image.yOffset < viewH &&
	            image.width > 0 && image.width <= viewW &&
	            image.height > 0 && image.height <= viewH,
	      'copy texture read out of bounds');
	    } else if (!data) {
	      image.width = image.width || 1;
	      image.height = image.height || 1;
	      image.channels = image.channels || 4;
	    } else if (isTypedArray(data)) {
	      image.channels = image.channels || 4;
	      image.data = data;
	      if (!('type' in options) && image.type === GL_UNSIGNED_BYTE$5) {
	        image.type = typedArrayCode$1(data);
	      }
	    } else if (isNumericArray(data)) {
	      image.channels = image.channels || 4;
	      convertData(image, data);
	      image.alignment = 1;
	      image.needsFree = true;
	    } else if (isNDArrayLike(data)) {
	      var array = data.data;
	      if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$5) {
	        image.type = typedArrayCode$1(array);
	      }
	      var shape = data.shape;
	      var stride = data.stride;
	      var shapeX, shapeY, shapeC, strideX, strideY, strideC;
	      if (shape.length === 3) {
	        shapeC = shape[2];
	        strideC = stride[2];
	      } else {
	        check$1(shape.length === 2, 'invalid ndarray pixel data, must be 2 or 3D');
	        shapeC = 1;
	        strideC = 1;
	      }
	      shapeX = shape[0];
	      shapeY = shape[1];
	      strideX = stride[0];
	      strideY = stride[1];
	      image.alignment = 1;
	      image.width = shapeX;
	      image.height = shapeY;
	      image.channels = shapeC;
	      image.format = image.internalformat = CHANNELS_FORMAT[shapeC];
	      image.needsFree = true;
	      transposeData(image, array, strideX, strideY, strideC, data.offset);
	    } else if (isCanvasElement(data) || isOffscreenCanvas(data) || isContext2D(data)) {
	      if (isCanvasElement(data) || isOffscreenCanvas(data)) {
	        image.element = data;
	      } else {
	        image.element = data.canvas;
	      }
	      image.width = image.element.width;
	      image.height = image.element.height;
	      image.channels = 4;
	    } else if (isBitmap(data)) {
	      image.element = data;
	      image.width = data.width;
	      image.height = data.height;
	      image.channels = 4;
	    } else if (isImageElement(data)) {
	      image.element = data;
	      image.width = data.naturalWidth;
	      image.height = data.naturalHeight;
	      image.channels = 4;
	    } else if (isVideoElement(data)) {
	      image.element = data;
	      image.width = data.videoWidth;
	      image.height = data.videoHeight;
	      image.channels = 4;
	    } else if (isRectArray(data)) {
	      var w = image.width || data[0].length;
	      var h = image.height || data.length;
	      var c = image.channels;
	      if (isArrayLike(data[0][0])) {
	        c = c || data[0][0].length;
	      } else {
	        c = c || 1;
	      }
	      var arrayShape = flattenUtils.shape(data);
	      var n = 1;
	      for (var dd = 0; dd < arrayShape.length; ++dd) {
	        n *= arrayShape[dd];
	      }
	      var allocData = preConvert(image, n);
	      flattenUtils.flatten(data, arrayShape, '', allocData);
	      postConvert(image, allocData);
	      image.alignment = 1;
	      image.width = w;
	      image.height = h;
	      image.channels = c;
	      image.format = image.internalformat = CHANNELS_FORMAT[c];
	      image.needsFree = true;
	    }

	    if (image.type === GL_FLOAT$4) {
	      check$1(limits.extensions.indexOf('oes_texture_float') >= 0,
	        'oes_texture_float extension not enabled');
	    } else if (image.type === GL_HALF_FLOAT_OES$1) {
	      check$1(limits.extensions.indexOf('oes_texture_half_float') >= 0,
	        'oes_texture_half_float extension not enabled');
	    }

	    // do compressed texture  validation here.
	  }

	  function setImage (info, target, miplevel) {
	    var element = info.element;
	    var data = info.data;
	    var internalformat = info.internalformat;
	    var format = info.format;
	    var type = info.type;
	    var width = info.width;
	    var height = info.height;

	    setFlags(info);

	    if (element) {
	      gl.texImage2D(target, miplevel, format, format, type, element);
	    } else if (info.compressed) {
	      gl.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data);
	    } else if (info.needsCopy) {
	      reglPoll();
	      gl.copyTexImage2D(
	        target, miplevel, format, info.xOffset, info.yOffset, width, height, 0);
	    } else {
	      gl.texImage2D(target, miplevel, format, width, height, 0, format, type, data || null);
	    }
	  }

	  function setSubImage (info, target, x, y, miplevel) {
	    var element = info.element;
	    var data = info.data;
	    var internalformat = info.internalformat;
	    var format = info.format;
	    var type = info.type;
	    var width = info.width;
	    var height = info.height;

	    setFlags(info);

	    if (element) {
	      gl.texSubImage2D(
	        target, miplevel, x, y, format, type, element);
	    } else if (info.compressed) {
	      gl.compressedTexSubImage2D(
	        target, miplevel, x, y, internalformat, width, height, data);
	    } else if (info.needsCopy) {
	      reglPoll();
	      gl.copyTexSubImage2D(
	        target, miplevel, x, y, info.xOffset, info.yOffset, width, height);
	    } else {
	      gl.texSubImage2D(
	        target, miplevel, x, y, width, height, format, type, data);
	    }
	  }

	  // texImage pool
	  var imagePool = [];

	  function allocImage () {
	    return imagePool.pop() || new TexImage()
	  }

	  function freeImage (image) {
	    if (image.needsFree) {
	      pool.freeType(image.data);
	    }
	    TexImage.call(image);
	    imagePool.push(image);
	  }

	  // -------------------------------------------------------
	  // Mip map
	  // -------------------------------------------------------
	  function MipMap () {
	    TexFlags.call(this);

	    this.genMipmaps = false;
	    this.mipmapHint = GL_DONT_CARE;
	    this.mipmask = 0;
	    this.images = Array(16);
	  }

	  function parseMipMapFromShape (mipmap, width, height) {
	    var img = mipmap.images[0] = allocImage();
	    mipmap.mipmask = 1;
	    img.width = mipmap.width = width;
	    img.height = mipmap.height = height;
	    img.channels = mipmap.channels = 4;
	  }

	  function parseMipMapFromObject (mipmap, options) {
	    var imgData = null;
	    if (isPixelData(options)) {
	      imgData = mipmap.images[0] = allocImage();
	      copyFlags(imgData, mipmap);
	      parseImage(imgData, options);
	      mipmap.mipmask = 1;
	    } else {
	      parseFlags(mipmap, options);
	      if (Array.isArray(options.mipmap)) {
	        var mipData = options.mipmap;
	        for (var i = 0; i < mipData.length; ++i) {
	          imgData = mipmap.images[i] = allocImage();
	          copyFlags(imgData, mipmap);
	          imgData.width >>= i;
	          imgData.height >>= i;
	          parseImage(imgData, mipData[i]);
	          mipmap.mipmask |= (1 << i);
	        }
	      } else {
	        imgData = mipmap.images[0] = allocImage();
	        copyFlags(imgData, mipmap);
	        parseImage(imgData, options);
	        mipmap.mipmask = 1;
	      }
	    }
	    copyFlags(mipmap, mipmap.images[0]);

	    // For textures of the compressed format WEBGL_compressed_texture_s3tc
	    // we must have that
	    //
	    // "When level equals zero width and height must be a multiple of 4.
	    // When level is greater than 0 width and height must be 0, 1, 2 or a multiple of 4. "
	    //
	    // but we do not yet support having multiple mipmap levels for compressed textures,
	    // so we only test for level zero.

	    if (
	      mipmap.compressed &&
	      (
	        mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT ||
	        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT ||
	        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT ||
	        mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
	      )
	    ) {
	      check$1(mipmap.width % 4 === 0 && mipmap.height % 4 === 0,
	        'for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4');
	    }
	  }

	  function setMipMap (mipmap, target) {
	    var images = mipmap.images;
	    for (var i = 0; i < images.length; ++i) {
	      if (!images[i]) {
	        return
	      }
	      setImage(images[i], target, i);
	    }
	  }

	  var mipPool = [];

	  function allocMipMap () {
	    var result = mipPool.pop() || new MipMap();
	    TexFlags.call(result);
	    result.mipmask = 0;
	    for (var i = 0; i < 16; ++i) {
	      result.images[i] = null;
	    }
	    return result
	  }

	  function freeMipMap (mipmap) {
	    var images = mipmap.images;
	    for (var i = 0; i < images.length; ++i) {
	      if (images[i]) {
	        freeImage(images[i]);
	      }
	      images[i] = null;
	    }
	    mipPool.push(mipmap);
	  }

	  // -------------------------------------------------------
	  // Tex info
	  // -------------------------------------------------------
	  function TexInfo () {
	    this.minFilter = GL_NEAREST$1;
	    this.magFilter = GL_NEAREST$1;

	    this.wrapS = GL_CLAMP_TO_EDGE$1;
	    this.wrapT = GL_CLAMP_TO_EDGE$1;

	    this.anisotropic = 1;

	    this.genMipmaps = false;
	    this.mipmapHint = GL_DONT_CARE;
	  }

	  function parseTexInfo (info, options) {
	    if ('min' in options) {
	      var minFilter = options.min;
	      check$1.parameter(minFilter, minFilters);
	      info.minFilter = minFilters[minFilter];
	      if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !('faces' in options)) {
	        info.genMipmaps = true;
	      }
	    }

	    if ('mag' in options) {
	      var magFilter = options.mag;
	      check$1.parameter(magFilter, magFilters);
	      info.magFilter = magFilters[magFilter];
	    }

	    var wrapS = info.wrapS;
	    var wrapT = info.wrapT;
	    if ('wrap' in options) {
	      var wrap = options.wrap;
	      if (typeof wrap === 'string') {
	        check$1.parameter(wrap, wrapModes);
	        wrapS = wrapT = wrapModes[wrap];
	      } else if (Array.isArray(wrap)) {
	        check$1.parameter(wrap[0], wrapModes);
	        check$1.parameter(wrap[1], wrapModes);
	        wrapS = wrapModes[wrap[0]];
	        wrapT = wrapModes[wrap[1]];
	      }
	    } else {
	      if ('wrapS' in options) {
	        var optWrapS = options.wrapS;
	        check$1.parameter(optWrapS, wrapModes);
	        wrapS = wrapModes[optWrapS];
	      }
	      if ('wrapT' in options) {
	        var optWrapT = options.wrapT;
	        check$1.parameter(optWrapT, wrapModes);
	        wrapT = wrapModes[optWrapT];
	      }
	    }
	    info.wrapS = wrapS;
	    info.wrapT = wrapT;

	    if ('anisotropic' in options) {
	      var anisotropic = options.anisotropic;
	      check$1(typeof anisotropic === 'number' &&
	         anisotropic >= 1 && anisotropic <= limits.maxAnisotropic,
	      'aniso samples must be between 1 and ');
	      info.anisotropic = options.anisotropic;
	    }

	    if ('mipmap' in options) {
	      var hasMipMap = false;
	      switch (typeof options.mipmap) {
	        case 'string':
	          check$1.parameter(options.mipmap, mipmapHint,
	            'invalid mipmap hint');
	          info.mipmapHint = mipmapHint[options.mipmap];
	          info.genMipmaps = true;
	          hasMipMap = true;
	          break

	        case 'boolean':
	          hasMipMap = info.genMipmaps = options.mipmap;
	          break

	        case 'object':
	          check$1(Array.isArray(options.mipmap), 'invalid mipmap type');
	          info.genMipmaps = false;
	          hasMipMap = true;
	          break

	        default:
	          check$1.raise('invalid mipmap type');
	      }
	      if (hasMipMap && !('min' in options)) {
	        info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1;
	      }
	    }
	  }

	  function setTexInfo (info, target) {
	    gl.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter);
	    gl.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter);
	    gl.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS);
	    gl.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT);
	    if (extensions.ext_texture_filter_anisotropic) {
	      gl.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic);
	    }
	    if (info.genMipmaps) {
	      gl.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint);
	      gl.generateMipmap(target);
	    }
	  }

	  // -------------------------------------------------------
	  // Full texture object
	  // -------------------------------------------------------
	  var textureCount = 0;
	  var textureSet = {};
	  var numTexUnits = limits.maxTextureUnits;
	  var textureUnits = Array(numTexUnits).map(function () {
	    return null
	  });

	  function REGLTexture (target) {
	    TexFlags.call(this);
	    this.mipmask = 0;
	    this.internalformat = GL_RGBA$1;

	    this.id = textureCount++;

	    this.refCount = 1;

	    this.target = target;
	    this.texture = gl.createTexture();

	    this.unit = -1;
	    this.bindCount = 0;

	    this.texInfo = new TexInfo();

	    if (config.profile) {
	      this.stats = { size: 0 };
	    }
	  }

	  function tempBind (texture) {
	    gl.activeTexture(GL_TEXTURE0$1);
	    gl.bindTexture(texture.target, texture.texture);
	  }

	  function tempRestore () {
	    var prev = textureUnits[0];
	    if (prev) {
	      gl.bindTexture(prev.target, prev.texture);
	    } else {
	      gl.bindTexture(GL_TEXTURE_2D$1, null);
	    }
	  }

	  function destroy (texture) {
	    var handle = texture.texture;
	    check$1(handle, 'must not double destroy texture');
	    var unit = texture.unit;
	    var target = texture.target;
	    if (unit >= 0) {
	      gl.activeTexture(GL_TEXTURE0$1 + unit);
	      gl.bindTexture(target, null);
	      textureUnits[unit] = null;
	    }
	    gl.deleteTexture(handle);
	    texture.texture = null;
	    texture.params = null;
	    texture.pixels = null;
	    texture.refCount = 0;
	    delete textureSet[texture.id];
	    stats.textureCount--;
	  }

	  extend(REGLTexture.prototype, {
	    bind: function () {
	      var texture = this;
	      texture.bindCount += 1;
	      var unit = texture.unit;
	      if (unit < 0) {
	        for (var i = 0; i < numTexUnits; ++i) {
	          var other = textureUnits[i];
	          if (other) {
	            if (other.bindCount > 0) {
	              continue
	            }
	            other.unit = -1;
	          }
	          textureUnits[i] = texture;
	          unit = i;
	          break
	        }
	        if (unit >= numTexUnits) {
	          check$1.raise('insufficient number of texture units');
	        }
	        if (config.profile && stats.maxTextureUnits < (unit + 1)) {
	          stats.maxTextureUnits = unit + 1; // +1, since the units are zero-based
	        }
	        texture.unit = unit;
	        gl.activeTexture(GL_TEXTURE0$1 + unit);
	        gl.bindTexture(texture.target, texture.texture);
	      }
	      return unit
	    },

	    unbind: function () {
	      this.bindCount -= 1;
	    },

	    decRef: function () {
	      if (--this.refCount <= 0) {
	        destroy(this);
	      }
	    }
	  });

	  function createTexture2D (a, b) {
	    var texture = new REGLTexture(GL_TEXTURE_2D$1);
	    textureSet[texture.id] = texture;
	    stats.textureCount++;

	    function reglTexture2D (a, b) {
	      var texInfo = texture.texInfo;
	      TexInfo.call(texInfo);
	      var mipData = allocMipMap();

	      if (typeof a === 'number') {
	        if (typeof b === 'number') {
	          parseMipMapFromShape(mipData, a | 0, b | 0);
	        } else {
	          parseMipMapFromShape(mipData, a | 0, a | 0);
	        }
	      } else if (a) {
	        check$1.type(a, 'object', 'invalid arguments to regl.texture');
	        parseTexInfo(texInfo, a);
	        parseMipMapFromObject(mipData, a);
	      } else {
	        // empty textures get assigned a default shape of 1x1
	        parseMipMapFromShape(mipData, 1, 1);
	      }

	      if (texInfo.genMipmaps) {
	        mipData.mipmask = (mipData.width << 1) - 1;
	      }
	      texture.mipmask = mipData.mipmask;

	      copyFlags(texture, mipData);

	      check$1.texture2D(texInfo, mipData, limits);
	      texture.internalformat = mipData.internalformat;

	      reglTexture2D.width = mipData.width;
	      reglTexture2D.height = mipData.height;

	      tempBind(texture);
	      setMipMap(mipData, GL_TEXTURE_2D$1);
	      setTexInfo(texInfo, GL_TEXTURE_2D$1);
	      tempRestore();

	      freeMipMap(mipData);

	      if (config.profile) {
	        texture.stats.size = getTextureSize(
	          texture.internalformat,
	          texture.type,
	          mipData.width,
	          mipData.height,
	          texInfo.genMipmaps,
	          false);
	      }
	      reglTexture2D.format = textureFormatsInvert[texture.internalformat];
	      reglTexture2D.type = textureTypesInvert[texture.type];

	      reglTexture2D.mag = magFiltersInvert[texInfo.magFilter];
	      reglTexture2D.min = minFiltersInvert[texInfo.minFilter];

	      reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS];
	      reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT];

	      return reglTexture2D
	    }

	    function subimage (image, x_, y_, level_) {
	      check$1(!!image, 'must specify image data');

	      var x = x_ | 0;
	      var y = y_ | 0;
	      var level = level_ | 0;

	      var imageData = allocImage();
	      copyFlags(imageData, texture);
	      imageData.width = 0;
	      imageData.height = 0;
	      parseImage(imageData, image);
	      imageData.width = imageData.width || ((texture.width >> level) - x);
	      imageData.height = imageData.height || ((texture.height >> level) - y);

	      check$1(
	        texture.type === imageData.type &&
	        texture.format === imageData.format &&
	        texture.internalformat === imageData.internalformat,
	        'incompatible format for texture.subimage');
	      check$1(
	        x >= 0 && y >= 0 &&
	        x + imageData.width <= texture.width &&
	        y + imageData.height <= texture.height,
	        'texture.subimage write out of bounds');
	      check$1(
	        texture.mipmask & (1 << level),
	        'missing mipmap data');
	      check$1(
	        imageData.data || imageData.element || imageData.needsCopy,
	        'missing image data');

	      tempBind(texture);
	      setSubImage(imageData, GL_TEXTURE_2D$1, x, y, level);
	      tempRestore();

	      freeImage(imageData);

	      return reglTexture2D
	    }

	    function resize (w_, h_) {
	      var w = w_ | 0;
	      var h = (h_ | 0) || w;
	      if (w === texture.width && h === texture.height) {
	        return reglTexture2D
	      }

	      reglTexture2D.width = texture.width = w;
	      reglTexture2D.height = texture.height = h;

	      tempBind(texture);

	      for (var i = 0; texture.mipmask >> i; ++i) {
	        var _w = w >> i;
	        var _h = h >> i;
	        if (!_w || !_h) break
	        gl.texImage2D(
	          GL_TEXTURE_2D$1,
	          i,
	          texture.format,
	          _w,
	          _h,
	          0,
	          texture.format,
	          texture.type,
	          null);
	      }
	      tempRestore();

	      // also, recompute the texture size.
	      if (config.profile) {
	        texture.stats.size = getTextureSize(
	          texture.internalformat,
	          texture.type,
	          w,
	          h,
	          false,
	          false);
	      }

	      return reglTexture2D
	    }

	    reglTexture2D(a, b);

	    reglTexture2D.subimage = subimage;
	    reglTexture2D.resize = resize;
	    reglTexture2D._reglType = 'texture2d';
	    reglTexture2D._texture = texture;
	    if (config.profile) {
	      reglTexture2D.stats = texture.stats;
	    }
	    reglTexture2D.destroy = function () {
	      texture.decRef();
	    };

	    return reglTexture2D
	  }

	  function createTextureCube (a0, a1, a2, a3, a4, a5) {
	    var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1);
	    textureSet[texture.id] = texture;
	    stats.cubeCount++;

	    var faces = new Array(6);

	    function reglTextureCube (a0, a1, a2, a3, a4, a5) {
	      var i;
	      var texInfo = texture.texInfo;
	      TexInfo.call(texInfo);
	      for (i = 0; i < 6; ++i) {
	        faces[i] = allocMipMap();
	      }

	      if (typeof a0 === 'number' || !a0) {
	        var s = (a0 | 0) || 1;
	        for (i = 0; i < 6; ++i) {
	          parseMipMapFromShape(faces[i], s, s);
	        }
	      } else if (typeof a0 === 'object') {
	        if (a1) {
	          parseMipMapFromObject(faces[0], a0);
	          parseMipMapFromObject(faces[1], a1);
	          parseMipMapFromObject(faces[2], a2);
	          parseMipMapFromObject(faces[3], a3);
	          parseMipMapFromObject(faces[4], a4);
	          parseMipMapFromObject(faces[5], a5);
	        } else {
	          parseTexInfo(texInfo, a0);
	          parseFlags(texture, a0);
	          if ('faces' in a0) {
	            var faceInput = a0.faces;
	            check$1(Array.isArray(faceInput) && faceInput.length === 6,
	              'cube faces must be a length 6 array');
	            for (i = 0; i < 6; ++i) {
	              check$1(typeof faceInput[i] === 'object' && !!faceInput[i],
	                'invalid input for cube map face');
	              copyFlags(faces[i], texture);
	              parseMipMapFromObject(faces[i], faceInput[i]);
	            }
	          } else {
	            for (i = 0; i < 6; ++i) {
	              parseMipMapFromObject(faces[i], a0);
	            }
	          }
	        }
	      } else {
	        check$1.raise('invalid arguments to cube map');
	      }

	      copyFlags(texture, faces[0]);
	      check$1.optional(function () {
	        if (!limits.npotTextureCube) {
	          check$1(isPow2$1(texture.width) && isPow2$1(texture.height), 'your browser does not support non power or two texture dimensions');
	        }
	      });

	      if (texInfo.genMipmaps) {
	        texture.mipmask = (faces[0].width << 1) - 1;
	      } else {
	        texture.mipmask = faces[0].mipmask;
	      }

	      check$1.textureCube(texture, texInfo, faces, limits);
	      texture.internalformat = faces[0].internalformat;

	      reglTextureCube.width = faces[0].width;
	      reglTextureCube.height = faces[0].height;

	      tempBind(texture);
	      for (i = 0; i < 6; ++i) {
	        setMipMap(faces[i], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i);
	      }
	      setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1);
	      tempRestore();

	      if (config.profile) {
	        texture.stats.size = getTextureSize(
	          texture.internalformat,
	          texture.type,
	          reglTextureCube.width,
	          reglTextureCube.height,
	          texInfo.genMipmaps,
	          true);
	      }

	      reglTextureCube.format = textureFormatsInvert[texture.internalformat];
	      reglTextureCube.type = textureTypesInvert[texture.type];

	      reglTextureCube.mag = magFiltersInvert[texInfo.magFilter];
	      reglTextureCube.min = minFiltersInvert[texInfo.minFilter];

	      reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS];
	      reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT];

	      for (i = 0; i < 6; ++i) {
	        freeMipMap(faces[i]);
	      }

	      return reglTextureCube
	    }

	    function subimage (face, image, x_, y_, level_) {
	      check$1(!!image, 'must specify image data');
	      check$1(typeof face === 'number' && face === (face | 0) &&
	        face >= 0 && face < 6, 'invalid face');

	      var x = x_ | 0;
	      var y = y_ | 0;
	      var level = level_ | 0;

	      var imageData = allocImage();
	      copyFlags(imageData, texture);
	      imageData.width = 0;
	      imageData.height = 0;
	      parseImage(imageData, image);
	      imageData.width = imageData.width || ((texture.width >> level) - x);
	      imageData.height = imageData.height || ((texture.height >> level) - y);

	      check$1(
	        texture.type === imageData.type &&
	        texture.format === imageData.format &&
	        texture.internalformat === imageData.internalformat,
	        'incompatible format for texture.subimage');
	      check$1(
	        x >= 0 && y >= 0 &&
	        x + imageData.width <= texture.width &&
	        y + imageData.height <= texture.height,
	        'texture.subimage write out of bounds');
	      check$1(
	        texture.mipmask & (1 << level),
	        'missing mipmap data');
	      check$1(
	        imageData.data || imageData.element || imageData.needsCopy,
	        'missing image data');

	      tempBind(texture);
	      setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x, y, level);
	      tempRestore();

	      freeImage(imageData);

	      return reglTextureCube
	    }

	    function resize (radius_) {
	      var radius = radius_ | 0;
	      if (radius === texture.width) {
	        return
	      }

	      reglTextureCube.width = texture.width = radius;
	      reglTextureCube.height = texture.height = radius;

	      tempBind(texture);
	      for (var i = 0; i < 6; ++i) {
	        for (var j = 0; texture.mipmask >> j; ++j) {
	          gl.texImage2D(
	            GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i,
	            j,
	            texture.format,
	            radius >> j,
	            radius >> j,
	            0,
	            texture.format,
	            texture.type,
	            null);
	        }
	      }
	      tempRestore();

	      if (config.profile) {
	        texture.stats.size = getTextureSize(
	          texture.internalformat,
	          texture.type,
	          reglTextureCube.width,
	          reglTextureCube.height,
	          false,
	          true);
	      }

	      return reglTextureCube
	    }

	    reglTextureCube(a0, a1, a2, a3, a4, a5);

	    reglTextureCube.subimage = subimage;
	    reglTextureCube.resize = resize;
	    reglTextureCube._reglType = 'textureCube';
	    reglTextureCube._texture = texture;
	    if (config.profile) {
	      reglTextureCube.stats = texture.stats;
	    }
	    reglTextureCube.destroy = function () {
	      texture.decRef();
	    };

	    return reglTextureCube
	  }

	  // Called when regl is destroyed
	  function destroyTextures () {
	    for (var i = 0; i < numTexUnits; ++i) {
	      gl.activeTexture(GL_TEXTURE0$1 + i);
	      gl.bindTexture(GL_TEXTURE_2D$1, null);
	      textureUnits[i] = null;
	    }
	    values(textureSet).forEach(destroy);

	    stats.cubeCount = 0;
	    stats.textureCount = 0;
	  }

	  if (config.profile) {
	    stats.getTotalTextureSize = function () {
	      var total = 0;
	      Object.keys(textureSet).forEach(function (key) {
	        total += textureSet[key].stats.size;
	      });
	      return total
	    };
	  }

	  function restoreTextures () {
	    for (var i = 0; i < numTexUnits; ++i) {
	      var tex = textureUnits[i];
	      if (tex) {
	        tex.bindCount = 0;
	        tex.unit = -1;
	        textureUnits[i] = null;
	      }
	    }

	    values(textureSet).forEach(function (texture) {
	      texture.texture = gl.createTexture();
	      gl.bindTexture(texture.target, texture.texture);
	      for (var i = 0; i < 32; ++i) {
	        if ((texture.mipmask & (1 << i)) === 0) {
	          continue
	        }
	        if (texture.target === GL_TEXTURE_2D$1) {
	          gl.texImage2D(GL_TEXTURE_2D$1,
	            i,
	            texture.internalformat,
	            texture.width >> i,
	            texture.height >> i,
	            0,
	            texture.internalformat,
	            texture.type,
	            null);
	        } else {
	          for (var j = 0; j < 6; ++j) {
	            gl.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j,
	              i,
	              texture.internalformat,
	              texture.width >> i,
	              texture.height >> i,
	              0,
	              texture.internalformat,
	              texture.type,
	              null);
	          }
	        }
	      }
	      setTexInfo(texture.texInfo, texture.target);
	    });
	  }

	  function refreshTextures () {
	    for (var i = 0; i < numTexUnits; ++i) {
	      var tex = textureUnits[i];
	      if (tex) {
	        tex.bindCount = 0;
	        tex.unit = -1;
	        textureUnits[i] = null;
	      }
	      gl.activeTexture(GL_TEXTURE0$1 + i);
	      gl.bindTexture(GL_TEXTURE_2D$1, null);
	      gl.bindTexture(GL_TEXTURE_CUBE_MAP$1, null);
	    }
	  }

	  return {
	    create2D: createTexture2D,
	    createCube: createTextureCube,
	    clear: destroyTextures,
	    getTexture: function (wrapper) {
	      return null
	    },
	    restore: restoreTextures,
	    refresh: refreshTextures
	  }
	}

	var GL_RENDERBUFFER = 0x8D41;

	var GL_RGBA4$1 = 0x8056;
	var GL_RGB5_A1$1 = 0x8057;
	var GL_RGBA8 = 0x8058;
	var GL_RGB565$1 = 0x8D62;
	var GL_DEPTH_COMPONENT16 = 0x81A5;
	var GL_STENCIL_INDEX8 = 0x8D48;
	var GL_DEPTH_STENCIL$1 = 0x84F9;
	var GL_DEPTH24_STENCIL8 = 0x88F0;

	var GL_SRGB8_ALPHA8_EXT = 0x8C43;

	var GL_RGBA32F_EXT = 0x8814;

	var GL_RGBA16F_EXT = 0x881A;
	var GL_RGB16F_EXT = 0x881B;

	var FORMAT_SIZES = [];

	FORMAT_SIZES[GL_RGBA4$1] = 2;
	FORMAT_SIZES[GL_RGB5_A1$1] = 2;
	FORMAT_SIZES[GL_RGB565$1] = 2;

	FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2;
	FORMAT_SIZES[GL_STENCIL_INDEX8] = 1;
	FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4;
	FORMAT_SIZES[GL_DEPTH24_STENCIL8] = 4;

	FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4;
	FORMAT_SIZES[GL_RGBA32F_EXT] = 16;
	FORMAT_SIZES[GL_RGBA16F_EXT] = 8;
	FORMAT_SIZES[GL_RGB16F_EXT] = 6;

	function getRenderbufferSize (format, width, height) {
	  return FORMAT_SIZES[format] * width * height
	}

	var wrapRenderbuffers = function (gl, extensions, limits, stats, config) {
	  var formatTypes = {
	    'rgba4': GL_RGBA4$1,
	    'rgba8': GL_RGBA8,
	    'rgb565': GL_RGB565$1,
	    'rgb5 a1': GL_RGB5_A1$1,
	    'depth': GL_DEPTH_COMPONENT16,
	    'stencil': GL_STENCIL_INDEX8,
	    'depth stencil': GL_DEPTH_STENCIL$1,
	    'depth24 stencil8': GL_DEPTH24_STENCIL8
	  };

	  if (extensions.ext_srgb) {
	    formatTypes['srgba'] = GL_SRGB8_ALPHA8_EXT;
	  }

	  if (extensions.ext_color_buffer_half_float) {
	    formatTypes['rgba16f'] = GL_RGBA16F_EXT;
	    formatTypes['rgb16f'] = GL_RGB16F_EXT;
	  }

	  if (extensions.webgl_color_buffer_float) {
	    formatTypes['rgba32f'] = GL_RGBA32F_EXT;
	  }

	  var formatTypesInvert = [];
	  Object.keys(formatTypes).forEach(function (key) {
	    var val = formatTypes[key];
	    formatTypesInvert[val] = key;
	  });

	  var renderbufferCount = 0;
	  var renderbufferSet = {};

	  function REGLRenderbuffer (renderbuffer) {
	    this.id = renderbufferCount++;
	    this.refCount = 1;

	    this.renderbuffer = renderbuffer;

	    this.format = GL_RGBA4$1;
	    this.width = 0;
	    this.height = 0;

	    if (config.profile) {
	      this.stats = { size: 0 };
	    }
	  }

	  REGLRenderbuffer.prototype.decRef = function () {
	    if (--this.refCount <= 0) {
	      destroy(this);
	    }
	  };

	  function destroy (rb) {
	    var handle = rb.renderbuffer;
	    check$1(handle, 'must not double destroy renderbuffer');
	    gl.bindRenderbuffer(GL_RENDERBUFFER, null);
	    gl.deleteRenderbuffer(handle);
	    rb.renderbuffer = null;
	    rb.refCount = 0;
	    delete renderbufferSet[rb.id];
	    stats.renderbufferCount--;
	  }

	  function createRenderbuffer (a, b) {
	    var renderbuffer = new REGLRenderbuffer(gl.createRenderbuffer());
	    renderbufferSet[renderbuffer.id] = renderbuffer;
	    stats.renderbufferCount++;

	    function reglRenderbuffer (a, b) {
	      var w = 0;
	      var h = 0;
	      var format = GL_RGBA4$1;
	      var samples = 0;

	      if (typeof a === 'object' && a) {
	        var options = a;
	        if ('shape' in options) {
	          var shape = options.shape;
	          check$1(Array.isArray(shape) && shape.length >= 2,
	            'invalid renderbuffer shape');
	          w = shape[0] | 0;
	          h = shape[1] | 0;
	        } else {
	          if ('radius' in options) {
	            w = h = options.radius | 0;
	          }
	          if ('width' in options) {
	            w = options.width | 0;
	          }
	          if ('height' in options) {
	            h = options.height | 0;
	          }
	        }
	        if ('format' in options) {
	          check$1.parameter(options.format, formatTypes,
	            'invalid renderbuffer format');
	          format = formatTypes[options.format];
	        }
	        if ('samples' in options) {
	          samples = options.samples;
	        }
	      } else if (typeof a === 'number') {
	        w = a | 0;
	        if (typeof b === 'number') {
	          h = b | 0;
	        } else {
	          h = w;
	        }
	      } else if (!a) {
	        w = h = 1;
	      } else {
	        check$1.raise('invalid arguments to renderbuffer constructor');
	      }

	      // check shape
	      check$1(
	        w > 0 && h > 0 &&
	        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
	        'invalid renderbuffer size');

	      if (w === renderbuffer.width &&
	          h === renderbuffer.height &&
	          format === renderbuffer.format) {
	        return
	      }

	      reglRenderbuffer.width = renderbuffer.width = w;
	      reglRenderbuffer.height = renderbuffer.height = h;
	      reglRenderbuffer.samples = samples;
	      renderbuffer.format = format;
	      renderbuffer.samples = samples;

	      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
	      if (samples && gl.renderbufferStorageMultisample)  {
	        gl.renderbufferStorageMultisample(GL_RENDERBUFFER, samples, format, w, h);
	      } else {
	        gl.renderbufferStorage(GL_RENDERBUFFER, format, w, h);
	      }

	      // check(
	      //   gl.getError() === 0,
	      //   'invalid render buffer format')

	      if (config.profile) {
	        renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);
	      }
	      reglRenderbuffer.format = formatTypesInvert[renderbuffer.format];

	      return reglRenderbuffer
	    }

	    function resize (w_, h_) {
	      var w = w_ | 0;
	      var h = (h_ | 0) || w;

	      if (w === renderbuffer.width && h === renderbuffer.height) {
	        return reglRenderbuffer
	      }

	      // check shape
	      check$1(
	        w > 0 && h > 0 &&
	        w <= limits.maxRenderbufferSize && h <= limits.maxRenderbufferSize,
	        'invalid renderbuffer size');

	      reglRenderbuffer.width = renderbuffer.width = w;
	      reglRenderbuffer.height = renderbuffer.height = h;
	      var samples = reglRenderbuffer.samples;

	      gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
	      if (samples && gl.renderbufferStorageMultisample)  {
	        gl.renderbufferStorageMultisample(GL_RENDERBUFFER, samples, renderbuffer.format, w, h);
	      } else {
	        gl.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w, h);
	      }

	      // check(
	      //   gl.getError() === 0,
	      //   'invalid render buffer format')

	      // also, recompute size.
	      if (config.profile) {
	        renderbuffer.stats.size = getRenderbufferSize(
	          renderbuffer.format, renderbuffer.width, renderbuffer.height);
	      }

	      return reglRenderbuffer
	    }

	    reglRenderbuffer(a, b);

	    reglRenderbuffer.resize = resize;
	    reglRenderbuffer._reglType = 'renderbuffer';
	    reglRenderbuffer._renderbuffer = renderbuffer;
	    if (config.profile) {
	      reglRenderbuffer.stats = renderbuffer.stats;
	    }
	    reglRenderbuffer.destroy = function () {
	      renderbuffer.decRef();
	    };

	    return reglRenderbuffer
	  }

	  if (config.profile) {
	    stats.getTotalRenderbufferSize = function () {
	      var total = 0;
	      Object.keys(renderbufferSet).forEach(function (key) {
	        total += renderbufferSet[key].stats.size;
	      });
	      return total
	    };
	  }

	  function restoreRenderbuffers () {
	    values(renderbufferSet).forEach(function (rb) {
	      rb.renderbuffer = gl.createRenderbuffer();
	      gl.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer);
	      if (rb.samples && gl.renderbufferStorageMultisample)  {
	        gl.renderbufferStorageMultisample(GL_RENDERBUFFER, rb.samples, rb.format, rb.width, rb.height);
	      } else {
	        gl.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height);
	      }
	    });
	    gl.bindRenderbuffer(GL_RENDERBUFFER, null);
	  }

	  return {
	    create: createRenderbuffer,
	    clear: function () {
	      values(renderbufferSet).forEach(destroy);
	    },
	    restore: restoreRenderbuffers
	  }
	};

	// We store these constants so that the minifier can inline them
	var GL_FRAMEBUFFER$1 = 0x8D40;
	var GL_RENDERBUFFER$1 = 0x8D41;

	var GL_TEXTURE_2D$2 = 0x0DE1;
	var GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 0x8515;

	var GL_COLOR_ATTACHMENT0$1 = 0x8CE0;
	var GL_DEPTH_ATTACHMENT = 0x8D00;
	var GL_STENCIL_ATTACHMENT = 0x8D20;
	var GL_DEPTH_STENCIL_ATTACHMENT = 0x821A;

	var GL_FRAMEBUFFER_COMPLETE$1 = 0x8CD5;
	var GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;
	var GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
	var GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;
	var GL_FRAMEBUFFER_UNSUPPORTED = 0x8CDD;

	var GL_HALF_FLOAT_OES$2 = 0x8D61;
	var GL_UNSIGNED_BYTE$6 = 0x1401;
	var GL_FLOAT$5 = 0x1406;

	var GL_RGB$1 = 0x1907;
	var GL_RGBA$2 = 0x1908;

	var GL_DEPTH_COMPONENT$1 = 0x1902;

	var GL_READ_FRAMEBUFFER = 0x8CA8;
	var GL_DRAW_FRAMEBUFFER = 0x8CA9;

	var GL_NEAREST$2 = 0x2600;
	var GL_LINEAR$1 = 0x2601;

	var GL_COLOR_BUFFER_BIT$2 = 0x4000;

	var colorTextureFormatEnums = [
	  GL_RGB$1,
	  GL_RGBA$2
	];

	// for every texture format, store
	// the number of channels
	var textureFormatChannels = [];
	textureFormatChannels[GL_RGBA$2] = 4;
	textureFormatChannels[GL_RGB$1] = 3;

	// for every texture type, store
	// the size in bytes.
	var textureTypeSizes = [];
	textureTypeSizes[GL_UNSIGNED_BYTE$6] = 1;
	textureTypeSizes[GL_FLOAT$5] = 4;
	textureTypeSizes[GL_HALF_FLOAT_OES$2] = 2;

	var GL_RGBA4$2 = 0x8056;
	var GL_RGB5_A1$2 = 0x8057;
	var GL_RGBA8$1 = 0x8058;
	var GL_RGB565$2 = 0x8D62;
	var GL_DEPTH_COMPONENT16$1 = 0x81A5;
	var GL_STENCIL_INDEX8$1 = 0x8D48;
	var GL_DEPTH_STENCIL$2 = 0x84F9;
	var GL_DEPTH24_STENCIL8$1 = 0x88F0;

	var GL_SRGB8_ALPHA8_EXT$1 = 0x8C43;

	var GL_RGBA32F_EXT$1 = 0x8814;

	var GL_RGBA16F_EXT$1 = 0x881A;
	var GL_RGB16F_EXT$1 = 0x881B;

	var colorRenderbufferFormatEnums = [
	  GL_RGBA4$2,
	  GL_RGBA8$1,
	  GL_RGB5_A1$2,
	  GL_RGB565$2,
	  GL_SRGB8_ALPHA8_EXT$1,
	  GL_RGBA16F_EXT$1,
	  GL_RGB16F_EXT$1,
	  GL_RGBA32F_EXT$1
	];

	var statusCode = {};
	statusCode[GL_FRAMEBUFFER_COMPLETE$1] = 'complete';
	statusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = 'incomplete attachment';
	statusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = 'incomplete dimensions';
	statusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = 'incomplete, missing attachment';
	statusCode[GL_FRAMEBUFFER_UNSUPPORTED] = 'unsupported';

	function wrapFBOState (
	  gl,
	  extensions,
	  limits,
	  textureState,
	  renderbufferState,
	  stats) {
	  var framebufferState = {
	    cur: null,
	    next: null,
	    dirty: false,
	    setFBO: null
	  };

	  var colorTextureFormats = ['rgba'];
	  var colorRenderbufferFormats = ['rgba4', 'rgb565', 'rgb5 a1'];

	  if (extensions.ext_srgb) {
	    colorRenderbufferFormats.push('srgba');
	  }

	  if (extensions.ext_color_buffer_half_float) {
	    colorRenderbufferFormats.push('rgba16f', 'rgb16f');
	  }

	  if (extensions.webgl_color_buffer_float) {
	    colorRenderbufferFormats.push('rgba32f');
	  }

	  var colorTypes = ['uint8'];
	  if (extensions.oes_texture_half_float) {
	    colorTypes.push('half float', 'float16');
	  }
	  if (extensions.oes_texture_float) {
	    colorTypes.push('float', 'float32');
	  }

	  function FramebufferAttachment (target, texture, renderbuffer) {
	    this.target = target;
	    this.texture = texture;
	    this.renderbuffer = renderbuffer;

	    var w = 0;
	    var h = 0;
	    if (texture) {
	      w = texture.width;
	      h = texture.height;
	    } else if (renderbuffer) {
	      w = renderbuffer.width;
	      h = renderbuffer.height;
	    }
	    this.width = w;
	    this.height = h;
	  }

	  function decRef (attachment) {
	    if (attachment) {
	      if (attachment.texture) {
	        attachment.texture._texture.decRef();
	      }
	      if (attachment.renderbuffer) {
	        attachment.renderbuffer._renderbuffer.decRef();
	      }
	    }
	  }

	  function incRefAndCheckShape (attachment, width, height) {
	    if (!attachment) {
	      return
	    }
	    if (attachment.texture) {
	      var texture = attachment.texture._texture;
	      var tw = Math.max(1, texture.width);
	      var th = Math.max(1, texture.height);
	      check$1(tw === width && th === height,
	        'inconsistent width/height for supplied texture');
	      texture.refCount += 1;
	    } else {
	      var renderbuffer = attachment.renderbuffer._renderbuffer;
	      check$1(
	        renderbuffer.width === width && renderbuffer.height === height,
	        'inconsistent width/height for renderbuffer');
	      renderbuffer.refCount += 1;
	    }
	  }

	  function attach (location, attachment) {
	    if (attachment) {
	      if (attachment.texture) {
	        gl.framebufferTexture2D(
	          GL_FRAMEBUFFER$1,
	          location,
	          attachment.target,
	          attachment.texture._texture.texture,
	          0);
	      } else {
	        gl.framebufferRenderbuffer(
	          GL_FRAMEBUFFER$1,
	          location,
	          GL_RENDERBUFFER$1,
	          attachment.renderbuffer._renderbuffer.renderbuffer);
	      }
	    }
	  }

	  function parseAttachment (attachment) {
	    var target = GL_TEXTURE_2D$2;
	    var texture = null;
	    var renderbuffer = null;

	    var data = attachment;
	    if (typeof attachment === 'object') {
	      data = attachment.data;
	      if ('target' in attachment) {
	        target = attachment.target | 0;
	      }
	    }

	    check$1.type(data, 'function', 'invalid attachment data');

	    var type = data._reglType;
	    if (type === 'texture2d') {
	      texture = data;
	      check$1(target === GL_TEXTURE_2D$2);
	    } else if (type === 'textureCube') {
	      texture = data;
	      check$1(
	        target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 &&
	        target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + 6,
	        'invalid cube map target');
	    } else if (type === 'renderbuffer') {
	      renderbuffer = data;
	      target = GL_RENDERBUFFER$1;
	    } else {
	      check$1.raise('invalid regl object for attachment');
	    }

	    return new FramebufferAttachment(target, texture, renderbuffer)
	  }

	  function allocAttachment (
	    width,
	    height,
	    isTexture,
	    format,
	    type) {
	    if (isTexture) {
	      var texture = textureState.create2D({
	        width: width,
	        height: height,
	        format: format,
	        type: type
	      });
	      texture._texture.refCount = 0;
	      return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null)
	    } else {
	      var rb = renderbufferState.create({
	        width: width,
	        height: height,
	        format: format
	      });
	      rb._renderbuffer.refCount = 0;
	      return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb)
	    }
	  }

	  function unwrapAttachment (attachment) {
	    return attachment && (attachment.texture || attachment.renderbuffer)
	  }

	  function resizeAttachment (attachment, w, h) {
	    if (attachment) {
	      if (attachment.texture) {
	        attachment.texture.resize(w, h);
	      } else if (attachment.renderbuffer) {
	        attachment.renderbuffer.resize(w, h);
	      }
	      attachment.width = w;
	      attachment.height = h;
	    }
	  }

	  var framebufferCount = 0;
	  var framebufferSet = {};

	  function REGLFramebuffer () {
	    this.id = framebufferCount++;
	    framebufferSet[this.id] = this;

	    this.framebuffer = gl.createFramebuffer();
	    this.width = 0;
	    this.height = 0;

	    this.colorAttachments = [];
	    this.depthAttachment = null;
	    this.stencilAttachment = null;
	    this.depthStencilAttachment = null;
	  }

	  function decFBORefs (framebuffer) {
	    framebuffer.colorAttachments.forEach(decRef);
	    decRef(framebuffer.depthAttachment);
	    decRef(framebuffer.stencilAttachment);
	    decRef(framebuffer.depthStencilAttachment);
	  }

	  function destroy (framebuffer) {
	    var handle = framebuffer.framebuffer;
	    check$1(handle, 'must not double destroy framebuffer');
	    gl.deleteFramebuffer(handle);
	    framebuffer.framebuffer = null;
	    stats.framebufferCount--;
	    delete framebufferSet[framebuffer.id];
	  }

	  function updateFramebuffer (framebuffer) {
	    var i;

	    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer);
	    var colorAttachments = framebuffer.colorAttachments;
	    for (i = 0; i < colorAttachments.length; ++i) {
	      attach(GL_COLOR_ATTACHMENT0$1 + i, colorAttachments[i]);
	    }
	    for (i = colorAttachments.length; i < limits.maxColorAttachments; ++i) {
	      gl.framebufferTexture2D(
	        GL_FRAMEBUFFER$1,
	        GL_COLOR_ATTACHMENT0$1 + i,
	        GL_TEXTURE_2D$2,
	        null,
	        0);
	    }

	    gl.framebufferTexture2D(
	      GL_FRAMEBUFFER$1,
	      GL_DEPTH_STENCIL_ATTACHMENT,
	      GL_TEXTURE_2D$2,
	      null,
	      0);
	    gl.framebufferTexture2D(
	      GL_FRAMEBUFFER$1,
	      GL_DEPTH_ATTACHMENT,
	      GL_TEXTURE_2D$2,
	      null,
	      0);
	    gl.framebufferTexture2D(
	      GL_FRAMEBUFFER$1,
	      GL_STENCIL_ATTACHMENT,
	      GL_TEXTURE_2D$2,
	      null,
	      0);

	    attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment);
	    attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment);
	    attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment);

	    // Check status code
	    var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER$1);
	    if (!gl.isContextLost() && status !== GL_FRAMEBUFFER_COMPLETE$1) {
	      check$1.raise('framebuffer configuration not supported, status = ' +
	        statusCode[status]);
	    }

	    gl.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null);
	    framebufferState.cur = framebufferState.next;

	    // FIXME: Clear error code here.  This is a work around for a bug in
	    // headless-gl
	    gl.getError();
	  }

	  function createFBO (a0, a1) {
	    var framebuffer = new REGLFramebuffer();
	    stats.framebufferCount++;

	    function reglFramebuffer (a, b) {
	      var i;

	      check$1(framebufferState.next !== framebuffer,
	        'can not update framebuffer which is currently in use');

	      var width = 0;
	      var height = 0;

	      var needsDepth = true;
	      var needsStencil = true;

	      var colorBuffer = null;
	      var colorTexture = true;
	      var colorFormat = 'rgba';
	      var colorType = 'uint8';
	      var colorCount = 1;

	      var depthBuffer = null;
	      var stencilBuffer = null;
	      var depthStencilBuffer = null;
	      var depthStencilTexture = false;

	      if (typeof a === 'number') {
	        width = a | 0;
	        height = (b | 0) || width;
	      } else if (!a) {
	        width = height = 1;
	      } else {
	        check$1.type(a, 'object', 'invalid arguments for framebuffer');
	        var options = a;

	        if ('shape' in options) {
	          var shape = options.shape;
	          check$1(Array.isArray(shape) && shape.length >= 2,
	            'invalid shape for framebuffer');
	          width = shape[0];
	          height = shape[1];
	        } else {
	          if ('radius' in options) {
	            width = height = options.radius;
	          }
	          if ('width' in options) {
	            width = options.width;
	          }
	          if ('height' in options) {
	            height = options.height;
	          }
	        }

	        if ('color' in options ||
	            'colors' in options) {
	          colorBuffer =
	            options.color ||
	            options.colors;
	          if (Array.isArray(colorBuffer)) {
	            check$1(
	              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
	              'multiple render targets not supported');
	          }
	        }

	        if (!colorBuffer) {
	          if ('colorCount' in options) {
	            colorCount = options.colorCount | 0;
	            check$1(colorCount > 0, 'invalid color buffer count');
	          }

	          if ('colorTexture' in options) {
	            colorTexture = !!options.colorTexture;
	            colorFormat = 'rgba4';
	          }

	          if ('colorType' in options) {
	            colorType = options.colorType;
	            if (!colorTexture) {
	              if (colorType === 'half float' || colorType === 'float16') {
	                check$1(extensions.ext_color_buffer_half_float,
	                  'you must enable EXT_color_buffer_half_float to use 16-bit render buffers');
	                colorFormat = 'rgba16f';
	              } else if (colorType === 'float' || colorType === 'float32') {
	                check$1(extensions.webgl_color_buffer_float,
	                  'you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers');
	                colorFormat = 'rgba32f';
	              }
	            } else {
	              check$1(extensions.oes_texture_float ||
	                !(colorType === 'float' || colorType === 'float32'),
	              'you must enable OES_texture_float in order to use floating point framebuffer objects');
	              check$1(extensions.oes_texture_half_float ||
	                !(colorType === 'half float' || colorType === 'float16'),
	              'you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects');
	            }
	            check$1.oneOf(colorType, colorTypes, 'invalid color type');
	          }

	          if ('colorFormat' in options) {
	            colorFormat = options.colorFormat;
	            if (colorTextureFormats.indexOf(colorFormat) >= 0) {
	              colorTexture = true;
	            } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
	              colorTexture = false;
	            } else {
	              check$1.optional(function () {
	                if (colorTexture) {
	                  check$1.oneOf(
	                    options.colorFormat, colorTextureFormats,
	                    'invalid color format for texture');
	                } else {
	                  check$1.oneOf(
	                    options.colorFormat, colorRenderbufferFormats,
	                    'invalid color format for renderbuffer');
	                }
	              });
	            }
	          }
	        }

	        if ('depthTexture' in options || 'depthStencilTexture' in options) {
	          depthStencilTexture = !!(options.depthTexture ||
	            options.depthStencilTexture);
	          check$1(!depthStencilTexture || extensions.webgl_depth_texture,
	            'webgl_depth_texture extension not supported');
	        }

	        if ('depth' in options) {
	          if (typeof options.depth === 'boolean') {
	            needsDepth = options.depth;
	          } else {
	            depthBuffer = options.depth;
	            needsStencil = false;
	          }
	        }

	        if ('stencil' in options) {
	          if (typeof options.stencil === 'boolean') {
	            needsStencil = options.stencil;
	          } else {
	            stencilBuffer = options.stencil;
	            needsDepth = false;
	          }
	        }

	        if ('depthStencil' in options) {
	          if (typeof options.depthStencil === 'boolean') {
	            needsDepth = needsStencil = options.depthStencil;
	          } else {
	            depthStencilBuffer = options.depthStencil;
	            needsDepth = false;
	            needsStencil = false;
	          }
	        }
	      }

	      // parse attachments
	      var colorAttachments = null;
	      var depthAttachment = null;
	      var stencilAttachment = null;
	      var depthStencilAttachment = null;

	      // Set up color attachments
	      if (Array.isArray(colorBuffer)) {
	        colorAttachments = colorBuffer.map(parseAttachment);
	      } else if (colorBuffer) {
	        colorAttachments = [parseAttachment(colorBuffer)];
	      } else {
	        colorAttachments = new Array(colorCount);
	        for (i = 0; i < colorCount; ++i) {
	          colorAttachments[i] = allocAttachment(
	            width,
	            height,
	            colorTexture,
	            colorFormat,
	            colorType);
	        }
	      }

	      check$1(extensions.webgl_draw_buffers || colorAttachments.length <= 1,
	        'you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers.');
	      check$1(colorAttachments.length <= limits.maxColorAttachments,
	        'too many color attachments, not supported');

	      width = width || colorAttachments[0].width;
	      height = height || colorAttachments[0].height;

	      if (depthBuffer) {
	        depthAttachment = parseAttachment(depthBuffer);
	      } else if (needsDepth && !needsStencil) {
	        depthAttachment = allocAttachment(
	          width,
	          height,
	          depthStencilTexture,
	          'depth',
	          'uint32');
	      }

	      if (stencilBuffer) {
	        stencilAttachment = parseAttachment(stencilBuffer);
	      } else if (needsStencil && !needsDepth) {
	        stencilAttachment = allocAttachment(
	          width,
	          height,
	          false,
	          'stencil',
	          'uint8');
	      }

	      if (depthStencilBuffer) {
	        depthStencilAttachment = parseAttachment(depthStencilBuffer);
	      } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
	        depthStencilAttachment = allocAttachment(
	          width,
	          height,
	          depthStencilTexture,
	          'depth stencil',
	          'depth stencil');
	      }

	      check$1(
	        (!!depthBuffer) + (!!stencilBuffer) + (!!depthStencilBuffer) <= 1,
	        'invalid framebuffer configuration, can specify exactly one depth/stencil attachment');

	      var commonColorAttachmentSize = null;

	      for (i = 0; i < colorAttachments.length; ++i) {
	        incRefAndCheckShape(colorAttachments[i], width, height);
	        check$1(!colorAttachments[i] ||
	          (colorAttachments[i].texture &&
	            colorTextureFormatEnums.indexOf(colorAttachments[i].texture._texture.format) >= 0) ||
	          (colorAttachments[i].renderbuffer &&
	            colorRenderbufferFormatEnums.indexOf(colorAttachments[i].renderbuffer._renderbuffer.format) >= 0),
	        'framebuffer color attachment ' + i + ' is invalid');

	        if (colorAttachments[i] && colorAttachments[i].texture) {
	          var colorAttachmentSize =
	              textureFormatChannels[colorAttachments[i].texture._texture.format] *
	              textureTypeSizes[colorAttachments[i].texture._texture.type];

	          if (commonColorAttachmentSize === null) {
	            commonColorAttachmentSize = colorAttachmentSize;
	          } else {
	            // We need to make sure that all color attachments have the same number of bitplanes
	            // (that is, the same numer of bits per pixel)
	            // This is required by the GLES2.0 standard. See the beginning of Chapter 4 in that document.
	            check$1(commonColorAttachmentSize === colorAttachmentSize,
	              'all color attachments much have the same number of bits per pixel.');
	          }
	        }
	      }
	      incRefAndCheckShape(depthAttachment, width, height);
	      check$1(!depthAttachment ||
	        (depthAttachment.texture &&
	          depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1) ||
	        (depthAttachment.renderbuffer &&
	          depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1),
	      'invalid depth attachment for framebuffer object');
	      incRefAndCheckShape(stencilAttachment, width, height);
	      check$1(!stencilAttachment ||
	        (stencilAttachment.renderbuffer &&
	          stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1),
	      'invalid stencil attachment for framebuffer object');
	      incRefAndCheckShape(depthStencilAttachment, width, height);
	      check$1(!depthStencilAttachment ||
	        (depthStencilAttachment.texture &&
	          depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2) ||
	        (depthStencilAttachment.renderbuffer &&
	          (depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2 || depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH24_STENCIL8$1)),
	      'invalid depth-stencil attachment for framebuffer object');

	      // decrement references
	      decFBORefs(framebuffer);

	      framebuffer.width = width;
	      framebuffer.height = height;

	      framebuffer.colorAttachments = colorAttachments;
	      framebuffer.depthAttachment = depthAttachment;
	      framebuffer.stencilAttachment = stencilAttachment;
	      framebuffer.depthStencilAttachment = depthStencilAttachment;

	      reglFramebuffer.color = colorAttachments.map(unwrapAttachment);
	      reglFramebuffer.depth = unwrapAttachment(depthAttachment);
	      reglFramebuffer.stencil = unwrapAttachment(stencilAttachment);
	      reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment);

	      reglFramebuffer.width = framebuffer.width;
	      reglFramebuffer.height = framebuffer.height;

	      updateFramebuffer(framebuffer);

	      return reglFramebuffer
	    }

	    function resize (w_, h_) {
	      check$1(framebufferState.next !== framebuffer,
	        'can not resize a framebuffer which is currently in use');

	      var w = Math.max(w_ | 0, 1);
	      var h = Math.max((h_ | 0) || w, 1);
	      if (w === framebuffer.width && h === framebuffer.height) {
	        return reglFramebuffer
	      }

	      // resize all buffers
	      var colorAttachments = framebuffer.colorAttachments;
	      for (var i = 0; i < colorAttachments.length; ++i) {
	        resizeAttachment(colorAttachments[i], w, h);
	      }
	      resizeAttachment(framebuffer.depthAttachment, w, h);
	      resizeAttachment(framebuffer.stencilAttachment, w, h);
	      resizeAttachment(framebuffer.depthStencilAttachment, w, h);

	      framebuffer.width = reglFramebuffer.width = w;
	      framebuffer.height = reglFramebuffer.height = h;

	      updateFramebuffer(framebuffer);

	      return reglFramebuffer
	    }

	    // webgl 2 gl.blitFramebuffer
	    function blit(srcFBO, mask, filter) {
	      gl.bindFramebuffer(GL_READ_FRAMEBUFFER, srcFBO['_framebuffer'].framebuffer);
	      gl.bindFramebuffer(GL_DRAW_FRAMEBUFFER, framebuffer.framebuffer);
	      if (!mask) {
	        mask = GL_COLOR_BUFFER_BIT$2;
	      }
	      if (filter === 'linear') {
	        filter = GL_LINEAR$1;
	      } else {
	        filter = GL_NEAREST$2;
	      }
	      gl.blitFramebuffer(
	          0, 0, srcFBO.width, srcFBO.height,
	          0, 0, framebuffer.width, framebuffer.height,
	          mask, filter
	      );
	      gl.bindFramebuffer(GL_READ_FRAMEBUFFER, null);
	      gl.bindFramebuffer(GL_DRAW_FRAMEBUFFER, null);
	    }

	    reglFramebuffer(a0, a1);

	    return extend(reglFramebuffer, {
	      resize: resize,
	      blit: blit,
	      _reglType: 'framebuffer',
	      _framebuffer: framebuffer,
	      destroy: function () {
	        destroy(framebuffer);
	        decFBORefs(framebuffer);
	      },
	      use: function (block) {
	        framebufferState.setFBO({
	          framebuffer: reglFramebuffer
	        }, block);
	      }
	    })
	  }

	  function createCubeFBO (options) {
	    var faces = Array(6);

	    function reglFramebufferCube (a) {
	      var i;

	      check$1(faces.indexOf(framebufferState.next) < 0,
	        'can not update framebuffer which is currently in use');

	      var params = {
	        color: null
	      };

	      var radius = 0;

	      var colorBuffer = null;
	      var colorFormat = 'rgba';
	      var colorType = 'uint8';
	      var colorCount = 1;

	      if (typeof a === 'number') {
	        radius = a | 0;
	      } else if (!a) {
	        radius = 1;
	      } else {
	        check$1.type(a, 'object', 'invalid arguments for framebuffer');
	        var options = a;

	        if ('shape' in options) {
	          var shape = options.shape;
	          check$1(
	            Array.isArray(shape) && shape.length >= 2,
	            'invalid shape for framebuffer');
	          check$1(
	            shape[0] === shape[1],
	            'cube framebuffer must be square');
	          radius = shape[0];
	        } else {
	          if ('radius' in options) {
	            radius = options.radius | 0;
	          }
	          if ('width' in options) {
	            radius = options.width | 0;
	            if ('height' in options) {
	              check$1(options.height === radius, 'must be square');
	            }
	          } else if ('height' in options) {
	            radius = options.height | 0;
	          }
	        }

	        if ('color' in options ||
	            'colors' in options) {
	          colorBuffer =
	            options.color ||
	            options.colors;
	          if (Array.isArray(colorBuffer)) {
	            check$1(
	              colorBuffer.length === 1 || extensions.webgl_draw_buffers,
	              'multiple render targets not supported');
	          }
	        }

	        if (!colorBuffer) {
	          if ('colorCount' in options) {
	            colorCount = options.colorCount | 0;
	            check$1(colorCount > 0, 'invalid color buffer count');
	          }

	          if ('colorType' in options) {
	            check$1.oneOf(
	              options.colorType, colorTypes,
	              'invalid color type');
	            colorType = options.colorType;
	          }

	          if ('colorFormat' in options) {
	            colorFormat = options.colorFormat;
	            check$1.oneOf(
	              options.colorFormat, colorTextureFormats,
	              'invalid color format for texture');
	          }
	        }

	        if ('depth' in options) {
	          params.depth = options.depth;
	        }

	        if ('stencil' in options) {
	          params.stencil = options.stencil;
	        }

	        if ('depthStencil' in options) {
	          params.depthStencil = options.depthStencil;
	        }
	      }

	      var colorCubes;
	      if (colorBuffer) {
	        if (Array.isArray(colorBuffer)) {
	          colorCubes = [];
	          for (i = 0; i < colorBuffer.length; ++i) {
	            colorCubes[i] = colorBuffer[i];
	          }
	        } else {
	          colorCubes = [ colorBuffer ];
	        }
	      } else {
	        colorCubes = Array(colorCount);
	        var cubeMapParams = {
	          radius: radius,
	          format: colorFormat,
	          type: colorType
	        };
	        for (i = 0; i < colorCount; ++i) {
	          colorCubes[i] = textureState.createCube(cubeMapParams);
	        }
	      }

	      // Check color cubes
	      params.color = Array(colorCubes.length);
	      for (i = 0; i < colorCubes.length; ++i) {
	        var cube = colorCubes[i];
	        check$1(
	          typeof cube === 'function' && cube._reglType === 'textureCube',
	          'invalid cube map');
	        radius = radius || cube.width;
	        check$1(
	          cube.width === radius && cube.height === radius,
	          'invalid cube map shape');
	        params.color[i] = {
	          target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,
	          data: colorCubes[i]
	        };
	      }

	      for (i = 0; i < 6; ++i) {
	        for (var j = 0; j < colorCubes.length; ++j) {
	          params.color[j].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i;
	        }
	        // reuse depth-stencil attachments across all cube maps
	        if (i > 0) {
	          params.depth = faces[0].depth;
	          params.stencil = faces[0].stencil;
	          params.depthStencil = faces[0].depthStencil;
	        }
	        if (faces[i]) {
	          (faces[i])(params);
	        } else {
	          faces[i] = createFBO(params);
	        }
	      }

	      return extend(reglFramebufferCube, {
	        width: radius,
	        height: radius,
	        color: colorCubes
	      })
	    }

	    function resize (radius_) {
	      var i;
	      var radius = radius_ | 0;
	      check$1(radius > 0 && radius <= limits.maxCubeMapSize,
	        'invalid radius for cube fbo');

	      if (radius === reglFramebufferCube.width) {
	        return reglFramebufferCube
	      }

	      var colors = reglFramebufferCube.color;
	      for (i = 0; i < colors.length; ++i) {
	        colors[i].resize(radius);
	      }

	      for (i = 0; i < 6; ++i) {
	        faces[i].resize(radius);
	      }

	      reglFramebufferCube.width = reglFramebufferCube.height = radius;

	      return reglFramebufferCube
	    }

	    reglFramebufferCube(options);

	    return extend(reglFramebufferCube, {
	      faces: faces,
	      resize: resize,
	      _reglType: 'framebufferCube',
	      destroy: function () {
	        faces.forEach(function (f) {
	          f.destroy();
	        });
	      }
	    })
	  }

	  function restoreFramebuffers () {
	    framebufferState.cur = null;
	    framebufferState.next = null;
	    framebufferState.dirty = true;
	    values(framebufferSet).forEach(function (fb) {
	      fb.framebuffer = gl.createFramebuffer();
	      updateFramebuffer(fb);
	    });
	  }

	  return extend(framebufferState, {
	    getFramebuffer: function (object) {
	      if (typeof object === 'function' && object._reglType === 'framebuffer') {
	        var fbo = object._framebuffer;
	        if (fbo instanceof REGLFramebuffer) {
	          return fbo
	        }
	      }
	      return null
	    },
	    create: createFBO,
	    createCube: createCubeFBO,
	    clear: function () {
	      values(framebufferSet).forEach(destroy);
	    },
	    restore: restoreFramebuffers
	  })
	}

	var GL_FLOAT$6 = 5126;
	var GL_ARRAY_BUFFER$1 = 34962;
	var GL_ELEMENT_ARRAY_BUFFER$1 = 34963;

	var VAO_OPTIONS = [
	  'attributes',
	  'elements',
	  'offset',
	  'count',
	  'primitive',
	  'instances'
	];

	function AttributeRecord () {
	  this.state = 0;

	  this.x = 0.0;
	  this.y = 0.0;
	  this.z = 0.0;
	  this.w = 0.0;

	  this.buffer = null;
	  this.size = 0;
	  this.normalized = false;
	  this.type = GL_FLOAT$6;
	  this.offset = 0;
	  this.stride = 0;
	  this.divisor = 0;
	}

	function wrapAttributeState (
	  gl,
	  extensions,
	  limits,
	  stats,
	  bufferState,
	  elementState,
	  drawState) {
	  var NUM_ATTRIBUTES = limits.maxAttributes;
	  var attributeBindings = new Array(NUM_ATTRIBUTES);
	  for (var i = 0; i < NUM_ATTRIBUTES; ++i) {
	    attributeBindings[i] = new AttributeRecord();
	  }
	  var vaoCount = 0;
	  var vaoSet = {};

	  var state = {
	    Record: AttributeRecord,
	    scope: {},
	    state: attributeBindings,
	    currentVAO: null,
	    targetVAO: null,
	    restore: extVAO() ? restoreVAO : function () {},
	    createVAO: createVAO,
	    getVAO: getVAO,
	    destroyBuffer: destroyBuffer,
	    setVAO: extVAO() ? setVAOEXT : setVAOEmulated,
	    clear: extVAO() ? destroyVAOEXT : function () {}
	  };

	  function destroyBuffer (buffer) {
	    for (var i = 0; i < attributeBindings.length; ++i) {
	      var record = attributeBindings[i];
	      if (record.buffer === buffer) {
	        gl.disableVertexAttribArray(i);
	        record.buffer = null;
	      }
	    }
	  }

	  function extVAO () {
	    return extensions.oes_vertex_array_object
	  }

	  function extInstanced () {
	    return extensions.angle_instanced_arrays
	  }

	  function getVAO (vao) {
	    if (typeof vao === 'function' && vao._vao) {
	      return vao._vao
	    }
	    return null
	  }

	  function setVAOEXT (vao) {
	    if (vao === state.currentVAO) {
	      return
	    }
	    var ext = extVAO();
	    if (vao) {
	      ext.bindVertexArrayOES(vao.vao);
	    } else {
	      ext.bindVertexArrayOES(null);
	    }
	    state.currentVAO = vao;
	  }

	  function setVAOEmulated (vao) {
	    if (vao === state.currentVAO) {
	      return
	    }
	    if (vao) {
	      vao.bindAttrs();
	    } else {
	      var exti = extInstanced();
	      for (var i = 0; i < attributeBindings.length; ++i) {
	        var binding = attributeBindings[i];
	        if (binding.buffer) {
	          gl.enableVertexAttribArray(i);
	          binding.buffer.bind();
	          gl.vertexAttribPointer(i, binding.size, binding.type, binding.normalized, binding.stride, binding.offfset);
	          if (exti && binding.divisor) {
	            exti.vertexAttribDivisorANGLE(i, binding.divisor);
	          }
	        } else {
	          gl.disableVertexAttribArray(i);
	          gl.vertexAttrib4f(i, binding.x, binding.y, binding.z, binding.w);
	        }
	      }
	      if (drawState.elements) {
	        gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, drawState.elements.buffer.buffer);
	      } else {
	        gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, null);
	      }
	    }
	    state.currentVAO = vao;
	  }

	  function destroyVAOEXT () {
	    values(vaoSet).forEach(function (vao) {
	      vao.destroy();
	    });
	  }

	  function REGLVAO () {
	    this.id = ++vaoCount;
	    this.attributes = [];
	    this.elements = null;
	    this.ownsElements = false;
	    this.count = 0;
	    this.offset = 0;
	    this.instances = -1;
	    this.primitive = 4;
	    var extension = extVAO();
	    if (extension) {
	      this.vao = extension.createVertexArrayOES();
	    } else {
	      this.vao = null;
	    }
	    vaoSet[this.id] = this;
	    this.buffers = [];
	  }

	  REGLVAO.prototype.bindAttrs = function () {
	    var exti = extInstanced();
	    var attributes = this.attributes;
	    for (var i = 0; i < attributes.length; ++i) {
	      var attr = attributes[i];
	      if (attr.buffer) {
	        gl.enableVertexAttribArray(i);
	        gl.bindBuffer(GL_ARRAY_BUFFER$1, attr.buffer.buffer);
	        gl.vertexAttribPointer(i, attr.size, attr.type, attr.normalized, attr.stride, attr.offset);
	        if (exti && attr.divisor) {
	          exti.vertexAttribDivisorANGLE(i, attr.divisor);
	        }
	      } else {
	        gl.disableVertexAttribArray(i);
	        gl.vertexAttrib4f(i, attr.x, attr.y, attr.z, attr.w);
	      }
	    }
	    for (var j = attributes.length; j < NUM_ATTRIBUTES; ++j) {
	      gl.disableVertexAttribArray(j);
	    }
	    var elements = elementState.getElements(this.elements);
	    if (elements) {
	      gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, elements.buffer.buffer);
	    } else {
	      gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER$1, null);
	    }
	  };

	  REGLVAO.prototype.refresh = function () {
	    var ext = extVAO();
	    if (ext) {
	      ext.bindVertexArrayOES(this.vao);
	      this.bindAttrs();
	      state.currentVAO = null;
	      ext.bindVertexArrayOES(null);
	    }
	  };

	  REGLVAO.prototype.destroy = function () {
	    if (this.vao) {
	      var extension = extVAO();
	      if (this === state.currentVAO) {
	        state.currentVAO = null;
	        extension.bindVertexArrayOES(null);
	      }
	      extension.deleteVertexArrayOES(this.vao);
	      this.vao = null;
	    }
	    if (this.ownsElements) {
	      this.elements.destroy();
	      this.elements = null;
	      this.ownsElements = false;
	    }
	    if (vaoSet[this.id]) {
	      delete vaoSet[this.id];
	      stats.vaoCount -= 1;
	    }
	  };

	  function restoreVAO () {
	    var ext = extVAO();
	    if (ext) {
	      values(vaoSet).forEach(function (vao) {
	        vao.refresh();
	      });
	    }
	  }

	  function createVAO (_attr) {
	    var vao = new REGLVAO();
	    stats.vaoCount += 1;

	    function updateVAO (options) {
	      var attributes;
	      if (Array.isArray(options)) {
	        attributes = options;
	        if (vao.elements && vao.ownsElements) {
	          vao.elements.destroy();
	        }
	        vao.elements = null;
	        vao.ownsElements = false;
	        vao.offset = 0;
	        vao.count = 0;
	        vao.instances = -1;
	        vao.primitive = 4;
	      } else {
	        check$1(typeof options === 'object', 'invalid arguments for create vao');
	        check$1('attributes' in options, 'must specify attributes for vao');
	        if (options.elements) {
	          var elements = options.elements;
	          if (vao.ownsElements) {
	            if (typeof elements === 'function' && elements._reglType === 'elements') {
	              vao.elements.destroy();
	              vao.ownsElements = false;
	            } else {
	              vao.elements(elements);
	              vao.ownsElements = false;
	            }
	          } else if (elementState.getElements(options.elements)) {
	            vao.elements = options.elements;
	            vao.ownsElements = false;
	          } else {
	            vao.elements = elementState.create(options.elements);
	            vao.ownsElements = true;
	          }
	        } else {
	          vao.elements = null;
	          vao.ownsElements = false;
	        }
	        attributes = options.attributes;

	        // set default vao
	        vao.offset = 0;
	        vao.count = -1;
	        vao.instances = -1;
	        vao.primitive = 4;

	        // copy element properties
	        if (vao.elements) {
	          vao.count = vao.elements._elements.vertCount;
	          vao.primitive = vao.elements._elements.primType;
	        }

	        if ('offset' in options) {
	          vao.offset = options.offset | 0;
	        }
	        if ('count' in options) {
	          vao.count = options.count | 0;
	        }
	        if ('instances' in options) {
	          vao.instances = options.instances | 0;
	        }
	        if ('primitive' in options) {
	          check$1(options.primitive in primTypes, 'bad primitive type: ' + options.primitive);
	          vao.primitive = primTypes[options.primitive];
	        }

	        check$1.optional(() => {
	          var keys = Object.keys(options);
	          for (var i = 0; i < keys.length; ++i) {
	            check$1(VAO_OPTIONS.indexOf(keys[i]) >= 0, 'invalid option for vao: "' + keys[i] + '" valid options are ' + VAO_OPTIONS);
	          }
	        });
	        check$1(Array.isArray(attributes), 'attributes must be an array');
	      }

	      check$1(attributes.length < NUM_ATTRIBUTES, 'too many attributes');
	      check$1(attributes.length > 0, 'must specify at least one attribute');

	      var bufUpdated = {};
	      var nattributes = vao.attributes;
	      nattributes.length = attributes.length;
	      for (var i = 0; i < attributes.length; ++i) {
	        var spec = attributes[i];
	        var rec = nattributes[i] = new AttributeRecord();
	        var data = spec.data || spec;
	        if (Array.isArray(data) || isTypedArray(data) || isNDArrayLike(data)) {
	          var buf;
	          if (vao.buffers[i]) {
	            buf = vao.buffers[i];
	            if (isTypedArray(data) && buf._buffer.byteLength >= data.byteLength) {
	              buf.subdata(data);
	            } else {
	              buf.destroy();
	              vao.buffers[i] = null;
	            }
	          }
	          if (!vao.buffers[i]) {
	            buf = vao.buffers[i] = bufferState.create(spec, GL_ARRAY_BUFFER$1, false, true);
	          }
	          rec.buffer = bufferState.getBuffer(buf);
	          rec.size = rec.buffer.dimension | 0;
	          rec.normalized = false;
	          rec.type = rec.buffer.dtype;
	          rec.offset = 0;
	          rec.stride = 0;
	          rec.divisor = 0;
	          rec.state = 1;
	          bufUpdated[i] = 1;
	        } else if (bufferState.getBuffer(spec)) {
	          rec.buffer = bufferState.getBuffer(spec);
	          rec.size = rec.buffer.dimension | 0;
	          rec.normalized = false;
	          rec.type = rec.buffer.dtype;
	          rec.offset = 0;
	          rec.stride = 0;
	          rec.divisor = 0;
	          rec.state = 1;
	        } else if (bufferState.getBuffer(spec.buffer)) {
	          rec.buffer = bufferState.getBuffer(spec.buffer);
	          rec.size = ((+spec.size) || rec.buffer.dimension) | 0;
	          rec.normalized = !!spec.normalized || false;
	          if ('type' in spec) {
	            check$1.parameter(spec.type, glTypes, 'invalid buffer type');
	            rec.type = glTypes[spec.type];
	          } else {
	            rec.type = rec.buffer.dtype;
	          }
	          rec.offset = (spec.offset || 0) | 0;
	          rec.stride = (spec.stride || 0) | 0;
	          rec.divisor = (spec.divisor || 0) | 0;
	          rec.state = 1;

	          check$1(rec.size >= 1 && rec.size <= 4, 'size must be between 1 and 4');
	          check$1(rec.offset >= 0, 'invalid offset');
	          check$1(rec.stride >= 0 && rec.stride <= 255, 'stride must be between 0 and 255');
	          check$1(rec.divisor >= 0, 'divisor must be positive');
	          check$1(!rec.divisor || !!extensions.angle_instanced_arrays, 'ANGLE_instanced_arrays must be enabled to use divisor');
	        } else if ('x' in spec) {
	          check$1(i > 0, 'first attribute must not be a constant');
	          rec.x = +spec.x || 0;
	          rec.y = +spec.y || 0;
	          rec.z = +spec.z || 0;
	          rec.w = +spec.w || 0;
	          rec.state = 2;
	        } else {
	          check$1(false, 'invalid attribute spec for location ' + i);
	        }
	      }

	      // retire unused buffers
	      for (var j = 0; j < vao.buffers.length; ++j) {
	        if (!bufUpdated[j] && vao.buffers[j]) {
	          vao.buffers[j].destroy();
	          vao.buffers[j] = null;
	        }
	      }

	      vao.refresh();
	      return updateVAO
	    }

	    updateVAO.destroy = function () {
	      for (var j = 0; j < vao.buffers.length; ++j) {
	        if (vao.buffers[j]) {
	          vao.buffers[j].destroy();
	        }
	      }
	      vao.buffers.length = 0;

	      if (vao.ownsElements) {
	        vao.elements.destroy();
	        vao.elements = null;
	        vao.ownsElements = false;
	      }

	      vao.destroy();
	    };

	    updateVAO._vao = vao;
	    updateVAO._reglType = 'vao';

	    return updateVAO(_attr)
	  }

	  return state
	}

	var GL_FRAGMENT_SHADER = 35632;
	var GL_VERTEX_SHADER = 35633;

	var GL_ACTIVE_UNIFORMS = 0x8B86;
	var GL_ACTIVE_ATTRIBUTES = 0x8B89;

	function wrapShaderState (gl, stringStore, stats, config) {
	  // ===================================================
	  // glsl compilation and linking
	  // ===================================================
	  var fragShaders = {};
	  var vertShaders = {};

	  function ActiveInfo (name, id, location, info) {
	    this.name = name;
	    this.id = id;
	    this.location = location;
	    this.info = info;
	  }

	  function insertActiveInfo (list, info) {
	    for (var i = 0; i < list.length; ++i) {
	      if (list[i].id === info.id) {
	        list[i].location = info.location;
	        return
	      }
	    }
	    list.push(info);
	  }

	  function getShader (type, id, command) {
	    var cache = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders;
	    var shader = cache[id];

	    if (!shader) {
	      var source = stringStore.str(id);
	      shader = gl.createShader(type);
	      gl.shaderSource(shader, source);
	      gl.compileShader(shader);
	      check$1.shaderError(gl, shader, source, type, command);
	      cache[id] = shader;
	    }

	    return shader
	  }

	  // ===================================================
	  // program linking
	  // ===================================================
	  var programCache = {};
	  var programList = [];

	  var PROGRAM_COUNTER = 0;

	  function REGLProgram (fragId, vertId) {
	    this.id = PROGRAM_COUNTER++;
	    this.fragId = fragId;
	    this.vertId = vertId;
	    this.program = null;
	    this.uniforms = [];
	    this.attributes = [];
	    this.refCount = 1;

	    if (config.profile) {
	      this.stats = {
	        uniformsCount: 0,
	        attributesCount: 0
	      };
	    }
	  }

	  function linkProgram (desc, command, attributeLocations) {
	    var i, info;

	    // -------------------------------
	    // compile & link
	    // -------------------------------
	    var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId);
	    var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId);

	    var program = desc.program = gl.createProgram();
	    gl.attachShader(program, fragShader);
	    gl.attachShader(program, vertShader);
	    if (attributeLocations) {
	      for (i = 0; i < attributeLocations.length; ++i) {
	        var binding = attributeLocations[i];
	        gl.bindAttribLocation(program, binding[0], binding[1]);
	      }
	    }

	    gl.linkProgram(program);
	    check$1.linkError(
	      gl,
	      program,
	      stringStore.str(desc.fragId),
	      stringStore.str(desc.vertId),
	      command);

	    // -------------------------------
	    // grab uniforms
	    // -------------------------------
	    var numUniforms = gl.getProgramParameter(program, GL_ACTIVE_UNIFORMS);
	    if (config.profile) {
	      desc.stats.uniformsCount = numUniforms;
	    }
	    var uniforms = desc.uniforms;
	    for (i = 0; i < numUniforms; ++i) {
	      info = gl.getActiveUniform(program, i);
	      if (info) {
	        if (info.size > 1) {
	          for (var j = 0; j < info.size; ++j) {
	            var name = info.name.replace('[0]', '[' + j + ']');
	            insertActiveInfo(uniforms, new ActiveInfo(
	              name,
	              stringStore.id(name),
	              gl.getUniformLocation(program, name),
	              info));
	          }
	        }
	        var uniName = info.name;
	        if (info.size > 1) {
	          uniName = uniName.replace('[0]', '');
	        }
	        insertActiveInfo(uniforms, new ActiveInfo(
	          uniName,
	          stringStore.id(uniName),
	          gl.getUniformLocation(program, uniName),
	          info));
	      }
	    }

	    // -------------------------------
	    // grab attributes
	    // -------------------------------
	    var numAttributes = gl.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES);
	    if (config.profile) {
	      desc.stats.attributesCount = numAttributes;
	    }

	    var attributes = desc.attributes;
	    for (i = 0; i < numAttributes; ++i) {
	      info = gl.getActiveAttrib(program, i);
	      if (info) {
	        insertActiveInfo(attributes, new ActiveInfo(
	          info.name,
	          stringStore.id(info.name),
	          gl.getAttribLocation(program, info.name),
	          info));
	      }
	    }
	  }

	  if (config.profile) {
	    stats.getMaxUniformsCount = function () {
	      var m = 0;
	      programList.forEach(function (desc) {
	        if (desc.stats.uniformsCount > m) {
	          m = desc.stats.uniformsCount;
	        }
	      });
	      return m
	    };

	    stats.getMaxAttributesCount = function () {
	      var m = 0;
	      programList.forEach(function (desc) {
	        if (desc.stats.attributesCount > m) {
	          m = desc.stats.attributesCount;
	        }
	      });
	      return m
	    };
	  }

	  function restoreShaders () {
	    fragShaders = {};
	    vertShaders = {};
	    for (var i = 0; i < programList.length; ++i) {
	      linkProgram(programList[i], null, programList[i].attributes.map(function (info) {
	        return [info.location, info.name]
	      }));
	    }
	  }

	  return {
	    clear: function () {
	      var deleteShader = gl.deleteShader.bind(gl);
	      values(fragShaders).forEach(deleteShader);
	      fragShaders = {};
	      values(vertShaders).forEach(deleteShader);
	      vertShaders = {};

	      programList.forEach(function (desc) {
	        gl.deleteProgram(desc.program);
	      });
	      programList.length = 0;
	      programCache = {};

	      stats.shaderCount = 0;
	    },

	    program: function (vertId, fragId, command, attribLocations) {
	      check$1.command(vertId >= 0, 'missing vertex shader', command);
	      check$1.command(fragId >= 0, 'missing fragment shader', command);

	      var cache = programCache[fragId];
	      if (!cache) {
	        cache = programCache[fragId] = {};
	      }
	      var prevProgram = cache[vertId];
	      if (prevProgram) {
	        prevProgram.refCount++;
	        if (!attribLocations) {
	          return prevProgram
	        }
	      }
	      var program = new REGLProgram(fragId, vertId);
	      stats.shaderCount++;
	      linkProgram(program, command, attribLocations);
	      if (!prevProgram) {
	        cache[vertId] = program;
	      }
	      programList.push(program);
	      return extend(program, {
	        destroy: function () {
	          program.refCount--;
	          if (program.refCount <= 0) {
	            gl.deleteProgram(program.program);
	            var idx = programList.indexOf(program);
	            programList.splice(idx, 1);
	            stats.shaderCount--;
	          }
	          // no program is linked to this vert anymore
	          if (cache[program.vertId].refCount <= 0) {
	            gl.deleteShader(vertShaders[program.vertId]);
	            delete vertShaders[program.vertId];
	            delete programCache[program.fragId][program.vertId];
	          }
	          // no program is linked to this frag anymore
	          if (!Object.keys(programCache[program.fragId]).length) {
	            gl.deleteShader(fragShaders[program.fragId]);
	            delete fragShaders[program.fragId];
	            delete programCache[program.fragId];
	          }
	        }
	      })
	    },

	    restore: restoreShaders,

	    shader: getShader,

	    frag: -1,
	    vert: -1
	  }
	}

	var GL_RGBA$3 = 6408;
	var GL_UNSIGNED_BYTE$7 = 5121;
	var GL_PACK_ALIGNMENT = 0x0D05;
	var GL_FLOAT$7 = 0x1406; // 5126

	function wrapReadPixels (
	  gl,
	  framebufferState,
	  reglPoll,
	  context,
	  glAttributes,
	  extensions,
	  limits) {
	  function readPixelsImpl (input) {
	    var type;
	    if (framebufferState.next === null) {
	      check$1(
	        glAttributes.preserveDrawingBuffer,
	        'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer');
	      type = GL_UNSIGNED_BYTE$7;
	    } else {
	      check$1(
	        framebufferState.next.colorAttachments[0].texture !== null,
	        'You cannot read from a renderbuffer');
	      type = framebufferState.next.colorAttachments[0].texture._texture.type;

	      check$1.optional(function () {
	        if (extensions.oes_texture_float) {
	          check$1(
	            type === GL_UNSIGNED_BYTE$7 || type === GL_FLOAT$7,
	            'Reading from a framebuffer is only allowed for the types \'uint8\' and \'float\'');

	          if (type === GL_FLOAT$7) {
	            check$1(limits.readFloat, 'Reading \'float\' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float');
	          }
	        } else {
	          check$1(
	            type === GL_UNSIGNED_BYTE$7,
	            'Reading from a framebuffer is only allowed for the type \'uint8\'');
	        }
	      });
	    }

	    var x = 0;
	    var y = 0;
	    var width = context.framebufferWidth;
	    var height = context.framebufferHeight;
	    var data = null;

	    if (isTypedArray(input)) {
	      data = input;
	    } else if (input) {
	      check$1.type(input, 'object', 'invalid arguments to regl.read()');
	      x = input.x | 0;
	      y = input.y | 0;
	      check$1(
	        x >= 0 && x < context.framebufferWidth,
	        'invalid x offset for regl.read');
	      check$1(
	        y >= 0 && y < context.framebufferHeight,
	        'invalid y offset for regl.read');
	      width = (input.width || (context.framebufferWidth - x)) | 0;
	      height = (input.height || (context.framebufferHeight - y)) | 0;
	      data = input.data || null;
	    }

	    // sanity check input.data
	    if (data) {
	      if (type === GL_UNSIGNED_BYTE$7) {
	        check$1(
	          data instanceof Uint8Array,
	          'buffer must be \'Uint8Array\' when reading from a framebuffer of type \'uint8\'');
	      } else if (type === GL_FLOAT$7) {
	        check$1(
	          data instanceof Float32Array,
	          'buffer must be \'Float32Array\' when reading from a framebuffer of type \'float\'');
	      }
	    }

	    check$1(
	      width > 0 && width + x <= context.framebufferWidth,
	      'invalid width for read pixels');
	    check$1(
	      height > 0 && height + y <= context.framebufferHeight,
	      'invalid height for read pixels');

	    // Update WebGL state
	    reglPoll();

	    // Compute size
	    var size = width * height * 4;

	    // Allocate data
	    if (!data) {
	      if (type === GL_UNSIGNED_BYTE$7) {
	        data = new Uint8Array(size);
	      } else if (type === GL_FLOAT$7) {
	        data = data || new Float32Array(size);
	      }
	    }

	    // Type check
	    check$1.isTypedArray(data, 'data buffer for regl.read() must be a typedarray');
	    check$1(data.byteLength >= size, 'data buffer for regl.read() too small');

	    // Run read pixels
	    gl.pixelStorei(GL_PACK_ALIGNMENT, 4);
	    gl.readPixels(x, y, width, height, GL_RGBA$3,
	      type,
	      data);

	    return data
	  }

	  function readPixelsFBO (options) {
	    var result;
	    framebufferState.setFBO({
	      framebuffer: options.framebuffer
	    }, function () {
	      result = readPixelsImpl(options);
	    });
	    return result
	  }

	  function readPixels (options) {
	    if (!options || !('framebuffer' in options)) {
	      return readPixelsImpl(options)
	    } else {
	      return readPixelsFBO(options)
	    }
	  }

	  return readPixels
	}

	function slice (x) {
	  return Array.prototype.slice.call(x)
	}

	function join (x) {
	  return slice(x).join('')
	}

	function createEnvironment () {
	  // Unique variable id counter
	  var varCounter = 0;

	  // Linked values are passed from this scope into the generated code block
	  // Calling link() passes a value into the generated scope and returns
	  // the variable name which it is bound to
	  var linkedNames = [];
	  var linkedValues = [];
	  function link (value) {
	    for (var i = 0; i < linkedValues.length; ++i) {
	      if (linkedValues[i] === value) {
	        return linkedNames[i]
	      }
	    }

	    var name = 'g' + (varCounter++);
	    linkedNames.push(name);
	    linkedValues.push(value);
	    return name
	  }

	  // create a code block
	  function block () {
	    var code = [];
	    function push () {
	      code.push.apply(code, slice(arguments));
	    }

	    var vars = [];
	    function def () {
	      var name = 'v' + (varCounter++);
	      vars.push(name);

	      if (arguments.length > 0) {
	        code.push(name, '=');
	        code.push.apply(code, slice(arguments));
	        code.push(';');
	      }

	      return name
	    }

	    return extend(push, {
	      def: def,
	      toString: function () {
	        return join([
	          (vars.length > 0 ? 'var ' + vars.join(',') + ';' : ''),
	          join(code)
	        ])
	      }
	    })
	  }

	  function scope () {
	    var entry = block();
	    var exit = block();

	    var entryToString = entry.toString;
	    var exitToString = exit.toString;

	    function save (object, prop) {
	      exit(object, prop, '=', entry.def(object, prop), ';');
	    }

	    return extend(function () {
	      entry.apply(entry, slice(arguments));
	    }, {
	      def: entry.def,
	      entry: entry,
	      exit: exit,
	      save: save,
	      set: function (object, prop, value) {
	        save(object, prop);
	        entry(object, prop, '=', value, ';');
	      },
	      toString: function () {
	        return entryToString() + exitToString()
	      }
	    })
	  }

	  function conditional () {
	    var pred = join(arguments);
	    var thenBlock = scope();
	    var elseBlock = scope();

	    var thenToString = thenBlock.toString;
	    var elseToString = elseBlock.toString;

	    return extend(thenBlock, {
	      then: function () {
	        thenBlock.apply(thenBlock, slice(arguments));
	        return this
	      },
	      else: function () {
	        elseBlock.apply(elseBlock, slice(arguments));
	        return this
	      },
	      toString: function () {
	        var elseClause = elseToString();
	        if (elseClause) {
	          elseClause = 'else{' + elseClause + '}';
	        }
	        return join([
	          'if(', pred, '){',
	          thenToString(),
	          '}', elseClause
	        ])
	      }
	    })
	  }

	  // procedure list
	  var globalBlock = block();
	  var procedures = {};
	  function proc (name, count) {
	    var args = [];
	    function arg () {
	      var name = 'a' + args.length;
	      args.push(name);
	      return name
	    }

	    count = count || 0;
	    for (var i = 0; i < count; ++i) {
	      arg();
	    }

	    var body = scope();
	    var bodyToString = body.toString;

	    var result = procedures[name] = extend(body, {
	      arg: arg,
	      toString: function () {
	        return join([
	          'function(', args.join(), '){',
	          bodyToString(),
	          '}'
	        ])
	      }
	    });

	    return result
	  }

	  function compile () {
	    var code = ['"use strict";',
	      globalBlock,
	      'return {'];
	    Object.keys(procedures).forEach(function (name) {
	      code.push('"', name, '":', procedures[name].toString(), ',');
	    });
	    code.push('}');
	    var src = join(code)
	      .replace(/;/g, ';\n')
	      .replace(/}/g, '}\n')
	      .replace(/{/g, '{\n');
	    var proc = Function.apply(null, linkedNames.concat(src));
	    return proc.apply(null, linkedValues)
	  }

	  return {
	    global: globalBlock,
	    link: link,
	    block: block,
	    proc: proc,
	    scope: scope,
	    cond: conditional,
	    compile: compile
	  }
	}

	// "cute" names for vector components
	var CUTE_COMPONENTS = 'xyzw'.split('');

	var GL_UNSIGNED_BYTE$8 = 5121;

	var ATTRIB_STATE_POINTER = 1;
	var ATTRIB_STATE_CONSTANT = 2;

	var DYN_FUNC$1 = 0;
	var DYN_PROP$1 = 1;
	var DYN_CONTEXT$1 = 2;
	var DYN_STATE$1 = 3;
	var DYN_THUNK = 4;
	var DYN_CONSTANT$1 = 5;
	var DYN_ARRAY$1 = 6;

	var S_DITHER = 'dither';
	var S_BLEND_ENABLE = 'blend.enable';
	var S_BLEND_COLOR = 'blend.color';
	var S_BLEND_EQUATION = 'blend.equation';
	var S_BLEND_FUNC = 'blend.func';
	var S_DEPTH_ENABLE = 'depth.enable';
	var S_DEPTH_FUNC = 'depth.func';
	var S_DEPTH_RANGE = 'depth.range';
	var S_DEPTH_MASK = 'depth.mask';
	var S_COLOR_MASK = 'colorMask';
	var S_CULL_ENABLE = 'cull.enable';
	var S_CULL_FACE = 'cull.face';
	var S_FRONT_FACE = 'frontFace';
	var S_LINE_WIDTH = 'lineWidth';
	var S_POLYGON_OFFSET_ENABLE = 'polygonOffset.enable';
	var S_POLYGON_OFFSET_OFFSET = 'polygonOffset.offset';
	var S_SAMPLE_ALPHA = 'sample.alpha';
	var S_SAMPLE_ENABLE = 'sample.enable';
	var S_SAMPLE_COVERAGE = 'sample.coverage';
	var S_STENCIL_ENABLE = 'stencil.enable';
	var S_STENCIL_MASK = 'stencil.mask';
	var S_STENCIL_FUNC = 'stencil.func';
	var S_STENCIL_OPFRONT = 'stencil.opFront';
	var S_STENCIL_OPBACK = 'stencil.opBack';
	var S_SCISSOR_ENABLE = 'scissor.enable';
	var S_SCISSOR_BOX = 'scissor.box';
	var S_VIEWPORT = 'viewport';

	var S_PROFILE = 'profile';

	var S_FRAMEBUFFER = 'framebuffer';
	var S_VERT = 'vert';
	var S_FRAG = 'frag';
	var S_ELEMENTS = 'elements';
	var S_PRIMITIVE = 'primitive';
	var S_COUNT = 'count';
	var S_OFFSET = 'offset';
	var S_INSTANCES = 'instances';
	var S_VAO = 'vao';

	var SUFFIX_WIDTH = 'Width';
	var SUFFIX_HEIGHT = 'Height';

	var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH;
	var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT;
	var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH;
	var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT;
	var S_DRAWINGBUFFER = 'drawingBuffer';
	var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH;
	var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT;

	var NESTED_OPTIONS = [
	  S_BLEND_FUNC,
	  S_BLEND_EQUATION,
	  S_STENCIL_FUNC,
	  S_STENCIL_OPFRONT,
	  S_STENCIL_OPBACK,
	  S_SAMPLE_COVERAGE,
	  S_VIEWPORT,
	  S_SCISSOR_BOX,
	  S_POLYGON_OFFSET_OFFSET
	];

	var GL_ARRAY_BUFFER$2 = 34962;
	var GL_ELEMENT_ARRAY_BUFFER$2 = 34963;

	var GL_FRAGMENT_SHADER$1 = 35632;
	var GL_VERTEX_SHADER$1 = 35633;

	var GL_TEXTURE_2D$3 = 0x0DE1;
	var GL_TEXTURE_CUBE_MAP$2 = 0x8513;

	var GL_CULL_FACE = 0x0B44;
	var GL_BLEND = 0x0BE2;
	var GL_DITHER = 0x0BD0;
	var GL_STENCIL_TEST = 0x0B90;
	var GL_DEPTH_TEST = 0x0B71;
	var GL_SCISSOR_TEST = 0x0C11;
	var GL_POLYGON_OFFSET_FILL = 0x8037;
	var GL_SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
	var GL_SAMPLE_COVERAGE = 0x80A0;

	var GL_FLOAT$8 = 5126;
	var GL_FLOAT_VEC2 = 35664;
	var GL_FLOAT_VEC3 = 35665;
	var GL_FLOAT_VEC4 = 35666;
	var GL_INT$3 = 5124;
	var GL_INT_VEC2 = 35667;
	var GL_INT_VEC3 = 35668;
	var GL_INT_VEC4 = 35669;
	var GL_BOOL = 35670;
	var GL_BOOL_VEC2 = 35671;
	var GL_BOOL_VEC3 = 35672;
	var GL_BOOL_VEC4 = 35673;
	var GL_FLOAT_MAT2 = 35674;
	var GL_FLOAT_MAT3 = 35675;
	var GL_FLOAT_MAT4 = 35676;
	var GL_SAMPLER_2D = 35678;
	var GL_SAMPLER_CUBE = 35680;

	var GL_TRIANGLES$1 = 4;

	var GL_FRONT = 1028;
	var GL_BACK = 1029;
	var GL_CW = 0x0900;
	var GL_CCW = 0x0901;
	var GL_MIN_EXT = 0x8007;
	var GL_MAX_EXT = 0x8008;
	var GL_ALWAYS = 519;
	var GL_KEEP = 7680;
	var GL_ZERO = 0;
	var GL_ONE = 1;
	var GL_FUNC_ADD = 0x8006;
	var GL_LESS = 513;

	var GL_FRAMEBUFFER$2 = 0x8D40;
	var GL_COLOR_ATTACHMENT0$2 = 0x8CE0;

	var blendFuncs = {
	  '0': 0,
	  '1': 1,
	  'zero': 0,
	  'one': 1,
	  'src color': 768,
	  'one minus src color': 769,
	  'src alpha': 770,
	  'one minus src alpha': 771,
	  'dst color': 774,
	  'one minus dst color': 775,
	  'dst alpha': 772,
	  'one minus dst alpha': 773,
	  'constant color': 32769,
	  'one minus constant color': 32770,
	  'constant alpha': 32771,
	  'one minus constant alpha': 32772,
	  'src alpha saturate': 776
	};

	// There are invalid values for srcRGB and dstRGB. See:
	// https://www.khronos.org/registry/webgl/specs/1.0/#6.13
	// https://github.com/KhronosGroup/WebGL/blob/0d3201f5f7ec3c0060bc1f04077461541f1987b9/conformance-suites/1.0.3/conformance/misc/webgl-specific.html#L56
	var invalidBlendCombinations = [
	  'constant color, constant alpha',
	  'one minus constant color, constant alpha',
	  'constant color, one minus constant alpha',
	  'one minus constant color, one minus constant alpha',
	  'constant alpha, constant color',
	  'constant alpha, one minus constant color',
	  'one minus constant alpha, constant color',
	  'one minus constant alpha, one minus constant color'
	];

	var compareFuncs = {
	  'never': 512,
	  'less': 513,
	  '<': 513,
	  'equal': 514,
	  '=': 514,
	  '==': 514,
	  '===': 514,
	  'lequal': 515,
	  '<=': 515,
	  'greater': 516,
	  '>': 516,
	  'notequal': 517,
	  '!=': 517,
	  '!==': 517,
	  'gequal': 518,
	  '>=': 518,
	  'always': 519
	};

	var stencilOps = {
	  '0': 0,
	  'zero': 0,
	  'keep': 7680,
	  'replace': 7681,
	  'increment': 7682,
	  'decrement': 7683,
	  'increment wrap': 34055,
	  'decrement wrap': 34056,
	  'invert': 5386
	};

	var shaderType = {
	  'frag': GL_FRAGMENT_SHADER$1,
	  'vert': GL_VERTEX_SHADER$1
	};

	var orientationType = {
	  'cw': GL_CW,
	  'ccw': GL_CCW
	};

	function isBufferArgs (x) {
	  return Array.isArray(x) ||
	    isTypedArray(x) ||
	    isNDArrayLike(x)
	}

	// Make sure viewport is processed first
	function sortState (state) {
	  return state.sort(function (a, b) {
	    if (a === S_VIEWPORT) {
	      return -1
	    } else if (b === S_VIEWPORT) {
	      return 1
	    }
	    return (a < b) ? -1 : 1
	  })
	}

	function Declaration (thisDep, contextDep, propDep, append) {
	  this.thisDep = thisDep;
	  this.contextDep = contextDep;
	  this.propDep = propDep;
	  this.append = append;
	}

	function isStatic (decl) {
	  return decl && !(decl.thisDep || decl.contextDep || decl.propDep)
	}

	function createStaticDecl (append) {
	  return new Declaration(false, false, false, append)
	}

	function createDynamicDecl (dyn, append) {
	  var type = dyn.type;
	  if (type === DYN_FUNC$1) {
	    var numArgs = dyn.data.length;
	    return new Declaration(
	      true,
	      numArgs >= 1,
	      numArgs >= 2,
	      append)
	  } else if (type === DYN_THUNK) {
	    var data = dyn.data;
	    return new Declaration(
	      data.thisDep,
	      data.contextDep,
	      data.propDep,
	      append)
	  } else if (type === DYN_CONSTANT$1) {
	    return new Declaration(
	      false,
	      false,
	      false,
	      append)
	  } else if (type === DYN_ARRAY$1) {
	    var thisDep = false;
	    var contextDep = false;
	    var propDep = false;
	    for (var i = 0; i < dyn.data.length; ++i) {
	      var subDyn = dyn.data[i];
	      if (subDyn.type === DYN_PROP$1) {
	        propDep = true;
	      } else if (subDyn.type === DYN_CONTEXT$1) {
	        contextDep = true;
	      } else if (subDyn.type === DYN_STATE$1) {
	        thisDep = true;
	      } else if (subDyn.type === DYN_FUNC$1) {
	        thisDep = true;
	        var subArgs = subDyn.data;
	        if (subArgs >= 1) {
	          contextDep = true;
	        }
	        if (subArgs >= 2) {
	          propDep = true;
	        }
	      } else if (subDyn.type === DYN_THUNK) {
	        thisDep = thisDep || subDyn.data.thisDep;
	        contextDep = contextDep || subDyn.data.contextDep;
	        propDep = propDep || subDyn.data.propDep;
	      }
	    }
	    return new Declaration(
	      thisDep,
	      contextDep,
	      propDep,
	      append)
	  } else {
	    return new Declaration(
	      type === DYN_STATE$1,
	      type === DYN_CONTEXT$1,
	      type === DYN_PROP$1,
	      append)
	  }
	}

	var SCOPE_DECL = new Declaration(false, false, false, function () {});

	function reglCore (
	  gl,
	  stringStore,
	  extensions,
	  limits,
	  bufferState,
	  elementState,
	  textureState,
	  framebufferState,
	  uniformState,
	  attributeState,
	  shaderState,
	  drawState,
	  contextState,
	  timer,
	  config) {
	  var AttributeRecord = attributeState.Record;

	  var blendEquations = {
	    'add': 32774,
	    'subtract': 32778,
	    'reverse subtract': 32779
	  };
	  if (extensions.ext_blend_minmax) {
	    blendEquations.min = GL_MIN_EXT;
	    blendEquations.max = GL_MAX_EXT;
	  }

	  var extInstancing = extensions.angle_instanced_arrays;
	  var extDrawBuffers = extensions.webgl_draw_buffers;
	  var extVertexArrays = extensions.oes_vertex_array_object;

	  // ===================================================
	  // ===================================================
	  // WEBGL STATE
	  // ===================================================
	  // ===================================================
	  var currentState = {
	    dirty: true,
	    profile: config.profile
	  };
	  var nextState = {};
	  var GL_STATE_NAMES = [];
	  var GL_FLAGS = {};
	  var GL_VARIABLES = {};

	  function propName (name) {
	    return name.replace('.', '_')
	  }

	  function stateFlag (sname, cap, init) {
	    var name = propName(sname);
	    GL_STATE_NAMES.push(sname);
	    nextState[name] = currentState[name] = !!init;
	    GL_FLAGS[name] = cap;
	  }

	  function stateVariable (sname, func, init) {
	    var name = propName(sname);
	    GL_STATE_NAMES.push(sname);
	    if (Array.isArray(init)) {
	      currentState[name] = init.slice();
	      nextState[name] = init.slice();
	    } else {
	      currentState[name] = nextState[name] = init;
	    }
	    GL_VARIABLES[name] = func;
	  }

	  // Dithering
	  stateFlag(S_DITHER, GL_DITHER);

	  // Blending
	  stateFlag(S_BLEND_ENABLE, GL_BLEND);
	  stateVariable(S_BLEND_COLOR, 'blendColor', [0, 0, 0, 0]);
	  stateVariable(S_BLEND_EQUATION, 'blendEquationSeparate',
	    [GL_FUNC_ADD, GL_FUNC_ADD]);
	  stateVariable(S_BLEND_FUNC, 'blendFuncSeparate',
	    [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO]);

	  // Depth
	  stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true);
	  stateVariable(S_DEPTH_FUNC, 'depthFunc', GL_LESS);
	  stateVariable(S_DEPTH_RANGE, 'depthRange', [0, 1]);
	  stateVariable(S_DEPTH_MASK, 'depthMask', true);

	  // Color mask
	  stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true]);

	  // Face culling
	  stateFlag(S_CULL_ENABLE, GL_CULL_FACE);
	  stateVariable(S_CULL_FACE, 'cullFace', GL_BACK);

	  // Front face orientation
	  stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW);

	  // Line width
	  stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1);

	  // Polygon offset
	  stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL);
	  stateVariable(S_POLYGON_OFFSET_OFFSET, 'polygonOffset', [0, 0]);

	  // Sample coverage
	  stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE);
	  stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE);
	  stateVariable(S_SAMPLE_COVERAGE, 'sampleCoverage', [1, false]);

	  // Stencil
	  stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST);
	  stateVariable(S_STENCIL_MASK, 'stencilMask', -1);
	  stateVariable(S_STENCIL_FUNC, 'stencilFunc', [GL_ALWAYS, 0, -1]);
	  stateVariable(S_STENCIL_OPFRONT, 'stencilOpSeparate',
	    [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP]);
	  stateVariable(S_STENCIL_OPBACK, 'stencilOpSeparate',
	    [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP]);

	  // Scissor
	  stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST);
	  stateVariable(S_SCISSOR_BOX, 'scissor',
	    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]);

	  // Viewport
	  stateVariable(S_VIEWPORT, S_VIEWPORT,
	    [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]);

	  // ===================================================
	  // ===================================================
	  // ENVIRONMENT
	  // ===================================================
	  // ===================================================
	  var sharedState = {
	    gl: gl,
	    context: contextState,
	    strings: stringStore,
	    next: nextState,
	    current: currentState,
	    draw: drawState,
	    elements: elementState,
	    buffer: bufferState,
	    shader: shaderState,
	    attributes: attributeState.state,
	    vao: attributeState,
	    uniforms: uniformState,
	    framebuffer: framebufferState,
	    extensions: extensions,

	    timer: timer,
	    isBufferArgs: isBufferArgs
	  };

	  var sharedConstants = {
	    primTypes: primTypes,
	    compareFuncs: compareFuncs,
	    blendFuncs: blendFuncs,
	    blendEquations: blendEquations,
	    stencilOps: stencilOps,
	    glTypes: glTypes,
	    orientationType: orientationType
	  };

	  check$1.optional(function () {
	    sharedState.isArrayLike = isArrayLike;
	  });

	  if (extDrawBuffers) {
	    sharedConstants.backBuffer = [GL_BACK];
	    sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function (i) {
	      if (i === 0) {
	        return [0]
	      }
	      return loop(i, function (j) {
	        return GL_COLOR_ATTACHMENT0$2 + j
	      })
	    });
	  }

	  var drawCallCounter = 0;
	  function createREGLEnvironment () {
	    var env = createEnvironment();
	    var link = env.link;
	    var global = env.global;
	    env.id = drawCallCounter++;

	    env.batchId = '0';

	    // link shared state
	    var SHARED = link(sharedState);
	    var shared = env.shared = {
	      props: 'a0'
	    };
	    Object.keys(sharedState).forEach(function (prop) {
	      shared[prop] = global.def(SHARED, '.', prop);
	    });

	    // Inject runtime assertion stuff for debug builds
	    check$1.optional(function () {
	      env.CHECK = link(check$1);
	      env.commandStr = check$1.guessCommand();
	      env.command = link(env.commandStr);
	      env.assert = function (block, pred, message) {
	        block(
	          'if(!(', pred, '))',
	          this.CHECK, '.commandRaise(', link(message), ',', this.command, ');');
	      };

	      sharedConstants.invalidBlendCombinations = invalidBlendCombinations;
	    });

	    // Copy GL state variables over
	    var nextVars = env.next = {};
	    var currentVars = env.current = {};
	    Object.keys(GL_VARIABLES).forEach(function (variable) {
	      if (Array.isArray(currentState[variable])) {
	        nextVars[variable] = global.def(shared.next, '.', variable);
	        currentVars[variable] = global.def(shared.current, '.', variable);
	      }
	    });

	    // Initialize shared constants
	    var constants = env.constants = {};
	    Object.keys(sharedConstants).forEach(function (name) {
	      constants[name] = global.def(JSON.stringify(sharedConstants[name]));
	    });

	    // Helper function for calling a block
	    env.invoke = function (block, x) {
	      switch (x.type) {
	        case DYN_FUNC$1:
	          var argList = [
	            'this',
	            shared.context,
	            shared.props,
	            env.batchId
	          ];
	          return block.def(
	            link(x.data), '.call(',
	            argList.slice(0, Math.max(x.data.length + 1, 4)),
	            ')')
	        case DYN_PROP$1:
	          return block.def(shared.props, x.data)
	        case DYN_CONTEXT$1:
	          return block.def(shared.context, x.data)
	        case DYN_STATE$1:
	          return block.def('this', x.data)
	        case DYN_THUNK:
	          x.data.append(env, block);
	          return x.data.ref
	        case DYN_CONSTANT$1:
	          return x.data.toString()
	        case DYN_ARRAY$1:
	          return x.data.map(function (y) {
	            return env.invoke(block, y)
	          })
	      }
	    };

	    env.attribCache = {};

	    var scopeAttribs = {};
	    env.scopeAttrib = function (name) {
	      var id = stringStore.id(name);
	      if (id in scopeAttribs) {
	        return scopeAttribs[id]
	      }
	      var binding = attributeState.scope[id];
	      if (!binding) {
	        binding = attributeState.scope[id] = new AttributeRecord();
	      }
	      var result = scopeAttribs[id] = link(binding);
	      return result
	    };

	    return env
	  }

	  // ===================================================
	  // ===================================================
	  // PARSING
	  // ===================================================
	  // ===================================================
	  function parseProfile (options) {
	    var staticOptions = options.static;
	    var dynamicOptions = options.dynamic;

	    var profileEnable;
	    if (S_PROFILE in staticOptions) {
	      var value = !!staticOptions[S_PROFILE];
	      profileEnable = createStaticDecl(function (env, scope) {
	        return value
	      });
	      profileEnable.enable = value;
	    } else if (S_PROFILE in dynamicOptions) {
	      var dyn = dynamicOptions[S_PROFILE];
	      profileEnable = createDynamicDecl(dyn, function (env, scope) {
	        return env.invoke(scope, dyn)
	      });
	    }

	    return profileEnable
	  }

	  function parseFramebuffer (options, env) {
	    var staticOptions = options.static;
	    var dynamicOptions = options.dynamic;

	    if (S_FRAMEBUFFER in staticOptions) {
	      var framebuffer = staticOptions[S_FRAMEBUFFER];
	      if (framebuffer) {
	        framebuffer = framebufferState.getFramebuffer(framebuffer);
	        check$1.command(framebuffer, 'invalid framebuffer object');
	        return createStaticDecl(function (env, block) {
	          var FRAMEBUFFER = env.link(framebuffer);
	          var shared = env.shared;
	          block.set(
	            shared.framebuffer,
	            '.next',
	            FRAMEBUFFER);
	          var CONTEXT = shared.context;
	          block.set(
	            CONTEXT,
	            '.' + S_FRAMEBUFFER_WIDTH,
	            FRAMEBUFFER + '.width');
	          block.set(
	            CONTEXT,
	            '.' + S_FRAMEBUFFER_HEIGHT,
	            FRAMEBUFFER + '.height');
	          return FRAMEBUFFER
	        })
	      } else {
	        return createStaticDecl(function (env, scope) {
	          var shared = env.shared;
	          scope.set(
	            shared.framebuffer,
	            '.next',
	            'null');
	          var CONTEXT = shared.context;
	          scope.set(
	            CONTEXT,
	            '.' + S_FRAMEBUFFER_WIDTH,
	            CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH);
	          scope.set(
	            CONTEXT,
	            '.' + S_FRAMEBUFFER_HEIGHT,
	            CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT);
	          return 'null'
	        })
	      }
	    } else if (S_FRAMEBUFFER in dynamicOptions) {
	      var dyn = dynamicOptions[S_FRAMEBUFFER];
	      return createDynamicDecl(dyn, function (env, scope) {
	        var FRAMEBUFFER_FUNC = env.invoke(scope, dyn);
	        var shared = env.shared;
	        var FRAMEBUFFER_STATE = shared.framebuffer;
	        var FRAMEBUFFER = scope.def(
	          FRAMEBUFFER_STATE, '.getFramebuffer(', FRAMEBUFFER_FUNC, ')');

	        check$1.optional(function () {
	          env.assert(scope,
	            '!' + FRAMEBUFFER_FUNC + '||' + FRAMEBUFFER,
	            'invalid framebuffer object');
	        });

	        scope.set(
	          FRAMEBUFFER_STATE,
	          '.next',
	          FRAMEBUFFER);
	        var CONTEXT = shared.context;
	        scope.set(
	          CONTEXT,
	          '.' + S_FRAMEBUFFER_WIDTH,
	          FRAMEBUFFER + '?' + FRAMEBUFFER + '.width:' +
	          CONTEXT + '.' + S_DRAWINGBUFFER_WIDTH);
	        scope.set(
	          CONTEXT,
	          '.' + S_FRAMEBUFFER_HEIGHT,
	          FRAMEBUFFER +
	          '?' + FRAMEBUFFER + '.height:' +
	          CONTEXT + '.' + S_DRAWINGBUFFER_HEIGHT);
	        return FRAMEBUFFER
	      })
	    } else {
	      return null
	    }
	  }

	  function parseViewportScissor (options, framebuffer, env) {
	    var staticOptions = options.static;
	    var dynamicOptions = options.dynamic;

	    function parseBox (param) {
	      if (param in staticOptions) {
	        var box = staticOptions[param];
	        check$1.commandType(box, 'object', 'invalid ' + param, env.commandStr);

	        var isStatic = true;
	        var x = box.x | 0;
	        var y = box.y | 0;
	        var w, h;
	        if ('width' in box) {
	          w = box.width | 0;
	          check$1.command(w >= 0, 'invalid ' + param, env.commandStr);
	        } else {
	          isStatic = false;
	        }
	        if ('height' in box) {
	          h = box.height | 0;
	          check$1.command(h >= 0, 'invalid ' + param, env.commandStr);
	        } else {
	          isStatic = false;
	        }

	        return new Declaration(
	          !isStatic && framebuffer && framebuffer.thisDep,
	          !isStatic && framebuffer && framebuffer.contextDep,
	          !isStatic && framebuffer && framebuffer.propDep,
	          function (env, scope) {
	            var CONTEXT = env.shared.context;
	            var BOX_W = w;
	            if (!('width' in box)) {
	              BOX_W = scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', x);
	            }
	            var BOX_H = h;
	            if (!('height' in box)) {
	              BOX_H = scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', y);
	            }
	            return [x, y, BOX_W, BOX_H]
	          })
	      } else if (param in dynamicOptions) {
	        var dynBox = dynamicOptions[param];
	        var result = createDynamicDecl(dynBox, function (env, scope) {
	          var BOX = env.invoke(scope, dynBox);

	          check$1.optional(function () {
	            env.assert(scope,
	              BOX + '&&typeof ' + BOX + '==="object"',
	              'invalid ' + param);
	          });

	          var CONTEXT = env.shared.context;
	          var BOX_X = scope.def(BOX, '.x|0');
	          var BOX_Y = scope.def(BOX, '.y|0');
	          var BOX_W = scope.def(
	            '"width" in ', BOX, '?', BOX, '.width|0:',
	            '(', CONTEXT, '.', S_FRAMEBUFFER_WIDTH, '-', BOX_X, ')');
	          var BOX_H = scope.def(
	            '"height" in ', BOX, '?', BOX, '.height|0:',
	            '(', CONTEXT, '.', S_FRAMEBUFFER_HEIGHT, '-', BOX_Y, ')');

	          check$1.optional(function () {
	            env.assert(scope,
	              BOX_W + '>=0&&' +
	              BOX_H + '>=0',
	              'invalid ' + param);
	          });

	          return [BOX_X, BOX_Y, BOX_W, BOX_H]
	        });
	        if (framebuffer) {
	          result.thisDep = result.thisDep || framebuffer.thisDep;
	          result.contextDep = result.contextDep || framebuffer.contextDep;
	          result.propDep = result.propDep || framebuffer.propDep;
	        }
	        return result
	      } else if (framebuffer) {
	        return new Declaration(
	          framebuffer.thisDep,
	          framebuffer.contextDep,
	          framebuffer.propDep,
	          function (env, scope) {
	            var CONTEXT = env.shared.context;
	            return [
	              0, 0,
	              scope.def(CONTEXT, '.', S_FRAMEBUFFER_WIDTH),
	              scope.def(CONTEXT, '.', S_FRAMEBUFFER_HEIGHT)]
	          })
	      } else {
	        return null
	      }
	    }

	    var viewport = parseBox(S_VIEWPORT);

	    if (viewport) {
	      var prevViewport = viewport;
	      viewport = new Declaration(
	        viewport.thisDep,
	        viewport.contextDep,
	        viewport.propDep,
	        function (env, scope) {
	          var VIEWPORT = prevViewport.append(env, scope);
	          var CONTEXT = env.shared.context;
	          scope.set(
	            CONTEXT,
	            '.' + S_VIEWPORT_WIDTH,
	            VIEWPORT[2]);
	          scope.set(
	            CONTEXT,
	            '.' + S_VIEWPORT_HEIGHT,
	            VIEWPORT[3]);
	          return VIEWPORT
	        });
	    }

	    return {
	      viewport: viewport,
	      scissor_box: parseBox(S_SCISSOR_BOX)
	    }
	  }

	  function parseAttribLocations (options, attributes) {
	    var staticOptions = options.static;
	    var staticProgram =
	      typeof staticOptions[S_FRAG] === 'string' &&
	      typeof staticOptions[S_VERT] === 'string';
	    if (staticProgram) {
	      if (Object.keys(attributes.dynamic).length > 0) {
	        return null
	      }
	      var staticAttributes = attributes.static;
	      var sAttributes = Object.keys(staticAttributes);
	      if (sAttributes.length > 0 && typeof staticAttributes[sAttributes[0]] === 'number') {
	        var bindings = [];
	        for (var i = 0; i < sAttributes.length; ++i) {
	          check$1(typeof staticAttributes[sAttributes[i]] === 'number', 'must specify all vertex attribute locations when using vaos');
	          bindings.push([staticAttributes[sAttributes[i]] | 0, sAttributes[i]]);
	        }
	        return bindings
	      }
	    }
	    return null
	  }

	  function parseProgram (options, env, attribLocations) {
	    var staticOptions = options.static;
	    var dynamicOptions = options.dynamic;

	    function parseShader (name) {
	      if (name in staticOptions) {
	        var id = stringStore.id(staticOptions[name]);
	        check$1.optional(function () {
	          shaderState.shader(shaderType[name], id, check$1.guessCommand());
	        });
	        var result = createStaticDecl(function () {
	          return id
	        });
	        result.id = id;
	        return result
	      } else if (name in dynamicOptions) {
	        var dyn = dynamicOptions[name];
	        return createDynamicDecl(dyn, function (env, scope) {
	          var str = env.invoke(scope, dyn);
	          var id = scope.def(env.shared.strings, '.id(', str, ')');
	          check$1.optional(function () {
	            scope(
	              env.shared.shader, '.shader(',
	              shaderType[name], ',',
	              id, ',',
	              env.command, ');');
	          });
	          return id
	        })
	      }
	      return null
	    }

	    var frag = parseShader(S_FRAG);
	    var vert = parseShader(S_VERT);

	    var program = null;
	    var progVar;
	    if (isStatic(frag) && isStatic(vert)) {
	      program = shaderState.program(vert.id, frag.id, null, attribLocations);
	      progVar = createStaticDecl(function (env, scope) {
	        return env.link(program)
	      });
	    } else {
	      progVar = new Declaration(
	        (frag && frag.thisDep) || (vert && vert.thisDep),
	        (frag && frag.contextDep) || (vert && vert.contextDep),
	        (frag && frag.propDep) || (vert && vert.propDep),
	        function (env, scope) {
	          var SHADER_STATE = env.shared.shader;
	          var fragId;
	          if (frag) {
	            fragId = frag.append(env, scope);
	          } else {
	            fragId = scope.def(SHADER_STATE, '.', S_FRAG);
	          }
	          var vertId;
	          if (vert) {
	            vertId = vert.append(env, scope);
	          } else {
	            vertId = scope.def(SHADER_STATE, '.', S_VERT);
	          }
	          var progDef = SHADER_STATE + '.program(' + vertId + ',' + fragId;
	          check$1.optional(function () {
	            progDef += ',' + env.command;
	          });
	          return scope.def(progDef + ')')
	        });
	    }

	    return {
	      frag: frag,
	      vert: vert,
	      progVar: progVar,
	      program: program
	    }
	  }

	  function parseDraw (options, env) {
	    var staticOptions = options.static;
	    var dynamicOptions = options.dynamic;

	    // TODO: should use VAO to get default values for offset properties
	    // should move vao parse into here and out of the old stuff

	    var staticDraw = {};
	    var vaoActive = false;

	    function parseVAO () {
	      if (S_VAO in staticOptions) {
	        var vao = staticOptions[S_VAO];
	        if (vao !== null && attributeState.getVAO(vao) === null) {
	          vao = attributeState.createVAO(vao);
	        }

	        vaoActive = true;
	        staticDraw.vao = vao;

	        return createStaticDecl(function (env) {
	          var vaoRef = attributeState.getVAO(vao);
	          if (vaoRef) {
	            return env.link(vaoRef)
	          } else {
	            return 'null'
	          }
	        })
	      } else if (S_VAO in dynamicOptions) {
	        vaoActive = true;
	        var dyn = dynamicOptions[S_VAO];
	        return createDynamicDecl(dyn, function (env, scope) {
	          var vaoRef = env.invoke(scope, dyn);
	          return scope.def(env.shared.vao + '.getVAO(' + vaoRef + ')')
	        })
	      }
	      return null
	    }

	    var vao = parseVAO();

	    var elementsActive = false;

	    function parseElements () {
	      if (S_ELEMENTS in staticOptions) {
	        var elements = staticOptions[S_ELEMENTS];
	        staticDraw.elements = elements;
	        if (isBufferArgs(elements)) {
	          var e = staticDraw.elements = elementState.create(elements, true);
	          elements = elementState.getElements(e);
	          elementsActive = true;
	        } else if (elements) {
	          elements = elementState.getElements(elements);
	          elementsActive = true;
	          check$1.command(elements, 'invalid elements', env.commandStr);
	        }

	        var result = createStaticDecl(function (env, scope) {
	          if (elements) {
	            var result = env.link(elements);
	            env.ELEMENTS = result;
	            return result
	          }
	          env.ELEMENTS = null;
	          return null
	        });
	        result.value = elements;
	        return result
	      } else if (S_ELEMENTS in dynamicOptions) {
	        elementsActive = true;

	        var dyn = dynamicOptions[S_ELEMENTS];
	        return createDynamicDecl(dyn, function (env, scope) {
	          var shared = env.shared;

	          var IS_BUFFER_ARGS = shared.isBufferArgs;
	          var ELEMENT_STATE = shared.elements;

	          var elementDefn = env.invoke(scope, dyn);
	          var elements = scope.def('null');
	          var elementStream = scope.def(IS_BUFFER_ARGS, '(', elementDefn, ')');

	          var ifte = env.cond(elementStream)
	            .then(elements, '=', ELEMENT_STATE, '.createStream(', elementDefn, ');')
	            .else(elements, '=', ELEMENT_STATE, '.getElements(', elementDefn, ');');

	          check$1.optional(function () {
	            env.assert(ifte.else,
	              '!' + elementDefn + '||' + elements,
	              'invalid elements');
	          });

	          scope.entry(ifte);
	          scope.exit(
	            env.cond(elementStream)
	              .then(ELEMENT_STATE, '.destroyStream(', elements, ');'));

	          env.ELEMENTS = elements;

	          return elements
	        })
	      } else if (vaoActive) {
	        return new Declaration(
	          vao.thisDep,
	          vao.contextDep,
	          vao.propDep,
	          function (env, scope) {
	            return scope.def(env.shared.vao + '.currentVAO?' + env.shared.elements + '.getElements(' + env.shared.vao + '.currentVAO.elements):null')
	          })
	      }
	      return null
	    }

	    var elements = parseElements();

	    function parsePrimitive () {
	      if (S_PRIMITIVE in staticOptions) {
	        var primitive = staticOptions[S_PRIMITIVE];
	        staticDraw.primitive = primitive;
	        check$1.commandParameter(primitive, primTypes, 'invalid primitve', env.commandStr);
	        return createStaticDecl(function (env, scope) {
	          return primTypes[primitive]
	        })
	      } else if (S_PRIMITIVE in dynamicOptions) {
	        var dynPrimitive = dynamicOptions[S_PRIMITIVE];
	        return createDynamicDecl(dynPrimitive, function (env, scope) {
	          var PRIM_TYPES = env.constants.primTypes;
	          var prim = env.invoke(scope, dynPrimitive);
	          check$1.optional(function () {
	            env.assert(scope,
	              prim + ' in ' + PRIM_TYPES,
	              'invalid primitive, must be one of ' + Object.keys(primTypes));
	          });
	          return scope.def(PRIM_TYPES, '[', prim, ']')
	        })
	      } else if (elementsActive) {
	        if (isStatic(elements)) {
	          if (elements.value) {
	            return createStaticDecl(function (env, scope) {
	              return scope.def(env.ELEMENTS, '.primType')
	            })
	          } else {
	            return createStaticDecl(function () {
	              return GL_TRIANGLES$1
	            })
	          }
	        } else {
	          return new Declaration(
	            elements.thisDep,
	            elements.contextDep,
	            elements.propDep,
	            function (env, scope) {
	              var elements = env.ELEMENTS;
	              return scope.def(elements, '?', elements, '.primType:', GL_TRIANGLES$1)
	            })
	        }
	      } else if (vaoActive) {
	        return new Declaration(
	          vao.thisDep,
	          vao.contextDep,
	          vao.propDep,
	          function (env, scope) {
	            return scope.def(env.shared.vao + '.currentVAO?' + env.shared.vao + '.currentVAO.primitive:' + GL_TRIANGLES$1)
	          })
	      }
	      return null
	    }

	    function parseParam (param, isOffset) {
	      if (param in staticOptions) {
	        var value = staticOptions[param] | 0;
	        if (isOffset) {
	          staticDraw.offset = value;
	        } else {
	          staticDraw.instances = value;
	        }
	        check$1.command(!isOffset || value >= 0, 'invalid ' + param, env.commandStr);
	        return createStaticDecl(function (env, scope) {
	          if (isOffset) {
	            env.OFFSET = value;
	          }
	          return value
	        })
	      } else if (param in dynamicOptions) {
	        var dynValue = dynamicOptions[param];
	        return createDynamicDecl(dynValue, function (env, scope) {
	          var result = env.invoke(scope, dynValue);
	          if (isOffset) {
	            env.OFFSET = result;
	            check$1.optional(function () {
	              env.assert(scope,
	                result + '>=0',
	                'invalid ' + param);
	            });
	          }
	          return result
	        })
	      } else if (isOffset) {
	        if (elementsActive) {
	          return createStaticDecl(function (env, scope) {
	            env.OFFSET = 0;
	            return 0
	          })
	        } else if (vaoActive) {
	          return new Declaration(
	            vao.thisDep,
	            vao.contextDep,
	            vao.propDep,
	            function (env, scope) {
	              return scope.def(env.shared.vao + '.currentVAO?' + env.shared.vao + '.currentVAO.offset:0')
	            })
	        }
	      } else if (vaoActive) {
	        return new Declaration(
	          vao.thisDep,
	          vao.contextDep,
	          vao.propDep,
	          function (env, scope) {
	            return scope.def(env.shared.vao + '.currentVAO?' + env.shared.vao + '.currentVAO.instances:-1')
	          })
	      }
	      return null
	    }

	    var OFFSET = parseParam(S_OFFSET, true);

	    function parseVertCount () {
	      if (S_COUNT in staticOptions) {
	        var count = staticOptions[S_COUNT] | 0;
	        staticDraw.count = count;
	        check$1.command(
	          typeof count === 'number' && count >= 0, 'invalid vertex count', env.commandStr);
	        return createStaticDecl(function () {
	          return count
	        })
	      } else if (S_COUNT in dynamicOptions) {
	        var dynCount = dynamicOptions[S_COUNT];
	        return createDynamicDecl(dynCount, function (env, scope) {
	          var result = env.invoke(scope, dynCount);
	          check$1.optional(function () {
	            env.assert(scope,
	              'typeof ' + result + '==="number"&&' +
	              result + '>=0&&' +
	              result + '===(' + result + '|0)',
	              'invalid vertex count');
	          });
	          return result
	        })
	      } else if (elementsActive) {
	        if (isStatic(elements)) {
	          if (elements) {
	            if (OFFSET) {
	              return new Declaration(
	                OFFSET.thisDep,
	                OFFSET.contextDep,
	                OFFSET.propDep,
	                function (env, scope) {
	                  var result = scope.def(
	                    env.ELEMENTS, '.vertCount-', env.OFFSET);

	                  check$1.optional(function () {
	                    env.assert(scope,
	                      result + '>=0',
	                      'invalid vertex offset/element buffer too small');
	                  });

	                  return result
	                })
	            } else {
	              return createStaticDecl(function (env, scope) {
	                return scope.def(env.ELEMENTS, '.vertCount')
	              })
	            }
	          } else {
	            var result = createStaticDecl(function () {
	              return -1
	            });
	            check$1.optional(function () {
	              result.MISSING = true;
	            });
	            return result
	          }
	        } else {
	          var variable = new Declaration(
	            elements.thisDep || OFFSET.thisDep,
	            elements.contextDep || OFFSET.contextDep,
	            elements.propDep || OFFSET.propDep,
	            function (env, scope) {
	              var elements = env.ELEMENTS;
	              if (env.OFFSET) {
	                return scope.def(elements, '?', elements, '.vertCount-',
	                  env.OFFSET, ':-1')
	              }
	              return scope.def(elements, '?', elements, '.vertCount:-1')
	            });
	          check$1.optional(function () {
	            variable.DYNAMIC = true;
	          });
	          return variable
	        }
	      } else if (vaoActive) {
	        var countVariable = new Declaration(
	          vao.thisDep,
	          vao.contextDep,
	          vao.propDep,
	          function (env, scope) {
	            return scope.def(env.shared.vao, '.currentVAO?', env.shared.vao, '.currentVAO.count:-1')
	          });
	        return countVariable
	      }
	      return null
	    }

	    var primitive = parsePrimitive();
	    var count = parseVertCount();
	    var instances = parseParam(S_INSTANCES, false);

	    return {
	      elements: elements,
	      primitive: primitive,
	      count: count,
	      instances: instances,
	      offset: OFFSET,
	      vao: vao,

	      vaoActive: vaoActive,
	      elementsActive: elementsActive,

	      // static draw props
	      static: staticDraw
	    }
	  }

	  function parseGLState (options, env) {
	    var staticOptions = options.static;
	    var dynamicOptions = options.dynamic;

	    var STATE = {};

	    GL_STATE_NAMES.forEach(function (prop) {
	      var param = propName(prop);

	      function parseParam (parseStatic, parseDynamic) {
	        if (prop in staticOptions) {
	          var value = parseStatic(staticOptions[prop]);
	          STATE[param] = createStaticDecl(function () {
	            return value
	          });
	        } else if (prop in dynamicOptions) {
	          var dyn = dynamicOptions[prop];
	          STATE[param] = createDynamicDecl(dyn, function (env, scope) {
	            return parseDynamic(env, scope, env.invoke(scope, dyn))
	          });
	        }
	      }

	      switch (prop) {
	        case S_CULL_ENABLE:
	        case S_BLEND_ENABLE:
	        case S_DITHER:
	        case S_STENCIL_ENABLE:
	        case S_DEPTH_ENABLE:
	        case S_SCISSOR_ENABLE:
	        case S_POLYGON_OFFSET_ENABLE:
	        case S_SAMPLE_ALPHA:
	        case S_SAMPLE_ENABLE:
	        case S_DEPTH_MASK:
	          return parseParam(
	            function (value) {
	              check$1.commandType(value, 'boolean', prop, env.commandStr);
	              return value
	            },
	            function (env, scope, value) {
	              check$1.optional(function () {
	                env.assert(scope,
	                  'typeof ' + value + '==="boolean"',
	                  'invalid flag ' + prop, env.commandStr);
	              });
	              return value
	            })

	        case S_DEPTH_FUNC:
	          return parseParam(
	            function (value) {
	              check$1.commandParameter(value, compareFuncs, 'invalid ' + prop, env.commandStr);
	              return compareFuncs[value]
	            },
	            function (env, scope, value) {
	              var COMPARE_FUNCS = env.constants.compareFuncs;
	              check$1.optional(function () {
	                env.assert(scope,
	                  value + ' in ' + COMPARE_FUNCS,
	                  'invalid ' + prop + ', must be one of ' + Object.keys(compareFuncs));
	              });
	              return scope.def(COMPARE_FUNCS, '[', value, ']')
	            })

	        case S_DEPTH_RANGE:
	          return parseParam(
	            function (value) {
	              check$1.command(
	                isArrayLike(value) &&
	                value.length === 2 &&
	                typeof value[0] === 'number' &&
	                typeof value[1] === 'number' &&
	                value[0] <= value[1],
	                'depth range is 2d array',
	                env.commandStr);
	              return value
	            },
	            function (env, scope, value) {
	              check$1.optional(function () {
	                env.assert(scope,
	                  env.shared.isArrayLike + '(' + value + ')&&' +
	                  value + '.length===2&&' +
	                  'typeof ' + value + '[0]==="number"&&' +
	                  'typeof ' + value + '[1]==="number"&&' +
	                  value + '[0]<=' + value + '[1]',
	                  'depth range must be a 2d array');
	              });

	              var Z_NEAR = scope.def('+', value, '[0]');
	              var Z_FAR = scope.def('+', value, '[1]');
	              return [Z_NEAR, Z_FAR]
	            })

	        case S_BLEND_FUNC:
	          return parseParam(
	            function (value) {
	              check$1.commandType(value, 'object', 'blend.func', env.commandStr);
	              var srcRGB = ('srcRGB' in value ? value.srcRGB : value.src);
	              var srcAlpha = ('srcAlpha' in value ? value.srcAlpha : value.src);
	              var dstRGB = ('dstRGB' in value ? value.dstRGB : value.dst);
	              var dstAlpha = ('dstAlpha' in value ? value.dstAlpha : value.dst);
	              check$1.commandParameter(srcRGB, blendFuncs, param + '.srcRGB', env.commandStr);
	              check$1.commandParameter(srcAlpha, blendFuncs, param + '.srcAlpha', env.commandStr);
	              check$1.commandParameter(dstRGB, blendFuncs, param + '.dstRGB', env.commandStr);
	              check$1.commandParameter(dstAlpha, blendFuncs, param + '.dstAlpha', env.commandStr);

	              check$1.command(
	                (invalidBlendCombinations.indexOf(srcRGB + ', ' + dstRGB) === -1),
	                'unallowed blending combination (srcRGB, dstRGB) = (' + srcRGB + ', ' + dstRGB + ')', env.commandStr);

	              return [
	                blendFuncs[srcRGB],
	                blendFuncs[dstRGB],
	                blendFuncs[srcAlpha],
	                blendFuncs[dstAlpha]
	              ]
	            },
	            function (env, scope, value) {
	              var BLEND_FUNCS = env.constants.blendFuncs;

	              check$1.optional(function () {
	                env.assert(scope,
	                  value + '&&typeof ' + value + '==="object"',
	                  'invalid blend func, must be an object');
	              });

	              function read (prefix, suffix) {
	                var func = scope.def(
	                  '"', prefix, suffix, '" in ', value,
	                  '?', value, '.', prefix, suffix,
	                  ':', value, '.', prefix);

	                check$1.optional(function () {
	                  env.assert(scope,
	                    func + ' in ' + BLEND_FUNCS,
	                    'invalid ' + prop + '.' + prefix + suffix + ', must be one of ' + Object.keys(blendFuncs));
	                });

	                return func
	              }

	              var srcRGB = read('src', 'RGB');
	              var dstRGB = read('dst', 'RGB');

	              check$1.optional(function () {
	                var INVALID_BLEND_COMBINATIONS = env.constants.invalidBlendCombinations;

	                env.assert(scope,
	                  INVALID_BLEND_COMBINATIONS +
	                           '.indexOf(' + srcRGB + '+", "+' + dstRGB + ') === -1 ',
	                  'unallowed blending combination for (srcRGB, dstRGB)'
	                );
	              });

	              var SRC_RGB = scope.def(BLEND_FUNCS, '[', srcRGB, ']');
	              var SRC_ALPHA = scope.def(BLEND_FUNCS, '[', read('src', 'Alpha'), ']');
	              var DST_RGB = scope.def(BLEND_FUNCS, '[', dstRGB, ']');
	              var DST_ALPHA = scope.def(BLEND_FUNCS, '[', read('dst', 'Alpha'), ']');

	              return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA]
	            })

	        case S_BLEND_EQUATION:
	          return parseParam(
	            function (value) {
	              if (typeof value === 'string') {
	                check$1.commandParameter(value, blendEquations, 'invalid ' + prop, env.commandStr);
	                return [
	                  blendEquations[value],
	                  blendEquations[value]
	                ]
	              } else if (typeof value === 'object') {
	                check$1.commandParameter(
	                  value.rgb, blendEquations, prop + '.rgb', env.commandStr);
	                check$1.commandParameter(
	                  value.alpha, blendEquations, prop + '.alpha', env.commandStr);
	                return [
	                  blendEquations[value.rgb],
	                  blendEquations[value.alpha]
	                ]
	              } else {
	                check$1.commandRaise('invalid blend.equation', env.commandStr);
	              }
	            },
	            function (env, scope, value) {
	              var BLEND_EQUATIONS = env.constants.blendEquations;

	              var RGB = scope.def();
	              var ALPHA = scope.def();

	              var ifte = env.cond('typeof ', value, '==="string"');

	              check$1.optional(function () {
	                function checkProp (block, name, value) {
	                  env.assert(block,
	                    value + ' in ' + BLEND_EQUATIONS,
	                    'invalid ' + name + ', must be one of ' + Object.keys(blendEquations));
	                }
	                checkProp(ifte.then, prop, value);

	                env.assert(ifte.else,
	                  value + '&&typeof ' + value + '==="object"',
	                  'invalid ' + prop);
	                checkProp(ifte.else, prop + '.rgb', value + '.rgb');
	                checkProp(ifte.else, prop + '.alpha', value + '.alpha');
	              });

	              ifte.then(
	                RGB, '=', ALPHA, '=', BLEND_EQUATIONS, '[', value, '];');
	              ifte.else(
	                RGB, '=', BLEND_EQUATIONS, '[', value, '.rgb];',
	                ALPHA, '=', BLEND_EQUATIONS, '[', value, '.alpha];');

	              scope(ifte);

	              return [RGB, ALPHA]
	            })

	        case S_BLEND_COLOR:
	          return parseParam(
	            function (value) {
	              check$1.command(
	                isArrayLike(value) &&
	                value.length === 4,
	                'blend.color must be a 4d array', env.commandStr);
	              return loop(4, function (i) {
	                return +value[i]
	              })
	            },
	            function (env, scope, value) {
	              check$1.optional(function () {
	                env.assert(scope,
	                  env.shared.isArrayLike + '(' + value + ')&&' +
	                  value + '.length===4',
	                  'blend.color must be a 4d array');
	              });
	              return loop(4, function (i) {
	                return scope.def('+', value, '[', i, ']')
	              })
	            })

	        case S_STENCIL_MASK:
	          return parseParam(
	            function (value) {
	              check$1.commandType(value, 'number', param, env.commandStr);
	              return value | 0
	            },
	            function (env, scope, value) {
	              check$1.optional(function () {
	                env.assert(scope,
	                  'typeof ' + value + '==="number"',
	                  'invalid stencil.mask');
	              });
	              return scope.def(value, '|0')
	            })

	        case S_STENCIL_FUNC:
	          return parseParam(
	            function (value) {
	              check$1.commandType(value, 'object', param, env.commandStr);
	              var cmp = value.cmp || 'keep';
	              var ref = value.ref || 0;
	              var mask = 'mask' in value ? value.mask : -1;
	              check$1.commandParameter(cmp, compareFuncs, prop + '.cmp', env.commandStr);
	              check$1.commandType(ref, 'number', prop + '.ref', env.commandStr);
	              check$1.commandType(mask, 'number', prop + '.mask', env.commandStr);
	              return [
	                compareFuncs[cmp],
	                ref,
	                mask
	              ]
	            },
	            function (env, scope, value) {
	              var COMPARE_FUNCS = env.constants.compareFuncs;
	              check$1.optional(function () {
	                function assert () {
	                  env.assert(scope,
	                    Array.prototype.join.call(arguments, ''),
	                    'invalid stencil.func');
	                }
	                assert(value + '&&typeof ', value, '==="object"');
	                assert('!("cmp" in ', value, ')||(',
	                  value, '.cmp in ', COMPARE_FUNCS, ')');
	              });
	              var cmp = scope.def(
	                '"cmp" in ', value,
	                '?', COMPARE_FUNCS, '[', value, '.cmp]',
	                ':', GL_KEEP);
	              var ref = scope.def(value, '.ref|0');
	              var mask = scope.def(
	                '"mask" in ', value,
	                '?', value, '.mask|0:-1');
	              return [cmp, ref, mask]
	            })

	        case S_STENCIL_OPFRONT:
	        case S_STENCIL_OPBACK:
	          return parseParam(
	            function (value) {
	              check$1.commandType(value, 'object', param, env.commandStr);
	              var fail = value.fail || 'keep';
	              var zfail = value.zfail || 'keep';
	              var zpass = value.zpass || 'keep';
	              check$1.commandParameter(fail, stencilOps, prop + '.fail', env.commandStr);
	              check$1.commandParameter(zfail, stencilOps, prop + '.zfail', env.commandStr);
	              check$1.commandParameter(zpass, stencilOps, prop + '.zpass', env.commandStr);
	              return [
	                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
	                stencilOps[fail],
	                stencilOps[zfail],
	                stencilOps[zpass]
	              ]
	            },
	            function (env, scope, value) {
	              var STENCIL_OPS = env.constants.stencilOps;

	              check$1.optional(function () {
	                env.assert(scope,
	                  value + '&&typeof ' + value + '==="object"',
	                  'invalid ' + prop);
	              });

	              function read (name) {
	                check$1.optional(function () {
	                  env.assert(scope,
	                    '!("' + name + '" in ' + value + ')||' +
	                    '(' + value + '.' + name + ' in ' + STENCIL_OPS + ')',
	                    'invalid ' + prop + '.' + name + ', must be one of ' + Object.keys(stencilOps));
	                });

	                return scope.def(
	                  '"', name, '" in ', value,
	                  '?', STENCIL_OPS, '[', value, '.', name, ']:',
	                  GL_KEEP)
	              }

	              return [
	                prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
	                read('fail'),
	                read('zfail'),
	                read('zpass')
	              ]
	            })

	        case S_POLYGON_OFFSET_OFFSET:
	          return parseParam(
	            function (value) {
	              check$1.commandType(value, 'object', param, env.commandStr);
	              var factor = value.factor | 0;
	              var units = value.units | 0;
	              check$1.commandType(factor, 'number', param + '.factor', env.commandStr);
	              check$1.commandType(units, 'number', param + '.units', env.commandStr);
	              return [factor, units]
	            },
	            function (env, scope, value) {
	              check$1.optional(function () {
	                env.assert(scope,
	                  value + '&&typeof ' + value + '==="object"',
	                  'invalid ' + prop);
	              });

	              var FACTOR = scope.def(value, '.factor|0');
	              var UNITS = scope.def(value, '.units|0');

	              return [FACTOR, UNITS]
	            })

	        case S_CULL_FACE:
	          return parseParam(
	            function (value) {
	              var face = 0;
	              if (value === 'front') {
	                face = GL_FRONT;
	              } else if (value === 'back') {
	                face = GL_BACK;
	              }
	              check$1.command(!!face, param, env.commandStr);
	              return face
	            },
	            function (env, scope, value) {
	              check$1.optional(function () {
	                env.assert(scope,
	                  value + '==="front"||' +
	                  value + '==="back"',
	                  'invalid cull.face');
	              });
	              return scope.def(value, '==="front"?', GL_FRONT, ':', GL_BACK)
	            })

	        case S_LINE_WIDTH:
	          return parseParam(
	            function (value) {
	              check$1.command(
	                typeof value === 'number' &&
	                value >= limits.lineWidthDims[0] &&
	                value <= limits.lineWidthDims[1],
	                'invalid line width, must be a positive number between ' +
	                limits.lineWidthDims[0] + ' and ' + limits.lineWidthDims[1], env.commandStr);
	              return value
	            },
	            function (env, scope, value) {
	              check$1.optional(function () {
	                env.assert(scope,
	                  'typeof ' + value + '==="number"&&' +
	                  value + '>=' + limits.lineWidthDims[0] + '&&' +
	                  value + '<=' + limits.lineWidthDims[1],
	                  'invalid line width');
	              });

	              return value
	            })

	        case S_FRONT_FACE:
	          return parseParam(
	            function (value) {
	              check$1.commandParameter(value, orientationType, param, env.commandStr);
	              return orientationType[value]
	            },
	            function (env, scope, value) {
	              check$1.optional(function () {
	                env.assert(scope,
	                  value + '==="cw"||' +
	                  value + '==="ccw"',
	                  'invalid frontFace, must be one of cw,ccw');
	              });
	              return scope.def(value + '==="cw"?' + GL_CW + ':' + GL_CCW)
	            })

	        case S_COLOR_MASK:
	          return parseParam(
	            function (value) {
	              check$1.command(
	                isArrayLike(value) && value.length === 4,
	                'color.mask must be length 4 array', env.commandStr);
	              return value.map(function (v) { return !!v })
	            },
	            function (env, scope, value) {
	              check$1.optional(function () {
	                env.assert(scope,
	                  env.shared.isArrayLike + '(' + value + ')&&' +
	                  value + '.length===4',
	                  'invalid color.mask');
	              });
	              return loop(4, function (i) {
	                return '!!' + value + '[' + i + ']'
	              })
	            })

	        case S_SAMPLE_COVERAGE:
	          return parseParam(
	            function (value) {
	              check$1.command(typeof value === 'object' && value, param, env.commandStr);
	              var sampleValue = 'value' in value ? value.value : 1;
	              var sampleInvert = !!value.invert;
	              check$1.command(
	                typeof sampleValue === 'number' &&
	                sampleValue >= 0 && sampleValue <= 1,
	                'sample.coverage.value must be a number between 0 and 1', env.commandStr);
	              return [sampleValue, sampleInvert]
	            },
	            function (env, scope, value) {
	              check$1.optional(function () {
	                env.assert(scope,
	                  value + '&&typeof ' + value + '==="object"',
	                  'invalid sample.coverage');
	              });
	              var VALUE = scope.def(
	                '"value" in ', value, '?+', value, '.value:1');
	              var INVERT = scope.def('!!', value, '.invert');
	              return [VALUE, INVERT]
	            })
	      }
	    });

	    return STATE
	  }

	  function parseUniforms (uniforms, env) {
	    var staticUniforms = uniforms.static;
	    var dynamicUniforms = uniforms.dynamic;

	    var UNIFORMS = {};

	    Object.keys(staticUniforms).forEach(function (name) {
	      var value = staticUniforms[name];
	      var result;
	      if (typeof value === 'number' ||
	          typeof value === 'boolean') {
	        result = createStaticDecl(function () {
	          return value
	        });
	      } else if (typeof value === 'function') {
	        var reglType = value._reglType;
	        if (reglType === 'texture2d' ||
	            reglType === 'textureCube') {
	          result = createStaticDecl(function (env) {
	            return env.link(value)
	          });
	        } else if (reglType === 'framebuffer' ||
	                   reglType === 'framebufferCube') {
	          check$1.command(value.color.length > 0,
	            'missing color attachment for framebuffer sent to uniform "' + name + '"', env.commandStr);
	          result = createStaticDecl(function (env) {
	            return env.link(value.color[0])
	          });
	        } else {
	          check$1.commandRaise('invalid data for uniform "' + name + '"', env.commandStr);
	        }
	      } else if (isArrayLike(value)) {
	        result = createStaticDecl(function (env) {
	          var ITEM = env.global.def('[',
	            loop(value.length, function (i) {
	              check$1.command(
	                typeof value[i] === 'number' ||
	                typeof value[i] === 'boolean',
	                'invalid uniform ' + name, env.commandStr);
	              return value[i]
	            }), ']');
	          return ITEM
	        });
	      } else {
	        check$1.commandRaise('invalid or missing data for uniform "' + name + '"', env.commandStr);
	      }
	      result.value = value;
	      UNIFORMS[name] = result;
	    });

	    Object.keys(dynamicUniforms).forEach(function (key) {
	      var dyn = dynamicUniforms[key];
	      UNIFORMS[key] = createDynamicDecl(dyn, function (env, scope) {
	        return env.invoke(scope, dyn)
	      });
	    });

	    return UNIFORMS
	  }

	  function parseAttributes (attributes, env) {
	    var staticAttributes = attributes.static;
	    var dynamicAttributes = attributes.dynamic;

	    var attributeDefs = {};

	    Object.keys(staticAttributes).forEach(function (attribute) {
	      var value = staticAttributes[attribute];
	      var id = stringStore.id(attribute);

	      var record = new AttributeRecord();
	      if (isBufferArgs(value)) {
	        record.state = ATTRIB_STATE_POINTER;
	        record.buffer = bufferState.getBuffer(
	          bufferState.create(value, GL_ARRAY_BUFFER$2, false, true));
	        record.type = 0;
	      } else {
	        var buffer = bufferState.getBuffer(value);
	        if (buffer) {
	          record.state = ATTRIB_STATE_POINTER;
	          record.buffer = buffer;
	          record.type = 0;
	        } else {
	          check$1.command(typeof value === 'object' && value,
	            'invalid data for attribute ' + attribute, env.commandStr);
	          if ('constant' in value) {
	            var constant = value.constant;
	            record.buffer = 'null';
	            record.state = ATTRIB_STATE_CONSTANT;
	            if (typeof constant === 'number') {
	              record.x = constant;
	            } else {
	              check$1.command(
	                isArrayLike(constant) &&
	                constant.length > 0 &&
	                constant.length <= 4,
	                'invalid constant for attribute ' + attribute, env.commandStr);
	              CUTE_COMPONENTS.forEach(function (c, i) {
	                if (i < constant.length) {
	                  record[c] = constant[i];
	                }
	              });
	            }
	          } else {
	            if (isBufferArgs(value.buffer)) {
	              buffer = bufferState.getBuffer(
	                bufferState.create(value.buffer, GL_ARRAY_BUFFER$2, false, true));
	            } else {
	              buffer = bufferState.getBuffer(value.buffer);
	            }
	            check$1.command(!!buffer, 'missing buffer for attribute "' + attribute + '"', env.commandStr);

	            var offset = value.offset | 0;
	            check$1.command(offset >= 0,
	              'invalid offset for attribute "' + attribute + '"', env.commandStr);

	            var stride = value.stride | 0;
	            check$1.command(stride >= 0 && stride < 256,
	              'invalid stride for attribute "' + attribute + '", must be integer betweeen [0, 255]', env.commandStr);

	            var size = value.size | 0;
	            check$1.command(!('size' in value) || (size > 0 && size <= 4),
	              'invalid size for attribute "' + attribute + '", must be 1,2,3,4', env.commandStr);

	            var normalized = !!value.normalized;

	            var type = 0;
	            if ('type' in value) {
	              check$1.commandParameter(
	                value.type, glTypes,
	                'invalid type for attribute ' + attribute, env.commandStr);
	              type = glTypes[value.type];
	            }

	            var divisor = value.divisor | 0;
	            check$1.optional(function () {
	              if ('divisor' in value) {
	                check$1.command(divisor === 0 || extInstancing,
	                  'cannot specify divisor for attribute "' + attribute + '", instancing not supported', env.commandStr);
	                check$1.command(divisor >= 0,
	                  'invalid divisor for attribute "' + attribute + '"', env.commandStr);
	              }

	              var command = env.commandStr;

	              var VALID_KEYS = [
	                'buffer',
	                'offset',
	                'divisor',
	                'normalized',
	                'type',
	                'size',
	                'stride'
	              ];

	              Object.keys(value).forEach(function (prop) {
	                check$1.command(
	                  VALID_KEYS.indexOf(prop) >= 0,
	                  'unknown parameter "' + prop + '" for attribute pointer "' + attribute + '" (valid parameters are ' + VALID_KEYS + ')',
	                  command);
	              });
	            });

	            record.buffer = buffer;
	            record.state = ATTRIB_STATE_POINTER;
	            record.size = size;
	            record.normalized = normalized;
	            record.type = type || buffer.dtype;
	            record.offset = offset;
	            record.stride = stride;
	            record.divisor = divisor;
	          }
	        }
	      }

	      attributeDefs[attribute] = createStaticDecl(function (env, scope) {
	        var cache = env.attribCache;
	        if (id in cache) {
	          return cache[id]
	        }
	        var result = {
	          isStream: false
	        };
	        Object.keys(record).forEach(function (key) {
	          result[key] = record[key];
	        });
	        if (record.buffer) {
	          result.buffer = env.link(record.buffer);
	          result.type = result.type || (result.buffer + '.dtype');
	        }
	        cache[id] = result;
	        return result
	      });
	    });

	    Object.keys(dynamicAttributes).forEach(function (attribute) {
	      var dyn = dynamicAttributes[attribute];

	      function appendAttributeCode (env, block) {
	        var VALUE = env.invoke(block, dyn);

	        var shared = env.shared;
	        var constants = env.constants;

	        var IS_BUFFER_ARGS = shared.isBufferArgs;
	        var BUFFER_STATE = shared.buffer;

	        // Perform validation on attribute
	        check$1.optional(function () {
	          env.assert(block,
	            VALUE + '&&(typeof ' + VALUE + '==="object"||typeof ' +
	            VALUE + '==="function")&&(' +
	            IS_BUFFER_ARGS + '(' + VALUE + ')||' +
	            BUFFER_STATE + '.getBuffer(' + VALUE + ')||' +
	            BUFFER_STATE + '.getBuffer(' + VALUE + '.buffer)||' +
	            IS_BUFFER_ARGS + '(' + VALUE + '.buffer)||' +
	            '("constant" in ' + VALUE +
	            '&&(typeof ' + VALUE + '.constant==="number"||' +
	            shared.isArrayLike + '(' + VALUE + '.constant))))',
	            'invalid dynamic attribute "' + attribute + '"');
	        });

	        // allocate names for result
	        var result = {
	          isStream: block.def(false)
	        };
	        var defaultRecord = new AttributeRecord();
	        defaultRecord.state = ATTRIB_STATE_POINTER;
	        Object.keys(defaultRecord).forEach(function (key) {
	          result[key] = block.def('' + defaultRecord[key]);
	        });

	        var BUFFER = result.buffer;
	        var TYPE = result.type;
	        block(
	          'if(', IS_BUFFER_ARGS, '(', VALUE, ')){',
	          result.isStream, '=true;',
	          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, ');',
	          TYPE, '=', BUFFER, '.dtype;',
	          '}else{',
	          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, ');',
	          'if(', BUFFER, '){',
	          TYPE, '=', BUFFER, '.dtype;',
	          '}else if("constant" in ', VALUE, '){',
	          result.state, '=', ATTRIB_STATE_CONSTANT, ';',
	          'if(typeof ' + VALUE + '.constant === "number"){',
	          result[CUTE_COMPONENTS[0]], '=', VALUE, '.constant;',
	          CUTE_COMPONENTS.slice(1).map(function (n) {
	            return result[n]
	          }).join('='), '=0;',
	          '}else{',
	          CUTE_COMPONENTS.map(function (name, i) {
	            return (
	              result[name] + '=' + VALUE + '.constant.length>' + i +
	              '?' + VALUE + '.constant[' + i + ']:0;'
	            )
	          }).join(''),
	          '}}else{',
	          'if(', IS_BUFFER_ARGS, '(', VALUE, '.buffer)){',
	          BUFFER, '=', BUFFER_STATE, '.createStream(', GL_ARRAY_BUFFER$2, ',', VALUE, '.buffer);',
	          '}else{',
	          BUFFER, '=', BUFFER_STATE, '.getBuffer(', VALUE, '.buffer);',
	          '}',
	          TYPE, '="type" in ', VALUE, '?',
	          constants.glTypes, '[', VALUE, '.type]:', BUFFER, '.dtype;',
	          result.normalized, '=!!', VALUE, '.normalized;');
	        function emitReadRecord (name) {
	          block(result[name], '=', VALUE, '.', name, '|0;');
	        }
	        emitReadRecord('size');
	        emitReadRecord('offset');
	        emitReadRecord('stride');
	        emitReadRecord('divisor');

	        block('}}');

	        block.exit(
	          'if(', result.isStream, '){',
	          BUFFER_STATE, '.destroyStream(', BUFFER, ');',
	          '}');

	        return result
	      }

	      attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode);
	    });

	    return attributeDefs
	  }

	  function parseContext (context) {
	    var staticContext = context.static;
	    var dynamicContext = context.dynamic;
	    var result = {};

	    Object.keys(staticContext).forEach(function (name) {
	      var value = staticContext[name];
	      result[name] = createStaticDecl(function (env, scope) {
	        if (typeof value === 'number' || typeof value === 'boolean') {
	          return '' + value
	        } else {
	          return env.link(value)
	        }
	      });
	    });

	    Object.keys(dynamicContext).forEach(function (name) {
	      var dyn = dynamicContext[name];
	      result[name] = createDynamicDecl(dyn, function (env, scope) {
	        return env.invoke(scope, dyn)
	      });
	    });

	    return result
	  }

	  function parseArguments (options, attributes, uniforms, context, env) {
	    var staticOptions = options.static;
	    var dynamicOptions = options.dynamic;

	    check$1.optional(function () {
	      var KEY_NAMES = [
	        S_FRAMEBUFFER,
	        S_VERT,
	        S_FRAG,
	        S_ELEMENTS,
	        S_PRIMITIVE,
	        S_OFFSET,
	        S_COUNT,
	        S_INSTANCES,
	        S_PROFILE,
	        S_VAO
	      ].concat(GL_STATE_NAMES);

	      function checkKeys (dict) {
	        Object.keys(dict).forEach(function (key) {
	          check$1.command(
	            KEY_NAMES.indexOf(key) >= 0,
	            'unknown parameter "' + key + '"',
	            env.commandStr);
	        });
	      }

	      checkKeys(staticOptions);
	      checkKeys(dynamicOptions);
	    });

	    var attribLocations = parseAttribLocations(options, attributes);

	    var framebuffer = parseFramebuffer(options);
	    var viewportAndScissor = parseViewportScissor(options, framebuffer, env);
	    var draw = parseDraw(options, env);
	    var state = parseGLState(options, env);
	    var shader = parseProgram(options, env, attribLocations);

	    function copyBox (name) {
	      var defn = viewportAndScissor[name];
	      if (defn) {
	        state[name] = defn;
	      }
	    }
	    copyBox(S_VIEWPORT);
	    copyBox(propName(S_SCISSOR_BOX));

	    var dirty = Object.keys(state).length > 0;

	    var result = {
	      framebuffer: framebuffer,
	      draw: draw,
	      shader: shader,
	      state: state,
	      dirty: dirty,
	      scopeVAO: null,
	      drawVAO: null,
	      useVAO: false,
	      attributes: {}
	    };

	    result.profile = parseProfile(options);
	    result.uniforms = parseUniforms(uniforms, env);
	    result.drawVAO = result.scopeVAO = draw.vao;
	    // special case: check if we can statically allocate a vertex array object for this program
	    if (!result.drawVAO &&
	      shader.program &&
	      !attribLocations &&
	      extensions.angle_instanced_arrays &&
	      draw.static.elements) {
	      var useVAO = true;
	      var staticBindings = shader.program.attributes.map(function (attr) {
	        var binding = attributes.static[attr];
	        useVAO = useVAO && !!binding;
	        return binding
	      });
	      if (useVAO && staticBindings.length > 0) {
	        var vao = attributeState.getVAO(attributeState.createVAO({
	          attributes: staticBindings,
	          elements: draw.static.elements
	        }));
	        result.drawVAO = new Declaration(null, null, null, function (env, scope) {
	          return env.link(vao)
	        });
	        result.useVAO = true;
	      }
	    }
	    if (attribLocations) {
	      result.useVAO = true;
	    } else {
	      result.attributes = parseAttributes(attributes, env);
	    }
	    result.context = parseContext(context);
	    return result
	  }

	  // ===================================================
	  // ===================================================
	  // COMMON UPDATE FUNCTIONS
	  // ===================================================
	  // ===================================================
	  function emitContext (env, scope, context) {
	    var shared = env.shared;
	    var CONTEXT = shared.context;

	    var contextEnter = env.scope();

	    Object.keys(context).forEach(function (name) {
	      scope.save(CONTEXT, '.' + name);
	      var defn = context[name];
	      var value = defn.append(env, scope);
	      if (Array.isArray(value)) {
	        contextEnter(CONTEXT, '.', name, '=[', value.join(), '];');
	      } else {
	        contextEnter(CONTEXT, '.', name, '=', value, ';');
	      }
	    });

	    scope(contextEnter);
	  }

	  // ===================================================
	  // ===================================================
	  // COMMON DRAWING FUNCTIONS
	  // ===================================================
	  // ===================================================
	  function emitPollFramebuffer (env, scope, framebuffer, skipCheck) {
	    var shared = env.shared;

	    var GL = shared.gl;
	    var FRAMEBUFFER_STATE = shared.framebuffer;
	    var EXT_DRAW_BUFFERS;
	    if (extDrawBuffers) {
	      EXT_DRAW_BUFFERS = scope.def(shared.extensions, '.webgl_draw_buffers');
	    }

	    var constants = env.constants;

	    var DRAW_BUFFERS = constants.drawBuffer;
	    var BACK_BUFFER = constants.backBuffer;

	    var NEXT;
	    if (framebuffer) {
	      NEXT = framebuffer.append(env, scope);
	    } else {
	      NEXT = scope.def(FRAMEBUFFER_STATE, '.next');
	    }

	    if (!skipCheck) {
	      scope('if(', NEXT, '!==', FRAMEBUFFER_STATE, '.cur){');
	    }
	    scope(
	      'if(', NEXT, '){',
	      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',', NEXT, '.framebuffer);');
	    if (extDrawBuffers) {
	      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(',
	        DRAW_BUFFERS, '[', NEXT, '.colorAttachments.length]);');
	    }
	    scope('}else{',
	      GL, '.bindFramebuffer(', GL_FRAMEBUFFER$2, ',null);');
	    if (extDrawBuffers) {
	      scope(EXT_DRAW_BUFFERS, '.drawBuffersWEBGL(', BACK_BUFFER, ');');
	    }
	    scope(
	      '}',
	      FRAMEBUFFER_STATE, '.cur=', NEXT, ';');
	    if (!skipCheck) {
	      scope('}');
	    }
	  }

	  function emitPollState (env, scope, args) {
	    var shared = env.shared;

	    var GL = shared.gl;

	    var CURRENT_VARS = env.current;
	    var NEXT_VARS = env.next;
	    var CURRENT_STATE = shared.current;
	    var NEXT_STATE = shared.next;

	    var block = env.cond(CURRENT_STATE, '.dirty');

	    GL_STATE_NAMES.forEach(function (prop) {
	      var param = propName(prop);
	      if (param in args.state) {
	        return
	      }

	      var NEXT, CURRENT;
	      if (param in NEXT_VARS) {
	        NEXT = NEXT_VARS[param];
	        CURRENT = CURRENT_VARS[param];
	        var parts = loop(currentState[param].length, function (i) {
	          return block.def(NEXT, '[', i, ']')
	        });
	        block(env.cond(parts.map(function (p, i) {
	          return p + '!==' + CURRENT + '[' + i + ']'
	        }).join('||'))
	          .then(
	            GL, '.', GL_VARIABLES[param], '(', parts, ');',
	            parts.map(function (p, i) {
	              return CURRENT + '[' + i + ']=' + p
	            }).join(';'), ';'));
	      } else {
	        NEXT = block.def(NEXT_STATE, '.', param);
	        var ifte = env.cond(NEXT, '!==', CURRENT_STATE, '.', param);
	        block(ifte);
	        if (param in GL_FLAGS) {
	          ifte(
	            env.cond(NEXT)
	              .then(GL, '.enable(', GL_FLAGS[param], ');')
	              .else(GL, '.disable(', GL_FLAGS[param], ');'),
	            CURRENT_STATE, '.', param, '=', NEXT, ';');
	        } else {
	          ifte(
	            GL, '.', GL_VARIABLES[param], '(', NEXT, ');',
	            CURRENT_STATE, '.', param, '=', NEXT, ';');
	        }
	      }
	    });
	    if (Object.keys(args.state).length === 0) {
	      block(CURRENT_STATE, '.dirty=false;');
	    }
	    scope(block);
	  }

	  function emitSetOptions (env, scope, options, filter) {
	    var shared = env.shared;
	    var CURRENT_VARS = env.current;
	    var CURRENT_STATE = shared.current;
	    var GL = shared.gl;
	    sortState(Object.keys(options)).forEach(function (param) {
	      var defn = options[param];
	      if (filter && !filter(defn)) {
	        return
	      }
	      var variable = defn.append(env, scope);
	      if (GL_FLAGS[param]) {
	        var flag = GL_FLAGS[param];
	        if (isStatic(defn)) {
	          if (variable) {
	            scope(GL, '.enable(', flag, ');');
	          } else {
	            scope(GL, '.disable(', flag, ');');
	          }
	        } else {
	          scope(env.cond(variable)
	            .then(GL, '.enable(', flag, ');')
	            .else(GL, '.disable(', flag, ');'));
	        }
	        scope(CURRENT_STATE, '.', param, '=', variable, ';');
	      } else if (isArrayLike(variable)) {
	        var CURRENT = CURRENT_VARS[param];
	        scope(
	          GL, '.', GL_VARIABLES[param], '(', variable, ');',
	          variable.map(function (v, i) {
	            return CURRENT + '[' + i + ']=' + v
	          }).join(';'), ';');
	      } else {
	        scope(
	          GL, '.', GL_VARIABLES[param], '(', variable, ');',
	          CURRENT_STATE, '.', param, '=', variable, ';');
	      }
	    });
	  }

	  function injectExtensions (env, scope) {
	    if (extInstancing) {
	      env.instancing = scope.def(
	        env.shared.extensions, '.angle_instanced_arrays');
	    }
	  }

	  function emitProfile (env, scope, args, useScope, incrementCounter) {
	    var shared = env.shared;
	    var STATS = env.stats;
	    var CURRENT_STATE = shared.current;
	    var TIMER = shared.timer;
	    var profileArg = args.profile;

	    function perfCounter () {
	      if (typeof performance === 'undefined') {
	        return 'Date.now()'
	      } else {
	        return 'performance.now()'
	      }
	    }

	    var CPU_START, QUERY_COUNTER;
	    function emitProfileStart (block) {
	      CPU_START = scope.def();
	      block(CPU_START, '=', perfCounter(), ';');
	      if (typeof incrementCounter === 'string') {
	        block(STATS, '.count+=', incrementCounter, ';');
	      } else {
	        block(STATS, '.count++;');
	      }
	      if (timer) {
	        if (useScope) {
	          QUERY_COUNTER = scope.def();
	          block(QUERY_COUNTER, '=', TIMER, '.getNumPendingQueries();');
	        } else {
	          block(TIMER, '.beginQuery(', STATS, ');');
	        }
	      }
	    }

	    function emitProfileEnd (block) {
	      block(STATS, '.cpuTime+=', perfCounter(), '-', CPU_START, ';');
	      if (timer) {
	        if (useScope) {
	          block(TIMER, '.pushScopeStats(',
	            QUERY_COUNTER, ',',
	            TIMER, '.getNumPendingQueries(),',
	            STATS, ');');
	        } else {
	          block(TIMER, '.endQuery();');
	        }
	      }
	    }

	    function scopeProfile (value) {
	      var prev = scope.def(CURRENT_STATE, '.profile');
	      scope(CURRENT_STATE, '.profile=', value, ';');
	      scope.exit(CURRENT_STATE, '.profile=', prev, ';');
	    }

	    var USE_PROFILE;
	    if (profileArg) {
	      if (isStatic(profileArg)) {
	        if (profileArg.enable) {
	          emitProfileStart(scope);
	          emitProfileEnd(scope.exit);
	          scopeProfile('true');
	        } else {
	          scopeProfile('false');
	        }
	        return
	      }
	      USE_PROFILE = profileArg.append(env, scope);
	      scopeProfile(USE_PROFILE);
	    } else {
	      USE_PROFILE = scope.def(CURRENT_STATE, '.profile');
	    }

	    var start = env.block();
	    emitProfileStart(start);
	    scope('if(', USE_PROFILE, '){', start, '}');
	    var end = env.block();
	    emitProfileEnd(end);
	    scope.exit('if(', USE_PROFILE, '){', end, '}');
	  }

	  function emitAttributes (env, scope, args, attributes, filter) {
	    var shared = env.shared;

	    function typeLength (x) {
	      switch (x) {
	        case GL_FLOAT_VEC2:
	        case GL_INT_VEC2:
	        case GL_BOOL_VEC2:
	          return 2
	        case GL_FLOAT_VEC3:
	        case GL_INT_VEC3:
	        case GL_BOOL_VEC3:
	          return 3
	        case GL_FLOAT_VEC4:
	        case GL_INT_VEC4:
	        case GL_BOOL_VEC4:
	          return 4
	        default:
	          return 1
	      }
	    }

	    function emitBindAttribute (ATTRIBUTE, size, record) {
	      var GL = shared.gl;

	      var LOCATION = scope.def(ATTRIBUTE, '.location');
	      var BINDING = scope.def(shared.attributes, '[', LOCATION, ']');

	      var STATE = record.state;
	      var BUFFER = record.buffer;
	      var CONST_COMPONENTS = [
	        record.x,
	        record.y,
	        record.z,
	        record.w
	      ];

	      var COMMON_KEYS = [
	        'buffer',
	        'normalized',
	        'offset',
	        'stride'
	      ];

	      // 因为regl自己全局状态可能和fusiongl产生冲突
	      // 所以去掉了以下逻辑中，与states的比较，每次都调用enableVertexAttribArray，bindBuffer和vertexAttribPointer
	      function emitBuffer () {
	        scope(
	          // 'if(!', BINDING, '.buffer){',
	          GL, '.enableVertexAttribArray(', LOCATION, ');');

	        var TYPE = record.type;
	        var SIZE;
	        if (!record.size) {
	          SIZE = size;
	        } else {
	          SIZE = scope.def(record.size, '||', size);
	        }

	        scope(/*'if(',
	          BINDING, '.type!==', TYPE, '||',
	          BINDING, '.size!==', SIZE, '||',
	          COMMON_KEYS.map(function (key) {
	            return BINDING + '.' + key + '!==' + record[key]
	          }).join('||'),
	          '){',*/
	          GL, '.bindBuffer(', GL_ARRAY_BUFFER$2, ',', BUFFER, '.buffer);',
	          GL, '.vertexAttribPointer(', [
	            LOCATION,
	            SIZE,
	            TYPE,
	            record.normalized,
	            record.stride,
	            record.offset
	          ], ');',
	          BINDING, '.type=', TYPE, ';',
	          BINDING, '.size=', SIZE, ';',
	          COMMON_KEYS.map(function (key) {
	            return BINDING + '.' + key + '=' + record[key] + ';'
	          }).join('')/*,
	          '}'*/);

	        if (extInstancing) {
	          var DIVISOR = record.divisor;
	          scope(
	            'if(', BINDING, '.divisor!==', DIVISOR, '){',
	            env.instancing, '.vertexAttribDivisorANGLE(', [LOCATION, DIVISOR], ');',
	            BINDING, '.divisor=', DIVISOR, ';}');
	        }
	      }

	      function emitConstant () {
	        scope(
	          'if(', BINDING, '.buffer){',
	          GL, '.disableVertexAttribArray(', LOCATION, ');',
	          BINDING, '.buffer=null;',
	          '}if(', CUTE_COMPONENTS.map(function (c, i) {
	            return BINDING + '.' + c + '!==' + CONST_COMPONENTS[i]
	          }).join('||'), '){',
	          GL, '.vertexAttrib4f(', LOCATION, ',', CONST_COMPONENTS, ');',
	          CUTE_COMPONENTS.map(function (c, i) {
	            return BINDING + '.' + c + '=' + CONST_COMPONENTS[i] + ';'
	          }).join(''),
	          '}');
	      }

	      if (STATE === ATTRIB_STATE_POINTER) {
	        emitBuffer();
	      } else if (STATE === ATTRIB_STATE_CONSTANT) {
	        emitConstant();
	      } else {
	        scope('if(', STATE, '===', ATTRIB_STATE_POINTER, '){');
	        emitBuffer();
	        scope('}else{');
	        emitConstant();
	        scope('}');
	      }
	    }

	    attributes.forEach(function (attribute) {
	      var name = attribute.name;
	      var arg = args.attributes[name];
	      var record;
	      if (arg) {
	        if (!filter(arg)) {
	          return
	        }
	        record = arg.append(env, scope);
	      } else {
	        if (!filter(SCOPE_DECL)) {
	          return
	        }
	        var scopeAttrib = env.scopeAttrib(name);
	        check$1.optional(function () {
	          env.assert(scope,
	            scopeAttrib + '.state',
	            'missing attribute ' + name);
	        });
	        record = {};
	        Object.keys(new AttributeRecord()).forEach(function (key) {
	          record[key] = scope.def(scopeAttrib, '.', key);
	        });
	      }
	      emitBindAttribute(
	        env.link(attribute), typeLength(attribute.info.type), record);
	    });
	  }

	  function emitUniforms (env, scope, args, uniforms, filter, isBatchInnerLoop) {
	    var shared = env.shared;
	    var GL = shared.gl;

	    var definedArrUniforms = {};
	    var infix;
	    for (var i = 0; i < uniforms.length; ++i) {
	      var uniform = uniforms[i];
	      var name = uniform.name;
	      var type = uniform.info.type;
	      var size = uniform.info.size;
	      var arg = args.uniforms[name];
	      if (size > 1) {
	        // either foo[n] or foos, avoid define both
	        if (!arg) {
	          continue
	        }
	        var arrUniformName = name.replace('[0]', '');
	        if (definedArrUniforms[arrUniformName]) {
	          continue
	        }
	        definedArrUniforms[arrUniformName] = 1;
	      }
	      var UNIFORM = env.link(uniform);
	      var LOCATION = UNIFORM + '.location';

	      var VALUE;
	      if (arg) {
	        if (!filter(arg)) {
	          continue
	        }
	        if (isStatic(arg)) {
	          var value = arg.value;
	          check$1.command(
	            value !== null && typeof value !== 'undefined',
	            'missing uniform "' + name + '"', env.commandStr);
	          if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
	            check$1.command(
	              typeof value === 'function' &&
	              ((type === GL_SAMPLER_2D &&
	                (value._reglType === 'texture2d' ||
	                value._reglType === 'framebuffer')) ||
	              (type === GL_SAMPLER_CUBE &&
	                (value._reglType === 'textureCube' ||
	                value._reglType === 'framebufferCube'))),
	              'invalid texture for uniform ' + name, env.commandStr);
	            var TEX_VALUE = env.link(value._texture || value.color[0]._texture);
	            scope(GL, '.uniform1i(', LOCATION, ',', TEX_VALUE + '.bind());');
	            scope.exit(TEX_VALUE, '.unbind();');
	          } else if (
	            type === GL_FLOAT_MAT2 ||
	            type === GL_FLOAT_MAT3 ||
	            type === GL_FLOAT_MAT4) {
	            check$1.optional(function () {
	              check$1.command(isArrayLike(value),
	                'invalid matrix for uniform ' + name, env.commandStr);
	              check$1.command(
	                (type === GL_FLOAT_MAT2 && value.length === 4) ||
	                (type === GL_FLOAT_MAT3 && value.length === 9) ||
	                (type === GL_FLOAT_MAT4 && value.length === 16),
	                'invalid length for matrix uniform ' + name, env.commandStr);
	            });
	            var MAT_VALUE = env.global.def('new Float32Array([' +
	              Array.prototype.slice.call(value) + '])');
	            var dim = 2;
	            if (type === GL_FLOAT_MAT3) {
	              dim = 3;
	            } else if (type === GL_FLOAT_MAT4) {
	              dim = 4;
	            }
	            scope(
	              GL, '.uniformMatrix', dim, 'fv(',
	              LOCATION, ',false,', MAT_VALUE, ');');
	          } else {
	            switch (type) {
	              case GL_FLOAT$8:
	                if (size === 1) {
	                  check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr);
	                } else {
	                  check$1.command(
	                    isArrayLike(value) && (value.length === size),
	                    'uniform ' + name, env.commandStr);
	                }
	                infix = '1f';
	                break
	              case GL_FLOAT_VEC2:
	                check$1.command(
	                  isArrayLike(value) && (value.length && value.length % 2 === 0 && value.length <= size * 2),
	                  'uniform ' + name, env.commandStr);
	                infix = '2f';
	                break
	              case GL_FLOAT_VEC3:
	                check$1.command(
	                  isArrayLike(value) && (value.length && value.length % 3 === 0 && value.length <= size * 3),
	                  'uniform ' + name, env.commandStr);
	                infix = '3f';
	                break
	              case GL_FLOAT_VEC4:
	                check$1.command(
	                  isArrayLike(value) && (value.length && value.length % 4 === 0 && value.length <= size * 4),
	                  'uniform ' + name, env.commandStr);
	                infix = '4f';
	                break
	              case GL_BOOL:
	                if (size === 1) {
	                  check$1.commandType(value, 'boolean', 'uniform ' + name, env.commandStr);
	                } else {
	                  check$1.command(
	                    isArrayLike(value) && (value.length === size),
	                    'uniform ' + name, env.commandStr);
	                }
	                infix = '1i';
	                break
	              case GL_INT$3:
	                if (size === 1) {
	                  check$1.commandType(value, 'number', 'uniform ' + name, env.commandStr);
	                } else {
	                  check$1.command(
	                    isArrayLike(value) && (value.length === size),
	                    'uniform ' + name, env.commandStr);
	                }
	                infix = '1i';
	                break
	              case GL_BOOL_VEC2:
	                check$1.command(
	                  isArrayLike(value) && (value.length && value.length % 2 === 0 && value.length <= size * 2),
	                  'uniform ' + name, env.commandStr);
	                infix = '2i';
	                break
	              case GL_INT_VEC2:
	                check$1.command(
	                  isArrayLike(value) && (value.length && value.length % 2 === 0 && value.length <= size * 2),
	                  'uniform ' + name, env.commandStr);
	                infix = '2i';
	                break
	              case GL_BOOL_VEC3:
	                check$1.command(
	                  isArrayLike(value) && (value.length && value.length % 3 === 0 && value.length <= size * 3),
	                  'uniform ' + name, env.commandStr);
	                infix = '3i';
	                break
	              case GL_INT_VEC3:
	                check$1.command(
	                  isArrayLike(value) && (value.length && value.length % 3 === 0 && value.length <= size * 3),
	                  'uniform ' + name, env.commandStr);
	                infix = '3i';
	                break
	              case GL_BOOL_VEC4:
	                check$1.command(
	                  isArrayLike(value) && (value.length && value.length % 4 === 0 && value.length <= size * 4),
	                  'uniform ' + name, env.commandStr);
	                infix = '4i';
	                break
	              case GL_INT_VEC4:
	                check$1.command(
	                  isArrayLike(value) && (value.length && value.length % 4 === 0 && value.length <= size * 4),
	                  'uniform ' + name, env.commandStr);
	                infix = '4i';
	                break
	            }
	            if (size > 1) {
	              infix += 'v';
	              value = env.global.def('[' +
	              Array.prototype.slice.call(value) + ']');
	            } else {
	              value = isArrayLike(value) ? Array.prototype.slice.call(value) : value;
	            }
	            scope(GL, '.uniform', infix, '(', LOCATION, ',',
	              value,
	              ');');
	          }
	          continue
	        } else {
	          VALUE = arg.append(env, scope);
	        }
	      } else {
	        if (!filter(SCOPE_DECL)) {
	          continue
	        }
	        VALUE = scope.def(shared.uniforms, '[', stringStore.id(name), ']');
	      }

	      if (type === GL_SAMPLER_2D) {
	        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for textures');
	        scope(
	          'if(', VALUE, '&&', VALUE, '._reglType==="framebuffer"){',
	          VALUE, '=', VALUE, '.color[0];',
	          '}');
	      } else if (type === GL_SAMPLER_CUBE) {
	        check$1(!Array.isArray(VALUE), 'must specify a scalar prop for cube maps');
	        scope(
	          'if(', VALUE, '&&', VALUE, '._reglType==="framebufferCube"){',
	          VALUE, '=', VALUE, '.color[0];',
	          '}');
	      }

	      // perform type validation
	      check$1.optional(function () {
	        function emitCheck (pred, message) {
	          env.assert(scope, pred,
	            'bad data or missing for uniform "' + name + '".  ' + message);
	        }

	        function checkType (type, size) {
	          if (size === 1) {
	            check$1(!Array.isArray(VALUE), 'must not specify an array type for uniform');
	          }
	          emitCheck(
	            'Array.isArray(' + VALUE + ') && typeof ' + VALUE + '[0]===" ' + type + '"' +
	            ' || typeof ' + VALUE + '==="' + type + '"',
	            'invalid type, expected ' + type);
	        }

	        function checkVector (n, type, size) {
	          if (Array.isArray(VALUE)) {
	            check$1(VALUE.length && VALUE.length % n === 0 && VALUE.length <= n * size, 'must have length of ' + (size === 1 ? '' : 'n * ') + n);
	          } else {
	            emitCheck(
	              shared.isArrayLike + '(' + VALUE + ')&&' + VALUE + '.length && ' + VALUE + '.length % ' + n + ' === 0' +
	              ' && ' + VALUE + '.length<=' + n * size,
	              'invalid vector, should have length of ' + (size === 1 ? '' : 'n * ') + n, env.commandStr);
	          }
	        }

	        function checkTexture (target) {
	          check$1(!Array.isArray(VALUE), 'must not specify a value type');
	          emitCheck(
	            'typeof ' + VALUE + '==="function"&&' +
	            VALUE + '._reglType==="texture' +
	            (target === GL_TEXTURE_2D$3 ? '2d' : 'Cube') + '"',
	            'invalid texture type', env.commandStr);
	        }

	        switch (type) {
	          case GL_INT$3:
	            checkType('number', size);
	            break
	          case GL_INT_VEC2:
	            checkVector(2, 'number', size);
	            break
	          case GL_INT_VEC3:
	            checkVector(3, 'number', size);
	            break
	          case GL_INT_VEC4:
	            checkVector(4, 'number', size);
	            break
	          case GL_FLOAT$8:
	            checkType('number', size);
	            break
	          case GL_FLOAT_VEC2:
	            checkVector(2, 'number', size);
	            break
	          case GL_FLOAT_VEC3:
	            checkVector(3, 'number', size);
	            break
	          case GL_FLOAT_VEC4:
	            checkVector(4, 'number', size);
	            break
	          case GL_BOOL:
	            checkType('boolean', size);
	            break
	          case GL_BOOL_VEC2:
	            checkVector(2, 'boolean', size);
	            break
	          case GL_BOOL_VEC3:
	            checkVector(3, 'boolean', size);
	            break
	          case GL_BOOL_VEC4:
	            checkVector(4, 'boolean', size);
	            break
	          case GL_FLOAT_MAT2:
	            checkVector(4, 'number', size);
	            break
	          case GL_FLOAT_MAT3:
	            checkVector(9, 'number', size);
	            break
	          case GL_FLOAT_MAT4:
	            checkVector(16, 'number', size);
	            break
	          case GL_SAMPLER_2D:
	            checkTexture(GL_TEXTURE_2D$3);
	            break
	          case GL_SAMPLER_CUBE:
	            checkTexture(GL_TEXTURE_CUBE_MAP$2);
	            break
	        }
	      });

	      var unroll = 1;
	      switch (type) {
	        case GL_SAMPLER_2D:
	        case GL_SAMPLER_CUBE:
	          var TEX = scope.def(VALUE, '._texture');
	          scope(GL, '.uniform1i(', LOCATION, ',', TEX, '.bind());');
	          scope.exit(TEX, '.unbind();');
	          continue

	        case GL_INT$3:
	        case GL_BOOL:
	          infix = '1i';
	          break

	        case GL_INT_VEC2:
	        case GL_BOOL_VEC2:
	          infix = '2i';
	          unroll = 2;
	          break

	        case GL_INT_VEC3:
	        case GL_BOOL_VEC3:
	          infix = '3i';
	          unroll = 3;
	          break

	        case GL_INT_VEC4:
	        case GL_BOOL_VEC4:
	          infix = '4i';
	          unroll = 4;
	          break

	        case GL_FLOAT$8:
	          infix = '1f';
	          break

	        case GL_FLOAT_VEC2:
	          infix = '2f';
	          unroll = 2;
	          break

	        case GL_FLOAT_VEC3:
	          infix = '3f';
	          unroll = 3;
	          break

	        case GL_FLOAT_VEC4:
	          infix = '4f';
	          unroll = 4;
	          break

	        case GL_FLOAT_MAT2:
	          infix = 'Matrix2fv';
	          break

	        case GL_FLOAT_MAT3:
	          infix = 'Matrix3fv';
	          break

	        case GL_FLOAT_MAT4:
	          infix = 'Matrix4fv';
	          break
	      }

	      if (infix.indexOf('Matrix') === -1 && size > 1) {
	        infix += 'v';
	        unroll = 1;
	      }

	      if (infix.charAt(0) === 'M') {
	        scope(GL, '.uniform', infix, '(', LOCATION, ',');
	        var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2);
	        var STORAGE = env.global.def('new Float32Array(', matSize, ')');
	        if (Array.isArray(VALUE)) {
	          scope(
	            'false,(',
	            loop(matSize, function (i) {
	              return STORAGE + '[' + i + ']=' + VALUE[i]
	            }), ',', STORAGE, ')');
	        } else {
	          scope(
	            'false,(Array.isArray(', VALUE, ')||', VALUE, ' instanceof Float32Array)?', VALUE, ':(',
	            loop(matSize, function (i) {
	              return STORAGE + '[' + i + ']=' + VALUE + '[' + i + ']'
	            }), ',', STORAGE, ')');
	        }
	        scope(');');
	      } else if (unroll > 1) {
	        var prev = [];
	        var cur = [];
	        for (var j = 0; j < unroll; ++j) {
	          if (Array.isArray(VALUE)) {
	            cur.push(VALUE[j]);
	          } else {
	            cur.push(scope.def(VALUE + '[' + j + ']'));
	          }
	          if (isBatchInnerLoop) {
	            prev.push(scope.def());
	          }
	        }
	        if (isBatchInnerLoop) {
	          scope('if(!', env.batchId, '||', prev.map(function (p, i) {
	            return p + '!==' + cur[i]
	          }).join('||'), '){', prev.map(function (p, i) {
	            return p + '=' + cur[i] + ';'
	          }).join(''));
	        }
	        scope(GL, '.uniform', infix, '(', LOCATION, ',', cur.join(','), ');');
	        if (isBatchInnerLoop) {
	          scope('}');
	        }
	      } else {
	        check$1(!Array.isArray(VALUE), 'uniform value must not be an array');
	        if (isBatchInnerLoop) {
	          var prevS = scope.def();
	          scope('if(!', env.batchId, '||', prevS, '!==', VALUE, '){',
	            prevS, '=', VALUE, ';');
	        }
	        scope(GL, '.uniform', infix, '(', LOCATION, ',', VALUE, ');');
	        if (isBatchInnerLoop) {
	          scope('}');
	        }
	      }
	    }
	  }

	  function emitDraw (env, outer, inner, args) {
	    var shared = env.shared;
	    var GL = shared.gl;
	    var DRAW_STATE = shared.draw;

	    var drawOptions = args.draw;

	    function emitElements () {
	      var defn = drawOptions.elements;
	      var ELEMENTS;
	      var scope = outer;
	      if (defn) {
	        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
	          scope = inner;
	        }
	        ELEMENTS = defn.append(env, scope);
	        if (drawOptions.elementsActive) {
	          scope(
	            'if(' + ELEMENTS + ')' +
	            GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$2 + ',' + ELEMENTS + '.buffer.buffer);');
	        }
	      } else {
	        ELEMENTS = scope.def();
	        scope(
	          ELEMENTS, '=', DRAW_STATE, '.', S_ELEMENTS, ';',
	          'if(', ELEMENTS, '){',
	          GL, '.bindBuffer(', GL_ELEMENT_ARRAY_BUFFER$2, ',', ELEMENTS, '.buffer.buffer);}',
	          'else if(', shared.vao, '.currentVAO){',
	          ELEMENTS, '=', env.shared.elements + '.getElements(' + shared.vao, '.currentVAO.elements);',
	          (!extVertexArrays ? 'if(' + ELEMENTS + ')' + GL + '.bindBuffer(' + GL_ELEMENT_ARRAY_BUFFER$2 + ',' + ELEMENTS + '.buffer.buffer);' : ''),
	          '}');
	      }
	      return ELEMENTS
	    }

	    function emitCount () {
	      var defn = drawOptions.count;
	      var COUNT;
	      var scope = outer;
	      if (defn) {
	        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
	          scope = inner;
	        }
	        COUNT = defn.append(env, scope);
	        check$1.optional(function () {
	          if (defn.MISSING) {
	            env.assert(outer, 'false', 'missing vertex count');
	          }
	          if (defn.DYNAMIC) {
	            env.assert(scope, COUNT + '>=0', 'missing vertex count');
	          }
	        });
	      } else {
	        COUNT = scope.def(DRAW_STATE, '.', S_COUNT);
	        check$1.optional(function () {
	          env.assert(scope, COUNT + '>=0', 'missing vertex count');
	        });
	      }
	      return COUNT
	    }

	    var ELEMENTS = emitElements();
	    function emitValue (name) {
	      var defn = drawOptions[name];
	      if (defn) {
	        if ((defn.contextDep && args.contextDynamic) || defn.propDep) {
	          return defn.append(env, inner)
	        } else {
	          return defn.append(env, outer)
	        }
	      } else {
	        return outer.def(DRAW_STATE, '.', name)
	      }
	    }

	    var PRIMITIVE = emitValue(S_PRIMITIVE);
	    var OFFSET = emitValue(S_OFFSET);

	    var COUNT = emitCount();
	    if (typeof COUNT === 'number') {
	      if (COUNT === 0) {
	        return
	      }
	    } else {
	      inner('if(', COUNT, '){');
	      inner.exit('}');
	    }

	    var INSTANCES, EXT_INSTANCING;
	    if (extInstancing) {
	      INSTANCES = emitValue(S_INSTANCES);
	      EXT_INSTANCING = env.instancing;
	    }

	    var ELEMENT_TYPE = ELEMENTS + '.type';

	    var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements) && !drawOptions.vaoActive;

	    function emitInstancing () {
	      function drawElements () {
	        inner(EXT_INSTANCING, '.drawElementsInstancedANGLE(', [
	          PRIMITIVE,
	          COUNT,
	          ELEMENT_TYPE,
	          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)',
	          INSTANCES
	        ], ');');
	      }

	      function drawArrays () {
	        inner(EXT_INSTANCING, '.drawArraysInstancedANGLE(',
	          [PRIMITIVE, OFFSET, COUNT, INSTANCES], ');');
	      }

	      if (ELEMENTS && ELEMENTS !== 'null') {
	        if (!elementsStatic) {
	          inner('if(', ELEMENTS, '){');
	          drawElements();
	          inner('}else{');
	          drawArrays();
	          inner('}');
	        } else {
	          drawElements();
	        }
	      } else {
	        drawArrays();
	      }
	    }

	    function emitRegular () {
	      function drawElements () {
	        inner(GL + '.drawElements(' + [
	          PRIMITIVE,
	          COUNT,
	          ELEMENT_TYPE,
	          OFFSET + '<<((' + ELEMENT_TYPE + '-' + GL_UNSIGNED_BYTE$8 + ')>>1)'
	        ] + ');');
	      }

	      function drawArrays () {
	        inner(GL + '.drawArrays(' + [PRIMITIVE, OFFSET, COUNT] + ');');
	      }

	      if (ELEMENTS && ELEMENTS !== 'null') {
	        if (!elementsStatic) {
	          inner('if(', ELEMENTS, '){');
	          drawElements();
	          inner('}else{');
	          drawArrays();
	          inner('}');
	        } else {
	          drawElements();
	        }
	      } else {
	        drawArrays();
	      }
	    }

	    if (extInstancing && (typeof INSTANCES !== 'number' || INSTANCES >= 0)) {
	      if (typeof INSTANCES === 'string') {
	        inner('if(', INSTANCES, '>0){');
	        emitInstancing();
	        inner('}else if(', INSTANCES, '<0){');
	        emitRegular();
	        inner('}');
	      } else {
	        emitInstancing();
	      }
	    } else {
	      emitRegular();
	    }
	  }

	  function createBody (emitBody, parentEnv, args, program, count) {
	    var env = createREGLEnvironment();
	    var scope = env.proc('body', count);
	    check$1.optional(function () {
	      env.commandStr = parentEnv.commandStr;
	      env.command = env.link(parentEnv.commandStr);
	    });
	    if (extInstancing) {
	      env.instancing = scope.def(
	        env.shared.extensions, '.angle_instanced_arrays');
	    }
	    emitBody(env, scope, args, program);
	    return env.compile().body
	  }

	  // ===================================================
	  // ===================================================
	  // DRAW PROC
	  // ===================================================
	  // ===================================================
	  function emitDrawBody (env, draw, args, program) {
	    injectExtensions(env, draw);
	    if (args.useVAO) {
	      if (args.drawVAO) {
	        draw(env.shared.vao, '.setVAO(', args.drawVAO.append(env, draw), ');');
	      } else {
	        draw(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);');
	      }
	    } else {
	      draw(env.shared.vao, '.setVAO(null);');
	      emitAttributes(env, draw, args, program.attributes, function () {
	        return true
	      });
	    }
	    emitUniforms(env, draw, args, program.uniforms, function () {
	      return true
	    }, false);
	    emitDraw(env, draw, draw, args);
	  }

	  function emitDrawProc (env, args) {
	    var draw = env.proc('draw', 1);

	    injectExtensions(env, draw);

	    emitContext(env, draw, args.context);
	    emitPollFramebuffer(env, draw, args.framebuffer);

	    emitPollState(env, draw, args);
	    emitSetOptions(env, draw, args.state);

	    emitProfile(env, draw, args, false, true);

	    var program = args.shader.progVar.append(env, draw);
	    draw(env.shared.gl, '.useProgram(', program, '.program);');

	    if (args.shader.program) {
	      emitDrawBody(env, draw, args, args.shader.program);
	    } else {
	      draw(env.shared.vao, '.setVAO(null);');
	      var drawCache = env.global.def('{}');
	      var PROG_ID = draw.def(program, '.id');
	      var CACHED_PROC = draw.def(drawCache, '[', PROG_ID, ']');
	      draw(
	        env.cond(CACHED_PROC)
	          .then(CACHED_PROC, '.call(this,a0);')
	          .else(
	            CACHED_PROC, '=', drawCache, '[', PROG_ID, ']=',
	            env.link(function (program) {
	              return createBody(emitDrawBody, env, args, program, 1)
	            }), '(', program, ');',
	            CACHED_PROC, '.call(this,a0);'));
	    }

	    if (Object.keys(args.state).length > 0) {
	      draw(env.shared.current, '.dirty=true;');
	    }

	    if (env.shared.vao) {
	      draw(env.shared.vao, '.setVAO(null);');
	    }
	  }

	  // ===================================================
	  // ===================================================
	  // BATCH PROC
	  // ===================================================
	  // ===================================================

	  function emitBatchDynamicShaderBody (env, scope, args, program) {
	    env.batchId = 'a1';

	    injectExtensions(env, scope);

	    function all () {
	      return true
	    }

	    emitAttributes(env, scope, args, program.attributes, all);
	    emitUniforms(env, scope, args, program.uniforms, all, false);
	    emitDraw(env, scope, scope, args);
	  }

	  function emitBatchBody (env, scope, args, program) {
	    injectExtensions(env, scope);

	    var contextDynamic = args.contextDep;

	    var BATCH_ID = scope.def();
	    var PROP_LIST = 'a0';
	    var NUM_PROPS = 'a1';
	    var PROPS = scope.def();
	    env.shared.props = PROPS;
	    env.batchId = BATCH_ID;

	    var outer = env.scope();
	    var inner = env.scope();

	    scope(
	      outer.entry,
	      'for(', BATCH_ID, '=0;', BATCH_ID, '<', NUM_PROPS, ';++', BATCH_ID, '){',
	      PROPS, '=', PROP_LIST, '[', BATCH_ID, '];',
	      inner,
	      '}',
	      outer.exit);

	    function isInnerDefn (defn) {
	      return ((defn.contextDep && contextDynamic) || defn.propDep)
	    }

	    function isOuterDefn (defn) {
	      return !isInnerDefn(defn)
	    }

	    if (args.needsContext) {
	      emitContext(env, inner, args.context);
	    }
	    if (args.needsFramebuffer) {
	      emitPollFramebuffer(env, inner, args.framebuffer);
	    }
	    emitSetOptions(env, inner, args.state, isInnerDefn);

	    if (args.profile && isInnerDefn(args.profile)) {
	      emitProfile(env, inner, args, false, true);
	    }

	    if (!program) {
	      var progCache = env.global.def('{}');
	      var PROGRAM = args.shader.progVar.append(env, inner);
	      var PROG_ID = inner.def(PROGRAM, '.id');
	      var CACHED_PROC = inner.def(progCache, '[', PROG_ID, ']');
	      inner(
	        env.shared.gl, '.useProgram(', PROGRAM, '.program);',
	        'if(!', CACHED_PROC, '){',
	        CACHED_PROC, '=', progCache, '[', PROG_ID, ']=',
	        env.link(function (program) {
	          return createBody(
	            emitBatchDynamicShaderBody, env, args, program, 2)
	        }), '(', PROGRAM, ');}',
	        CACHED_PROC, '.call(this,a0[', BATCH_ID, '],', BATCH_ID, ');');
	    } else {
	      if (args.useVAO) {
	        if (args.drawVAO) {
	          if (isInnerDefn(args.drawVAO)) {
	            // vao is a prop
	            inner(env.shared.vao, '.setVAO(', args.drawVAO.append(env, inner), ');');
	          } else {
	            // vao is invariant
	            outer(env.shared.vao, '.setVAO(', args.drawVAO.append(env, outer), ');');
	          }
	        } else {
	          // scoped vao binding
	          outer(env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);');
	        }
	      } else {
	        outer(env.shared.vao, '.setVAO(null);');
	        emitAttributes(env, outer, args, program.attributes, isOuterDefn);
	        emitAttributes(env, inner, args, program.attributes, isInnerDefn);
	      }
	      emitUniforms(env, outer, args, program.uniforms, isOuterDefn, false);
	      emitUniforms(env, inner, args, program.uniforms, isInnerDefn, true);
	      emitDraw(env, outer, inner, args);
	    }
	  }

	  function emitBatchProc (env, args) {
	    var batch = env.proc('batch', 2);
	    env.batchId = '0';

	    injectExtensions(env, batch);

	    // Check if any context variables depend on props
	    var contextDynamic = false;
	    var needsContext = true;
	    Object.keys(args.context).forEach(function (name) {
	      contextDynamic = contextDynamic || args.context[name].propDep;
	    });
	    if (!contextDynamic) {
	      emitContext(env, batch, args.context);
	      needsContext = false;
	    }

	    // framebuffer state affects framebufferWidth/height context vars
	    var framebuffer = args.framebuffer;
	    var needsFramebuffer = false;
	    if (framebuffer) {
	      if (framebuffer.propDep) {
	        contextDynamic = needsFramebuffer = true;
	      } else if (framebuffer.contextDep && contextDynamic) {
	        needsFramebuffer = true;
	      }
	      if (!needsFramebuffer) {
	        emitPollFramebuffer(env, batch, framebuffer);
	      }
	    } else {
	      emitPollFramebuffer(env, batch, null);
	    }

	    // viewport is weird because it can affect context vars
	    if (args.state.viewport && args.state.viewport.propDep) {
	      contextDynamic = true;
	    }

	    function isInnerDefn (defn) {
	      return (defn.contextDep && contextDynamic) || defn.propDep
	    }

	    // set webgl options
	    emitPollState(env, batch, args);
	    emitSetOptions(env, batch, args.state, function (defn) {
	      return !isInnerDefn(defn)
	    });

	    if (!args.profile || !isInnerDefn(args.profile)) {
	      emitProfile(env, batch, args, false, 'a1');
	    }

	    // Save these values to args so that the batch body routine can use them
	    args.contextDep = contextDynamic;
	    args.needsContext = needsContext;
	    args.needsFramebuffer = needsFramebuffer;

	    // determine if shader is dynamic
	    var progDefn = args.shader.progVar;
	    if ((progDefn.contextDep && contextDynamic) || progDefn.propDep) {
	      emitBatchBody(
	        env,
	        batch,
	        args,
	        null);
	    } else {
	      var PROGRAM = progDefn.append(env, batch);
	      batch(env.shared.gl, '.useProgram(', PROGRAM, '.program);');
	      if (args.shader.program) {
	        emitBatchBody(
	          env,
	          batch,
	          args,
	          args.shader.program);
	      } else {
	        batch(env.shared.vao, '.setVAO(null);');
	        var batchCache = env.global.def('{}');
	        var PROG_ID = batch.def(PROGRAM, '.id');
	        var CACHED_PROC = batch.def(batchCache, '[', PROG_ID, ']');
	        batch(
	          env.cond(CACHED_PROC)
	            .then(CACHED_PROC, '.call(this,a0,a1);')
	            .else(
	              CACHED_PROC, '=', batchCache, '[', PROG_ID, ']=',
	              env.link(function (program) {
	                return createBody(emitBatchBody, env, args, program, 2)
	              }), '(', PROGRAM, ');',
	              CACHED_PROC, '.call(this,a0,a1);'));
	      }
	    }

	    if (Object.keys(args.state).length > 0) {
	      batch(env.shared.current, '.dirty=true;');
	    }

	    if (env.shared.vao) {
	      batch(env.shared.vao, '.setVAO(null);');
	    }
	  }

	  // ===================================================
	  // ===================================================
	  // SCOPE COMMAND
	  // ===================================================
	  // ===================================================
	  function emitScopeProc (env, args) {
	    var scope = env.proc('scope', 3);
	    env.batchId = 'a2';

	    var shared = env.shared;
	    var CURRENT_STATE = shared.current;

	    emitContext(env, scope, args.context);

	    if (args.framebuffer) {
	      args.framebuffer.append(env, scope);
	    }

	    sortState(Object.keys(args.state)).forEach(function (name) {
	      var defn = args.state[name];
	      var value = defn.append(env, scope);
	      if (isArrayLike(value)) {
	        value.forEach(function (v, i) {
	          scope.set(env.next[name], '[' + i + ']', v);
	        });
	      } else {
	        scope.set(shared.next, '.' + name, value);
	      }
	    });

	    emitProfile(env, scope, args, true, true)

	    ;[S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(
	      function (opt) {
	        var variable = args.draw[opt];
	        if (!variable) {
	          return
	        }
	        scope.set(shared.draw, '.' + opt, '' + variable.append(env, scope));
	      });

	    Object.keys(args.uniforms).forEach(function (opt) {
	      var value = args.uniforms[opt].append(env, scope);
	      if (Array.isArray(value)) {
	        value = '[' + value.join() + ']';
	      }
	      scope.set(
	        shared.uniforms,
	        '[' + stringStore.id(opt) + ']',
	        value);
	    });

	    Object.keys(args.attributes).forEach(function (name) {
	      var record = args.attributes[name].append(env, scope);
	      var scopeAttrib = env.scopeAttrib(name);
	      Object.keys(new AttributeRecord()).forEach(function (prop) {
	        scope.set(scopeAttrib, '.' + prop, record[prop]);
	      });
	    });

	    if (args.scopeVAO) {
	      scope.set(shared.vao, '.targetVAO', args.scopeVAO.append(env, scope));
	    }

	    function saveShader (name) {
	      var shader = args.shader[name];
	      if (shader) {
	        scope.set(shared.shader, '.' + name, shader.append(env, scope));
	      }
	    }
	    saveShader(S_VERT);
	    saveShader(S_FRAG);

	    if (Object.keys(args.state).length > 0) {
	      scope(CURRENT_STATE, '.dirty=true;');
	      scope.exit(CURRENT_STATE, '.dirty=true;');
	    }

	    scope('a1(', env.shared.context, ',a0,', env.batchId, ');');
	  }

	  function isDynamicObject (object) {
	    if (typeof object !== 'object' || isArrayLike(object)) {
	      return
	    }
	    var props = Object.keys(object);
	    for (var i = 0; i < props.length; ++i) {
	      if (dynamic.isDynamic(object[props[i]])) {
	        return true
	      }
	    }
	    return false
	  }

	  function splatObject (env, options, name) {
	    var object = options.static[name];
	    if (!object || !isDynamicObject(object)) {
	      return
	    }

	    var globals = env.global;
	    var keys = Object.keys(object);
	    var thisDep = false;
	    var contextDep = false;
	    var propDep = false;
	    var objectRef = env.global.def('{}');
	    keys.forEach(function (key) {
	      var value = object[key];
	      if (dynamic.isDynamic(value)) {
	        if (typeof value === 'function') {
	          value = object[key] = dynamic.unbox(value);
	        }
	        var deps = createDynamicDecl(value, null);
	        thisDep = thisDep || deps.thisDep;
	        propDep = propDep || deps.propDep;
	        contextDep = contextDep || deps.contextDep;
	      } else {
	        globals(objectRef, '.', key, '=');
	        switch (typeof value) {
	          case 'number':
	            globals(value);
	            break
	          case 'string':
	            globals('"', value, '"');
	            break
	          case 'object':
	            if (Array.isArray(value)) {
	              globals('[', value.join(), ']');
	            }
	            break
	          default:
	            globals(env.link(value));
	            break
	        }
	        globals(';');
	      }
	    });

	    function appendBlock (env, block) {
	      keys.forEach(function (key) {
	        var value = object[key];
	        if (!dynamic.isDynamic(value)) {
	          return
	        }
	        var ref = env.invoke(block, value);
	        block(objectRef, '.', key, '=', ref, ';');
	      });
	    }

	    options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
	      thisDep: thisDep,
	      contextDep: contextDep,
	      propDep: propDep,
	      ref: objectRef,
	      append: appendBlock
	    });
	    delete options.static[name];
	  }

	  // ===========================================================================
	  // ===========================================================================
	  // MAIN DRAW COMMAND
	  // ===========================================================================
	  // ===========================================================================
	  function compileCommand (options, attributes, uniforms, context, stats) {
	    var env = createREGLEnvironment();

	    // link stats, so that we can easily access it in the program.
	    env.stats = env.link(stats);

	    // splat options and attributes to allow for dynamic nested properties
	    Object.keys(attributes.static).forEach(function (key) {
	      splatObject(env, attributes, key);
	    });
	    NESTED_OPTIONS.forEach(function (name) {
	      splatObject(env, options, name);
	    });

	    var args = parseArguments(options, attributes, uniforms, context, env);

	    emitDrawProc(env, args);
	    emitScopeProc(env, args);
	    emitBatchProc(env, args);

	    return extend(env.compile(), {
	      destroy: function () {
	        args.shader.program.destroy();
	      }
	    })
	  }

	  // ===========================================================================
	  // ===========================================================================
	  // POLL / REFRESH
	  // ===========================================================================
	  // ===========================================================================
	  return {
	    next: nextState,
	    current: currentState,
	    procs: (function () {
	      var env = createREGLEnvironment();
	      var poll = env.proc('poll');
	      var refresh = env.proc('refresh');
	      var common = env.block();
	      poll(common);
	      refresh(common);

	      var shared = env.shared;
	      var GL = shared.gl;
	      var NEXT_STATE = shared.next;
	      var CURRENT_STATE = shared.current;

	      common(CURRENT_STATE, '.dirty=false;');

	      emitPollFramebuffer(env, poll);
	      emitPollFramebuffer(env, refresh, null, true);

	      // Refresh updates all attribute state changes
	      var INSTANCING;
	      if (extInstancing) {
	        INSTANCING = env.link(extInstancing);
	      }

	      // update vertex array bindings
	      if (extensions.oes_vertex_array_object) {
	        refresh(env.link(extensions.oes_vertex_array_object), '.bindVertexArrayOES(null);');
	      }
	      for (var i = 0; i < limits.maxAttributes; ++i) {
	        var BINDING = refresh.def(shared.attributes, '[', i, ']');
	        var ifte = env.cond(BINDING, '.buffer');
	        ifte.then(
	          GL, '.enableVertexAttribArray(', i, ');',
	          GL, '.bindBuffer(',
	          GL_ARRAY_BUFFER$2, ',',
	          BINDING, '.buffer.buffer);',
	          GL, '.vertexAttribPointer(',
	          i, ',',
	          BINDING, '.size,',
	          BINDING, '.type,',
	          BINDING, '.normalized,',
	          BINDING, '.stride,',
	          BINDING, '.offset);'
	        ).else(
	          GL, '.disableVertexAttribArray(', i, ');',
	          GL, '.vertexAttrib4f(',
	          i, ',',
	          BINDING, '.x,',
	          BINDING, '.y,',
	          BINDING, '.z,',
	          BINDING, '.w);',
	          BINDING, '.buffer=null;');
	        refresh(ifte);
	        if (extInstancing) {
	          refresh(
	            INSTANCING, '.vertexAttribDivisorANGLE(',
	            i, ',',
	            BINDING, '.divisor);');
	        }
	      }
	      refresh(
	        env.shared.vao, '.currentVAO=null;',
	        env.shared.vao, '.setVAO(', env.shared.vao, '.targetVAO);');

	      Object.keys(GL_FLAGS).forEach(function (flag) {
	        var cap = GL_FLAGS[flag];
	        var NEXT = common.def(NEXT_STATE, '.', flag);
	        var block = env.block();
	        block('if(', NEXT, '){',
	          GL, '.enable(', cap, ')}else{',
	          GL, '.disable(', cap, ')}',
	          CURRENT_STATE, '.', flag, '=', NEXT, ';');
	        refresh(block);
	        poll(
	          'if(', NEXT, '!==', CURRENT_STATE, '.', flag, '){',
	          block,
	          '}');
	      });

	      Object.keys(GL_VARIABLES).forEach(function (name) {
	        var func = GL_VARIABLES[name];
	        var init = currentState[name];
	        var NEXT, CURRENT;
	        var block = env.block();
	        block(GL, '.', func, '(');
	        if (isArrayLike(init)) {
	          var n = init.length;
	          NEXT = env.global.def(NEXT_STATE, '.', name);
	          CURRENT = env.global.def(CURRENT_STATE, '.', name);
	          block(
	            loop(n, function (i) {
	              return NEXT + '[' + i + ']'
	            }), ');',
	            loop(n, function (i) {
	              return CURRENT + '[' + i + ']=' + NEXT + '[' + i + '];'
	            }).join(''));
	          poll(
	            'if(', loop(n, function (i) {
	              return NEXT + '[' + i + ']!==' + CURRENT + '[' + i + ']'
	            }).join('||'), '){',
	            block,
	            '}');
	        } else {
	          NEXT = common.def(NEXT_STATE, '.', name);
	          CURRENT = common.def(CURRENT_STATE, '.', name);
	          block(
	            NEXT, ');',
	            CURRENT_STATE, '.', name, '=', NEXT, ';');
	          poll(
	            'if(', NEXT, '!==', CURRENT, '){',
	            block,
	            '}');
	        }
	        refresh(block);
	      });

	      return env.compile()
	    })(),
	    compile: compileCommand
	  }
	}

	function stats () {
	  return {
	    vaoCount: 0,
	    bufferCount: 0,
	    elementsCount: 0,
	    framebufferCount: 0,
	    shaderCount: 0,
	    textureCount: 0,
	    cubeCount: 0,
	    renderbufferCount: 0,
	    maxTextureUnits: 0
	  }
	}

	var GL_QUERY_RESULT_EXT = 0x8866;
	var GL_QUERY_RESULT_AVAILABLE_EXT = 0x8867;
	var GL_TIME_ELAPSED_EXT = 0x88BF;

	var createTimer = function (gl, extensions) {
	  if (!extensions.ext_disjoint_timer_query) {
	    return null
	  }

	  // QUERY POOL BEGIN
	  var queryPool = [];
	  function allocQuery () {
	    return queryPool.pop() || extensions.ext_disjoint_timer_query.createQueryEXT()
	  }
	  function freeQuery (query) {
	    queryPool.push(query);
	  }
	  // QUERY POOL END

	  var pendingQueries = [];
	  function beginQuery (stats) {
	    var query = allocQuery();
	    extensions.ext_disjoint_timer_query.beginQueryEXT(GL_TIME_ELAPSED_EXT, query);
	    pendingQueries.push(query);
	    pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats);
	  }

	  function endQuery () {
	    extensions.ext_disjoint_timer_query.endQueryEXT(GL_TIME_ELAPSED_EXT);
	  }

	  //
	  // Pending stats pool.
	  //
	  function PendingStats () {
	    this.startQueryIndex = -1;
	    this.endQueryIndex = -1;
	    this.sum = 0;
	    this.stats = null;
	  }
	  var pendingStatsPool = [];
	  function allocPendingStats () {
	    return pendingStatsPool.pop() || new PendingStats()
	  }
	  function freePendingStats (pendingStats) {
	    pendingStatsPool.push(pendingStats);
	  }
	  // Pending stats pool end

	  var pendingStats = [];
	  function pushScopeStats (start, end, stats) {
	    var ps = allocPendingStats();
	    ps.startQueryIndex = start;
	    ps.endQueryIndex = end;
	    ps.sum = 0;
	    ps.stats = stats;
	    pendingStats.push(ps);
	  }

	  // we should call this at the beginning of the frame,
	  // in order to update gpuTime
	  var timeSum = [];
	  var queryPtr = [];
	  function update () {
	    var ptr, i;

	    var n = pendingQueries.length;
	    if (n === 0) {
	      return
	    }

	    // Reserve space
	    queryPtr.length = Math.max(queryPtr.length, n + 1);
	    timeSum.length = Math.max(timeSum.length, n + 1);
	    timeSum[0] = 0;
	    queryPtr[0] = 0;

	    // Update all pending timer queries
	    var queryTime = 0;
	    ptr = 0;
	    for (i = 0; i < pendingQueries.length; ++i) {
	      var query = pendingQueries[i];
	      if (extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
	        queryTime += extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT);
	        freeQuery(query);
	      } else {
	        pendingQueries[ptr++] = query;
	      }
	      timeSum[i + 1] = queryTime;
	      queryPtr[i + 1] = ptr;
	    }
	    pendingQueries.length = ptr;

	    // Update all pending stat queries
	    ptr = 0;
	    for (i = 0; i < pendingStats.length; ++i) {
	      var stats = pendingStats[i];
	      var start = stats.startQueryIndex;
	      var end = stats.endQueryIndex;
	      stats.sum += timeSum[end] - timeSum[start];
	      var startPtr = queryPtr[start];
	      var endPtr = queryPtr[end];
	      if (endPtr === startPtr) {
	        stats.stats.gpuTime += stats.sum / 1e6;
	        freePendingStats(stats);
	      } else {
	        stats.startQueryIndex = startPtr;
	        stats.endQueryIndex = endPtr;
	        pendingStats[ptr++] = stats;
	      }
	    }
	    pendingStats.length = ptr;
	  }

	  return {
	    beginQuery: beginQuery,
	    endQuery: endQuery,
	    pushScopeStats: pushScopeStats,
	    update: update,
	    getNumPendingQueries: function () {
	      return pendingQueries.length
	    },
	    clear: function () {
	      queryPool.push.apply(queryPool, pendingQueries);
	      for (var i = 0; i < queryPool.length; i++) {
	        extensions.ext_disjoint_timer_query.deleteQueryEXT(queryPool[i]);
	      }
	      pendingQueries.length = 0;
	      queryPool.length = 0;
	    },
	    restore: function () {
	      pendingQueries.length = 0;
	      queryPool.length = 0;
	    }
	  }
	};

	var GL_COLOR_BUFFER_BIT = 16384;
	var GL_DEPTH_BUFFER_BIT = 256;
	var GL_STENCIL_BUFFER_BIT = 1024;

	var GL_ARRAY_BUFFER = 34962;

	var CONTEXT_LOST_EVENT = 'webglcontextlost';
	var CONTEXT_RESTORED_EVENT = 'webglcontextrestored';

	var DYN_PROP = 1;
	var DYN_CONTEXT = 2;
	var DYN_STATE = 3;

	function find (haystack, needle) {
	  for (var i = 0; i < haystack.length; ++i) {
	    if (haystack[i] === needle) {
	      return i
	    }
	  }
	  return -1
	}

	function wrapREGL (args) {
	  var config = parseArgs(args);
	  if (!config) {
	    return null
	  }

	  var gl = config.gl;
	  var glAttributes = gl.getContextAttributes();
	  var contextLost = gl.isContextLost();

	  var extensionState = createExtensionCache(gl, config);
	  if (!extensionState) {
	    return null
	  }

	  var stringStore = createStringStore();
	  var stats$$1 = stats();
	  var extensions = extensionState.extensions;
	  var timer = createTimer(gl, extensions);

	  var START_TIME = clock();
	  var WIDTH = gl.drawingBufferWidth;
	  var HEIGHT = gl.drawingBufferHeight;

	  var contextState = {
	    tick: 0,
	    time: 0,
	    viewportWidth: WIDTH,
	    viewportHeight: HEIGHT,
	    framebufferWidth: WIDTH,
	    framebufferHeight: HEIGHT,
	    drawingBufferWidth: WIDTH,
	    drawingBufferHeight: HEIGHT,
	    pixelRatio: config.pixelRatio
	  };
	  var uniformState = {};
	  var drawState = {
	    elements: null,
	    primitive: 4, // GL_TRIANGLES
	    count: -1,
	    offset: 0,
	    instances: -1
	  };

	  var limits = wrapLimits(gl, extensions);
	  var bufferState = wrapBufferState(
	    gl,
	    stats$$1,
	    config,
	    destroyBuffer);
	  var elementState = wrapElementsState(gl, extensions, bufferState, stats$$1);
	  var attributeState = wrapAttributeState(
	    gl,
	    extensions,
	    limits,
	    stats$$1,
	    bufferState,
	    elementState,
	    drawState);
	  function destroyBuffer (buffer) {
	    return attributeState.destroyBuffer(buffer)
	  }
	  var shaderState = wrapShaderState(gl, stringStore, stats$$1, config);
	  var textureState = createTextureSet(
	    gl,
	    extensions,
	    limits,
	    function () { core.procs.poll(); },
	    contextState,
	    stats$$1,
	    config);
	  var renderbufferState = wrapRenderbuffers(gl, extensions, limits, stats$$1, config);
	  var framebufferState = wrapFBOState(
	    gl,
	    extensions,
	    limits,
	    textureState,
	    renderbufferState,
	    stats$$1);
	  var core = reglCore(
	    gl,
	    stringStore,
	    extensions,
	    limits,
	    bufferState,
	    elementState,
	    textureState,
	    framebufferState,
	    uniformState,
	    attributeState,
	    shaderState,
	    drawState,
	    contextState,
	    timer,
	    config);
	  var readPixels = wrapReadPixels(
	    gl,
	    framebufferState,
	    core.procs.poll,
	    contextState,
	    glAttributes, extensions, limits);

	  var nextState = core.next;
	  var canvas = gl.canvas;

	  var rafCallbacks = [];
	  var lossCallbacks = [];
	  var restoreCallbacks = [];
	  var destroyCallbacks = [config.onDestroy];

	  var activeRAF = null;
	  function handleRAF () {
	    if (rafCallbacks.length === 0) {
	      if (timer) {
	        timer.update();
	      }
	      activeRAF = null;
	      return
	    }

	    // schedule next animation frame
	    activeRAF = raf.next(handleRAF);

	    // poll for changes
	    poll();

	    // fire a callback for all pending rafs
	    for (var i = rafCallbacks.length - 1; i >= 0; --i) {
	      var cb = rafCallbacks[i];
	      if (cb) {
	        cb(contextState, null, 0);
	      }
	    }

	    // flush all pending webgl calls
	    gl.flush();

	    // poll GPU timers *after* gl.flush so we don't delay command dispatch
	    if (timer) {
	      timer.update();
	    }
	  }

	  function startRAF () {
	    if (!activeRAF && rafCallbacks.length > 0) {
	      activeRAF = raf.next(handleRAF);
	    }
	  }

	  function stopRAF () {
	    if (activeRAF) {
	      raf.cancel(handleRAF);
	      activeRAF = null;
	    }
	  }

	  function handleContextLoss (event) {
	    event.preventDefault();

	    // set context lost flag
	    contextLost = true;

	    // pause request animation frame
	    stopRAF();

	    // lose context
	    lossCallbacks.forEach(function (cb) {
	      cb();
	    });
	  }

	  function handleContextRestored (event) {
	    // clear error code
	    gl.getError();

	    // clear context lost flag
	    contextLost = false;

	    // refresh state
	    extensionState.restore();
	    shaderState.restore();
	    bufferState.restore();
	    textureState.restore();
	    renderbufferState.restore();
	    framebufferState.restore();
	    attributeState.restore();
	    if (timer) {
	      timer.restore();
	    }

	    // refresh state
	    core.procs.refresh();

	    // restart RAF
	    startRAF();

	    // restore context
	    restoreCallbacks.forEach(function (cb) {
	      cb();
	    });
	  }

	  if (canvas) {
	    canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false);
	    canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false);
	  }

	  function destroy () {
	    rafCallbacks.length = 0;
	    stopRAF();

	    if (canvas) {
	      canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss);
	      canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored);
	    }

	    shaderState.clear();
	    framebufferState.clear();
	    renderbufferState.clear();
	    attributeState.clear();
	    textureState.clear();
	    elementState.clear();
	    bufferState.clear();

	    if (timer) {
	      timer.clear();
	    }

	    destroyCallbacks.forEach(function (cb) {
	      cb();
	    });
	  }

	  function compileProcedure (options) {
	    check$1(!!options, 'invalid args to regl({...})');
	    check$1.type(options, 'object', 'invalid args to regl({...})');

	    function flattenNestedOptions (options) {
	      var result = extend({}, options);
	      delete result.uniforms;
	      delete result.attributes;
	      delete result.context;
	      delete result.vao;

	      if ('stencil' in result && result.stencil.op) {
	        result.stencil.opBack = result.stencil.opFront = result.stencil.op;
	        delete result.stencil.op;
	      }

	      function merge (name) {
	        if (name in result) {
	          var child = result[name];
	          delete result[name];
	          Object.keys(child).forEach(function (prop) {
	            result[name + '.' + prop] = child[prop];
	          });
	        }
	      }
	      merge('blend');
	      merge('depth');
	      merge('cull');
	      merge('stencil');
	      merge('polygonOffset');
	      merge('scissor');
	      merge('sample');

	      if ('vao' in options) {
	        result.vao = options.vao;
	      }

	      return result
	    }

	    function separateDynamic (object, useArrays) {
	      var staticItems = {};
	      var dynamicItems = {};
	      Object.keys(object).forEach(function (option) {
	        var value = object[option];
	        if (dynamic.isDynamic(value)) {
	          dynamicItems[option] = dynamic.unbox(value, option);
	          return
	        } else if (useArrays && Array.isArray(value)) {
	          for (var i = 0; i < value.length; ++i) {
	            if (dynamic.isDynamic(value[i])) {
	              dynamicItems[option] = dynamic.unbox(value, option);
	              return
	            }
	          }
	        }
	        staticItems[option] = value;
	      });
	      return {
	        dynamic: dynamicItems,
	        static: staticItems
	      }
	    }

	    // Treat context variables separate from other dynamic variables
	    var context = separateDynamic(options.context || {}, true);
	    var uniforms = separateDynamic(options.uniforms || {}, true);
	    var attributes = separateDynamic(options.attributes || {}, false);
	    var opts = separateDynamic(flattenNestedOptions(options), false);

	    var stats$$1 = {
	      gpuTime: 0.0,
	      cpuTime: 0.0,
	      count: 0
	    };

	    var compiled = core.compile(opts, attributes, uniforms, context, stats$$1);

	    var draw = compiled.draw;
	    var batch = compiled.batch;
	    var scope = compiled.scope;

	    // FIXME: we should modify code generation for batch commands so this
	    // isn't necessary
	    var EMPTY_ARRAY = [];
	    function reserve (count) {
	      while (EMPTY_ARRAY.length < count) {
	        EMPTY_ARRAY.push(null);
	      }
	      return EMPTY_ARRAY
	    }

	    function REGLCommand (args, body) {
	      var i;
	      if (contextLost) {
	        check$1.raise('context lost');
	      }
	      if (typeof args === 'function') {
	        return scope.call(this, null, args, 0)
	      } else if (typeof body === 'function') {
	        if (typeof args === 'number') {
	          for (i = 0; i < args; ++i) {
	            scope.call(this, null, body, i);
	          }
	        } else if (Array.isArray(args)) {
	          for (i = 0; i < args.length; ++i) {
	            scope.call(this, args[i], body, i);
	          }
	        } else {
	          return scope.call(this, args, body, 0)
	        }
	      } else if (typeof args === 'number') {
	        if (args > 0) {
	          return batch.call(this, reserve(args | 0), args | 0)
	        }
	      } else if (Array.isArray(args)) {
	        if (args.length) {
	          return batch.call(this, args, args.length)
	        }
	      } else {
	        return draw.call(this, args)
	      }
	    }

	    return extend(REGLCommand, {
	      stats: stats$$1,
	      destroy: function () {
	        compiled.destroy();
	      }
	    })
	  }

	  var setFBO = framebufferState.setFBO = compileProcedure({
	    framebuffer: dynamic.define.call(null, DYN_PROP, 'framebuffer')
	  });

	  function clearImpl (_, options) {
	    var clearFlags = 0;
	    core.procs.poll();

	    var c = options.color;
	    if (c) {
	      gl.clearColor(+c[0] || 0, +c[1] || 0, +c[2] || 0, +c[3] || 0);
	      clearFlags |= GL_COLOR_BUFFER_BIT;
	    }
	    if ('depth' in options) {
	      gl.clearDepth(+options.depth);
	      clearFlags |= GL_DEPTH_BUFFER_BIT;
	    }
	    if ('stencil' in options) {
	      gl.clearStencil(options.stencil | 0);
	      clearFlags |= GL_STENCIL_BUFFER_BIT;
	    }

	    check$1(!!clearFlags, 'called regl.clear with no buffer specified');
	    gl.clear(clearFlags);
	  }

	  function clear (options) {
	    check$1(
	      typeof options === 'object' && options,
	      'regl.clear() takes an object as input');
	    if ('framebuffer' in options) {
	      if (options.framebuffer &&
	          options.framebuffer_reglType === 'framebufferCube') {
	        for (var i = 0; i < 6; ++i) {
	          setFBO(extend({
	            framebuffer: options.framebuffer.faces[i]
	          }, options), clearImpl);
	        }
	      } else {
	        setFBO(options, clearImpl);
	      }
	    } else {
	      clearImpl(null, options);
	    }
	  }

	  function frame (cb) {
	    check$1.type(cb, 'function', 'regl.frame() callback must be a function');
	    rafCallbacks.push(cb);

	    function cancel () {
	      // FIXME:  should we check something other than equals cb here?
	      // what if a user calls frame twice with the same callback...
	      //
	      var i = find(rafCallbacks, cb);
	      check$1(i >= 0, 'cannot cancel a frame twice');
	      function pendingCancel () {
	        var index = find(rafCallbacks, pendingCancel);
	        rafCallbacks[index] = rafCallbacks[rafCallbacks.length - 1];
	        rafCallbacks.length -= 1;
	        if (rafCallbacks.length <= 0) {
	          stopRAF();
	        }
	      }
	      rafCallbacks[i] = pendingCancel;
	    }

	    startRAF();

	    return {
	      cancel: cancel
	    }
	  }

	  // poll viewport
	  function pollViewport () {
	    var viewport = nextState.viewport;
	    var scissorBox = nextState.scissor_box;
	    viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0;
	    contextState.viewportWidth =
	      contextState.framebufferWidth =
	      contextState.drawingBufferWidth =
	      viewport[2] =
	      scissorBox[2] = gl.drawingBufferWidth;
	    contextState.viewportHeight =
	      contextState.framebufferHeight =
	      contextState.drawingBufferHeight =
	      viewport[3] =
	      scissorBox[3] = gl.drawingBufferHeight;
	  }

	  function poll () {
	    contextState.tick += 1;
	    contextState.time = now();
	    pollViewport();
	    core.procs.poll();
	  }

	  function refresh () {
	    textureState.refresh();
	    pollViewport();
	    core.procs.refresh();
	    if (timer) {
	      timer.update();
	    }
	  }

	  function now () {
	    return (clock() - START_TIME) / 1000.0
	  }

	  refresh();

	  function addListener (event, callback) {
	    check$1.type(callback, 'function', 'listener callback must be a function');

	    var callbacks;
	    switch (event) {
	      case 'frame':
	        return frame(callback)
	      case 'lost':
	        callbacks = lossCallbacks;
	        break
	      case 'restore':
	        callbacks = restoreCallbacks;
	        break
	      case 'destroy':
	        callbacks = destroyCallbacks;
	        break
	      default:
	        check$1.raise('invalid event, must be one of frame,lost,restore,destroy');
	    }

	    callbacks.push(callback);
	    return {
	      cancel: function () {
	        for (var i = 0; i < callbacks.length; ++i) {
	          if (callbacks[i] === callback) {
	            callbacks[i] = callbacks[callbacks.length - 1];
	            callbacks.pop();
	            return
	          }
	        }
	      }
	    }
	  }

	  var regl = extend(compileProcedure, {
	    // Clear current FBO
	    clear: clear,

	    // Short cuts for dynamic variables
	    prop: dynamic.define.bind(null, DYN_PROP),
	    context: dynamic.define.bind(null, DYN_CONTEXT),
	    this: dynamic.define.bind(null, DYN_STATE),

	    // executes an empty draw command
	    draw: compileProcedure({}),

	    // Resources
	    buffer: function (options) {
	      return bufferState.create(options, GL_ARRAY_BUFFER, false, false)
	    },
	    elements: function (options) {
	      return elementState.create(options, false)
	    },
	    texture: textureState.create2D,
	    cube: textureState.createCube,
	    renderbuffer: renderbufferState.create,
	    framebuffer: framebufferState.create,
	    framebufferCube: framebufferState.createCube,
	    vao: attributeState.createVAO,

	    // Expose context attributes
	    attributes: glAttributes,

	    // Frame rendering
	    frame: frame,
	    on: addListener,

	    // System limits
	    limits: limits,
	    hasExtension: function (name) {
	      return limits.extensions.indexOf(name.toLowerCase()) >= 0
	    },

	    // Read pixels
	    read: readPixels,

	    // Destroy regl and all associated resources
	    destroy: destroy,

	    // Direct GL state manipulation
	    _gl: gl,
	    _refresh: refresh,

	    poll: function () {
	      poll();
	      if (timer) {
	        timer.update();
	      }
	    },

	    // Current time
	    now: now,

	    // regl Statistics Information
	    stats: stats$$1,

	    blit: framebufferState.blit
	  });

	  config.onDone(null, regl);

	  return regl
	}

	return wrapREGL;

	})));

	}(regl));

	var p$2 = regl.exports;

	/**
	 * Common utilities
	 * @module glMatrix
	 */

	// Configuration Constants
	var EPSILON = 0.000001;
	var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
	var RANDOM = Math.random;

	/**
	 * Sets the type of array used when creating new vectors and matrices
	 *
	 * @param {Type} type Array type, such as Float32Array or Array
	 */
	function setMatrixArrayType(type) {
	  ARRAY_TYPE = type;
	}

	var degree = Math.PI / 180;

	/**
	 * Convert Degree To Radian
	 *
	 * @param {Number} a Angle in Degrees
	 */
	function toRadian(a) {
	  return a * degree;
	}

	/**
	 * Tests whether or not the arguments have approximately the same value, within an absolute
	 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
	 * than or equal to 1.0, and a relative tolerance is used for larger values)
	 *
	 * @param {Number} a The first number to test.
	 * @param {Number} b The second number to test.
	 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
	 */
	function equals$9(a, b) {
	  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
	}

	var common = /*#__PURE__*/Object.freeze({
		__proto__: null,
		EPSILON: EPSILON,
		get ARRAY_TYPE () { return ARRAY_TYPE; },
		RANDOM: RANDOM,
		setMatrixArrayType: setMatrixArrayType,
		toRadian: toRadian,
		equals: equals$9
	});

	/**
	 * 2x2 Matrix
	 * @module mat2
	 */

	/**
	 * Creates a new identity mat2
	 *
	 * @returns {mat2} a new 2x2 matrix
	 */
	function create$8() {
	  var out = new ARRAY_TYPE(4);
	  if (ARRAY_TYPE != Float32Array) {
	    out[1] = 0;
	    out[2] = 0;
	  }
	  out[0] = 1;
	  out[3] = 1;
	  return out;
	}

	/**
	 * Creates a new mat2 initialized with values from an existing matrix
	 *
	 * @param {mat2} a matrix to clone
	 * @returns {mat2} a new 2x2 matrix
	 */
	function clone$8(a) {
	  var out = new ARRAY_TYPE(4);
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  return out;
	}

	/**
	 * Copy the values from one mat2 to another
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	function copy$8(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  return out;
	}

	/**
	 * Set a mat2 to the identity matrix
	 *
	 * @param {mat2} out the receiving matrix
	 * @returns {mat2} out
	 */
	function identity$5(out) {
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 1;
	  return out;
	}

	/**
	 * Create a new mat2 with the given values
	 *
	 * @param {Number} m00 Component in column 0, row 0 position (index 0)
	 * @param {Number} m01 Component in column 0, row 1 position (index 1)
	 * @param {Number} m10 Component in column 1, row 0 position (index 2)
	 * @param {Number} m11 Component in column 1, row 1 position (index 3)
	 * @returns {mat2} out A new 2x2 matrix
	 */
	function fromValues$8(m00, m01, m10, m11) {
	  var out = new ARRAY_TYPE(4);
	  out[0] = m00;
	  out[1] = m01;
	  out[2] = m10;
	  out[3] = m11;
	  return out;
	}

	/**
	 * Set the components of a mat2 to the given values
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {Number} m00 Component in column 0, row 0 position (index 0)
	 * @param {Number} m01 Component in column 0, row 1 position (index 1)
	 * @param {Number} m10 Component in column 1, row 0 position (index 2)
	 * @param {Number} m11 Component in column 1, row 1 position (index 3)
	 * @returns {mat2} out
	 */
	function set$8(out, m00, m01, m10, m11) {
	  out[0] = m00;
	  out[1] = m01;
	  out[2] = m10;
	  out[3] = m11;
	  return out;
	}

	/**
	 * Transpose the values of a mat2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	function transpose$2(out, a) {
	  // If we are transposing ourselves we can skip a few steps but have to cache
	  // some values
	  if (out === a) {
	    var a1 = a[1];
	    out[1] = a[2];
	    out[2] = a1;
	  } else {
	    out[0] = a[0];
	    out[1] = a[2];
	    out[2] = a[1];
	    out[3] = a[3];
	  }

	  return out;
	}

	/**
	 * Inverts a mat2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	function invert$5(out, a) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3];

	  // Calculate the determinant
	  var det = a0 * a3 - a2 * a1;

	  if (!det) {
	    return null;
	  }
	  det = 1.0 / det;

	  out[0] = a3 * det;
	  out[1] = -a1 * det;
	  out[2] = -a2 * det;
	  out[3] = a0 * det;

	  return out;
	}

	/**
	 * Calculates the adjugate of a mat2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the source matrix
	 * @returns {mat2} out
	 */
	function adjoint$2(out, a) {
	  // Caching this value is nessecary if out == a
	  var a0 = a[0];
	  out[0] = a[3];
	  out[1] = -a[1];
	  out[2] = -a[2];
	  out[3] = a0;

	  return out;
	}

	/**
	 * Calculates the determinant of a mat2
	 *
	 * @param {mat2} a the source matrix
	 * @returns {Number} determinant of a
	 */
	function determinant$3(a) {
	  return a[0] * a[3] - a[2] * a[1];
	}

	/**
	 * Multiplies two mat2's
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the first operand
	 * @param {mat2} b the second operand
	 * @returns {mat2} out
	 */
	function multiply$8(out, a, b) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3];
	  var b0 = b[0],
	      b1 = b[1],
	      b2 = b[2],
	      b3 = b[3];
	  out[0] = a0 * b0 + a2 * b1;
	  out[1] = a1 * b0 + a3 * b1;
	  out[2] = a0 * b2 + a2 * b3;
	  out[3] = a1 * b2 + a3 * b3;
	  return out;
	}

	/**
	 * Rotates a mat2 by the given angle
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat2} out
	 */
	function rotate$4(out, a, rad) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3];
	  var s = Math.sin(rad);
	  var c = Math.cos(rad);
	  out[0] = a0 * c + a2 * s;
	  out[1] = a1 * c + a3 * s;
	  out[2] = a0 * -s + a2 * c;
	  out[3] = a1 * -s + a3 * c;
	  return out;
	}

	/**
	 * Scales the mat2 by the dimensions in the given vec2
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the matrix to rotate
	 * @param {vec2} v the vec2 to scale the matrix by
	 * @returns {mat2} out
	 **/
	function scale$8(out, a, v) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3];
	  var v0 = v[0],
	      v1 = v[1];
	  out[0] = a0 * v0;
	  out[1] = a1 * v0;
	  out[2] = a2 * v1;
	  out[3] = a3 * v1;
	  return out;
	}

	/**
	 * Creates a matrix from a given angle
	 * This is equivalent to (but much faster than):
	 *
	 *     mat2.identity(dest);
	 *     mat2.rotate(dest, dest, rad);
	 *
	 * @param {mat2} out mat2 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat2} out
	 */
	function fromRotation$4(out, rad) {
	  var s = Math.sin(rad);
	  var c = Math.cos(rad);
	  out[0] = c;
	  out[1] = s;
	  out[2] = -s;
	  out[3] = c;
	  return out;
	}

	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat2.identity(dest);
	 *     mat2.scale(dest, dest, vec);
	 *
	 * @param {mat2} out mat2 receiving operation result
	 * @param {vec2} v Scaling vector
	 * @returns {mat2} out
	 */
	function fromScaling$3(out, v) {
	  out[0] = v[0];
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = v[1];
	  return out;
	}

	/**
	 * Returns a string representation of a mat2
	 *
	 * @param {mat2} a matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	function str$8(a) {
	  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
	}

	/**
	 * Returns Frobenius norm of a mat2
	 *
	 * @param {mat2} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	function frob$3(a) {
	  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
	}

	/**
	 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
	 * @param {mat2} L the lower triangular matrix
	 * @param {mat2} D the diagonal matrix
	 * @param {mat2} U the upper triangular matrix
	 * @param {mat2} a the input matrix to factorize
	 */

	function LDU(L, D, U, a) {
	  L[2] = a[2] / a[0];
	  U[0] = a[0];
	  U[1] = a[1];
	  U[3] = a[3] - L[2] * U[1];
	  return [L, D, U];
	}

	/**
	 * Adds two mat2's
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the first operand
	 * @param {mat2} b the second operand
	 * @returns {mat2} out
	 */
	function add$8(out, a, b) {
	  out[0] = a[0] + b[0];
	  out[1] = a[1] + b[1];
	  out[2] = a[2] + b[2];
	  out[3] = a[3] + b[3];
	  return out;
	}

	/**
	 * Subtracts matrix b from matrix a
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the first operand
	 * @param {mat2} b the second operand
	 * @returns {mat2} out
	 */
	function subtract$6(out, a, b) {
	  out[0] = a[0] - b[0];
	  out[1] = a[1] - b[1];
	  out[2] = a[2] - b[2];
	  out[3] = a[3] - b[3];
	  return out;
	}

	/**
	 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {mat2} a The first matrix.
	 * @param {mat2} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	function exactEquals$8(a, b) {
	  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
	}

	/**
	 * Returns whether or not the matrices have approximately the same elements in the same position.
	 *
	 * @param {mat2} a The first matrix.
	 * @param {mat2} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	function equals$8(a, b) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3];
	  var b0 = b[0],
	      b1 = b[1],
	      b2 = b[2],
	      b3 = b[3];
	  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
	}

	/**
	 * Multiply each element of the matrix by a scalar.
	 *
	 * @param {mat2} out the receiving matrix
	 * @param {mat2} a the matrix to scale
	 * @param {Number} b amount to scale the matrix's elements by
	 * @returns {mat2} out
	 */
	function multiplyScalar$3(out, a, b) {
	  out[0] = a[0] * b;
	  out[1] = a[1] * b;
	  out[2] = a[2] * b;
	  out[3] = a[3] * b;
	  return out;
	}

	/**
	 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
	 *
	 * @param {mat2} out the receiving vector
	 * @param {mat2} a the first operand
	 * @param {mat2} b the second operand
	 * @param {Number} scale the amount to scale b's elements by before adding
	 * @returns {mat2} out
	 */
	function multiplyScalarAndAdd$3(out, a, b, scale) {
	  out[0] = a[0] + b[0] * scale;
	  out[1] = a[1] + b[1] * scale;
	  out[2] = a[2] + b[2] * scale;
	  out[3] = a[3] + b[3] * scale;
	  return out;
	}

	/**
	 * Alias for {@link mat2.multiply}
	 * @function
	 */
	var mul$8 = multiply$8;

	/**
	 * Alias for {@link mat2.subtract}
	 * @function
	 */
	var sub$6 = subtract$6;

	var mat2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$8,
		clone: clone$8,
		copy: copy$8,
		identity: identity$5,
		fromValues: fromValues$8,
		set: set$8,
		transpose: transpose$2,
		invert: invert$5,
		adjoint: adjoint$2,
		determinant: determinant$3,
		multiply: multiply$8,
		rotate: rotate$4,
		scale: scale$8,
		fromRotation: fromRotation$4,
		fromScaling: fromScaling$3,
		str: str$8,
		frob: frob$3,
		LDU: LDU,
		add: add$8,
		subtract: subtract$6,
		exactEquals: exactEquals$8,
		equals: equals$8,
		multiplyScalar: multiplyScalar$3,
		multiplyScalarAndAdd: multiplyScalarAndAdd$3,
		mul: mul$8,
		sub: sub$6
	});

	/**
	 * 2x3 Matrix
	 * @module mat2d
	 *
	 * @description
	 * A mat2d contains six elements defined as:
	 * <pre>
	 * [a, c, tx,
	 *  b, d, ty]
	 * </pre>
	 * This is a short form for the 3x3 matrix:
	 * <pre>
	 * [a, c, tx,
	 *  b, d, ty,
	 *  0, 0, 1]
	 * </pre>
	 * The last row is ignored so the array is shorter and operations are faster.
	 */

	/**
	 * Creates a new identity mat2d
	 *
	 * @returns {mat2d} a new 2x3 matrix
	 */
	function create$7() {
	  var out = new ARRAY_TYPE(6);
	  if (ARRAY_TYPE != Float32Array) {
	    out[1] = 0;
	    out[2] = 0;
	    out[4] = 0;
	    out[5] = 0;
	  }
	  out[0] = 1;
	  out[3] = 1;
	  return out;
	}

	/**
	 * Creates a new mat2d initialized with values from an existing matrix
	 *
	 * @param {mat2d} a matrix to clone
	 * @returns {mat2d} a new 2x3 matrix
	 */
	function clone$7(a) {
	  var out = new ARRAY_TYPE(6);
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  out[4] = a[4];
	  out[5] = a[5];
	  return out;
	}

	/**
	 * Copy the values from one mat2d to another
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the source matrix
	 * @returns {mat2d} out
	 */
	function copy$7(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  out[4] = a[4];
	  out[5] = a[5];
	  return out;
	}

	/**
	 * Set a mat2d to the identity matrix
	 *
	 * @param {mat2d} out the receiving matrix
	 * @returns {mat2d} out
	 */
	function identity$4(out) {
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 1;
	  out[4] = 0;
	  out[5] = 0;
	  return out;
	}

	/**
	 * Create a new mat2d with the given values
	 *
	 * @param {Number} a Component A (index 0)
	 * @param {Number} b Component B (index 1)
	 * @param {Number} c Component C (index 2)
	 * @param {Number} d Component D (index 3)
	 * @param {Number} tx Component TX (index 4)
	 * @param {Number} ty Component TY (index 5)
	 * @returns {mat2d} A new mat2d
	 */
	function fromValues$7(a, b, c, d, tx, ty) {
	  var out = new ARRAY_TYPE(6);
	  out[0] = a;
	  out[1] = b;
	  out[2] = c;
	  out[3] = d;
	  out[4] = tx;
	  out[5] = ty;
	  return out;
	}

	/**
	 * Set the components of a mat2d to the given values
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {Number} a Component A (index 0)
	 * @param {Number} b Component B (index 1)
	 * @param {Number} c Component C (index 2)
	 * @param {Number} d Component D (index 3)
	 * @param {Number} tx Component TX (index 4)
	 * @param {Number} ty Component TY (index 5)
	 * @returns {mat2d} out
	 */
	function set$7(out, a, b, c, d, tx, ty) {
	  out[0] = a;
	  out[1] = b;
	  out[2] = c;
	  out[3] = d;
	  out[4] = tx;
	  out[5] = ty;
	  return out;
	}

	/**
	 * Inverts a mat2d
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the source matrix
	 * @returns {mat2d} out
	 */
	function invert$4(out, a) {
	  var aa = a[0],
	      ab = a[1],
	      ac = a[2],
	      ad = a[3];
	  var atx = a[4],
	      aty = a[5];

	  var det = aa * ad - ab * ac;
	  if (!det) {
	    return null;
	  }
	  det = 1.0 / det;

	  out[0] = ad * det;
	  out[1] = -ab * det;
	  out[2] = -ac * det;
	  out[3] = aa * det;
	  out[4] = (ac * aty - ad * atx) * det;
	  out[5] = (ab * atx - aa * aty) * det;
	  return out;
	}

	/**
	 * Calculates the determinant of a mat2d
	 *
	 * @param {mat2d} a the source matrix
	 * @returns {Number} determinant of a
	 */
	function determinant$2(a) {
	  return a[0] * a[3] - a[1] * a[2];
	}

	/**
	 * Multiplies two mat2d's
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the first operand
	 * @param {mat2d} b the second operand
	 * @returns {mat2d} out
	 */
	function multiply$7(out, a, b) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3],
	      a4 = a[4],
	      a5 = a[5];
	  var b0 = b[0],
	      b1 = b[1],
	      b2 = b[2],
	      b3 = b[3],
	      b4 = b[4],
	      b5 = b[5];
	  out[0] = a0 * b0 + a2 * b1;
	  out[1] = a1 * b0 + a3 * b1;
	  out[2] = a0 * b2 + a2 * b3;
	  out[3] = a1 * b2 + a3 * b3;
	  out[4] = a0 * b4 + a2 * b5 + a4;
	  out[5] = a1 * b4 + a3 * b5 + a5;
	  return out;
	}

	/**
	 * Rotates a mat2d by the given angle
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat2d} out
	 */
	function rotate$3(out, a, rad) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3],
	      a4 = a[4],
	      a5 = a[5];
	  var s = Math.sin(rad);
	  var c = Math.cos(rad);
	  out[0] = a0 * c + a2 * s;
	  out[1] = a1 * c + a3 * s;
	  out[2] = a0 * -s + a2 * c;
	  out[3] = a1 * -s + a3 * c;
	  out[4] = a4;
	  out[5] = a5;
	  return out;
	}

	/**
	 * Scales the mat2d by the dimensions in the given vec2
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the matrix to translate
	 * @param {vec2} v the vec2 to scale the matrix by
	 * @returns {mat2d} out
	 **/
	function scale$7(out, a, v) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3],
	      a4 = a[4],
	      a5 = a[5];
	  var v0 = v[0],
	      v1 = v[1];
	  out[0] = a0 * v0;
	  out[1] = a1 * v0;
	  out[2] = a2 * v1;
	  out[3] = a3 * v1;
	  out[4] = a4;
	  out[5] = a5;
	  return out;
	}

	/**
	 * Translates the mat2d by the dimensions in the given vec2
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the matrix to translate
	 * @param {vec2} v the vec2 to translate the matrix by
	 * @returns {mat2d} out
	 **/
	function translate$3(out, a, v) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3],
	      a4 = a[4],
	      a5 = a[5];
	  var v0 = v[0],
	      v1 = v[1];
	  out[0] = a0;
	  out[1] = a1;
	  out[2] = a2;
	  out[3] = a3;
	  out[4] = a0 * v0 + a2 * v1 + a4;
	  out[5] = a1 * v0 + a3 * v1 + a5;
	  return out;
	}

	/**
	 * Creates a matrix from a given angle
	 * This is equivalent to (but much faster than):
	 *
	 *     mat2d.identity(dest);
	 *     mat2d.rotate(dest, dest, rad);
	 *
	 * @param {mat2d} out mat2d receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat2d} out
	 */
	function fromRotation$3(out, rad) {
	  var s = Math.sin(rad),
	      c = Math.cos(rad);
	  out[0] = c;
	  out[1] = s;
	  out[2] = -s;
	  out[3] = c;
	  out[4] = 0;
	  out[5] = 0;
	  return out;
	}

	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat2d.identity(dest);
	 *     mat2d.scale(dest, dest, vec);
	 *
	 * @param {mat2d} out mat2d receiving operation result
	 * @param {vec2} v Scaling vector
	 * @returns {mat2d} out
	 */
	function fromScaling$2(out, v) {
	  out[0] = v[0];
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = v[1];
	  out[4] = 0;
	  out[5] = 0;
	  return out;
	}

	/**
	 * Creates a matrix from a vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat2d.identity(dest);
	 *     mat2d.translate(dest, dest, vec);
	 *
	 * @param {mat2d} out mat2d receiving operation result
	 * @param {vec2} v Translation vector
	 * @returns {mat2d} out
	 */
	function fromTranslation$3(out, v) {
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 1;
	  out[4] = v[0];
	  out[5] = v[1];
	  return out;
	}

	/**
	 * Returns a string representation of a mat2d
	 *
	 * @param {mat2d} a matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	function str$7(a) {
	  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
	}

	/**
	 * Returns Frobenius norm of a mat2d
	 *
	 * @param {mat2d} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	function frob$2(a) {
	  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
	}

	/**
	 * Adds two mat2d's
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the first operand
	 * @param {mat2d} b the second operand
	 * @returns {mat2d} out
	 */
	function add$7(out, a, b) {
	  out[0] = a[0] + b[0];
	  out[1] = a[1] + b[1];
	  out[2] = a[2] + b[2];
	  out[3] = a[3] + b[3];
	  out[4] = a[4] + b[4];
	  out[5] = a[5] + b[5];
	  return out;
	}

	/**
	 * Subtracts matrix b from matrix a
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the first operand
	 * @param {mat2d} b the second operand
	 * @returns {mat2d} out
	 */
	function subtract$5(out, a, b) {
	  out[0] = a[0] - b[0];
	  out[1] = a[1] - b[1];
	  out[2] = a[2] - b[2];
	  out[3] = a[3] - b[3];
	  out[4] = a[4] - b[4];
	  out[5] = a[5] - b[5];
	  return out;
	}

	/**
	 * Multiply each element of the matrix by a scalar.
	 *
	 * @param {mat2d} out the receiving matrix
	 * @param {mat2d} a the matrix to scale
	 * @param {Number} b amount to scale the matrix's elements by
	 * @returns {mat2d} out
	 */
	function multiplyScalar$2(out, a, b) {
	  out[0] = a[0] * b;
	  out[1] = a[1] * b;
	  out[2] = a[2] * b;
	  out[3] = a[3] * b;
	  out[4] = a[4] * b;
	  out[5] = a[5] * b;
	  return out;
	}

	/**
	 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
	 *
	 * @param {mat2d} out the receiving vector
	 * @param {mat2d} a the first operand
	 * @param {mat2d} b the second operand
	 * @param {Number} scale the amount to scale b's elements by before adding
	 * @returns {mat2d} out
	 */
	function multiplyScalarAndAdd$2(out, a, b, scale) {
	  out[0] = a[0] + b[0] * scale;
	  out[1] = a[1] + b[1] * scale;
	  out[2] = a[2] + b[2] * scale;
	  out[3] = a[3] + b[3] * scale;
	  out[4] = a[4] + b[4] * scale;
	  out[5] = a[5] + b[5] * scale;
	  return out;
	}

	/**
	 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {mat2d} a The first matrix.
	 * @param {mat2d} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	function exactEquals$7(a, b) {
	  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
	}

	/**
	 * Returns whether or not the matrices have approximately the same elements in the same position.
	 *
	 * @param {mat2d} a The first matrix.
	 * @param {mat2d} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	function equals$7(a, b) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3],
	      a4 = a[4],
	      a5 = a[5];
	  var b0 = b[0],
	      b1 = b[1],
	      b2 = b[2],
	      b3 = b[3],
	      b4 = b[4],
	      b5 = b[5];
	  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
	}

	/**
	 * Alias for {@link mat2d.multiply}
	 * @function
	 */
	var mul$7 = multiply$7;

	/**
	 * Alias for {@link mat2d.subtract}
	 * @function
	 */
	var sub$5 = subtract$5;

	var mat2d = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$7,
		clone: clone$7,
		copy: copy$7,
		identity: identity$4,
		fromValues: fromValues$7,
		set: set$7,
		invert: invert$4,
		determinant: determinant$2,
		multiply: multiply$7,
		rotate: rotate$3,
		scale: scale$7,
		translate: translate$3,
		fromRotation: fromRotation$3,
		fromScaling: fromScaling$2,
		fromTranslation: fromTranslation$3,
		str: str$7,
		frob: frob$2,
		add: add$7,
		subtract: subtract$5,
		multiplyScalar: multiplyScalar$2,
		multiplyScalarAndAdd: multiplyScalarAndAdd$2,
		exactEquals: exactEquals$7,
		equals: equals$7,
		mul: mul$7,
		sub: sub$5
	});

	/**
	 * 3x3 Matrix
	 * @module mat3
	 */

	/**
	 * Creates a new identity mat3
	 *
	 * @returns {mat3} a new 3x3 matrix
	 */
	function create$6() {
	  var out = new ARRAY_TYPE(9);
	  if (ARRAY_TYPE != Float32Array) {
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[5] = 0;
	    out[6] = 0;
	    out[7] = 0;
	  }
	  out[0] = 1;
	  out[4] = 1;
	  out[8] = 1;
	  return out;
	}

	/**
	 * Copies the upper-left 3x3 values into the given mat3.
	 *
	 * @param {mat3} out the receiving 3x3 matrix
	 * @param {mat4} a   the source 4x4 matrix
	 * @returns {mat3} out
	 */
	function fromMat4$1(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[4];
	  out[4] = a[5];
	  out[5] = a[6];
	  out[6] = a[8];
	  out[7] = a[9];
	  out[8] = a[10];
	  return out;
	}

	/**
	 * Creates a new mat3 initialized with values from an existing matrix
	 *
	 * @param {mat3} a matrix to clone
	 * @returns {mat3} a new 3x3 matrix
	 */
	function clone$6(a) {
	  var out = new ARRAY_TYPE(9);
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  out[4] = a[4];
	  out[5] = a[5];
	  out[6] = a[6];
	  out[7] = a[7];
	  out[8] = a[8];
	  return out;
	}

	/**
	 * Copy the values from one mat3 to another
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	function copy$6(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  out[4] = a[4];
	  out[5] = a[5];
	  out[6] = a[6];
	  out[7] = a[7];
	  out[8] = a[8];
	  return out;
	}

	/**
	 * Create a new mat3 with the given values
	 *
	 * @param {Number} m00 Component in column 0, row 0 position (index 0)
	 * @param {Number} m01 Component in column 0, row 1 position (index 1)
	 * @param {Number} m02 Component in column 0, row 2 position (index 2)
	 * @param {Number} m10 Component in column 1, row 0 position (index 3)
	 * @param {Number} m11 Component in column 1, row 1 position (index 4)
	 * @param {Number} m12 Component in column 1, row 2 position (index 5)
	 * @param {Number} m20 Component in column 2, row 0 position (index 6)
	 * @param {Number} m21 Component in column 2, row 1 position (index 7)
	 * @param {Number} m22 Component in column 2, row 2 position (index 8)
	 * @returns {mat3} A new mat3
	 */
	function fromValues$6(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
	  var out = new ARRAY_TYPE(9);
	  out[0] = m00;
	  out[1] = m01;
	  out[2] = m02;
	  out[3] = m10;
	  out[4] = m11;
	  out[5] = m12;
	  out[6] = m20;
	  out[7] = m21;
	  out[8] = m22;
	  return out;
	}

	/**
	 * Set the components of a mat3 to the given values
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {Number} m00 Component in column 0, row 0 position (index 0)
	 * @param {Number} m01 Component in column 0, row 1 position (index 1)
	 * @param {Number} m02 Component in column 0, row 2 position (index 2)
	 * @param {Number} m10 Component in column 1, row 0 position (index 3)
	 * @param {Number} m11 Component in column 1, row 1 position (index 4)
	 * @param {Number} m12 Component in column 1, row 2 position (index 5)
	 * @param {Number} m20 Component in column 2, row 0 position (index 6)
	 * @param {Number} m21 Component in column 2, row 1 position (index 7)
	 * @param {Number} m22 Component in column 2, row 2 position (index 8)
	 * @returns {mat3} out
	 */
	function set$6(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
	  out[0] = m00;
	  out[1] = m01;
	  out[2] = m02;
	  out[3] = m10;
	  out[4] = m11;
	  out[5] = m12;
	  out[6] = m20;
	  out[7] = m21;
	  out[8] = m22;
	  return out;
	}

	/**
	 * Set a mat3 to the identity matrix
	 *
	 * @param {mat3} out the receiving matrix
	 * @returns {mat3} out
	 */
	function identity$3(out) {
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 1;
	  out[5] = 0;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 1;
	  return out;
	}

	/**
	 * Transpose the values of a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	function transpose$1(out, a) {
	  // If we are transposing ourselves we can skip a few steps but have to cache some values
	  if (out === a) {
	    var a01 = a[1],
	        a02 = a[2],
	        a12 = a[5];
	    out[1] = a[3];
	    out[2] = a[6];
	    out[3] = a01;
	    out[5] = a[7];
	    out[6] = a02;
	    out[7] = a12;
	  } else {
	    out[0] = a[0];
	    out[1] = a[3];
	    out[2] = a[6];
	    out[3] = a[1];
	    out[4] = a[4];
	    out[5] = a[7];
	    out[6] = a[2];
	    out[7] = a[5];
	    out[8] = a[8];
	  }

	  return out;
	}

	/**
	 * Inverts a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	function invert$3(out, a) {
	  var a00 = a[0],
	      a01 = a[1],
	      a02 = a[2];
	  var a10 = a[3],
	      a11 = a[4],
	      a12 = a[5];
	  var a20 = a[6],
	      a21 = a[7],
	      a22 = a[8];

	  var b01 = a22 * a11 - a12 * a21;
	  var b11 = -a22 * a10 + a12 * a20;
	  var b21 = a21 * a10 - a11 * a20;

	  // Calculate the determinant
	  var det = a00 * b01 + a01 * b11 + a02 * b21;

	  if (!det) {
	    return null;
	  }
	  det = 1.0 / det;

	  out[0] = b01 * det;
	  out[1] = (-a22 * a01 + a02 * a21) * det;
	  out[2] = (a12 * a01 - a02 * a11) * det;
	  out[3] = b11 * det;
	  out[4] = (a22 * a00 - a02 * a20) * det;
	  out[5] = (-a12 * a00 + a02 * a10) * det;
	  out[6] = b21 * det;
	  out[7] = (-a21 * a00 + a01 * a20) * det;
	  out[8] = (a11 * a00 - a01 * a10) * det;
	  return out;
	}

	/**
	 * Calculates the adjugate of a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the source matrix
	 * @returns {mat3} out
	 */
	function adjoint$1(out, a) {
	  var a00 = a[0],
	      a01 = a[1],
	      a02 = a[2];
	  var a10 = a[3],
	      a11 = a[4],
	      a12 = a[5];
	  var a20 = a[6],
	      a21 = a[7],
	      a22 = a[8];

	  out[0] = a11 * a22 - a12 * a21;
	  out[1] = a02 * a21 - a01 * a22;
	  out[2] = a01 * a12 - a02 * a11;
	  out[3] = a12 * a20 - a10 * a22;
	  out[4] = a00 * a22 - a02 * a20;
	  out[5] = a02 * a10 - a00 * a12;
	  out[6] = a10 * a21 - a11 * a20;
	  out[7] = a01 * a20 - a00 * a21;
	  out[8] = a00 * a11 - a01 * a10;
	  return out;
	}

	/**
	 * Calculates the determinant of a mat3
	 *
	 * @param {mat3} a the source matrix
	 * @returns {Number} determinant of a
	 */
	function determinant$1(a) {
	  var a00 = a[0],
	      a01 = a[1],
	      a02 = a[2];
	  var a10 = a[3],
	      a11 = a[4],
	      a12 = a[5];
	  var a20 = a[6],
	      a21 = a[7],
	      a22 = a[8];

	  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
	}

	/**
	 * Multiplies two mat3's
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the first operand
	 * @param {mat3} b the second operand
	 * @returns {mat3} out
	 */
	function multiply$6(out, a, b) {
	  var a00 = a[0],
	      a01 = a[1],
	      a02 = a[2];
	  var a10 = a[3],
	      a11 = a[4],
	      a12 = a[5];
	  var a20 = a[6],
	      a21 = a[7],
	      a22 = a[8];

	  var b00 = b[0],
	      b01 = b[1],
	      b02 = b[2];
	  var b10 = b[3],
	      b11 = b[4],
	      b12 = b[5];
	  var b20 = b[6],
	      b21 = b[7],
	      b22 = b[8];

	  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
	  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
	  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

	  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
	  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
	  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

	  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
	  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
	  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
	  return out;
	}

	/**
	 * Translate a mat3 by the given vector
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the matrix to translate
	 * @param {vec2} v vector to translate by
	 * @returns {mat3} out
	 */
	function translate$2(out, a, v) {
	  var a00 = a[0],
	      a01 = a[1],
	      a02 = a[2],
	      a10 = a[3],
	      a11 = a[4],
	      a12 = a[5],
	      a20 = a[6],
	      a21 = a[7],
	      a22 = a[8],
	      x = v[0],
	      y = v[1];

	  out[0] = a00;
	  out[1] = a01;
	  out[2] = a02;

	  out[3] = a10;
	  out[4] = a11;
	  out[5] = a12;

	  out[6] = x * a00 + y * a10 + a20;
	  out[7] = x * a01 + y * a11 + a21;
	  out[8] = x * a02 + y * a12 + a22;
	  return out;
	}

	/**
	 * Rotates a mat3 by the given angle
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat3} out
	 */
	function rotate$2(out, a, rad) {
	  var a00 = a[0],
	      a01 = a[1],
	      a02 = a[2],
	      a10 = a[3],
	      a11 = a[4],
	      a12 = a[5],
	      a20 = a[6],
	      a21 = a[7],
	      a22 = a[8],
	      s = Math.sin(rad),
	      c = Math.cos(rad);

	  out[0] = c * a00 + s * a10;
	  out[1] = c * a01 + s * a11;
	  out[2] = c * a02 + s * a12;

	  out[3] = c * a10 - s * a00;
	  out[4] = c * a11 - s * a01;
	  out[5] = c * a12 - s * a02;

	  out[6] = a20;
	  out[7] = a21;
	  out[8] = a22;
	  return out;
	}
	/**
	 * Scales the mat3 by the dimensions in the given vec2
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the matrix to rotate
	 * @param {vec2} v the vec2 to scale the matrix by
	 * @returns {mat3} out
	 **/
	function scale$6(out, a, v) {
	  var x = v[0],
	      y = v[1];

	  out[0] = x * a[0];
	  out[1] = x * a[1];
	  out[2] = x * a[2];

	  out[3] = y * a[3];
	  out[4] = y * a[4];
	  out[5] = y * a[5];

	  out[6] = a[6];
	  out[7] = a[7];
	  out[8] = a[8];
	  return out;
	}

	/**
	 * Creates a matrix from a vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat3.identity(dest);
	 *     mat3.translate(dest, dest, vec);
	 *
	 * @param {mat3} out mat3 receiving operation result
	 * @param {vec2} v Translation vector
	 * @returns {mat3} out
	 */
	function fromTranslation$2(out, v) {
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 1;
	  out[5] = 0;
	  out[6] = v[0];
	  out[7] = v[1];
	  out[8] = 1;
	  return out;
	}

	/**
	 * Creates a matrix from a given angle
	 * This is equivalent to (but much faster than):
	 *
	 *     mat3.identity(dest);
	 *     mat3.rotate(dest, dest, rad);
	 *
	 * @param {mat3} out mat3 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat3} out
	 */
	function fromRotation$2(out, rad) {
	  var s = Math.sin(rad),
	      c = Math.cos(rad);

	  out[0] = c;
	  out[1] = s;
	  out[2] = 0;

	  out[3] = -s;
	  out[4] = c;
	  out[5] = 0;

	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 1;
	  return out;
	}

	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat3.identity(dest);
	 *     mat3.scale(dest, dest, vec);
	 *
	 * @param {mat3} out mat3 receiving operation result
	 * @param {vec2} v Scaling vector
	 * @returns {mat3} out
	 */
	function fromScaling$1(out, v) {
	  out[0] = v[0];
	  out[1] = 0;
	  out[2] = 0;

	  out[3] = 0;
	  out[4] = v[1];
	  out[5] = 0;

	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 1;
	  return out;
	}

	/**
	 * Copies the values from a mat2d into a mat3
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat2d} a the matrix to copy
	 * @returns {mat3} out
	 **/
	function fromMat2d(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = 0;

	  out[3] = a[2];
	  out[4] = a[3];
	  out[5] = 0;

	  out[6] = a[4];
	  out[7] = a[5];
	  out[8] = 1;
	  return out;
	}

	/**
	* Calculates a 3x3 matrix from the given quaternion
	*
	* @param {mat3} out mat3 receiving operation result
	* @param {quat} q Quaternion to create matrix from
	*
	* @returns {mat3} out
	*/
	function fromQuat$1(out, q) {
	  var x = q[0],
	      y = q[1],
	      z = q[2],
	      w = q[3];
	  var x2 = x + x;
	  var y2 = y + y;
	  var z2 = z + z;

	  var xx = x * x2;
	  var yx = y * x2;
	  var yy = y * y2;
	  var zx = z * x2;
	  var zy = z * y2;
	  var zz = z * z2;
	  var wx = w * x2;
	  var wy = w * y2;
	  var wz = w * z2;

	  out[0] = 1 - yy - zz;
	  out[3] = yx - wz;
	  out[6] = zx + wy;

	  out[1] = yx + wz;
	  out[4] = 1 - xx - zz;
	  out[7] = zy - wx;

	  out[2] = zx - wy;
	  out[5] = zy + wx;
	  out[8] = 1 - xx - yy;

	  return out;
	}

	/**
	* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
	*
	* @param {mat3} out mat3 receiving operation result
	* @param {mat4} a Mat4 to derive the normal matrix from
	*
	* @returns {mat3} out
	*/
	function normalFromMat4(out, a) {
	  var a00 = a[0],
	      a01 = a[1],
	      a02 = a[2],
	      a03 = a[3];
	  var a10 = a[4],
	      a11 = a[5],
	      a12 = a[6],
	      a13 = a[7];
	  var a20 = a[8],
	      a21 = a[9],
	      a22 = a[10],
	      a23 = a[11];
	  var a30 = a[12],
	      a31 = a[13],
	      a32 = a[14],
	      a33 = a[15];

	  var b00 = a00 * a11 - a01 * a10;
	  var b01 = a00 * a12 - a02 * a10;
	  var b02 = a00 * a13 - a03 * a10;
	  var b03 = a01 * a12 - a02 * a11;
	  var b04 = a01 * a13 - a03 * a11;
	  var b05 = a02 * a13 - a03 * a12;
	  var b06 = a20 * a31 - a21 * a30;
	  var b07 = a20 * a32 - a22 * a30;
	  var b08 = a20 * a33 - a23 * a30;
	  var b09 = a21 * a32 - a22 * a31;
	  var b10 = a21 * a33 - a23 * a31;
	  var b11 = a22 * a33 - a23 * a32;

	  // Calculate the determinant
	  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	  if (!det) {
	    return null;
	  }
	  det = 1.0 / det;

	  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

	  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

	  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

	  return out;
	}

	/**
	 * Generates a 2D projection matrix with the given bounds
	 *
	 * @param {mat3} out mat3 frustum matrix will be written into
	 * @param {number} width Width of your gl context
	 * @param {number} height Height of gl context
	 * @returns {mat3} out
	 */
	function projection(out, width, height) {
	  out[0] = 2 / width;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = -2 / height;
	  out[5] = 0;
	  out[6] = -1;
	  out[7] = 1;
	  out[8] = 1;
	  return out;
	}

	/**
	 * Returns a string representation of a mat3
	 *
	 * @param {mat3} a matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	function str$6(a) {
	  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
	}

	/**
	 * Returns Frobenius norm of a mat3
	 *
	 * @param {mat3} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	function frob$1(a) {
	  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
	}

	/**
	 * Adds two mat3's
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the first operand
	 * @param {mat3} b the second operand
	 * @returns {mat3} out
	 */
	function add$6(out, a, b) {
	  out[0] = a[0] + b[0];
	  out[1] = a[1] + b[1];
	  out[2] = a[2] + b[2];
	  out[3] = a[3] + b[3];
	  out[4] = a[4] + b[4];
	  out[5] = a[5] + b[5];
	  out[6] = a[6] + b[6];
	  out[7] = a[7] + b[7];
	  out[8] = a[8] + b[8];
	  return out;
	}

	/**
	 * Subtracts matrix b from matrix a
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the first operand
	 * @param {mat3} b the second operand
	 * @returns {mat3} out
	 */
	function subtract$4(out, a, b) {
	  out[0] = a[0] - b[0];
	  out[1] = a[1] - b[1];
	  out[2] = a[2] - b[2];
	  out[3] = a[3] - b[3];
	  out[4] = a[4] - b[4];
	  out[5] = a[5] - b[5];
	  out[6] = a[6] - b[6];
	  out[7] = a[7] - b[7];
	  out[8] = a[8] - b[8];
	  return out;
	}

	/**
	 * Multiply each element of the matrix by a scalar.
	 *
	 * @param {mat3} out the receiving matrix
	 * @param {mat3} a the matrix to scale
	 * @param {Number} b amount to scale the matrix's elements by
	 * @returns {mat3} out
	 */
	function multiplyScalar$1(out, a, b) {
	  out[0] = a[0] * b;
	  out[1] = a[1] * b;
	  out[2] = a[2] * b;
	  out[3] = a[3] * b;
	  out[4] = a[4] * b;
	  out[5] = a[5] * b;
	  out[6] = a[6] * b;
	  out[7] = a[7] * b;
	  out[8] = a[8] * b;
	  return out;
	}

	/**
	 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
	 *
	 * @param {mat3} out the receiving vector
	 * @param {mat3} a the first operand
	 * @param {mat3} b the second operand
	 * @param {Number} scale the amount to scale b's elements by before adding
	 * @returns {mat3} out
	 */
	function multiplyScalarAndAdd$1(out, a, b, scale) {
	  out[0] = a[0] + b[0] * scale;
	  out[1] = a[1] + b[1] * scale;
	  out[2] = a[2] + b[2] * scale;
	  out[3] = a[3] + b[3] * scale;
	  out[4] = a[4] + b[4] * scale;
	  out[5] = a[5] + b[5] * scale;
	  out[6] = a[6] + b[6] * scale;
	  out[7] = a[7] + b[7] * scale;
	  out[8] = a[8] + b[8] * scale;
	  return out;
	}

	/**
	 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {mat3} a The first matrix.
	 * @param {mat3} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	function exactEquals$6(a, b) {
	  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
	}

	/**
	 * Returns whether or not the matrices have approximately the same elements in the same position.
	 *
	 * @param {mat3} a The first matrix.
	 * @param {mat3} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	function equals$6(a, b) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3],
	      a4 = a[4],
	      a5 = a[5],
	      a6 = a[6],
	      a7 = a[7],
	      a8 = a[8];
	  var b0 = b[0],
	      b1 = b[1],
	      b2 = b[2],
	      b3 = b[3],
	      b4 = b[4],
	      b5 = b[5],
	      b6 = b[6],
	      b7 = b[7],
	      b8 = b[8];
	  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
	}

	/**
	 * Alias for {@link mat3.multiply}
	 * @function
	 */
	var mul$6 = multiply$6;

	/**
	 * Alias for {@link mat3.subtract}
	 * @function
	 */
	var sub$4 = subtract$4;

	var mat3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$6,
		fromMat4: fromMat4$1,
		clone: clone$6,
		copy: copy$6,
		fromValues: fromValues$6,
		set: set$6,
		identity: identity$3,
		transpose: transpose$1,
		invert: invert$3,
		adjoint: adjoint$1,
		determinant: determinant$1,
		multiply: multiply$6,
		translate: translate$2,
		rotate: rotate$2,
		scale: scale$6,
		fromTranslation: fromTranslation$2,
		fromRotation: fromRotation$2,
		fromScaling: fromScaling$1,
		fromMat2d: fromMat2d,
		fromQuat: fromQuat$1,
		normalFromMat4: normalFromMat4,
		projection: projection,
		str: str$6,
		frob: frob$1,
		add: add$6,
		subtract: subtract$4,
		multiplyScalar: multiplyScalar$1,
		multiplyScalarAndAdd: multiplyScalarAndAdd$1,
		exactEquals: exactEquals$6,
		equals: equals$6,
		mul: mul$6,
		sub: sub$4
	});

	/**
	 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
	 * @module mat4
	 */

	/**
	 * Creates a new identity mat4
	 *
	 * @returns {mat4} a new 4x4 matrix
	 */
	function create$5() {
	  var out = new ARRAY_TYPE(16);
	  if (ARRAY_TYPE != Float32Array) {
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	  }
	  out[0] = 1;
	  out[5] = 1;
	  out[10] = 1;
	  out[15] = 1;
	  return out;
	}

	/**
	 * Creates a new mat4 initialized with values from an existing matrix
	 *
	 * @param {mat4} a matrix to clone
	 * @returns {mat4} a new 4x4 matrix
	 */
	function clone$5(a) {
	  var out = new ARRAY_TYPE(16);
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  out[4] = a[4];
	  out[5] = a[5];
	  out[6] = a[6];
	  out[7] = a[7];
	  out[8] = a[8];
	  out[9] = a[9];
	  out[10] = a[10];
	  out[11] = a[11];
	  out[12] = a[12];
	  out[13] = a[13];
	  out[14] = a[14];
	  out[15] = a[15];
	  return out;
	}

	/**
	 * Copy the values from one mat4 to another
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	function copy$5(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  out[4] = a[4];
	  out[5] = a[5];
	  out[6] = a[6];
	  out[7] = a[7];
	  out[8] = a[8];
	  out[9] = a[9];
	  out[10] = a[10];
	  out[11] = a[11];
	  out[12] = a[12];
	  out[13] = a[13];
	  out[14] = a[14];
	  out[15] = a[15];
	  return out;
	}

	/**
	 * Create a new mat4 with the given values
	 *
	 * @param {Number} m00 Component in column 0, row 0 position (index 0)
	 * @param {Number} m01 Component in column 0, row 1 position (index 1)
	 * @param {Number} m02 Component in column 0, row 2 position (index 2)
	 * @param {Number} m03 Component in column 0, row 3 position (index 3)
	 * @param {Number} m10 Component in column 1, row 0 position (index 4)
	 * @param {Number} m11 Component in column 1, row 1 position (index 5)
	 * @param {Number} m12 Component in column 1, row 2 position (index 6)
	 * @param {Number} m13 Component in column 1, row 3 position (index 7)
	 * @param {Number} m20 Component in column 2, row 0 position (index 8)
	 * @param {Number} m21 Component in column 2, row 1 position (index 9)
	 * @param {Number} m22 Component in column 2, row 2 position (index 10)
	 * @param {Number} m23 Component in column 2, row 3 position (index 11)
	 * @param {Number} m30 Component in column 3, row 0 position (index 12)
	 * @param {Number} m31 Component in column 3, row 1 position (index 13)
	 * @param {Number} m32 Component in column 3, row 2 position (index 14)
	 * @param {Number} m33 Component in column 3, row 3 position (index 15)
	 * @returns {mat4} A new mat4
	 */
	function fromValues$5(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
	  var out = new ARRAY_TYPE(16);
	  out[0] = m00;
	  out[1] = m01;
	  out[2] = m02;
	  out[3] = m03;
	  out[4] = m10;
	  out[5] = m11;
	  out[6] = m12;
	  out[7] = m13;
	  out[8] = m20;
	  out[9] = m21;
	  out[10] = m22;
	  out[11] = m23;
	  out[12] = m30;
	  out[13] = m31;
	  out[14] = m32;
	  out[15] = m33;
	  return out;
	}

	/**
	 * Set the components of a mat4 to the given values
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {Number} m00 Component in column 0, row 0 position (index 0)
	 * @param {Number} m01 Component in column 0, row 1 position (index 1)
	 * @param {Number} m02 Component in column 0, row 2 position (index 2)
	 * @param {Number} m03 Component in column 0, row 3 position (index 3)
	 * @param {Number} m10 Component in column 1, row 0 position (index 4)
	 * @param {Number} m11 Component in column 1, row 1 position (index 5)
	 * @param {Number} m12 Component in column 1, row 2 position (index 6)
	 * @param {Number} m13 Component in column 1, row 3 position (index 7)
	 * @param {Number} m20 Component in column 2, row 0 position (index 8)
	 * @param {Number} m21 Component in column 2, row 1 position (index 9)
	 * @param {Number} m22 Component in column 2, row 2 position (index 10)
	 * @param {Number} m23 Component in column 2, row 3 position (index 11)
	 * @param {Number} m30 Component in column 3, row 0 position (index 12)
	 * @param {Number} m31 Component in column 3, row 1 position (index 13)
	 * @param {Number} m32 Component in column 3, row 2 position (index 14)
	 * @param {Number} m33 Component in column 3, row 3 position (index 15)
	 * @returns {mat4} out
	 */
	function set$5(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
	  out[0] = m00;
	  out[1] = m01;
	  out[2] = m02;
	  out[3] = m03;
	  out[4] = m10;
	  out[5] = m11;
	  out[6] = m12;
	  out[7] = m13;
	  out[8] = m20;
	  out[9] = m21;
	  out[10] = m22;
	  out[11] = m23;
	  out[12] = m30;
	  out[13] = m31;
	  out[14] = m32;
	  out[15] = m33;
	  return out;
	}

	/**
	 * Set a mat4 to the identity matrix
	 *
	 * @param {mat4} out the receiving matrix
	 * @returns {mat4} out
	 */
	function identity$2(out) {
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = 1;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = 1;
	  out[11] = 0;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;
	  return out;
	}

	/**
	 * Transpose the values of a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	function transpose(out, a) {
	  // If we are transposing ourselves we can skip a few steps but have to cache some values
	  if (out === a) {
	    var a01 = a[1],
	        a02 = a[2],
	        a03 = a[3];
	    var a12 = a[6],
	        a13 = a[7];
	    var a23 = a[11];

	    out[1] = a[4];
	    out[2] = a[8];
	    out[3] = a[12];
	    out[4] = a01;
	    out[6] = a[9];
	    out[7] = a[13];
	    out[8] = a02;
	    out[9] = a12;
	    out[11] = a[14];
	    out[12] = a03;
	    out[13] = a13;
	    out[14] = a23;
	  } else {
	    out[0] = a[0];
	    out[1] = a[4];
	    out[2] = a[8];
	    out[3] = a[12];
	    out[4] = a[1];
	    out[5] = a[5];
	    out[6] = a[9];
	    out[7] = a[13];
	    out[8] = a[2];
	    out[9] = a[6];
	    out[10] = a[10];
	    out[11] = a[14];
	    out[12] = a[3];
	    out[13] = a[7];
	    out[14] = a[11];
	    out[15] = a[15];
	  }

	  return out;
	}

	/**
	 * Inverts a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	function invert$2(out, a) {
	  var a00 = a[0],
	      a01 = a[1],
	      a02 = a[2],
	      a03 = a[3];
	  var a10 = a[4],
	      a11 = a[5],
	      a12 = a[6],
	      a13 = a[7];
	  var a20 = a[8],
	      a21 = a[9],
	      a22 = a[10],
	      a23 = a[11];
	  var a30 = a[12],
	      a31 = a[13],
	      a32 = a[14],
	      a33 = a[15];

	  var b00 = a00 * a11 - a01 * a10;
	  var b01 = a00 * a12 - a02 * a10;
	  var b02 = a00 * a13 - a03 * a10;
	  var b03 = a01 * a12 - a02 * a11;
	  var b04 = a01 * a13 - a03 * a11;
	  var b05 = a02 * a13 - a03 * a12;
	  var b06 = a20 * a31 - a21 * a30;
	  var b07 = a20 * a32 - a22 * a30;
	  var b08 = a20 * a33 - a23 * a30;
	  var b09 = a21 * a32 - a22 * a31;
	  var b10 = a21 * a33 - a23 * a31;
	  var b11 = a22 * a33 - a23 * a32;

	  // Calculate the determinant
	  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	  if (!det) {
	    return null;
	  }
	  det = 1.0 / det;

	  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

	  return out;
	}

	/**
	 * Calculates the adjugate of a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	function adjoint(out, a) {
	  var a00 = a[0],
	      a01 = a[1],
	      a02 = a[2],
	      a03 = a[3];
	  var a10 = a[4],
	      a11 = a[5],
	      a12 = a[6],
	      a13 = a[7];
	  var a20 = a[8],
	      a21 = a[9],
	      a22 = a[10],
	      a23 = a[11];
	  var a30 = a[12],
	      a31 = a[13],
	      a32 = a[14],
	      a33 = a[15];

	  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
	  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
	  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
	  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
	  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
	  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
	  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
	  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
	  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
	  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
	  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
	  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
	  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
	  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
	  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
	  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
	  return out;
	}

	/**
	 * Calculates the determinant of a mat4
	 *
	 * @param {mat4} a the source matrix
	 * @returns {Number} determinant of a
	 */
	function determinant(a) {
	  var a00 = a[0],
	      a01 = a[1],
	      a02 = a[2],
	      a03 = a[3];
	  var a10 = a[4],
	      a11 = a[5],
	      a12 = a[6],
	      a13 = a[7];
	  var a20 = a[8],
	      a21 = a[9],
	      a22 = a[10],
	      a23 = a[11];
	  var a30 = a[12],
	      a31 = a[13],
	      a32 = a[14],
	      a33 = a[15];

	  var b00 = a00 * a11 - a01 * a10;
	  var b01 = a00 * a12 - a02 * a10;
	  var b02 = a00 * a13 - a03 * a10;
	  var b03 = a01 * a12 - a02 * a11;
	  var b04 = a01 * a13 - a03 * a11;
	  var b05 = a02 * a13 - a03 * a12;
	  var b06 = a20 * a31 - a21 * a30;
	  var b07 = a20 * a32 - a22 * a30;
	  var b08 = a20 * a33 - a23 * a30;
	  var b09 = a21 * a32 - a22 * a31;
	  var b10 = a21 * a33 - a23 * a31;
	  var b11 = a22 * a33 - a23 * a32;

	  // Calculate the determinant
	  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	}

	/**
	 * Multiplies two mat4s
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the first operand
	 * @param {mat4} b the second operand
	 * @returns {mat4} out
	 */
	function multiply$5(out, a, b) {
	  var a00 = a[0],
	      a01 = a[1],
	      a02 = a[2],
	      a03 = a[3];
	  var a10 = a[4],
	      a11 = a[5],
	      a12 = a[6],
	      a13 = a[7];
	  var a20 = a[8],
	      a21 = a[9],
	      a22 = a[10],
	      a23 = a[11];
	  var a30 = a[12],
	      a31 = a[13],
	      a32 = a[14],
	      a33 = a[15];

	  // Cache only the current line of the second matrix
	  var b0 = b[0],
	      b1 = b[1],
	      b2 = b[2],
	      b3 = b[3];
	  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

	  b0 = b[4];b1 = b[5];b2 = b[6];b3 = b[7];
	  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

	  b0 = b[8];b1 = b[9];b2 = b[10];b3 = b[11];
	  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

	  b0 = b[12];b1 = b[13];b2 = b[14];b3 = b[15];
	  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	  return out;
	}

	/**
	 * Translate a mat4 by the given vector
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to translate
	 * @param {vec3} v vector to translate by
	 * @returns {mat4} out
	 */
	function translate$1(out, a, v) {
	  var x = v[0],
	      y = v[1],
	      z = v[2];
	  var a00 = void 0,
	      a01 = void 0,
	      a02 = void 0,
	      a03 = void 0;
	  var a10 = void 0,
	      a11 = void 0,
	      a12 = void 0,
	      a13 = void 0;
	  var a20 = void 0,
	      a21 = void 0,
	      a22 = void 0,
	      a23 = void 0;

	  if (a === out) {
	    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
	    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
	    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
	    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	  } else {
	    a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
	    a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
	    a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];

	    out[0] = a00;out[1] = a01;out[2] = a02;out[3] = a03;
	    out[4] = a10;out[5] = a11;out[6] = a12;out[7] = a13;
	    out[8] = a20;out[9] = a21;out[10] = a22;out[11] = a23;

	    out[12] = a00 * x + a10 * y + a20 * z + a[12];
	    out[13] = a01 * x + a11 * y + a21 * z + a[13];
	    out[14] = a02 * x + a12 * y + a22 * z + a[14];
	    out[15] = a03 * x + a13 * y + a23 * z + a[15];
	  }

	  return out;
	}

	/**
	 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to scale
	 * @param {vec3} v the vec3 to scale the matrix by
	 * @returns {mat4} out
	 **/
	function scale$5(out, a, v) {
	  var x = v[0],
	      y = v[1],
	      z = v[2];

	  out[0] = a[0] * x;
	  out[1] = a[1] * x;
	  out[2] = a[2] * x;
	  out[3] = a[3] * x;
	  out[4] = a[4] * y;
	  out[5] = a[5] * y;
	  out[6] = a[6] * y;
	  out[7] = a[7] * y;
	  out[8] = a[8] * z;
	  out[9] = a[9] * z;
	  out[10] = a[10] * z;
	  out[11] = a[11] * z;
	  out[12] = a[12];
	  out[13] = a[13];
	  out[14] = a[14];
	  out[15] = a[15];
	  return out;
	}

	/**
	 * Rotates a mat4 by the given angle around the given axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @param {vec3} axis the axis to rotate around
	 * @returns {mat4} out
	 */
	function rotate$1(out, a, rad, axis) {
	  var x = axis[0],
	      y = axis[1],
	      z = axis[2];
	  var len = Math.sqrt(x * x + y * y + z * z);
	  var s = void 0,
	      c = void 0,
	      t = void 0;
	  var a00 = void 0,
	      a01 = void 0,
	      a02 = void 0,
	      a03 = void 0;
	  var a10 = void 0,
	      a11 = void 0,
	      a12 = void 0,
	      a13 = void 0;
	  var a20 = void 0,
	      a21 = void 0,
	      a22 = void 0,
	      a23 = void 0;
	  var b00 = void 0,
	      b01 = void 0,
	      b02 = void 0;
	  var b10 = void 0,
	      b11 = void 0,
	      b12 = void 0;
	  var b20 = void 0,
	      b21 = void 0,
	      b22 = void 0;

	  if (len < EPSILON) {
	    return null;
	  }

	  len = 1 / len;
	  x *= len;
	  y *= len;
	  z *= len;

	  s = Math.sin(rad);
	  c = Math.cos(rad);
	  t = 1 - c;

	  a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
	  a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
	  a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];

	  // Construct the elements of the rotation matrix
	  b00 = x * x * t + c;b01 = y * x * t + z * s;b02 = z * x * t - y * s;
	  b10 = x * y * t - z * s;b11 = y * y * t + c;b12 = z * y * t + x * s;
	  b20 = x * z * t + y * s;b21 = y * z * t - x * s;b22 = z * z * t + c;

	  // Perform rotation-specific matrix multiplication
	  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
	  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
	  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
	  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
	  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
	  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
	  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
	  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
	  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
	  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
	  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
	  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

	  if (a !== out) {
	    // If the source and destination differ, copy the unchanged last row
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	  }
	  return out;
	}

	/**
	 * Rotates a matrix by the given angle around the X axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function rotateX$3(out, a, rad) {
	  var s = Math.sin(rad);
	  var c = Math.cos(rad);
	  var a10 = a[4];
	  var a11 = a[5];
	  var a12 = a[6];
	  var a13 = a[7];
	  var a20 = a[8];
	  var a21 = a[9];
	  var a22 = a[10];
	  var a23 = a[11];

	  if (a !== out) {
	    // If the source and destination differ, copy the unchanged rows
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	  }

	  // Perform axis-specific matrix multiplication
	  out[4] = a10 * c + a20 * s;
	  out[5] = a11 * c + a21 * s;
	  out[6] = a12 * c + a22 * s;
	  out[7] = a13 * c + a23 * s;
	  out[8] = a20 * c - a10 * s;
	  out[9] = a21 * c - a11 * s;
	  out[10] = a22 * c - a12 * s;
	  out[11] = a23 * c - a13 * s;
	  return out;
	}

	/**
	 * Rotates a matrix by the given angle around the Y axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function rotateY$3(out, a, rad) {
	  var s = Math.sin(rad);
	  var c = Math.cos(rad);
	  var a00 = a[0];
	  var a01 = a[1];
	  var a02 = a[2];
	  var a03 = a[3];
	  var a20 = a[8];
	  var a21 = a[9];
	  var a22 = a[10];
	  var a23 = a[11];

	  if (a !== out) {
	    // If the source and destination differ, copy the unchanged rows
	    out[4] = a[4];
	    out[5] = a[5];
	    out[6] = a[6];
	    out[7] = a[7];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	  }

	  // Perform axis-specific matrix multiplication
	  out[0] = a00 * c - a20 * s;
	  out[1] = a01 * c - a21 * s;
	  out[2] = a02 * c - a22 * s;
	  out[3] = a03 * c - a23 * s;
	  out[8] = a00 * s + a20 * c;
	  out[9] = a01 * s + a21 * c;
	  out[10] = a02 * s + a22 * c;
	  out[11] = a03 * s + a23 * c;
	  return out;
	}

	/**
	 * Rotates a matrix by the given angle around the Z axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function rotateZ$3(out, a, rad) {
	  var s = Math.sin(rad);
	  var c = Math.cos(rad);
	  var a00 = a[0];
	  var a01 = a[1];
	  var a02 = a[2];
	  var a03 = a[3];
	  var a10 = a[4];
	  var a11 = a[5];
	  var a12 = a[6];
	  var a13 = a[7];

	  if (a !== out) {
	    // If the source and destination differ, copy the unchanged last row
	    out[8] = a[8];
	    out[9] = a[9];
	    out[10] = a[10];
	    out[11] = a[11];
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	  }

	  // Perform axis-specific matrix multiplication
	  out[0] = a00 * c + a10 * s;
	  out[1] = a01 * c + a11 * s;
	  out[2] = a02 * c + a12 * s;
	  out[3] = a03 * c + a13 * s;
	  out[4] = a10 * c - a00 * s;
	  out[5] = a11 * c - a01 * s;
	  out[6] = a12 * c - a02 * s;
	  out[7] = a13 * c - a03 * s;
	  return out;
	}

	/**
	 * Creates a matrix from a vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, dest, vec);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {vec3} v Translation vector
	 * @returns {mat4} out
	 */
	function fromTranslation$1(out, v) {
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = 1;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = 1;
	  out[11] = 0;
	  out[12] = v[0];
	  out[13] = v[1];
	  out[14] = v[2];
	  out[15] = 1;
	  return out;
	}

	/**
	 * Creates a matrix from a vector scaling
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.scale(dest, dest, vec);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {vec3} v Scaling vector
	 * @returns {mat4} out
	 */
	function fromScaling(out, v) {
	  out[0] = v[0];
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = v[1];
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = v[2];
	  out[11] = 0;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;
	  return out;
	}

	/**
	 * Creates a matrix from a given angle around a given axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotate(dest, dest, rad, axis);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @param {vec3} axis the axis to rotate around
	 * @returns {mat4} out
	 */
	function fromRotation$1(out, rad, axis) {
	  var x = axis[0],
	      y = axis[1],
	      z = axis[2];
	  var len = Math.sqrt(x * x + y * y + z * z);
	  var s = void 0,
	      c = void 0,
	      t = void 0;

	  if (len < EPSILON) {
	    return null;
	  }

	  len = 1 / len;
	  x *= len;
	  y *= len;
	  z *= len;

	  s = Math.sin(rad);
	  c = Math.cos(rad);
	  t = 1 - c;

	  // Perform rotation-specific matrix multiplication
	  out[0] = x * x * t + c;
	  out[1] = y * x * t + z * s;
	  out[2] = z * x * t - y * s;
	  out[3] = 0;
	  out[4] = x * y * t - z * s;
	  out[5] = y * y * t + c;
	  out[6] = z * y * t + x * s;
	  out[7] = 0;
	  out[8] = x * z * t + y * s;
	  out[9] = y * z * t - x * s;
	  out[10] = z * z * t + c;
	  out[11] = 0;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;
	  return out;
	}

	/**
	 * Creates a matrix from the given angle around the X axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotateX(dest, dest, rad);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function fromXRotation(out, rad) {
	  var s = Math.sin(rad);
	  var c = Math.cos(rad);

	  // Perform axis-specific matrix multiplication
	  out[0] = 1;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = c;
	  out[6] = s;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = -s;
	  out[10] = c;
	  out[11] = 0;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;
	  return out;
	}

	/**
	 * Creates a matrix from the given angle around the Y axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotateY(dest, dest, rad);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function fromYRotation(out, rad) {
	  var s = Math.sin(rad);
	  var c = Math.cos(rad);

	  // Perform axis-specific matrix multiplication
	  out[0] = c;
	  out[1] = 0;
	  out[2] = -s;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = 1;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = s;
	  out[9] = 0;
	  out[10] = c;
	  out[11] = 0;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;
	  return out;
	}

	/**
	 * Creates a matrix from the given angle around the Z axis
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.rotateZ(dest, dest, rad);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function fromZRotation(out, rad) {
	  var s = Math.sin(rad);
	  var c = Math.cos(rad);

	  // Perform axis-specific matrix multiplication
	  out[0] = c;
	  out[1] = s;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = -s;
	  out[5] = c;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = 1;
	  out[11] = 0;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;
	  return out;
	}

	/**
	 * Creates a matrix from a quaternion rotation and vector translation
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     let quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @param {vec3} v Translation vector
	 * @returns {mat4} out
	 */
	function fromRotationTranslation$1(out, q, v) {
	  // Quaternion math
	  var x = q[0],
	      y = q[1],
	      z = q[2],
	      w = q[3];
	  var x2 = x + x;
	  var y2 = y + y;
	  var z2 = z + z;

	  var xx = x * x2;
	  var xy = x * y2;
	  var xz = x * z2;
	  var yy = y * y2;
	  var yz = y * z2;
	  var zz = z * z2;
	  var wx = w * x2;
	  var wy = w * y2;
	  var wz = w * z2;

	  out[0] = 1 - (yy + zz);
	  out[1] = xy + wz;
	  out[2] = xz - wy;
	  out[3] = 0;
	  out[4] = xy - wz;
	  out[5] = 1 - (xx + zz);
	  out[6] = yz + wx;
	  out[7] = 0;
	  out[8] = xz + wy;
	  out[9] = yz - wx;
	  out[10] = 1 - (xx + yy);
	  out[11] = 0;
	  out[12] = v[0];
	  out[13] = v[1];
	  out[14] = v[2];
	  out[15] = 1;

	  return out;
	}

	/**
	 * Creates a new mat4 from a dual quat.
	 *
	 * @param {mat4} out Matrix
	 * @param {quat2} a Dual Quaternion
	 * @returns {mat4} mat4 receiving operation result
	 */
	function fromQuat2(out, a) {
	  var translation = new ARRAY_TYPE(3);
	  var bx = -a[0],
	      by = -a[1],
	      bz = -a[2],
	      bw = a[3],
	      ax = a[4],
	      ay = a[5],
	      az = a[6],
	      aw = a[7];

	  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
	  //Only scale if it makes sense
	  if (magnitude > 0) {
	    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
	    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
	    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
	  } else {
	    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
	    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
	    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
	  }
	  fromRotationTranslation$1(out, a, translation);
	  return out;
	}

	/**
	 * Returns the translation vector component of a transformation
	 *  matrix. If a matrix is built with fromRotationTranslation,
	 *  the returned vector will be the same as the translation vector
	 *  originally supplied.
	 * @param  {vec3} out Vector to receive translation component
	 * @param  {mat4} mat Matrix to be decomposed (input)
	 * @return {vec3} out
	 */
	function getTranslation$1(out, mat) {
	  out[0] = mat[12];
	  out[1] = mat[13];
	  out[2] = mat[14];

	  return out;
	}

	/**
	 * Returns the scaling factor component of a transformation
	 *  matrix. If a matrix is built with fromRotationTranslationScale
	 *  with a normalized Quaternion paramter, the returned vector will be
	 *  the same as the scaling vector
	 *  originally supplied.
	 * @param  {vec3} out Vector to receive scaling factor component
	 * @param  {mat4} mat Matrix to be decomposed (input)
	 * @return {vec3} out
	 */
	function getScaling(out, mat) {
	  var m11 = mat[0];
	  var m12 = mat[1];
	  var m13 = mat[2];
	  var m21 = mat[4];
	  var m22 = mat[5];
	  var m23 = mat[6];
	  var m31 = mat[8];
	  var m32 = mat[9];
	  var m33 = mat[10];

	  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
	  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
	  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

	  return out;
	}

	/**
	 * Returns a quaternion representing the rotational component
	 *  of a transformation matrix. If a matrix is built with
	 *  fromRotationTranslation, the returned quaternion will be the
	 *  same as the quaternion originally supplied.
	 * @param {quat} out Quaternion to receive the rotation component
	 * @param {mat4} mat Matrix to be decomposed (input)
	 * @return {quat} out
	 */
	function getRotation(out, mat) {
	  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	  var trace = mat[0] + mat[5] + mat[10];
	  var S = 0;

	  if (trace > 0) {
	    S = Math.sqrt(trace + 1.0) * 2;
	    out[3] = 0.25 * S;
	    out[0] = (mat[6] - mat[9]) / S;
	    out[1] = (mat[8] - mat[2]) / S;
	    out[2] = (mat[1] - mat[4]) / S;
	  } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
	    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
	    out[3] = (mat[6] - mat[9]) / S;
	    out[0] = 0.25 * S;
	    out[1] = (mat[1] + mat[4]) / S;
	    out[2] = (mat[8] + mat[2]) / S;
	  } else if (mat[5] > mat[10]) {
	    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
	    out[3] = (mat[8] - mat[2]) / S;
	    out[0] = (mat[1] + mat[4]) / S;
	    out[1] = 0.25 * S;
	    out[2] = (mat[6] + mat[9]) / S;
	  } else {
	    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
	    out[3] = (mat[1] - mat[4]) / S;
	    out[0] = (mat[8] + mat[2]) / S;
	    out[1] = (mat[6] + mat[9]) / S;
	    out[2] = 0.25 * S;
	  }

	  return out;
	}

	/**
	 * Creates a matrix from a quaternion rotation, vector translation and vector scale
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     let quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *     mat4.scale(dest, scale)
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @param {vec3} v Translation vector
	 * @param {vec3} s Scaling vector
	 * @returns {mat4} out
	 */
	function fromRotationTranslationScale(out, q, v, s) {
	  // Quaternion math
	  var x = q[0],
	      y = q[1],
	      z = q[2],
	      w = q[3];
	  var x2 = x + x;
	  var y2 = y + y;
	  var z2 = z + z;

	  var xx = x * x2;
	  var xy = x * y2;
	  var xz = x * z2;
	  var yy = y * y2;
	  var yz = y * z2;
	  var zz = z * z2;
	  var wx = w * x2;
	  var wy = w * y2;
	  var wz = w * z2;
	  var sx = s[0];
	  var sy = s[1];
	  var sz = s[2];

	  out[0] = (1 - (yy + zz)) * sx;
	  out[1] = (xy + wz) * sx;
	  out[2] = (xz - wy) * sx;
	  out[3] = 0;
	  out[4] = (xy - wz) * sy;
	  out[5] = (1 - (xx + zz)) * sy;
	  out[6] = (yz + wx) * sy;
	  out[7] = 0;
	  out[8] = (xz + wy) * sz;
	  out[9] = (yz - wx) * sz;
	  out[10] = (1 - (xx + yy)) * sz;
	  out[11] = 0;
	  out[12] = v[0];
	  out[13] = v[1];
	  out[14] = v[2];
	  out[15] = 1;

	  return out;
	}

	/**
	 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
	 * This is equivalent to (but much faster than):
	 *
	 *     mat4.identity(dest);
	 *     mat4.translate(dest, vec);
	 *     mat4.translate(dest, origin);
	 *     let quatMat = mat4.create();
	 *     quat4.toMat4(quat, quatMat);
	 *     mat4.multiply(dest, quatMat);
	 *     mat4.scale(dest, scale)
	 *     mat4.translate(dest, negativeOrigin);
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @param {vec3} v Translation vector
	 * @param {vec3} s Scaling vector
	 * @param {vec3} o The origin vector around which to scale and rotate
	 * @returns {mat4} out
	 */
	function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
	  // Quaternion math
	  var x = q[0],
	      y = q[1],
	      z = q[2],
	      w = q[3];
	  var x2 = x + x;
	  var y2 = y + y;
	  var z2 = z + z;

	  var xx = x * x2;
	  var xy = x * y2;
	  var xz = x * z2;
	  var yy = y * y2;
	  var yz = y * z2;
	  var zz = z * z2;
	  var wx = w * x2;
	  var wy = w * y2;
	  var wz = w * z2;

	  var sx = s[0];
	  var sy = s[1];
	  var sz = s[2];

	  var ox = o[0];
	  var oy = o[1];
	  var oz = o[2];

	  var out0 = (1 - (yy + zz)) * sx;
	  var out1 = (xy + wz) * sx;
	  var out2 = (xz - wy) * sx;
	  var out4 = (xy - wz) * sy;
	  var out5 = (1 - (xx + zz)) * sy;
	  var out6 = (yz + wx) * sy;
	  var out8 = (xz + wy) * sz;
	  var out9 = (yz - wx) * sz;
	  var out10 = (1 - (xx + yy)) * sz;

	  out[0] = out0;
	  out[1] = out1;
	  out[2] = out2;
	  out[3] = 0;
	  out[4] = out4;
	  out[5] = out5;
	  out[6] = out6;
	  out[7] = 0;
	  out[8] = out8;
	  out[9] = out9;
	  out[10] = out10;
	  out[11] = 0;
	  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
	  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
	  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
	  out[15] = 1;

	  return out;
	}

	/**
	 * Calculates a 4x4 matrix from the given quaternion
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat} q Quaternion to create matrix from
	 *
	 * @returns {mat4} out
	 */
	function fromQuat(out, q) {
	  var x = q[0],
	      y = q[1],
	      z = q[2],
	      w = q[3];
	  var x2 = x + x;
	  var y2 = y + y;
	  var z2 = z + z;

	  var xx = x * x2;
	  var yx = y * x2;
	  var yy = y * y2;
	  var zx = z * x2;
	  var zy = z * y2;
	  var zz = z * z2;
	  var wx = w * x2;
	  var wy = w * y2;
	  var wz = w * z2;

	  out[0] = 1 - yy - zz;
	  out[1] = yx + wz;
	  out[2] = zx - wy;
	  out[3] = 0;

	  out[4] = yx - wz;
	  out[5] = 1 - xx - zz;
	  out[6] = zy + wx;
	  out[7] = 0;

	  out[8] = zx + wy;
	  out[9] = zy - wx;
	  out[10] = 1 - xx - yy;
	  out[11] = 0;

	  out[12] = 0;
	  out[13] = 0;
	  out[14] = 0;
	  out[15] = 1;

	  return out;
	}

	/**
	 * Generates a frustum matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {Number} left Left bound of the frustum
	 * @param {Number} right Right bound of the frustum
	 * @param {Number} bottom Bottom bound of the frustum
	 * @param {Number} top Top bound of the frustum
	 * @param {Number} near Near bound of the frustum
	 * @param {Number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	function frustum(out, left, right, bottom, top, near, far) {
	  var rl = 1 / (right - left);
	  var tb = 1 / (top - bottom);
	  var nf = 1 / (near - far);
	  out[0] = near * 2 * rl;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = near * 2 * tb;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = (right + left) * rl;
	  out[9] = (top + bottom) * tb;
	  out[10] = (far + near) * nf;
	  out[11] = -1;
	  out[12] = 0;
	  out[13] = 0;
	  out[14] = far * near * 2 * nf;
	  out[15] = 0;
	  return out;
	}

	/**
	 * Generates a perspective projection matrix with the given bounds.
	 * Passing null/undefined/no value for far will generate infinite projection matrix.
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} fovy Vertical field of view in radians
	 * @param {number} aspect Aspect ratio. typically viewport width/height
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum, can be null or Infinity
	 * @returns {mat4} out
	 */
	function perspective(out, fovy, aspect, near, far) {
	  var f = 1.0 / Math.tan(fovy / 2),
	      nf = void 0;
	  out[0] = f / aspect;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = f;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[11] = -1;
	  out[12] = 0;
	  out[13] = 0;
	  out[15] = 0;
	  if (far != null && far !== Infinity) {
	    nf = 1 / (near - far);
	    out[10] = (far + near) * nf;
	    out[14] = 2 * far * near * nf;
	  } else {
	    out[10] = -1;
	    out[14] = -2 * near;
	  }
	  return out;
	}

	/**
	 * Generates a perspective projection matrix with the given field of view.
	 * This is primarily useful for generating projection matrices to be used
	 * with the still experiemental WebVR API.
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	function perspectiveFromFieldOfView(out, fov, near, far) {
	  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
	  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
	  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
	  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
	  var xScale = 2.0 / (leftTan + rightTan);
	  var yScale = 2.0 / (upTan + downTan);

	  out[0] = xScale;
	  out[1] = 0.0;
	  out[2] = 0.0;
	  out[3] = 0.0;
	  out[4] = 0.0;
	  out[5] = yScale;
	  out[6] = 0.0;
	  out[7] = 0.0;
	  out[8] = -((leftTan - rightTan) * xScale * 0.5);
	  out[9] = (upTan - downTan) * yScale * 0.5;
	  out[10] = far / (near - far);
	  out[11] = -1.0;
	  out[12] = 0.0;
	  out[13] = 0.0;
	  out[14] = far * near / (near - far);
	  out[15] = 0.0;
	  return out;
	}

	/**
	 * Generates a orthogonal projection matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} left Left bound of the frustum
	 * @param {number} right Right bound of the frustum
	 * @param {number} bottom Bottom bound of the frustum
	 * @param {number} top Top bound of the frustum
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	function ortho(out, left, right, bottom, top, near, far) {
	  var lr = 1 / (left - right);
	  var bt = 1 / (bottom - top);
	  var nf = 1 / (near - far);
	  out[0] = -2 * lr;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 0;
	  out[4] = 0;
	  out[5] = -2 * bt;
	  out[6] = 0;
	  out[7] = 0;
	  out[8] = 0;
	  out[9] = 0;
	  out[10] = 2 * nf;
	  out[11] = 0;
	  out[12] = (left + right) * lr;
	  out[13] = (top + bottom) * bt;
	  out[14] = (far + near) * nf;
	  out[15] = 1;
	  return out;
	}

	/**
	 * Generates a look-at matrix with the given eye position, focal point, and up axis.
	 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {vec3} eye Position of the viewer
	 * @param {vec3} center Point the viewer is looking at
	 * @param {vec3} up vec3 pointing up
	 * @returns {mat4} out
	 */
	function lookAt(out, eye, center, up) {
	  var x0 = void 0,
	      x1 = void 0,
	      x2 = void 0,
	      y0 = void 0,
	      y1 = void 0,
	      y2 = void 0,
	      z0 = void 0,
	      z1 = void 0,
	      z2 = void 0,
	      len = void 0;
	  var eyex = eye[0];
	  var eyey = eye[1];
	  var eyez = eye[2];
	  var upx = up[0];
	  var upy = up[1];
	  var upz = up[2];
	  var centerx = center[0];
	  var centery = center[1];
	  var centerz = center[2];

	  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
	    return identity$2(out);
	  }

	  z0 = eyex - centerx;
	  z1 = eyey - centery;
	  z2 = eyez - centerz;

	  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
	  z0 *= len;
	  z1 *= len;
	  z2 *= len;

	  x0 = upy * z2 - upz * z1;
	  x1 = upz * z0 - upx * z2;
	  x2 = upx * z1 - upy * z0;
	  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
	  if (!len) {
	    x0 = 0;
	    x1 = 0;
	    x2 = 0;
	  } else {
	    len = 1 / len;
	    x0 *= len;
	    x1 *= len;
	    x2 *= len;
	  }

	  y0 = z1 * x2 - z2 * x1;
	  y1 = z2 * x0 - z0 * x2;
	  y2 = z0 * x1 - z1 * x0;

	  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
	  if (!len) {
	    y0 = 0;
	    y1 = 0;
	    y2 = 0;
	  } else {
	    len = 1 / len;
	    y0 *= len;
	    y1 *= len;
	    y2 *= len;
	  }

	  out[0] = x0;
	  out[1] = y0;
	  out[2] = z0;
	  out[3] = 0;
	  out[4] = x1;
	  out[5] = y1;
	  out[6] = z1;
	  out[7] = 0;
	  out[8] = x2;
	  out[9] = y2;
	  out[10] = z2;
	  out[11] = 0;
	  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	  out[15] = 1;

	  return out;
	}

	/**
	 * Generates a matrix that makes something look at something else.
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {vec3} eye Position of the viewer
	 * @param {vec3} center Point the viewer is looking at
	 * @param {vec3} up vec3 pointing up
	 * @returns {mat4} out
	 */
	function targetTo(out, eye, target, up) {
	  var eyex = eye[0],
	      eyey = eye[1],
	      eyez = eye[2],
	      upx = up[0],
	      upy = up[1],
	      upz = up[2];

	  var z0 = eyex - target[0],
	      z1 = eyey - target[1],
	      z2 = eyez - target[2];

	  var len = z0 * z0 + z1 * z1 + z2 * z2;
	  if (len > 0) {
	    len = 1 / Math.sqrt(len);
	    z0 *= len;
	    z1 *= len;
	    z2 *= len;
	  }

	  var x0 = upy * z2 - upz * z1,
	      x1 = upz * z0 - upx * z2,
	      x2 = upx * z1 - upy * z0;

	  len = x0 * x0 + x1 * x1 + x2 * x2;
	  if (len > 0) {
	    len = 1 / Math.sqrt(len);
	    x0 *= len;
	    x1 *= len;
	    x2 *= len;
	  }

	  out[0] = x0;
	  out[1] = x1;
	  out[2] = x2;
	  out[3] = 0;
	  out[4] = z1 * x2 - z2 * x1;
	  out[5] = z2 * x0 - z0 * x2;
	  out[6] = z0 * x1 - z1 * x0;
	  out[7] = 0;
	  out[8] = z0;
	  out[9] = z1;
	  out[10] = z2;
	  out[11] = 0;
	  out[12] = eyex;
	  out[13] = eyey;
	  out[14] = eyez;
	  out[15] = 1;
	  return out;
	}
	/**
	 * Returns a string representation of a mat4
	 *
	 * @param {mat4} a matrix to represent as a string
	 * @returns {String} string representation of the matrix
	 */
	function str$5(a) {
	  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
	}

	/**
	 * Returns Frobenius norm of a mat4
	 *
	 * @param {mat4} a the matrix to calculate Frobenius norm of
	 * @returns {Number} Frobenius norm
	 */
	function frob(a) {
	  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
	}

	/**
	 * Adds two mat4's
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the first operand
	 * @param {mat4} b the second operand
	 * @returns {mat4} out
	 */
	function add$5(out, a, b) {
	  out[0] = a[0] + b[0];
	  out[1] = a[1] + b[1];
	  out[2] = a[2] + b[2];
	  out[3] = a[3] + b[3];
	  out[4] = a[4] + b[4];
	  out[5] = a[5] + b[5];
	  out[6] = a[6] + b[6];
	  out[7] = a[7] + b[7];
	  out[8] = a[8] + b[8];
	  out[9] = a[9] + b[9];
	  out[10] = a[10] + b[10];
	  out[11] = a[11] + b[11];
	  out[12] = a[12] + b[12];
	  out[13] = a[13] + b[13];
	  out[14] = a[14] + b[14];
	  out[15] = a[15] + b[15];
	  return out;
	}

	/**
	 * Subtracts matrix b from matrix a
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the first operand
	 * @param {mat4} b the second operand
	 * @returns {mat4} out
	 */
	function subtract$3(out, a, b) {
	  out[0] = a[0] - b[0];
	  out[1] = a[1] - b[1];
	  out[2] = a[2] - b[2];
	  out[3] = a[3] - b[3];
	  out[4] = a[4] - b[4];
	  out[5] = a[5] - b[5];
	  out[6] = a[6] - b[6];
	  out[7] = a[7] - b[7];
	  out[8] = a[8] - b[8];
	  out[9] = a[9] - b[9];
	  out[10] = a[10] - b[10];
	  out[11] = a[11] - b[11];
	  out[12] = a[12] - b[12];
	  out[13] = a[13] - b[13];
	  out[14] = a[14] - b[14];
	  out[15] = a[15] - b[15];
	  return out;
	}

	/**
	 * Multiply each element of the matrix by a scalar.
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to scale
	 * @param {Number} b amount to scale the matrix's elements by
	 * @returns {mat4} out
	 */
	function multiplyScalar(out, a, b) {
	  out[0] = a[0] * b;
	  out[1] = a[1] * b;
	  out[2] = a[2] * b;
	  out[3] = a[3] * b;
	  out[4] = a[4] * b;
	  out[5] = a[5] * b;
	  out[6] = a[6] * b;
	  out[7] = a[7] * b;
	  out[8] = a[8] * b;
	  out[9] = a[9] * b;
	  out[10] = a[10] * b;
	  out[11] = a[11] * b;
	  out[12] = a[12] * b;
	  out[13] = a[13] * b;
	  out[14] = a[14] * b;
	  out[15] = a[15] * b;
	  return out;
	}

	/**
	 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
	 *
	 * @param {mat4} out the receiving vector
	 * @param {mat4} a the first operand
	 * @param {mat4} b the second operand
	 * @param {Number} scale the amount to scale b's elements by before adding
	 * @returns {mat4} out
	 */
	function multiplyScalarAndAdd(out, a, b, scale) {
	  out[0] = a[0] + b[0] * scale;
	  out[1] = a[1] + b[1] * scale;
	  out[2] = a[2] + b[2] * scale;
	  out[3] = a[3] + b[3] * scale;
	  out[4] = a[4] + b[4] * scale;
	  out[5] = a[5] + b[5] * scale;
	  out[6] = a[6] + b[6] * scale;
	  out[7] = a[7] + b[7] * scale;
	  out[8] = a[8] + b[8] * scale;
	  out[9] = a[9] + b[9] * scale;
	  out[10] = a[10] + b[10] * scale;
	  out[11] = a[11] + b[11] * scale;
	  out[12] = a[12] + b[12] * scale;
	  out[13] = a[13] + b[13] * scale;
	  out[14] = a[14] + b[14] * scale;
	  out[15] = a[15] + b[15] * scale;
	  return out;
	}

	/**
	 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {mat4} a The first matrix.
	 * @param {mat4} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	function exactEquals$5(a, b) {
	  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
	}

	/**
	 * Returns whether or not the matrices have approximately the same elements in the same position.
	 *
	 * @param {mat4} a The first matrix.
	 * @param {mat4} b The second matrix.
	 * @returns {Boolean} True if the matrices are equal, false otherwise.
	 */
	function equals$5(a, b) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3];
	  var a4 = a[4],
	      a5 = a[5],
	      a6 = a[6],
	      a7 = a[7];
	  var a8 = a[8],
	      a9 = a[9],
	      a10 = a[10],
	      a11 = a[11];
	  var a12 = a[12],
	      a13 = a[13],
	      a14 = a[14],
	      a15 = a[15];

	  var b0 = b[0],
	      b1 = b[1],
	      b2 = b[2],
	      b3 = b[3];
	  var b4 = b[4],
	      b5 = b[5],
	      b6 = b[6],
	      b7 = b[7];
	  var b8 = b[8],
	      b9 = b[9],
	      b10 = b[10],
	      b11 = b[11];
	  var b12 = b[12],
	      b13 = b[13],
	      b14 = b[14],
	      b15 = b[15];

	  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
	}

	/**
	 * Alias for {@link mat4.multiply}
	 * @function
	 */
	var mul$5 = multiply$5;

	/**
	 * Alias for {@link mat4.subtract}
	 * @function
	 */
	var sub$3 = subtract$3;

	var mat4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$5,
		clone: clone$5,
		copy: copy$5,
		fromValues: fromValues$5,
		set: set$5,
		identity: identity$2,
		transpose: transpose,
		invert: invert$2,
		adjoint: adjoint,
		determinant: determinant,
		multiply: multiply$5,
		translate: translate$1,
		scale: scale$5,
		rotate: rotate$1,
		rotateX: rotateX$3,
		rotateY: rotateY$3,
		rotateZ: rotateZ$3,
		fromTranslation: fromTranslation$1,
		fromScaling: fromScaling,
		fromRotation: fromRotation$1,
		fromXRotation: fromXRotation,
		fromYRotation: fromYRotation,
		fromZRotation: fromZRotation,
		fromRotationTranslation: fromRotationTranslation$1,
		fromQuat2: fromQuat2,
		getTranslation: getTranslation$1,
		getScaling: getScaling,
		getRotation: getRotation,
		fromRotationTranslationScale: fromRotationTranslationScale,
		fromRotationTranslationScaleOrigin: fromRotationTranslationScaleOrigin,
		fromQuat: fromQuat,
		frustum: frustum,
		perspective: perspective,
		perspectiveFromFieldOfView: perspectiveFromFieldOfView,
		ortho: ortho,
		lookAt: lookAt,
		targetTo: targetTo,
		str: str$5,
		frob: frob,
		add: add$5,
		subtract: subtract$3,
		multiplyScalar: multiplyScalar,
		multiplyScalarAndAdd: multiplyScalarAndAdd,
		exactEquals: exactEquals$5,
		equals: equals$5,
		mul: mul$5,
		sub: sub$3
	});

	/**
	 * 3 Dimensional Vector
	 * @module vec3
	 */

	/**
	 * Creates a new, empty vec3
	 *
	 * @returns {vec3} a new 3D vector
	 */
	function create$4() {
	  var out = new ARRAY_TYPE(3);
	  if (ARRAY_TYPE != Float32Array) {
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	  }
	  return out;
	}

	/**
	 * Creates a new vec3 initialized with values from an existing vector
	 *
	 * @param {vec3} a vector to clone
	 * @returns {vec3} a new 3D vector
	 */
	function clone$4(a) {
	  var out = new ARRAY_TYPE(3);
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  return out;
	}

	/**
	 * Calculates the length of a vec3
	 *
	 * @param {vec3} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	function length$4(a) {
	  var x = a[0];
	  var y = a[1];
	  var z = a[2];
	  return Math.sqrt(x * x + y * y + z * z);
	}

	/**
	 * Creates a new vec3 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @returns {vec3} a new 3D vector
	 */
	function fromValues$4(x, y, z) {
	  var out = new ARRAY_TYPE(3);
	  out[0] = x;
	  out[1] = y;
	  out[2] = z;
	  return out;
	}

	/**
	 * Copy the values from one vec3 to another
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the source vector
	 * @returns {vec3} out
	 */
	function copy$4(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  return out;
	}

	/**
	 * Set the components of a vec3 to the given values
	 *
	 * @param {vec3} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @returns {vec3} out
	 */
	function set$4(out, x, y, z) {
	  out[0] = x;
	  out[1] = y;
	  out[2] = z;
	  return out;
	}

	/**
	 * Adds two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function add$4(out, a, b) {
	  out[0] = a[0] + b[0];
	  out[1] = a[1] + b[1];
	  out[2] = a[2] + b[2];
	  return out;
	}

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function subtract$2(out, a, b) {
	  out[0] = a[0] - b[0];
	  out[1] = a[1] - b[1];
	  out[2] = a[2] - b[2];
	  return out;
	}

	/**
	 * Multiplies two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function multiply$4(out, a, b) {
	  out[0] = a[0] * b[0];
	  out[1] = a[1] * b[1];
	  out[2] = a[2] * b[2];
	  return out;
	}

	/**
	 * Divides two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function divide$2(out, a, b) {
	  out[0] = a[0] / b[0];
	  out[1] = a[1] / b[1];
	  out[2] = a[2] / b[2];
	  return out;
	}

	/**
	 * Math.ceil the components of a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to ceil
	 * @returns {vec3} out
	 */
	function ceil$2(out, a) {
	  out[0] = Math.ceil(a[0]);
	  out[1] = Math.ceil(a[1]);
	  out[2] = Math.ceil(a[2]);
	  return out;
	}

	/**
	 * Math.floor the components of a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to floor
	 * @returns {vec3} out
	 */
	function floor$2(out, a) {
	  out[0] = Math.floor(a[0]);
	  out[1] = Math.floor(a[1]);
	  out[2] = Math.floor(a[2]);
	  return out;
	}

	/**
	 * Returns the minimum of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function min$2(out, a, b) {
	  out[0] = Math.min(a[0], b[0]);
	  out[1] = Math.min(a[1], b[1]);
	  out[2] = Math.min(a[2], b[2]);
	  return out;
	}

	/**
	 * Returns the maximum of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function max$2(out, a, b) {
	  out[0] = Math.max(a[0], b[0]);
	  out[1] = Math.max(a[1], b[1]);
	  out[2] = Math.max(a[2], b[2]);
	  return out;
	}

	/**
	 * Math.round the components of a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to round
	 * @returns {vec3} out
	 */
	function round$2(out, a) {
	  out[0] = Math.round(a[0]);
	  out[1] = Math.round(a[1]);
	  out[2] = Math.round(a[2]);
	  return out;
	}

	/**
	 * Scales a vec3 by a scalar number
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec3} out
	 */
	function scale$4(out, a, b) {
	  out[0] = a[0] * b;
	  out[1] = a[1] * b;
	  out[2] = a[2] * b;
	  return out;
	}

	/**
	 * Adds two vec3's after scaling the second operand by a scalar value
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {vec3} out
	 */
	function scaleAndAdd$2(out, a, b, scale) {
	  out[0] = a[0] + b[0] * scale;
	  out[1] = a[1] + b[1] * scale;
	  out[2] = a[2] + b[2] * scale;
	  return out;
	}

	/**
	 * Calculates the euclidian distance between two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} distance between a and b
	 */
	function distance$2(a, b) {
	  var x = b[0] - a[0];
	  var y = b[1] - a[1];
	  var z = b[2] - a[2];
	  return Math.sqrt(x * x + y * y + z * z);
	}

	/**
	 * Calculates the squared euclidian distance between two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} squared distance between a and b
	 */
	function squaredDistance$2(a, b) {
	  var x = b[0] - a[0];
	  var y = b[1] - a[1];
	  var z = b[2] - a[2];
	  return x * x + y * y + z * z;
	}

	/**
	 * Calculates the squared length of a vec3
	 *
	 * @param {vec3} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	function squaredLength$4(a) {
	  var x = a[0];
	  var y = a[1];
	  var z = a[2];
	  return x * x + y * y + z * z;
	}

	/**
	 * Negates the components of a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to negate
	 * @returns {vec3} out
	 */
	function negate$2(out, a) {
	  out[0] = -a[0];
	  out[1] = -a[1];
	  out[2] = -a[2];
	  return out;
	}

	/**
	 * Returns the inverse of the components of a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to invert
	 * @returns {vec3} out
	 */
	function inverse$2(out, a) {
	  out[0] = 1.0 / a[0];
	  out[1] = 1.0 / a[1];
	  out[2] = 1.0 / a[2];
	  return out;
	}

	/**
	 * Normalize a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to normalize
	 * @returns {vec3} out
	 */
	function normalize$4(out, a) {
	  var x = a[0];
	  var y = a[1];
	  var z = a[2];
	  var len = x * x + y * y + z * z;
	  if (len > 0) {
	    //TODO: evaluate use of glm_invsqrt here?
	    len = 1 / Math.sqrt(len);
	    out[0] = a[0] * len;
	    out[1] = a[1] * len;
	    out[2] = a[2] * len;
	  }
	  return out;
	}

	/**
	 * Calculates the dot product of two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	function dot$4(a, b) {
	  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	}

	/**
	 * Computes the cross product of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function cross$1(out, a, b) {
	  var ax = a[0],
	      ay = a[1],
	      az = a[2];
	  var bx = b[0],
	      by = b[1],
	      bz = b[2];

	  out[0] = ay * bz - az * by;
	  out[1] = az * bx - ax * bz;
	  out[2] = ax * by - ay * bx;
	  return out;
	}

	/**
	 * Performs a linear interpolation between two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
	 * @returns {vec3} out
	 */
	function lerp$4(out, a, b, t) {
	  var ax = a[0];
	  var ay = a[1];
	  var az = a[2];
	  out[0] = ax + t * (b[0] - ax);
	  out[1] = ay + t * (b[1] - ay);
	  out[2] = az + t * (b[2] - az);
	  return out;
	}

	/**
	 * Performs a hermite interpolation with two control points
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {vec3} c the third operand
	 * @param {vec3} d the fourth operand
	 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
	 * @returns {vec3} out
	 */
	function hermite(out, a, b, c, d, t) {
	  var factorTimes2 = t * t;
	  var factor1 = factorTimes2 * (2 * t - 3) + 1;
	  var factor2 = factorTimes2 * (t - 2) + t;
	  var factor3 = factorTimes2 * (t - 1);
	  var factor4 = factorTimes2 * (3 - 2 * t);

	  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
	  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
	  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

	  return out;
	}

	/**
	 * Performs a bezier interpolation with two control points
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @param {vec3} c the third operand
	 * @param {vec3} d the fourth operand
	 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
	 * @returns {vec3} out
	 */
	function bezier(out, a, b, c, d, t) {
	  var inverseFactor = 1 - t;
	  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
	  var factorTimes2 = t * t;
	  var factor1 = inverseFactorTimesTwo * inverseFactor;
	  var factor2 = 3 * t * inverseFactorTimesTwo;
	  var factor3 = 3 * factorTimes2 * inverseFactor;
	  var factor4 = factorTimes2 * t;

	  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
	  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
	  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

	  return out;
	}

	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {vec3} out the receiving vector
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {vec3} out
	 */
	function random$3(out, scale) {
	  scale = scale || 1.0;

	  var r = RANDOM() * 2.0 * Math.PI;
	  var z = RANDOM() * 2.0 - 1.0;
	  var zScale = Math.sqrt(1.0 - z * z) * scale;

	  out[0] = Math.cos(r) * zScale;
	  out[1] = Math.sin(r) * zScale;
	  out[2] = z * scale;
	  return out;
	}

	/**
	 * Transforms the vec3 with a mat4.
	 * 4th vector component is implicitly '1'
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec3} out
	 */
	function transformMat4$2(out, a, m) {
	  var x = a[0],
	      y = a[1],
	      z = a[2];
	  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
	  w = w || 1.0;
	  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
	  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
	  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
	  return out;
	}

	/**
	 * Transforms the vec3 with a mat3.
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {mat3} m the 3x3 matrix to transform with
	 * @returns {vec3} out
	 */
	function transformMat3$1(out, a, m) {
	  var x = a[0],
	      y = a[1],
	      z = a[2];
	  out[0] = x * m[0] + y * m[3] + z * m[6];
	  out[1] = x * m[1] + y * m[4] + z * m[7];
	  out[2] = x * m[2] + y * m[5] + z * m[8];
	  return out;
	}

	/**
	 * Transforms the vec3 with a quat
	 * Can also be used for dual quaternions. (Multiply it with the real part)
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {quat} q quaternion to transform with
	 * @returns {vec3} out
	 */
	function transformQuat$1(out, a, q) {
	  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
	  var qx = q[0],
	      qy = q[1],
	      qz = q[2],
	      qw = q[3];
	  var x = a[0],
	      y = a[1],
	      z = a[2];
	  // var qvec = [qx, qy, qz];
	  // var uv = vec3.cross([], qvec, a);
	  var uvx = qy * z - qz * y,
	      uvy = qz * x - qx * z,
	      uvz = qx * y - qy * x;
	  // var uuv = vec3.cross([], qvec, uv);
	  var uuvx = qy * uvz - qz * uvy,
	      uuvy = qz * uvx - qx * uvz,
	      uuvz = qx * uvy - qy * uvx;
	  // vec3.scale(uv, uv, 2 * w);
	  var w2 = qw * 2;
	  uvx *= w2;
	  uvy *= w2;
	  uvz *= w2;
	  // vec3.scale(uuv, uuv, 2);
	  uuvx *= 2;
	  uuvy *= 2;
	  uuvz *= 2;
	  // return vec3.add(out, a, vec3.add(out, uv, uuv));
	  out[0] = x + uvx + uuvx;
	  out[1] = y + uvy + uuvy;
	  out[2] = z + uvz + uuvz;
	  return out;
	}

	/**
	 * Rotate a 3D vector around the x-axis
	 * @param {vec3} out The receiving vec3
	 * @param {vec3} a The vec3 point to rotate
	 * @param {vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec3} out
	 */
	function rotateX$2(out, a, b, c) {
	  var p = [],
	      r = [];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
	  p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
	  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

	  return out;
	}

	/**
	 * Rotate a 3D vector around the y-axis
	 * @param {vec3} out The receiving vec3
	 * @param {vec3} a The vec3 point to rotate
	 * @param {vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec3} out
	 */
	function rotateY$2(out, a, b, c) {
	  var p = [],
	      r = [];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
	  p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
	  r[1] = p[1];
	  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

	  return out;
	}

	/**
	 * Rotate a 3D vector around the z-axis
	 * @param {vec3} out The receiving vec3
	 * @param {vec3} a The vec3 point to rotate
	 * @param {vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec3} out
	 */
	function rotateZ$2(out, a, b, c) {
	  var p = [],
	      r = [];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
	  p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
	  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
	  r[2] = p[2];

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

	  return out;
	}

	/**
	 * Get the angle between two 3D vectors
	 * @param {vec3} a The first operand
	 * @param {vec3} b The second operand
	 * @returns {Number} The angle in radians
	 */
	function angle$1(a, b) {
	  var tempA = fromValues$4(a[0], a[1], a[2]);
	  var tempB = fromValues$4(b[0], b[1], b[2]);

	  normalize$4(tempA, tempA);
	  normalize$4(tempB, tempB);

	  var cosine = dot$4(tempA, tempB);

	  if (cosine > 1.0) {
	    return 0;
	  } else if (cosine < -1.0) {
	    return Math.PI;
	  } else {
	    return Math.acos(cosine);
	  }
	}

	/**
	 * Returns a string representation of a vector
	 *
	 * @param {vec3} a vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	function str$4(a) {
	  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
	}

	/**
	 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {vec3} a The first vector.
	 * @param {vec3} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	function exactEquals$4(a, b) {
	  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
	}

	/**
	 * Returns whether or not the vectors have approximately the same elements in the same position.
	 *
	 * @param {vec3} a The first vector.
	 * @param {vec3} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	function equals$4(a, b) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2];
	  var b0 = b[0],
	      b1 = b[1],
	      b2 = b[2];
	  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
	}

	/**
	 * Alias for {@link vec3.subtract}
	 * @function
	 */
	var sub$2 = subtract$2;

	/**
	 * Alias for {@link vec3.multiply}
	 * @function
	 */
	var mul$4 = multiply$4;

	/**
	 * Alias for {@link vec3.divide}
	 * @function
	 */
	var div$2 = divide$2;

	/**
	 * Alias for {@link vec3.distance}
	 * @function
	 */
	var dist$2 = distance$2;

	/**
	 * Alias for {@link vec3.squaredDistance}
	 * @function
	 */
	var sqrDist$2 = squaredDistance$2;

	/**
	 * Alias for {@link vec3.length}
	 * @function
	 */
	var len$4 = length$4;

	/**
	 * Alias for {@link vec3.squaredLength}
	 * @function
	 */
	var sqrLen$4 = squaredLength$4;

	/**
	 * Perform some operation over an array of vec3s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */
	var forEach$2 = function () {
	  var vec = create$4();

	  return function (a, stride, offset, count, fn, arg) {
	    var i = void 0,
	        l = void 0;
	    if (!stride) {
	      stride = 3;
	    }

	    if (!offset) {
	      offset = 0;
	    }

	    if (count) {
	      l = Math.min(count * stride + offset, a.length);
	    } else {
	      l = a.length;
	    }

	    for (i = offset; i < l; i += stride) {
	      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];
	      fn(vec, vec, arg);
	      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];
	    }

	    return a;
	  };
	}();

	var vec3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$4,
		clone: clone$4,
		length: length$4,
		fromValues: fromValues$4,
		copy: copy$4,
		set: set$4,
		add: add$4,
		subtract: subtract$2,
		multiply: multiply$4,
		divide: divide$2,
		ceil: ceil$2,
		floor: floor$2,
		min: min$2,
		max: max$2,
		round: round$2,
		scale: scale$4,
		scaleAndAdd: scaleAndAdd$2,
		distance: distance$2,
		squaredDistance: squaredDistance$2,
		squaredLength: squaredLength$4,
		negate: negate$2,
		inverse: inverse$2,
		normalize: normalize$4,
		dot: dot$4,
		cross: cross$1,
		lerp: lerp$4,
		hermite: hermite,
		bezier: bezier,
		random: random$3,
		transformMat4: transformMat4$2,
		transformMat3: transformMat3$1,
		transformQuat: transformQuat$1,
		rotateX: rotateX$2,
		rotateY: rotateY$2,
		rotateZ: rotateZ$2,
		angle: angle$1,
		str: str$4,
		exactEquals: exactEquals$4,
		equals: equals$4,
		sub: sub$2,
		mul: mul$4,
		div: div$2,
		dist: dist$2,
		sqrDist: sqrDist$2,
		len: len$4,
		sqrLen: sqrLen$4,
		forEach: forEach$2
	});

	/**
	 * 4 Dimensional Vector
	 * @module vec4
	 */

	/**
	 * Creates a new, empty vec4
	 *
	 * @returns {vec4} a new 4D vector
	 */
	function create$3() {
	  var out = new ARRAY_TYPE(4);
	  if (ARRAY_TYPE != Float32Array) {
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	  }
	  return out;
	}

	/**
	 * Creates a new vec4 initialized with values from an existing vector
	 *
	 * @param {vec4} a vector to clone
	 * @returns {vec4} a new 4D vector
	 */
	function clone$3(a) {
	  var out = new ARRAY_TYPE(4);
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  return out;
	}

	/**
	 * Creates a new vec4 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {vec4} a new 4D vector
	 */
	function fromValues$3(x, y, z, w) {
	  var out = new ARRAY_TYPE(4);
	  out[0] = x;
	  out[1] = y;
	  out[2] = z;
	  out[3] = w;
	  return out;
	}

	/**
	 * Copy the values from one vec4 to another
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the source vector
	 * @returns {vec4} out
	 */
	function copy$3(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  return out;
	}

	/**
	 * Set the components of a vec4 to the given values
	 *
	 * @param {vec4} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {vec4} out
	 */
	function set$3(out, x, y, z, w) {
	  out[0] = x;
	  out[1] = y;
	  out[2] = z;
	  out[3] = w;
	  return out;
	}

	/**
	 * Adds two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	function add$3(out, a, b) {
	  out[0] = a[0] + b[0];
	  out[1] = a[1] + b[1];
	  out[2] = a[2] + b[2];
	  out[3] = a[3] + b[3];
	  return out;
	}

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	function subtract$1(out, a, b) {
	  out[0] = a[0] - b[0];
	  out[1] = a[1] - b[1];
	  out[2] = a[2] - b[2];
	  out[3] = a[3] - b[3];
	  return out;
	}

	/**
	 * Multiplies two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	function multiply$3(out, a, b) {
	  out[0] = a[0] * b[0];
	  out[1] = a[1] * b[1];
	  out[2] = a[2] * b[2];
	  out[3] = a[3] * b[3];
	  return out;
	}

	/**
	 * Divides two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	function divide$1(out, a, b) {
	  out[0] = a[0] / b[0];
	  out[1] = a[1] / b[1];
	  out[2] = a[2] / b[2];
	  out[3] = a[3] / b[3];
	  return out;
	}

	/**
	 * Math.ceil the components of a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to ceil
	 * @returns {vec4} out
	 */
	function ceil$1(out, a) {
	  out[0] = Math.ceil(a[0]);
	  out[1] = Math.ceil(a[1]);
	  out[2] = Math.ceil(a[2]);
	  out[3] = Math.ceil(a[3]);
	  return out;
	}

	/**
	 * Math.floor the components of a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to floor
	 * @returns {vec4} out
	 */
	function floor$1(out, a) {
	  out[0] = Math.floor(a[0]);
	  out[1] = Math.floor(a[1]);
	  out[2] = Math.floor(a[2]);
	  out[3] = Math.floor(a[3]);
	  return out;
	}

	/**
	 * Returns the minimum of two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	function min$1(out, a, b) {
	  out[0] = Math.min(a[0], b[0]);
	  out[1] = Math.min(a[1], b[1]);
	  out[2] = Math.min(a[2], b[2]);
	  out[3] = Math.min(a[3], b[3]);
	  return out;
	}

	/**
	 * Returns the maximum of two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	function max$1(out, a, b) {
	  out[0] = Math.max(a[0], b[0]);
	  out[1] = Math.max(a[1], b[1]);
	  out[2] = Math.max(a[2], b[2]);
	  out[3] = Math.max(a[3], b[3]);
	  return out;
	}

	/**
	 * Math.round the components of a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to round
	 * @returns {vec4} out
	 */
	function round$1(out, a) {
	  out[0] = Math.round(a[0]);
	  out[1] = Math.round(a[1]);
	  out[2] = Math.round(a[2]);
	  out[3] = Math.round(a[3]);
	  return out;
	}

	/**
	 * Scales a vec4 by a scalar number
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec4} out
	 */
	function scale$3(out, a, b) {
	  out[0] = a[0] * b;
	  out[1] = a[1] * b;
	  out[2] = a[2] * b;
	  out[3] = a[3] * b;
	  return out;
	}

	/**
	 * Adds two vec4's after scaling the second operand by a scalar value
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {vec4} out
	 */
	function scaleAndAdd$1(out, a, b, scale) {
	  out[0] = a[0] + b[0] * scale;
	  out[1] = a[1] + b[1] * scale;
	  out[2] = a[2] + b[2] * scale;
	  out[3] = a[3] + b[3] * scale;
	  return out;
	}

	/**
	 * Calculates the euclidian distance between two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} distance between a and b
	 */
	function distance$1(a, b) {
	  var x = b[0] - a[0];
	  var y = b[1] - a[1];
	  var z = b[2] - a[2];
	  var w = b[3] - a[3];
	  return Math.sqrt(x * x + y * y + z * z + w * w);
	}

	/**
	 * Calculates the squared euclidian distance between two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} squared distance between a and b
	 */
	function squaredDistance$1(a, b) {
	  var x = b[0] - a[0];
	  var y = b[1] - a[1];
	  var z = b[2] - a[2];
	  var w = b[3] - a[3];
	  return x * x + y * y + z * z + w * w;
	}

	/**
	 * Calculates the length of a vec4
	 *
	 * @param {vec4} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	function length$3(a) {
	  var x = a[0];
	  var y = a[1];
	  var z = a[2];
	  var w = a[3];
	  return Math.sqrt(x * x + y * y + z * z + w * w);
	}

	/**
	 * Calculates the squared length of a vec4
	 *
	 * @param {vec4} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	function squaredLength$3(a) {
	  var x = a[0];
	  var y = a[1];
	  var z = a[2];
	  var w = a[3];
	  return x * x + y * y + z * z + w * w;
	}

	/**
	 * Negates the components of a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to negate
	 * @returns {vec4} out
	 */
	function negate$1(out, a) {
	  out[0] = -a[0];
	  out[1] = -a[1];
	  out[2] = -a[2];
	  out[3] = -a[3];
	  return out;
	}

	/**
	 * Returns the inverse of the components of a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to invert
	 * @returns {vec4} out
	 */
	function inverse$1(out, a) {
	  out[0] = 1.0 / a[0];
	  out[1] = 1.0 / a[1];
	  out[2] = 1.0 / a[2];
	  out[3] = 1.0 / a[3];
	  return out;
	}

	/**
	 * Normalize a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to normalize
	 * @returns {vec4} out
	 */
	function normalize$3(out, a) {
	  var x = a[0];
	  var y = a[1];
	  var z = a[2];
	  var w = a[3];
	  var len = x * x + y * y + z * z + w * w;
	  if (len > 0) {
	    len = 1 / Math.sqrt(len);
	    out[0] = x * len;
	    out[1] = y * len;
	    out[2] = z * len;
	    out[3] = w * len;
	  }
	  return out;
	}

	/**
	 * Calculates the dot product of two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	function dot$3(a, b) {
	  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	}

	/**
	 * Performs a linear interpolation between two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
	 * @returns {vec4} out
	 */
	function lerp$3(out, a, b, t) {
	  var ax = a[0];
	  var ay = a[1];
	  var az = a[2];
	  var aw = a[3];
	  out[0] = ax + t * (b[0] - ax);
	  out[1] = ay + t * (b[1] - ay);
	  out[2] = az + t * (b[2] - az);
	  out[3] = aw + t * (b[3] - aw);
	  return out;
	}

	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {vec4} out the receiving vector
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {vec4} out
	 */
	function random$2(out, scale) {
	  scale = scale || 1.0;

	  // Marsaglia, George. Choosing a Point from the Surface of a
	  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
	  // http://projecteuclid.org/euclid.aoms/1177692644;
	  var v1, v2, v3, v4;
	  var s1, s2;
	  do {
	    v1 = RANDOM() * 2 - 1;
	    v2 = RANDOM() * 2 - 1;
	    s1 = v1 * v1 + v2 * v2;
	  } while (s1 >= 1);
	  do {
	    v3 = RANDOM() * 2 - 1;
	    v4 = RANDOM() * 2 - 1;
	    s2 = v3 * v3 + v4 * v4;
	  } while (s2 >= 1);

	  var d = Math.sqrt((1 - s1) / s2);
	  out[0] = scale * v1;
	  out[1] = scale * v2;
	  out[2] = scale * v3 * d;
	  out[3] = scale * v4 * d;
	  return out;
	}

	/**
	 * Transforms the vec4 with a mat4.
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec4} out
	 */
	function transformMat4$1(out, a, m) {
	  var x = a[0],
	      y = a[1],
	      z = a[2],
	      w = a[3];
	  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
	  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
	  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
	  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
	  return out;
	}

	/**
	 * Transforms the vec4 with a quat
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to transform
	 * @param {quat} q quaternion to transform with
	 * @returns {vec4} out
	 */
	function transformQuat(out, a, q) {
	  var x = a[0],
	      y = a[1],
	      z = a[2];
	  var qx = q[0],
	      qy = q[1],
	      qz = q[2],
	      qw = q[3];

	  // calculate quat * vec
	  var ix = qw * x + qy * z - qz * y;
	  var iy = qw * y + qz * x - qx * z;
	  var iz = qw * z + qx * y - qy * x;
	  var iw = -qx * x - qy * y - qz * z;

	  // calculate result * inverse quat
	  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	  out[3] = a[3];
	  return out;
	}

	/**
	 * Returns a string representation of a vector
	 *
	 * @param {vec4} a vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	function str$3(a) {
	  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
	}

	/**
	 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {vec4} a The first vector.
	 * @param {vec4} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	function exactEquals$3(a, b) {
	  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
	}

	/**
	 * Returns whether or not the vectors have approximately the same elements in the same position.
	 *
	 * @param {vec4} a The first vector.
	 * @param {vec4} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	function equals$3(a, b) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3];
	  var b0 = b[0],
	      b1 = b[1],
	      b2 = b[2],
	      b3 = b[3];
	  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
	}

	/**
	 * Alias for {@link vec4.subtract}
	 * @function
	 */
	var sub$1 = subtract$1;

	/**
	 * Alias for {@link vec4.multiply}
	 * @function
	 */
	var mul$3 = multiply$3;

	/**
	 * Alias for {@link vec4.divide}
	 * @function
	 */
	var div$1 = divide$1;

	/**
	 * Alias for {@link vec4.distance}
	 * @function
	 */
	var dist$1 = distance$1;

	/**
	 * Alias for {@link vec4.squaredDistance}
	 * @function
	 */
	var sqrDist$1 = squaredDistance$1;

	/**
	 * Alias for {@link vec4.length}
	 * @function
	 */
	var len$3 = length$3;

	/**
	 * Alias for {@link vec4.squaredLength}
	 * @function
	 */
	var sqrLen$3 = squaredLength$3;

	/**
	 * Perform some operation over an array of vec4s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */
	var forEach$1 = function () {
	  var vec = create$3();

	  return function (a, stride, offset, count, fn, arg) {
	    var i = void 0,
	        l = void 0;
	    if (!stride) {
	      stride = 4;
	    }

	    if (!offset) {
	      offset = 0;
	    }

	    if (count) {
	      l = Math.min(count * stride + offset, a.length);
	    } else {
	      l = a.length;
	    }

	    for (i = offset; i < l; i += stride) {
	      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];vec[3] = a[i + 3];
	      fn(vec, vec, arg);
	      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];a[i + 3] = vec[3];
	    }

	    return a;
	  };
	}();

	var vec4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$3,
		clone: clone$3,
		fromValues: fromValues$3,
		copy: copy$3,
		set: set$3,
		add: add$3,
		subtract: subtract$1,
		multiply: multiply$3,
		divide: divide$1,
		ceil: ceil$1,
		floor: floor$1,
		min: min$1,
		max: max$1,
		round: round$1,
		scale: scale$3,
		scaleAndAdd: scaleAndAdd$1,
		distance: distance$1,
		squaredDistance: squaredDistance$1,
		length: length$3,
		squaredLength: squaredLength$3,
		negate: negate$1,
		inverse: inverse$1,
		normalize: normalize$3,
		dot: dot$3,
		lerp: lerp$3,
		random: random$2,
		transformMat4: transformMat4$1,
		transformQuat: transformQuat,
		str: str$3,
		exactEquals: exactEquals$3,
		equals: equals$3,
		sub: sub$1,
		mul: mul$3,
		div: div$1,
		dist: dist$1,
		sqrDist: sqrDist$1,
		len: len$3,
		sqrLen: sqrLen$3,
		forEach: forEach$1
	});

	/**
	 * Quaternion
	 * @module quat
	 */

	/**
	 * Creates a new identity quat
	 *
	 * @returns {quat} a new quaternion
	 */
	function create$2() {
	  var out = new ARRAY_TYPE(4);
	  if (ARRAY_TYPE != Float32Array) {
	    out[0] = 0;
	    out[1] = 0;
	    out[2] = 0;
	  }
	  out[3] = 1;
	  return out;
	}

	/**
	 * Set a quat to the identity quaternion
	 *
	 * @param {quat} out the receiving quaternion
	 * @returns {quat} out
	 */
	function identity$1(out) {
	  out[0] = 0;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 1;
	  return out;
	}

	/**
	 * Sets a quat from the given angle and rotation axis,
	 * then returns it.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {vec3} axis the axis around which to rotate
	 * @param {Number} rad the angle in radians
	 * @returns {quat} out
	 **/
	function setAxisAngle(out, axis, rad) {
	  rad = rad * 0.5;
	  var s = Math.sin(rad);
	  out[0] = s * axis[0];
	  out[1] = s * axis[1];
	  out[2] = s * axis[2];
	  out[3] = Math.cos(rad);
	  return out;
	}

	/**
	 * Gets the rotation axis and angle for a given
	 *  quaternion. If a quaternion is created with
	 *  setAxisAngle, this method will return the same
	 *  values as providied in the original parameter list
	 *  OR functionally equivalent values.
	 * Example: The quaternion formed by axis [0, 0, 1] and
	 *  angle -90 is the same as the quaternion formed by
	 *  [0, 0, 1] and 270. This method favors the latter.
	 * @param  {vec3} out_axis  Vector receiving the axis of rotation
	 * @param  {quat} q     Quaternion to be decomposed
	 * @return {Number}     Angle, in radians, of the rotation
	 */
	function getAxisAngle(out_axis, q) {
	  var rad = Math.acos(q[3]) * 2.0;
	  var s = Math.sin(rad / 2.0);
	  if (s > EPSILON) {
	    out_axis[0] = q[0] / s;
	    out_axis[1] = q[1] / s;
	    out_axis[2] = q[2] / s;
	  } else {
	    // If s is zero, return any axis (no rotation - axis does not matter)
	    out_axis[0] = 1;
	    out_axis[1] = 0;
	    out_axis[2] = 0;
	  }
	  return rad;
	}

	/**
	 * Multiplies two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @returns {quat} out
	 */
	function multiply$2(out, a, b) {
	  var ax = a[0],
	      ay = a[1],
	      az = a[2],
	      aw = a[3];
	  var bx = b[0],
	      by = b[1],
	      bz = b[2],
	      bw = b[3];

	  out[0] = ax * bw + aw * bx + ay * bz - az * by;
	  out[1] = ay * bw + aw * by + az * bx - ax * bz;
	  out[2] = az * bw + aw * bz + ax * by - ay * bx;
	  out[3] = aw * bw - ax * bx - ay * by - az * bz;
	  return out;
	}

	/**
	 * Rotates a quaternion by the given angle about the X axis
	 *
	 * @param {quat} out quat receiving operation result
	 * @param {quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {quat} out
	 */
	function rotateX$1(out, a, rad) {
	  rad *= 0.5;

	  var ax = a[0],
	      ay = a[1],
	      az = a[2],
	      aw = a[3];
	  var bx = Math.sin(rad),
	      bw = Math.cos(rad);

	  out[0] = ax * bw + aw * bx;
	  out[1] = ay * bw + az * bx;
	  out[2] = az * bw - ay * bx;
	  out[3] = aw * bw - ax * bx;
	  return out;
	}

	/**
	 * Rotates a quaternion by the given angle about the Y axis
	 *
	 * @param {quat} out quat receiving operation result
	 * @param {quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {quat} out
	 */
	function rotateY$1(out, a, rad) {
	  rad *= 0.5;

	  var ax = a[0],
	      ay = a[1],
	      az = a[2],
	      aw = a[3];
	  var by = Math.sin(rad),
	      bw = Math.cos(rad);

	  out[0] = ax * bw - az * by;
	  out[1] = ay * bw + aw * by;
	  out[2] = az * bw + ax * by;
	  out[3] = aw * bw - ay * by;
	  return out;
	}

	/**
	 * Rotates a quaternion by the given angle about the Z axis
	 *
	 * @param {quat} out quat receiving operation result
	 * @param {quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {quat} out
	 */
	function rotateZ$1(out, a, rad) {
	  rad *= 0.5;

	  var ax = a[0],
	      ay = a[1],
	      az = a[2],
	      aw = a[3];
	  var bz = Math.sin(rad),
	      bw = Math.cos(rad);

	  out[0] = ax * bw + ay * bz;
	  out[1] = ay * bw - ax * bz;
	  out[2] = az * bw + aw * bz;
	  out[3] = aw * bw - az * bz;
	  return out;
	}

	/**
	 * Calculates the W component of a quat from the X, Y, and Z components.
	 * Assumes that quaternion is 1 unit in length.
	 * Any existing W component will be ignored.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quat to calculate W component of
	 * @returns {quat} out
	 */
	function calculateW(out, a) {
	  var x = a[0],
	      y = a[1],
	      z = a[2];

	  out[0] = x;
	  out[1] = y;
	  out[2] = z;
	  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
	  return out;
	}

	/**
	 * Performs a spherical linear interpolation between two quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
	 * @returns {quat} out
	 */
	function slerp(out, a, b, t) {
	  // benchmarks:
	  //    http://jsperf.com/quaternion-slerp-implementations
	  var ax = a[0],
	      ay = a[1],
	      az = a[2],
	      aw = a[3];
	  var bx = b[0],
	      by = b[1],
	      bz = b[2],
	      bw = b[3];

	  var omega = void 0,
	      cosom = void 0,
	      sinom = void 0,
	      scale0 = void 0,
	      scale1 = void 0;

	  // calc cosine
	  cosom = ax * bx + ay * by + az * bz + aw * bw;
	  // adjust signs (if necessary)
	  if (cosom < 0.0) {
	    cosom = -cosom;
	    bx = -bx;
	    by = -by;
	    bz = -bz;
	    bw = -bw;
	  }
	  // calculate coefficients
	  if (1.0 - cosom > EPSILON) {
	    // standard case (slerp)
	    omega = Math.acos(cosom);
	    sinom = Math.sin(omega);
	    scale0 = Math.sin((1.0 - t) * omega) / sinom;
	    scale1 = Math.sin(t * omega) / sinom;
	  } else {
	    // "from" and "to" quaternions are very close
	    //  ... so we can do a linear interpolation
	    scale0 = 1.0 - t;
	    scale1 = t;
	  }
	  // calculate final values
	  out[0] = scale0 * ax + scale1 * bx;
	  out[1] = scale0 * ay + scale1 * by;
	  out[2] = scale0 * az + scale1 * bz;
	  out[3] = scale0 * aw + scale1 * bw;

	  return out;
	}

	/**
	 * Generates a random quaternion
	 *
	 * @param {quat} out the receiving quaternion
	 * @returns {quat} out
	 */
	function random$1(out) {
	  // Implementation of http://planning.cs.uiuc.edu/node198.html
	  // TODO: Calling random 3 times is probably not the fastest solution
	  var u1 = RANDOM();
	  var u2 = RANDOM();
	  var u3 = RANDOM();

	  var sqrt1MinusU1 = Math.sqrt(1 - u1);
	  var sqrtU1 = Math.sqrt(u1);

	  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
	  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
	  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
	  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
	  return out;
	}

	/**
	 * Calculates the inverse of a quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quat to calculate inverse of
	 * @returns {quat} out
	 */
	function invert$1(out, a) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3];
	  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
	  var invDot = dot ? 1.0 / dot : 0;

	  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

	  out[0] = -a0 * invDot;
	  out[1] = -a1 * invDot;
	  out[2] = -a2 * invDot;
	  out[3] = a3 * invDot;
	  return out;
	}

	/**
	 * Calculates the conjugate of a quat
	 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quat to calculate conjugate of
	 * @returns {quat} out
	 */
	function conjugate$1(out, a) {
	  out[0] = -a[0];
	  out[1] = -a[1];
	  out[2] = -a[2];
	  out[3] = a[3];
	  return out;
	}

	/**
	 * Creates a quaternion from the given 3x3 rotation matrix.
	 *
	 * NOTE: The resultant quaternion is not normalized, so you should be sure
	 * to renormalize the quaternion yourself where necessary.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {mat3} m rotation matrix
	 * @returns {quat} out
	 * @function
	 */
	function fromMat3(out, m) {
	  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
	  // article "Quaternion Calculus and Fast Animation".
	  var fTrace = m[0] + m[4] + m[8];
	  var fRoot = void 0;

	  if (fTrace > 0.0) {
	    // |w| > 1/2, may as well choose w > 1/2
	    fRoot = Math.sqrt(fTrace + 1.0); // 2w
	    out[3] = 0.5 * fRoot;
	    fRoot = 0.5 / fRoot; // 1/(4w)
	    out[0] = (m[5] - m[7]) * fRoot;
	    out[1] = (m[6] - m[2]) * fRoot;
	    out[2] = (m[1] - m[3]) * fRoot;
	  } else {
	    // |w| <= 1/2
	    var i = 0;
	    if (m[4] > m[0]) i = 1;
	    if (m[8] > m[i * 3 + i]) i = 2;
	    var j = (i + 1) % 3;
	    var k = (i + 2) % 3;

	    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
	    out[i] = 0.5 * fRoot;
	    fRoot = 0.5 / fRoot;
	    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
	    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
	    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
	  }

	  return out;
	}

	/**
	 * Creates a quaternion from the given euler angle x, y, z.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {x} Angle to rotate around X axis in degrees.
	 * @param {y} Angle to rotate around Y axis in degrees.
	 * @param {z} Angle to rotate around Z axis in degrees.
	 * @returns {quat} out
	 * @function
	 */
	function fromEuler(out, x, y, z) {
	  var halfToRad = 0.5 * Math.PI / 180.0;
	  x *= halfToRad;
	  y *= halfToRad;
	  z *= halfToRad;

	  var sx = Math.sin(x);
	  var cx = Math.cos(x);
	  var sy = Math.sin(y);
	  var cy = Math.cos(y);
	  var sz = Math.sin(z);
	  var cz = Math.cos(z);

	  out[0] = sx * cy * cz - cx * sy * sz;
	  out[1] = cx * sy * cz + sx * cy * sz;
	  out[2] = cx * cy * sz - sx * sy * cz;
	  out[3] = cx * cy * cz + sx * sy * sz;

	  return out;
	}

	/**
	 * Returns a string representation of a quatenion
	 *
	 * @param {quat} a vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	function str$2(a) {
	  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
	}

	/**
	 * Creates a new quat initialized with values from an existing quaternion
	 *
	 * @param {quat} a quaternion to clone
	 * @returns {quat} a new quaternion
	 * @function
	 */
	var clone$2 = clone$3;

	/**
	 * Creates a new quat initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {quat} a new quaternion
	 * @function
	 */
	var fromValues$2 = fromValues$3;

	/**
	 * Copy the values from one quat to another
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the source quaternion
	 * @returns {quat} out
	 * @function
	 */
	var copy$2 = copy$3;

	/**
	 * Set the components of a quat to the given values
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {quat} out
	 * @function
	 */
	var set$2 = set$3;

	/**
	 * Adds two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @returns {quat} out
	 * @function
	 */
	var add$2 = add$3;

	/**
	 * Alias for {@link quat.multiply}
	 * @function
	 */
	var mul$2 = multiply$2;

	/**
	 * Scales a quat by a scalar number
	 *
	 * @param {quat} out the receiving vector
	 * @param {quat} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {quat} out
	 * @function
	 */
	var scale$2 = scale$3;

	/**
	 * Calculates the dot product of two quat's
	 *
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @returns {Number} dot product of a and b
	 * @function
	 */
	var dot$2 = dot$3;

	/**
	 * Performs a linear interpolation between two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
	 * @returns {quat} out
	 * @function
	 */
	var lerp$2 = lerp$3;

	/**
	 * Calculates the length of a quat
	 *
	 * @param {quat} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	var length$2 = length$3;

	/**
	 * Alias for {@link quat.length}
	 * @function
	 */
	var len$2 = length$2;

	/**
	 * Calculates the squared length of a quat
	 *
	 * @param {quat} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 * @function
	 */
	var squaredLength$2 = squaredLength$3;

	/**
	 * Alias for {@link quat.squaredLength}
	 * @function
	 */
	var sqrLen$2 = squaredLength$2;

	/**
	 * Normalize a quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quaternion to normalize
	 * @returns {quat} out
	 * @function
	 */
	var normalize$2 = normalize$3;

	/**
	 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {quat} a The first quaternion.
	 * @param {quat} b The second quaternion.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	var exactEquals$2 = exactEquals$3;

	/**
	 * Returns whether or not the quaternions have approximately the same elements in the same position.
	 *
	 * @param {quat} a The first vector.
	 * @param {quat} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	var equals$2 = equals$3;

	/**
	 * Sets a quaternion to represent the shortest rotation from one
	 * vector to another.
	 *
	 * Both vectors are assumed to be unit length.
	 *
	 * @param {quat} out the receiving quaternion.
	 * @param {vec3} a the initial vector
	 * @param {vec3} b the destination vector
	 * @returns {quat} out
	 */
	var rotationTo = function () {
	  var tmpvec3 = create$4();
	  var xUnitVec3 = fromValues$4(1, 0, 0);
	  var yUnitVec3 = fromValues$4(0, 1, 0);

	  return function (out, a, b) {
	    var dot = dot$4(a, b);
	    if (dot < -0.999999) {
	      cross$1(tmpvec3, xUnitVec3, a);
	      if (len$4(tmpvec3) < 0.000001) cross$1(tmpvec3, yUnitVec3, a);
	      normalize$4(tmpvec3, tmpvec3);
	      setAxisAngle(out, tmpvec3, Math.PI);
	      return out;
	    } else if (dot > 0.999999) {
	      out[0] = 0;
	      out[1] = 0;
	      out[2] = 0;
	      out[3] = 1;
	      return out;
	    } else {
	      cross$1(tmpvec3, a, b);
	      out[0] = tmpvec3[0];
	      out[1] = tmpvec3[1];
	      out[2] = tmpvec3[2];
	      out[3] = 1 + dot;
	      return normalize$2(out, out);
	    }
	  };
	}();

	/**
	 * Performs a spherical linear interpolation with two control points
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @param {quat} c the third operand
	 * @param {quat} d the fourth operand
	 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
	 * @returns {quat} out
	 */
	var sqlerp = function () {
	  var temp1 = create$2();
	  var temp2 = create$2();

	  return function (out, a, b, c, d, t) {
	    slerp(temp1, a, d, t);
	    slerp(temp2, b, c, t);
	    slerp(out, temp1, temp2, 2 * t * (1 - t));

	    return out;
	  };
	}();

	/**
	 * Sets the specified quaternion with values corresponding to the given
	 * axes. Each axis is a vec3 and is expected to be unit length and
	 * perpendicular to all other specified axes.
	 *
	 * @param {vec3} view  the vector representing the viewing direction
	 * @param {vec3} right the vector representing the local "right" direction
	 * @param {vec3} up    the vector representing the local "up" direction
	 * @returns {quat} out
	 */
	var setAxes = function () {
	  var matr = create$6();

	  return function (out, view, right, up) {
	    matr[0] = right[0];
	    matr[3] = right[1];
	    matr[6] = right[2];

	    matr[1] = up[0];
	    matr[4] = up[1];
	    matr[7] = up[2];

	    matr[2] = -view[0];
	    matr[5] = -view[1];
	    matr[8] = -view[2];

	    return normalize$2(out, fromMat3(out, matr));
	  };
	}();

	var quat = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$2,
		identity: identity$1,
		setAxisAngle: setAxisAngle,
		getAxisAngle: getAxisAngle,
		multiply: multiply$2,
		rotateX: rotateX$1,
		rotateY: rotateY$1,
		rotateZ: rotateZ$1,
		calculateW: calculateW,
		slerp: slerp,
		random: random$1,
		invert: invert$1,
		conjugate: conjugate$1,
		fromMat3: fromMat3,
		fromEuler: fromEuler,
		str: str$2,
		clone: clone$2,
		fromValues: fromValues$2,
		copy: copy$2,
		set: set$2,
		add: add$2,
		mul: mul$2,
		scale: scale$2,
		dot: dot$2,
		lerp: lerp$2,
		length: length$2,
		len: len$2,
		squaredLength: squaredLength$2,
		sqrLen: sqrLen$2,
		normalize: normalize$2,
		exactEquals: exactEquals$2,
		equals: equals$2,
		rotationTo: rotationTo,
		sqlerp: sqlerp,
		setAxes: setAxes
	});

	/**
	 * Dual Quaternion<br>
	 * Format: [real, dual]<br>
	 * Quaternion format: XYZW<br>
	 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
	 * @module quat2
	 */

	/**
	 * Creates a new identity dual quat
	 *
	 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
	 */
	function create$1() {
	  var dq = new ARRAY_TYPE(8);
	  if (ARRAY_TYPE != Float32Array) {
	    dq[0] = 0;
	    dq[1] = 0;
	    dq[2] = 0;
	    dq[4] = 0;
	    dq[5] = 0;
	    dq[6] = 0;
	    dq[7] = 0;
	  }
	  dq[3] = 1;
	  return dq;
	}

	/**
	 * Creates a new quat initialized with values from an existing quaternion
	 *
	 * @param {quat2} a dual quaternion to clone
	 * @returns {quat2} new dual quaternion
	 * @function
	 */
	function clone$1(a) {
	  var dq = new ARRAY_TYPE(8);
	  dq[0] = a[0];
	  dq[1] = a[1];
	  dq[2] = a[2];
	  dq[3] = a[3];
	  dq[4] = a[4];
	  dq[5] = a[5];
	  dq[6] = a[6];
	  dq[7] = a[7];
	  return dq;
	}

	/**
	 * Creates a new dual quat initialized with the given values
	 *
	 * @param {Number} x1 X component
	 * @param {Number} y1 Y component
	 * @param {Number} z1 Z component
	 * @param {Number} w1 W component
	 * @param {Number} x2 X component
	 * @param {Number} y2 Y component
	 * @param {Number} z2 Z component
	 * @param {Number} w2 W component
	 * @returns {quat2} new dual quaternion
	 * @function
	 */
	function fromValues$1(x1, y1, z1, w1, x2, y2, z2, w2) {
	  var dq = new ARRAY_TYPE(8);
	  dq[0] = x1;
	  dq[1] = y1;
	  dq[2] = z1;
	  dq[3] = w1;
	  dq[4] = x2;
	  dq[5] = y2;
	  dq[6] = z2;
	  dq[7] = w2;
	  return dq;
	}

	/**
	 * Creates a new dual quat from the given values (quat and translation)
	 *
	 * @param {Number} x1 X component
	 * @param {Number} y1 Y component
	 * @param {Number} z1 Z component
	 * @param {Number} w1 W component
	 * @param {Number} x2 X component (translation)
	 * @param {Number} y2 Y component (translation)
	 * @param {Number} z2 Z component (translation)
	 * @returns {quat2} new dual quaternion
	 * @function
	 */
	function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
	  var dq = new ARRAY_TYPE(8);
	  dq[0] = x1;
	  dq[1] = y1;
	  dq[2] = z1;
	  dq[3] = w1;
	  var ax = x2 * 0.5,
	      ay = y2 * 0.5,
	      az = z2 * 0.5;
	  dq[4] = ax * w1 + ay * z1 - az * y1;
	  dq[5] = ay * w1 + az * x1 - ax * z1;
	  dq[6] = az * w1 + ax * y1 - ay * x1;
	  dq[7] = -ax * x1 - ay * y1 - az * z1;
	  return dq;
	}

	/**
	 * Creates a dual quat from a quaternion and a translation
	 *
	 * @param {quat2} dual quaternion receiving operation result
	 * @param {quat} q quaternion
	 * @param {vec3} t tranlation vector
	 * @returns {quat2} dual quaternion receiving operation result
	 * @function
	 */
	function fromRotationTranslation(out, q, t) {
	  var ax = t[0] * 0.5,
	      ay = t[1] * 0.5,
	      az = t[2] * 0.5,
	      bx = q[0],
	      by = q[1],
	      bz = q[2],
	      bw = q[3];
	  out[0] = bx;
	  out[1] = by;
	  out[2] = bz;
	  out[3] = bw;
	  out[4] = ax * bw + ay * bz - az * by;
	  out[5] = ay * bw + az * bx - ax * bz;
	  out[6] = az * bw + ax * by - ay * bx;
	  out[7] = -ax * bx - ay * by - az * bz;
	  return out;
	}

	/**
	 * Creates a dual quat from a translation
	 *
	 * @param {quat2} dual quaternion receiving operation result
	 * @param {vec3} t translation vector
	 * @returns {quat2} dual quaternion receiving operation result
	 * @function
	 */
	function fromTranslation(out, t) {
	  out[0] = 0;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 1;
	  out[4] = t[0] * 0.5;
	  out[5] = t[1] * 0.5;
	  out[6] = t[2] * 0.5;
	  out[7] = 0;
	  return out;
	}

	/**
	 * Creates a dual quat from a quaternion
	 *
	 * @param {quat2} dual quaternion receiving operation result
	 * @param {quat} q the quaternion
	 * @returns {quat2} dual quaternion receiving operation result
	 * @function
	 */
	function fromRotation(out, q) {
	  out[0] = q[0];
	  out[1] = q[1];
	  out[2] = q[2];
	  out[3] = q[3];
	  out[4] = 0;
	  out[5] = 0;
	  out[6] = 0;
	  out[7] = 0;
	  return out;
	}

	/**
	 * Creates a new dual quat from a matrix (4x4)
	 *
	 * @param {quat2} out the dual quaternion
	 * @param {mat4} a the matrix
	 * @returns {quat2} dual quat receiving operation result
	 * @function
	 */
	function fromMat4(out, a) {
	  //TODO Optimize this
	  var outer = create$2();
	  getRotation(outer, a);
	  var t = new ARRAY_TYPE(3);
	  getTranslation$1(t, a);
	  fromRotationTranslation(out, outer, t);
	  return out;
	}

	/**
	 * Copy the values from one dual quat to another
	 *
	 * @param {quat2} out the receiving dual quaternion
	 * @param {quat2} a the source dual quaternion
	 * @returns {quat2} out
	 * @function
	 */
	function copy$1(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  out[2] = a[2];
	  out[3] = a[3];
	  out[4] = a[4];
	  out[5] = a[5];
	  out[6] = a[6];
	  out[7] = a[7];
	  return out;
	}

	/**
	 * Set a dual quat to the identity dual quaternion
	 *
	 * @param {quat2} out the receiving quaternion
	 * @returns {quat2} out
	 */
	function identity(out) {
	  out[0] = 0;
	  out[1] = 0;
	  out[2] = 0;
	  out[3] = 1;
	  out[4] = 0;
	  out[5] = 0;
	  out[6] = 0;
	  out[7] = 0;
	  return out;
	}

	/**
	 * Set the components of a dual quat to the given values
	 *
	 * @param {quat2} out the receiving quaternion
	 * @param {Number} x1 X component
	 * @param {Number} y1 Y component
	 * @param {Number} z1 Z component
	 * @param {Number} w1 W component
	 * @param {Number} x2 X component
	 * @param {Number} y2 Y component
	 * @param {Number} z2 Z component
	 * @param {Number} w2 W component
	 * @returns {quat2} out
	 * @function
	 */
	function set$1(out, x1, y1, z1, w1, x2, y2, z2, w2) {
	  out[0] = x1;
	  out[1] = y1;
	  out[2] = z1;
	  out[3] = w1;

	  out[4] = x2;
	  out[5] = y2;
	  out[6] = z2;
	  out[7] = w2;
	  return out;
	}

	/**
	 * Gets the real part of a dual quat
	 * @param  {quat} out real part
	 * @param  {quat2} a Dual Quaternion
	 * @return {quat} real part
	 */
	var getReal = copy$2;

	/**
	 * Gets the dual part of a dual quat
	 * @param  {quat} out dual part
	 * @param  {quat2} a Dual Quaternion
	 * @return {quat} dual part
	 */
	function getDual(out, a) {
	  out[0] = a[4];
	  out[1] = a[5];
	  out[2] = a[6];
	  out[3] = a[7];
	  return out;
	}

	/**
	 * Set the real component of a dual quat to the given quaternion
	 *
	 * @param {quat2} out the receiving quaternion
	 * @param {quat} q a quaternion representing the real part
	 * @returns {quat2} out
	 * @function
	 */
	var setReal = copy$2;

	/**
	 * Set the dual component of a dual quat to the given quaternion
	 *
	 * @param {quat2} out the receiving quaternion
	 * @param {quat} q a quaternion representing the dual part
	 * @returns {quat2} out
	 * @function
	 */
	function setDual(out, q) {
	  out[4] = q[0];
	  out[5] = q[1];
	  out[6] = q[2];
	  out[7] = q[3];
	  return out;
	}

	/**
	 * Gets the translation of a normalized dual quat
	 * @param  {vec3} out translation
	 * @param  {quat2} a Dual Quaternion to be decomposed
	 * @return {vec3} translation
	 */
	function getTranslation(out, a) {
	  var ax = a[4],
	      ay = a[5],
	      az = a[6],
	      aw = a[7],
	      bx = -a[0],
	      by = -a[1],
	      bz = -a[2],
	      bw = a[3];
	  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
	  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
	  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
	  return out;
	}

	/**
	 * Translates a dual quat by the given vector
	 *
	 * @param {quat2} out the receiving dual quaternion
	 * @param {quat2} a the dual quaternion to translate
	 * @param {vec3} v vector to translate by
	 * @returns {quat2} out
	 */
	function translate(out, a, v) {
	  var ax1 = a[0],
	      ay1 = a[1],
	      az1 = a[2],
	      aw1 = a[3],
	      bx1 = v[0] * 0.5,
	      by1 = v[1] * 0.5,
	      bz1 = v[2] * 0.5,
	      ax2 = a[4],
	      ay2 = a[5],
	      az2 = a[6],
	      aw2 = a[7];
	  out[0] = ax1;
	  out[1] = ay1;
	  out[2] = az1;
	  out[3] = aw1;
	  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
	  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
	  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
	  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
	  return out;
	}

	/**
	 * Rotates a dual quat around the X axis
	 *
	 * @param {quat2} out the receiving dual quaternion
	 * @param {quat2} a the dual quaternion to rotate
	 * @param {number} rad how far should the rotation be
	 * @returns {quat2} out
	 */
	function rotateX(out, a, rad) {
	  var bx = -a[0],
	      by = -a[1],
	      bz = -a[2],
	      bw = a[3],
	      ax = a[4],
	      ay = a[5],
	      az = a[6],
	      aw = a[7],
	      ax1 = ax * bw + aw * bx + ay * bz - az * by,
	      ay1 = ay * bw + aw * by + az * bx - ax * bz,
	      az1 = az * bw + aw * bz + ax * by - ay * bx,
	      aw1 = aw * bw - ax * bx - ay * by - az * bz;
	  rotateX$1(out, a, rad);
	  bx = out[0];
	  by = out[1];
	  bz = out[2];
	  bw = out[3];
	  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
	  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
	  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
	  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
	  return out;
	}

	/**
	 * Rotates a dual quat around the Y axis
	 *
	 * @param {quat2} out the receiving dual quaternion
	 * @param {quat2} a the dual quaternion to rotate
	 * @param {number} rad how far should the rotation be
	 * @returns {quat2} out
	 */
	function rotateY(out, a, rad) {
	  var bx = -a[0],
	      by = -a[1],
	      bz = -a[2],
	      bw = a[3],
	      ax = a[4],
	      ay = a[5],
	      az = a[6],
	      aw = a[7],
	      ax1 = ax * bw + aw * bx + ay * bz - az * by,
	      ay1 = ay * bw + aw * by + az * bx - ax * bz,
	      az1 = az * bw + aw * bz + ax * by - ay * bx,
	      aw1 = aw * bw - ax * bx - ay * by - az * bz;
	  rotateY$1(out, a, rad);
	  bx = out[0];
	  by = out[1];
	  bz = out[2];
	  bw = out[3];
	  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
	  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
	  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
	  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
	  return out;
	}

	/**
	 * Rotates a dual quat around the Z axis
	 *
	 * @param {quat2} out the receiving dual quaternion
	 * @param {quat2} a the dual quaternion to rotate
	 * @param {number} rad how far should the rotation be
	 * @returns {quat2} out
	 */
	function rotateZ(out, a, rad) {
	  var bx = -a[0],
	      by = -a[1],
	      bz = -a[2],
	      bw = a[3],
	      ax = a[4],
	      ay = a[5],
	      az = a[6],
	      aw = a[7],
	      ax1 = ax * bw + aw * bx + ay * bz - az * by,
	      ay1 = ay * bw + aw * by + az * bx - ax * bz,
	      az1 = az * bw + aw * bz + ax * by - ay * bx,
	      aw1 = aw * bw - ax * bx - ay * by - az * bz;
	  rotateZ$1(out, a, rad);
	  bx = out[0];
	  by = out[1];
	  bz = out[2];
	  bw = out[3];
	  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
	  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
	  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
	  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
	  return out;
	}

	/**
	 * Rotates a dual quat by a given quaternion (a * q)
	 *
	 * @param {quat2} out the receiving dual quaternion
	 * @param {quat2} a the dual quaternion to rotate
	 * @param {quat} q quaternion to rotate by
	 * @returns {quat2} out
	 */
	function rotateByQuatAppend(out, a, q) {
	  var qx = q[0],
	      qy = q[1],
	      qz = q[2],
	      qw = q[3],
	      ax = a[0],
	      ay = a[1],
	      az = a[2],
	      aw = a[3];

	  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
	  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
	  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
	  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
	  ax = a[4];
	  ay = a[5];
	  az = a[6];
	  aw = a[7];
	  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
	  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
	  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
	  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
	  return out;
	}

	/**
	 * Rotates a dual quat by a given quaternion (q * a)
	 *
	 * @param {quat2} out the receiving dual quaternion
	 * @param {quat} q quaternion to rotate by
	 * @param {quat2} a the dual quaternion to rotate
	 * @returns {quat2} out
	 */
	function rotateByQuatPrepend(out, q, a) {
	  var qx = q[0],
	      qy = q[1],
	      qz = q[2],
	      qw = q[3],
	      bx = a[0],
	      by = a[1],
	      bz = a[2],
	      bw = a[3];

	  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
	  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
	  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
	  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
	  bx = a[4];
	  by = a[5];
	  bz = a[6];
	  bw = a[7];
	  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
	  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
	  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
	  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
	  return out;
	}

	/**
	 * Rotates a dual quat around a given axis. Does the normalisation automatically
	 *
	 * @param {quat2} out the receiving dual quaternion
	 * @param {quat2} a the dual quaternion to rotate
	 * @param {vec3} axis the axis to rotate around
	 * @param {Number} rad how far the rotation should be
	 * @returns {quat2} out
	 */
	function rotateAroundAxis(out, a, axis, rad) {
	  //Special case for rad = 0
	  if (Math.abs(rad) < EPSILON) {
	    return copy$1(out, a);
	  }
	  var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);

	  rad = rad * 0.5;
	  var s = Math.sin(rad);
	  var bx = s * axis[0] / axisLength;
	  var by = s * axis[1] / axisLength;
	  var bz = s * axis[2] / axisLength;
	  var bw = Math.cos(rad);

	  var ax1 = a[0],
	      ay1 = a[1],
	      az1 = a[2],
	      aw1 = a[3];
	  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
	  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
	  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
	  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;

	  var ax = a[4],
	      ay = a[5],
	      az = a[6],
	      aw = a[7];
	  out[4] = ax * bw + aw * bx + ay * bz - az * by;
	  out[5] = ay * bw + aw * by + az * bx - ax * bz;
	  out[6] = az * bw + aw * bz + ax * by - ay * bx;
	  out[7] = aw * bw - ax * bx - ay * by - az * bz;

	  return out;
	}

	/**
	 * Adds two dual quat's
	 *
	 * @param {quat2} out the receiving dual quaternion
	 * @param {quat2} a the first operand
	 * @param {quat2} b the second operand
	 * @returns {quat2} out
	 * @function
	 */
	function add$1(out, a, b) {
	  out[0] = a[0] + b[0];
	  out[1] = a[1] + b[1];
	  out[2] = a[2] + b[2];
	  out[3] = a[3] + b[3];
	  out[4] = a[4] + b[4];
	  out[5] = a[5] + b[5];
	  out[6] = a[6] + b[6];
	  out[7] = a[7] + b[7];
	  return out;
	}

	/**
	 * Multiplies two dual quat's
	 *
	 * @param {quat2} out the receiving dual quaternion
	 * @param {quat2} a the first operand
	 * @param {quat2} b the second operand
	 * @returns {quat2} out
	 */
	function multiply$1(out, a, b) {
	  var ax0 = a[0],
	      ay0 = a[1],
	      az0 = a[2],
	      aw0 = a[3],
	      bx1 = b[4],
	      by1 = b[5],
	      bz1 = b[6],
	      bw1 = b[7],
	      ax1 = a[4],
	      ay1 = a[5],
	      az1 = a[6],
	      aw1 = a[7],
	      bx0 = b[0],
	      by0 = b[1],
	      bz0 = b[2],
	      bw0 = b[3];
	  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
	  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
	  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
	  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
	  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
	  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
	  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
	  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
	  return out;
	}

	/**
	 * Alias for {@link quat2.multiply}
	 * @function
	 */
	var mul$1 = multiply$1;

	/**
	 * Scales a dual quat by a scalar number
	 *
	 * @param {quat2} out the receiving dual quat
	 * @param {quat2} a the dual quat to scale
	 * @param {Number} b amount to scale the dual quat by
	 * @returns {quat2} out
	 * @function
	 */
	function scale$1(out, a, b) {
	  out[0] = a[0] * b;
	  out[1] = a[1] * b;
	  out[2] = a[2] * b;
	  out[3] = a[3] * b;
	  out[4] = a[4] * b;
	  out[5] = a[5] * b;
	  out[6] = a[6] * b;
	  out[7] = a[7] * b;
	  return out;
	}

	/**
	 * Calculates the dot product of two dual quat's (The dot product of the real parts)
	 *
	 * @param {quat2} a the first operand
	 * @param {quat2} b the second operand
	 * @returns {Number} dot product of a and b
	 * @function
	 */
	var dot$1 = dot$2;

	/**
	 * Performs a linear interpolation between two dual quats's
	 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
	 *
	 * @param {quat2} out the receiving dual quat
	 * @param {quat2} a the first operand
	 * @param {quat2} b the second operand
	 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
	 * @returns {quat2} out
	 */
	function lerp$1(out, a, b, t) {
	  var mt = 1 - t;
	  if (dot$1(a, b) < 0) t = -t;

	  out[0] = a[0] * mt + b[0] * t;
	  out[1] = a[1] * mt + b[1] * t;
	  out[2] = a[2] * mt + b[2] * t;
	  out[3] = a[3] * mt + b[3] * t;
	  out[4] = a[4] * mt + b[4] * t;
	  out[5] = a[5] * mt + b[5] * t;
	  out[6] = a[6] * mt + b[6] * t;
	  out[7] = a[7] * mt + b[7] * t;

	  return out;
	}

	/**
	 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
	 *
	 * @param {quat2} out the receiving dual quaternion
	 * @param {quat2} a dual quat to calculate inverse of
	 * @returns {quat2} out
	 */
	function invert(out, a) {
	  var sqlen = squaredLength$1(a);
	  out[0] = -a[0] / sqlen;
	  out[1] = -a[1] / sqlen;
	  out[2] = -a[2] / sqlen;
	  out[3] = a[3] / sqlen;
	  out[4] = -a[4] / sqlen;
	  out[5] = -a[5] / sqlen;
	  out[6] = -a[6] / sqlen;
	  out[7] = a[7] / sqlen;
	  return out;
	}

	/**
	 * Calculates the conjugate of a dual quat
	 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
	 *
	 * @param {quat2} out the receiving quaternion
	 * @param {quat2} a quat to calculate conjugate of
	 * @returns {quat2} out
	 */
	function conjugate(out, a) {
	  out[0] = -a[0];
	  out[1] = -a[1];
	  out[2] = -a[2];
	  out[3] = a[3];
	  out[4] = -a[4];
	  out[5] = -a[5];
	  out[6] = -a[6];
	  out[7] = a[7];
	  return out;
	}

	/**
	 * Calculates the length of a dual quat
	 *
	 * @param {quat2} a dual quat to calculate length of
	 * @returns {Number} length of a
	 * @function
	 */
	var length$1 = length$2;

	/**
	 * Alias for {@link quat2.length}
	 * @function
	 */
	var len$1 = length$1;

	/**
	 * Calculates the squared length of a dual quat
	 *
	 * @param {quat2} a dual quat to calculate squared length of
	 * @returns {Number} squared length of a
	 * @function
	 */
	var squaredLength$1 = squaredLength$2;

	/**
	 * Alias for {@link quat2.squaredLength}
	 * @function
	 */
	var sqrLen$1 = squaredLength$1;

	/**
	 * Normalize a dual quat
	 *
	 * @param {quat2} out the receiving dual quaternion
	 * @param {quat2} a dual quaternion to normalize
	 * @returns {quat2} out
	 * @function
	 */
	function normalize$1(out, a) {
	  var magnitude = squaredLength$1(a);
	  if (magnitude > 0) {
	    magnitude = Math.sqrt(magnitude);

	    var a0 = a[0] / magnitude;
	    var a1 = a[1] / magnitude;
	    var a2 = a[2] / magnitude;
	    var a3 = a[3] / magnitude;

	    var b0 = a[4];
	    var b1 = a[5];
	    var b2 = a[6];
	    var b3 = a[7];

	    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;

	    out[0] = a0;
	    out[1] = a1;
	    out[2] = a2;
	    out[3] = a3;

	    out[4] = (b0 - a0 * a_dot_b) / magnitude;
	    out[5] = (b1 - a1 * a_dot_b) / magnitude;
	    out[6] = (b2 - a2 * a_dot_b) / magnitude;
	    out[7] = (b3 - a3 * a_dot_b) / magnitude;
	  }
	  return out;
	}

	/**
	 * Returns a string representation of a dual quatenion
	 *
	 * @param {quat2} a dual quaternion to represent as a string
	 * @returns {String} string representation of the dual quat
	 */
	function str$1(a) {
	  return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
	}

	/**
	 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
	 *
	 * @param {quat2} a the first dual quaternion.
	 * @param {quat2} b the second dual quaternion.
	 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
	 */
	function exactEquals$1(a, b) {
	  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
	}

	/**
	 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
	 *
	 * @param {quat2} a the first dual quat.
	 * @param {quat2} b the second dual quat.
	 * @returns {Boolean} true if the dual quats are equal, false otherwise.
	 */
	function equals$1(a, b) {
	  var a0 = a[0],
	      a1 = a[1],
	      a2 = a[2],
	      a3 = a[3],
	      a4 = a[4],
	      a5 = a[5],
	      a6 = a[6],
	      a7 = a[7];
	  var b0 = b[0],
	      b1 = b[1],
	      b2 = b[2],
	      b3 = b[3],
	      b4 = b[4],
	      b5 = b[5],
	      b6 = b[6],
	      b7 = b[7];
	  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
	}

	var quat2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create$1,
		clone: clone$1,
		fromValues: fromValues$1,
		fromRotationTranslationValues: fromRotationTranslationValues,
		fromRotationTranslation: fromRotationTranslation,
		fromTranslation: fromTranslation,
		fromRotation: fromRotation,
		fromMat4: fromMat4,
		copy: copy$1,
		identity: identity,
		set: set$1,
		getReal: getReal,
		getDual: getDual,
		setReal: setReal,
		setDual: setDual,
		getTranslation: getTranslation,
		translate: translate,
		rotateX: rotateX,
		rotateY: rotateY,
		rotateZ: rotateZ,
		rotateByQuatAppend: rotateByQuatAppend,
		rotateByQuatPrepend: rotateByQuatPrepend,
		rotateAroundAxis: rotateAroundAxis,
		add: add$1,
		multiply: multiply$1,
		mul: mul$1,
		scale: scale$1,
		dot: dot$1,
		lerp: lerp$1,
		invert: invert,
		conjugate: conjugate,
		length: length$1,
		len: len$1,
		squaredLength: squaredLength$1,
		sqrLen: sqrLen$1,
		normalize: normalize$1,
		str: str$1,
		exactEquals: exactEquals$1,
		equals: equals$1
	});

	/**
	 * 2 Dimensional Vector
	 * @module vec2
	 */

	/**
	 * Creates a new, empty vec2
	 *
	 * @returns {vec2} a new 2D vector
	 */
	function create() {
	  var out = new ARRAY_TYPE(2);
	  if (ARRAY_TYPE != Float32Array) {
	    out[0] = 0;
	    out[1] = 0;
	  }
	  return out;
	}

	/**
	 * Creates a new vec2 initialized with values from an existing vector
	 *
	 * @param {vec2} a vector to clone
	 * @returns {vec2} a new 2D vector
	 */
	function clone(a) {
	  var out = new ARRAY_TYPE(2);
	  out[0] = a[0];
	  out[1] = a[1];
	  return out;
	}

	/**
	 * Creates a new vec2 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @returns {vec2} a new 2D vector
	 */
	function fromValues(x, y) {
	  var out = new ARRAY_TYPE(2);
	  out[0] = x;
	  out[1] = y;
	  return out;
	}

	/**
	 * Copy the values from one vec2 to another
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the source vector
	 * @returns {vec2} out
	 */
	function copy(out, a) {
	  out[0] = a[0];
	  out[1] = a[1];
	  return out;
	}

	/**
	 * Set the components of a vec2 to the given values
	 *
	 * @param {vec2} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @returns {vec2} out
	 */
	function set(out, x, y) {
	  out[0] = x;
	  out[1] = y;
	  return out;
	}

	/**
	 * Adds two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function add(out, a, b) {
	  out[0] = a[0] + b[0];
	  out[1] = a[1] + b[1];
	  return out;
	}

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function subtract(out, a, b) {
	  out[0] = a[0] - b[0];
	  out[1] = a[1] - b[1];
	  return out;
	}

	/**
	 * Multiplies two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function multiply(out, a, b) {
	  out[0] = a[0] * b[0];
	  out[1] = a[1] * b[1];
	  return out;
	}

	/**
	 * Divides two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function divide(out, a, b) {
	  out[0] = a[0] / b[0];
	  out[1] = a[1] / b[1];
	  return out;
	}

	/**
	 * Math.ceil the components of a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to ceil
	 * @returns {vec2} out
	 */
	function ceil(out, a) {
	  out[0] = Math.ceil(a[0]);
	  out[1] = Math.ceil(a[1]);
	  return out;
	}

	/**
	 * Math.floor the components of a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to floor
	 * @returns {vec2} out
	 */
	function floor(out, a) {
	  out[0] = Math.floor(a[0]);
	  out[1] = Math.floor(a[1]);
	  return out;
	}

	/**
	 * Returns the minimum of two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function min(out, a, b) {
	  out[0] = Math.min(a[0], b[0]);
	  out[1] = Math.min(a[1], b[1]);
	  return out;
	}

	/**
	 * Returns the maximum of two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function max(out, a, b) {
	  out[0] = Math.max(a[0], b[0]);
	  out[1] = Math.max(a[1], b[1]);
	  return out;
	}

	/**
	 * Math.round the components of a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to round
	 * @returns {vec2} out
	 */
	function round(out, a) {
	  out[0] = Math.round(a[0]);
	  out[1] = Math.round(a[1]);
	  return out;
	}

	/**
	 * Scales a vec2 by a scalar number
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec2} out
	 */
	function scale(out, a, b) {
	  out[0] = a[0] * b;
	  out[1] = a[1] * b;
	  return out;
	}

	/**
	 * Adds two vec2's after scaling the second operand by a scalar value
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @param {Number} scale the amount to scale b by before adding
	 * @returns {vec2} out
	 */
	function scaleAndAdd(out, a, b, scale) {
	  out[0] = a[0] + b[0] * scale;
	  out[1] = a[1] + b[1] * scale;
	  return out;
	}

	/**
	 * Calculates the euclidian distance between two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} distance between a and b
	 */
	function distance(a, b) {
	  var x = b[0] - a[0],
	      y = b[1] - a[1];
	  return Math.sqrt(x * x + y * y);
	}

	/**
	 * Calculates the squared euclidian distance between two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} squared distance between a and b
	 */
	function squaredDistance(a, b) {
	  var x = b[0] - a[0],
	      y = b[1] - a[1];
	  return x * x + y * y;
	}

	/**
	 * Calculates the length of a vec2
	 *
	 * @param {vec2} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	function length(a) {
	  var x = a[0],
	      y = a[1];
	  return Math.sqrt(x * x + y * y);
	}

	/**
	 * Calculates the squared length of a vec2
	 *
	 * @param {vec2} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	function squaredLength(a) {
	  var x = a[0],
	      y = a[1];
	  return x * x + y * y;
	}

	/**
	 * Negates the components of a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to negate
	 * @returns {vec2} out
	 */
	function negate(out, a) {
	  out[0] = -a[0];
	  out[1] = -a[1];
	  return out;
	}

	/**
	 * Returns the inverse of the components of a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to invert
	 * @returns {vec2} out
	 */
	function inverse(out, a) {
	  out[0] = 1.0 / a[0];
	  out[1] = 1.0 / a[1];
	  return out;
	}

	/**
	 * Normalize a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to normalize
	 * @returns {vec2} out
	 */
	function normalize(out, a) {
	  var x = a[0],
	      y = a[1];
	  var len = x * x + y * y;
	  if (len > 0) {
	    //TODO: evaluate use of glm_invsqrt here?
	    len = 1 / Math.sqrt(len);
	    out[0] = a[0] * len;
	    out[1] = a[1] * len;
	  }
	  return out;
	}

	/**
	 * Calculates the dot product of two vec2's
	 *
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	function dot(a, b) {
	  return a[0] * b[0] + a[1] * b[1];
	}

	/**
	 * Computes the cross product of two vec2's
	 * Note that the cross product must by definition produce a 3D vector
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec3} out
	 */
	function cross(out, a, b) {
	  var z = a[0] * b[1] - a[1] * b[0];
	  out[0] = out[1] = 0;
	  out[2] = z;
	  return out;
	}

	/**
	 * Performs a linear interpolation between two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
	 * @returns {vec2} out
	 */
	function lerp(out, a, b, t) {
	  var ax = a[0],
	      ay = a[1];
	  out[0] = ax + t * (b[0] - ax);
	  out[1] = ay + t * (b[1] - ay);
	  return out;
	}

	/**
	 * Generates a random vector with the given scale
	 *
	 * @param {vec2} out the receiving vector
	 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
	 * @returns {vec2} out
	 */
	function random(out, scale) {
	  scale = scale || 1.0;
	  var r = RANDOM() * 2.0 * Math.PI;
	  out[0] = Math.cos(r) * scale;
	  out[1] = Math.sin(r) * scale;
	  return out;
	}

	/**
	 * Transforms the vec2 with a mat2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat2} m matrix to transform with
	 * @returns {vec2} out
	 */
	function transformMat2(out, a, m) {
	  var x = a[0],
	      y = a[1];
	  out[0] = m[0] * x + m[2] * y;
	  out[1] = m[1] * x + m[3] * y;
	  return out;
	}

	/**
	 * Transforms the vec2 with a mat2d
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat2d} m matrix to transform with
	 * @returns {vec2} out
	 */
	function transformMat2d(out, a, m) {
	  var x = a[0],
	      y = a[1];
	  out[0] = m[0] * x + m[2] * y + m[4];
	  out[1] = m[1] * x + m[3] * y + m[5];
	  return out;
	}

	/**
	 * Transforms the vec2 with a mat3
	 * 3rd vector component is implicitly '1'
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat3} m matrix to transform with
	 * @returns {vec2} out
	 */
	function transformMat3(out, a, m) {
	  var x = a[0],
	      y = a[1];
	  out[0] = m[0] * x + m[3] * y + m[6];
	  out[1] = m[1] * x + m[4] * y + m[7];
	  return out;
	}

	/**
	 * Transforms the vec2 with a mat4
	 * 3rd vector component is implicitly '0'
	 * 4th vector component is implicitly '1'
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec2} out
	 */
	function transformMat4(out, a, m) {
	  var x = a[0];
	  var y = a[1];
	  out[0] = m[0] * x + m[4] * y + m[12];
	  out[1] = m[1] * x + m[5] * y + m[13];
	  return out;
	}

	/**
	 * Rotate a 2D vector
	 * @param {vec2} out The receiving vec2
	 * @param {vec2} a The vec2 point to rotate
	 * @param {vec2} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec2} out
	 */
	function rotate(out, a, b, c) {
	  //Translate point to the origin
	  var p0 = a[0] - b[0],
	      p1 = a[1] - b[1],
	      sinC = Math.sin(c),
	      cosC = Math.cos(c);

	  //perform rotation and translate to correct position
	  out[0] = p0 * cosC - p1 * sinC + b[0];
	  out[1] = p0 * sinC + p1 * cosC + b[1];

	  return out;
	}

	/**
	 * Get the angle between two 2D vectors
	 * @param {vec2} a The first operand
	 * @param {vec2} b The second operand
	 * @returns {Number} The angle in radians
	 */
	function angle(a, b) {
	  var x1 = a[0],
	      y1 = a[1],
	      x2 = b[0],
	      y2 = b[1];

	  var len1 = x1 * x1 + y1 * y1;
	  if (len1 > 0) {
	    //TODO: evaluate use of glm_invsqrt here?
	    len1 = 1 / Math.sqrt(len1);
	  }

	  var len2 = x2 * x2 + y2 * y2;
	  if (len2 > 0) {
	    //TODO: evaluate use of glm_invsqrt here?
	    len2 = 1 / Math.sqrt(len2);
	  }

	  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

	  if (cosine > 1.0) {
	    return 0;
	  } else if (cosine < -1.0) {
	    return Math.PI;
	  } else {
	    return Math.acos(cosine);
	  }
	}

	/**
	 * Returns a string representation of a vector
	 *
	 * @param {vec2} a vector to represent as a string
	 * @returns {String} string representation of the vector
	 */
	function str(a) {
	  return 'vec2(' + a[0] + ', ' + a[1] + ')';
	}

	/**
	 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
	 *
	 * @param {vec2} a The first vector.
	 * @param {vec2} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	function exactEquals(a, b) {
	  return a[0] === b[0] && a[1] === b[1];
	}

	/**
	 * Returns whether or not the vectors have approximately the same elements in the same position.
	 *
	 * @param {vec2} a The first vector.
	 * @param {vec2} b The second vector.
	 * @returns {Boolean} True if the vectors are equal, false otherwise.
	 */
	function equals(a, b) {
	  var a0 = a[0],
	      a1 = a[1];
	  var b0 = b[0],
	      b1 = b[1];
	  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
	}

	/**
	 * Alias for {@link vec2.length}
	 * @function
	 */
	var len = length;

	/**
	 * Alias for {@link vec2.subtract}
	 * @function
	 */
	var sub = subtract;

	/**
	 * Alias for {@link vec2.multiply}
	 * @function
	 */
	var mul = multiply;

	/**
	 * Alias for {@link vec2.divide}
	 * @function
	 */
	var div = divide;

	/**
	 * Alias for {@link vec2.distance}
	 * @function
	 */
	var dist = distance;

	/**
	 * Alias for {@link vec2.squaredDistance}
	 * @function
	 */
	var sqrDist = squaredDistance;

	/**
	 * Alias for {@link vec2.squaredLength}
	 * @function
	 */
	var sqrLen = squaredLength;

	/**
	 * Perform some operation over an array of vec2s.
	 *
	 * @param {Array} a the array of vectors to iterate over
	 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
	 * @param {Number} offset Number of elements to skip at the beginning of the array
	 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
	 * @param {Function} fn Function to call for each vector in the array
	 * @param {Object} [arg] additional argument to pass to fn
	 * @returns {Array} a
	 * @function
	 */
	var forEach = function () {
	  var vec = create();

	  return function (a, stride, offset, count, fn, arg) {
	    var i = void 0,
	        l = void 0;
	    if (!stride) {
	      stride = 2;
	    }

	    if (!offset) {
	      offset = 0;
	    }

	    if (count) {
	      l = Math.min(count * stride + offset, a.length);
	    } else {
	      l = a.length;
	    }

	    for (i = offset; i < l; i += stride) {
	      vec[0] = a[i];vec[1] = a[i + 1];
	      fn(vec, vec, arg);
	      a[i] = vec[0];a[i + 1] = vec[1];
	    }

	    return a;
	  };
	}();

	var vec2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		create: create,
		clone: clone,
		fromValues: fromValues,
		copy: copy,
		set: set,
		add: add,
		subtract: subtract,
		multiply: multiply,
		divide: divide,
		ceil: ceil,
		floor: floor,
		min: min,
		max: max,
		round: round,
		scale: scale,
		scaleAndAdd: scaleAndAdd,
		distance: distance,
		squaredDistance: squaredDistance,
		length: length,
		squaredLength: squaredLength,
		negate: negate,
		inverse: inverse,
		normalize: normalize,
		dot: dot,
		cross: cross,
		lerp: lerp,
		random: random,
		transformMat2: transformMat2,
		transformMat2d: transformMat2d,
		transformMat3: transformMat3,
		transformMat4: transformMat4,
		rotate: rotate,
		angle: angle,
		str: str,
		exactEquals: exactEquals,
		equals: equals,
		len: len,
		sub: sub,
		mul: mul,
		div: div,
		dist: dist,
		sqrDist: sqrDist,
		sqrLen: sqrLen,
		forEach: forEach
	});

	/*!
	 * @maptalks/gltf-loader v0.27.2
	 * LICENSE : UNLICENSED
	 * (c) 2016-2022 maptalks.org
	 */
	let n=0;function i$1(e){return null==e}function a(e){return !i$1(e)}function o(e){for(let t=1;t<arguments.length;t++){const s=arguments[t];for(const t in s)e[t]=s[t];}return e}function f$1(e){switch(e){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5124:return Int32Array;case 5125:return Uint32Array;case 5126:return Float32Array}throw new Error("unsupported bufferView's component type: "+e)}function u$1(e){return 0===e.indexOf("data:")&&e.indexOf("base64,")>0}function h(e){const t=function(e){return "undefined"!=typeof self?self.atob(e):window.atob(e)}(e.substring(e.indexOf(",")+1)),s=t.length,r=new Uint8Array(s);for(let e=0;e<s;e++)r[e]=t.charCodeAt(e);return r.buffer}const c$1=[],l=[],d$1=[],m$2=[0,0,0],g$1=identity$1([]),p$1=[1,1,1];function b$2(e,t,s,r,n,i,a){const o=f$1(a);if((0===n||n===r*o.BYTES_PER_ELEMENT)&&i%o.BYTES_PER_ELEMENT==0){const n=new o(t,i,s*r);return e.set(n),e}0===n&&(n=r*o.BYTES_PER_ELEMENT);const u=new Uint8Array(r*o.BYTES_PER_ELEMENT);for(let a=0;a<s;a++){let s=null;const f=new Uint8Array(t,n*a+i,r*o.BYTES_PER_ELEMENT);u.set(f),s=new o(u.buffer,0,r);for(let t=0;t<r;t++)e[a*r+t]=s[t];}return e}const y$2="undefined"!=typeof TextDecoder?new TextDecoder("utf-8"):null;function _$3(e,t,s){const r=new Uint8Array(e,t,s);return y$2.decode(r)}const w$2={get:function(e,t={}){t||(t={});const s=new AbortController,r=s.signal,n=o({},t);n.signal=r,n.method||(n.method="GET");const i=fetch(e,n).then(e=>{const s=this._parseResponse(e,t.responseType);return s.message?s:s.then(s=>"arraybuffer"===t.responseType?{data:s,cacheControl:e.headers.get("Cache-Control"),expires:e.headers.get("Expires"),contentType:e.headers.get("Content-Type")}:s).catch(e=>{if(!e.code||e.code!==DOMException.ABORT_ERR)throw e})}).catch(e=>{if(!e.code||e.code!==DOMException.ABORT_ERR)throw e});return i.xhr=s,i},_parseResponse:(e,t)=>200!==e.status?{status:e.status,statusText:e.statusText,message:`incorrect http request with status code(${e.status}): ${e.statusText}`}:"arraybuffer"===t?e.arrayBuffer():"json"===t?e.json():e.text(),getArrayBuffer:(e,t={})=>(t||(t={}),t.responseType="arraybuffer",w$2.get(e,t)),getJSON:function(e,t={}){return t&&t.jsonp?w$2.jsonp(e):((t=t||{}).responseType="json",w$2.get(e,t))}};w$2.jsonp=function(e){const t="_maptalks_jsonp_"+n++;e.match(/\?/)?e+="&callback="+t:e+="?callback="+t;let s=document.createElement("script");return s.type="text/javascript",s.src=e,new Promise(e=>{window[t]=function(r){document.getElementsByTagName("head")[0].removeChild(s),s=null,delete window[t],e(r);},document.getElementsByTagName("head")[0].appendChild(s);})};class x$2{constructor(e,t,s){this._requestImage=e,this.decoders=t,this._supportedFormats=s,this.images={},this._imgRequests={};}requestImageFromBufferURI(e,t,s){if(this.buffers[e.id]){const r=this.buffers[e.id],n=this._createDataView(t,r);return this.getImageByBuffer(n,s)}if(this._imgRequests[e.id])return this._imgRequests[e.id].then(()=>{const r=this.buffers[e.id],n=this._createDataView(t,r);return this.getImageByBuffer(n,s)});if(u$1(e.uri)){const r=this.buffers[e.id]=h(e.uri),n=this._createDataView(t,r);return this.getImageByBuffer(n,s)}return this._imgRequests[e.id]=w$2.getArrayBuffer(e.uri,null).then(r=>{const n=this.buffers[e.id]=r.data,i=this._createDataView(t,n);return this.getImageByBuffer(i,s)})}getImageByBuffer(e,t){if(this.images[t.id])return Promise.resolve(this.images[t.id]);const s=this.decoders;if(s[t.mimeType])return s[t.mimeType](e,{supportedFormats:this._supportedFormats});if("image/crn"===t.mimeType||"image/ktx2"===t.mimeType||"image/cttf"===t.mimeType)return console.warn("missing transcoder for "+t.mimeType,", visit https://maptalks.com/docs/transcoders for details"),Promise.resolve(null);{const s=new Blob([e],{type:t.mimeType}),r=URL.createObjectURL(s);return this._getImageInfo(t.id,r)}}requestExternalImage(e){if(this.images[e.id])return Promise.resolve(this.images[e.id]);const t=0===e.uri.indexOf("data:image/")?e.uri:this.rootPath+"/"+e.uri;if(this._imgRequests[e.id])return this._imgRequests[e.id].then(()=>this.images[e.id]);return this._imgRequests[e.id]=this._getImageInfo(e.id,t)}_getImageInfo(e,t){return new Promise((s,r)=>{this._requestImage(t,(n,i)=>{n?r(n):(URL.revokeObjectURL(t),this.images[e]=i,s(this.images[e]));});})}}const T$3=["SCALAR",1,"VEC2",2,"VEC3",3,"VEC4",4,"MAT2",4,"MAT3",9,"MAT4",16];class E$2{constructor(e,t,s){this.rootPath=e,this.gltf=t,this._enableInterleave=!1,this.glbBuffer=s,this.buffers={},this.requests={},this.accessors={},this._compareAccessor();}_requestData(e,t){const s=this.gltf,r=s.accessors[t];if(void 0===r.bufferView)return this.accessors[r.id]=this._toBufferData(e,t,null,0),Promise.resolve(this.accessors[r.id]);if(r&&this.accessors[r.id])return Promise.resolve(this.accessors[r.id]);const n=s.bufferViews[r.bufferView];return this._requestBufferOfBufferView(n).then(s=>{const{buffer:n,byteOffset:i}=s;return this.accessors[r.id]=this._toBufferData(e,t,n,i)})}_requestBufferOfBufferView(e){const t=this.gltf.buffers[e.buffer];if(this.buffers[t.id]){const e=this.buffers[t.id];return Promise.resolve({buffer:e,byteOffset:0})}if(this.requests[t.id])return this.requests[t.id].then(()=>{const e=this.buffers[t.id];return Promise.resolve({buffer:e,byteOffset:0})});if("binary_glTF"!==e.buffer&&"KHR_binary_glTF"!==e.buffer&&t.uri){if(u$1(t.uri)){const e=this.buffers[t.id]=h(t.uri);return Promise.resolve({buffer:e,byteOffset:0})}let e;const s=t.uri.indexOf("blob:")>=0;e=t.uri.indexOf("://")>0||s?t.uri:this.rootPath+"/"+t.uri;return this.requests[t.id]=w$2.getArrayBuffer(e,null).then(r=>{s&&URL.revokeObjectURL(e);return {buffer:this.buffers[t.id]=r.data,byteOffset:0}})}return Promise.resolve({buffer:this.glbBuffer.buffer,byteOffset:this.glbBuffer.byteOffset})}_toBufferData(e,t,s,r=0){const n=this.gltf,i=n.accessors[t],a=void 0!==i.bufferView?n.bufferViews[i.bufferView]:{},o=(a.byteOffset||0)+r,u=this._getTypeItemSize(i.type),h=f$1(i.componentType),c=a.byteStride||0;const l={array:void 0,name:e,accessorName:t,byteLength:i.count*u*h.BYTES_PER_ELEMENT,componentType:i.componentType,count:i.count,type:i.type,itemSize:u};if(i.min&&(l.min=i.min),i.max&&(l.max=i.max),s)if(this._enableInterleave)l.byteStride=c,l.byteOffset=o+(i.byteOffset||0),!c||c===u*h.BYTES_PER_ELEMENT||"indices"===e||"input"===e||"output"===e||e.indexOf("morph")>=0?(l.array=this._typedArray(s,i.count,u,o+(i.byteOffset||0),h),l.array.buffer.byteLength===l.byteLength&&(l.byteOffset=0)):l.array=new Uint8Array(s,o,a.byteLength);else if(i.interleaved){l.byteStride=0,l.byteOffset=0;const e=new h(i.count*u);l.array=b$2(e,s,i.count,u,c,o+(i.byteOffset||0),i.componentType);}else l.byteStride=0,l.array=this._typedArray(s,i.count,u,o+(i.byteOffset||0),h),l.byteOffset=l.array.byteOffset;else {l.array=new h(i.count);const e=l.min||l.max;e&&(l.array[0]=e[0],l.array[1]=e[1],l.array[2]=e[2]);}return l}_compareAccessor(){const e=this.gltf.accessors;if(Array.isArray(e))for(let t=0;t<e.length;t++)for(let s=0;s<e.length;s++)t!==s&&e[t].bufferView===e[s].bufferView&&(e[t].interleaved=e[s].interleaved=!0);else for(const t in e)for(const s in e)t!==s&&e[t].bufferView===e[s].bufferView&&(e[t].interleaved=e[s].interleaved=!0);}_typedArray(e,t,s,r,n){return r%n.BYTES_PER_ELEMENT!=0&&(e=e.slice(r,r+t*s*n.BYTES_PER_ELEMENT),r=0),new n(e,r,s*t)}_getTypeItemSize(e){const t=T$3.indexOf(e);return T$3[t+1]}requestKHRTechniquesWebgl(e){const{shaders:t}=e,s=t.map(e=>{if(void 0!==e.bufferView){const t=this.gltf.bufferViews[e.bufferView],{byteLength:s}=t;return this._requestBufferOfBufferView(t).then(r=>{const{buffer:n,byteOffset:i}=r,a=_$3(n,i+(t.byteOffset||0),s);return e.content=a,e})}if(e.uri){if(u$1(e.uri)){const t=h(e.uri),s=_$3(t,0,t.byteLength);return e.content=s,Promise.resolve(e)}{const t=this.rootPath+"/"+e.uri;return w$2.get(t).then(t=>(e.content=t,e))}}return Promise.resolve(e)});return Promise.all(s).then(()=>e)}}class I$2 extends x$2{constructor(e,t,s,r,n,i){super(r,n,i),this.rootPath=e,this.gltf=t,this.requests={},this.buffers={},this.glbBuffer=s,this.accessor=new E$2(e,t,s);}iterate(e,t){const s=this.gltf[t];if(!s)return;let r=0;for(const t in s)e(t,s[t],r++);}createNode(e){const s={};if(a(e.name)&&(s.name=e.name),a(e.children)&&(s.children=e.children),a(e.jointName)&&(s.jointName=e.jointName),a(e.matrix)&&(s.matrix=e.matrix),a(e.rotation)&&(s.rotation=e.rotation),a(e.scale)&&(s.scale=e.scale),a(e.translation)&&(s.translation=e.translation),a(e.extras)&&(s.extras=e.extras),a(e.meshes)&&(s.mesh=e.meshes[0]),s.translation||s.rotation||s.scale){const e=function(e,s){if(s.matrix)return s.matrix;if(s.translation||s.scale||s.rotation){const r=fromTranslation$1(c$1,s.translation||m$2),n=fromQuat(l,s.rotation||g$1),i=fromScaling(d$1,s.scale||p$1);return multiply$5(i,n,i),multiply$5(e,r,i)}return identity$2(e)}([],s);delete s.translation,delete s.rotation,delete s.scale,s.matrix=e;}return s}_loadMaterials(e){const t={};for(const s in e){const r=e[s];let n,i;r.instanceTechnique&&r.instanceTechnique.values?(n=r.instanceTechnique,i=n.values.diffuse):(n=r,i=n.values.tex||n.values.diffuseTex||n.values.diffuse);const a={baseColorTexture:{index:i}};r.name&&(a.name=r.name),r.extensions&&(a.extensions=r.extensions),r.extras&&(a.extras=r.extras),t[s]=a;}return t}_loadImage(e){if(e.bufferView||e.extensions&&(e.extensions.KHR_binary_glTF||e.extensions.binary_glTF)){const t=e.bufferView?e:e.extensions.KHR_binary_glTF||e.extensions.binary_glTF;e.extensions&&(e.mimeType=t.mimeType,e.width=t.width,e.height=t.height);const s=this.gltf.bufferViews[t.bufferView],r=(s.byteOffset||0)+this.glbBuffer.byteOffset,n=s.byteLength,i=this.buffers[t.bufferView]=new Uint8Array(this.glbBuffer.buffer,r,n);return this.getImageByBuffer(i,e)}return this.requestExternalImage(e)}_getTexture(e){const t=this.gltf.textures[e];if(!t)return null;const s=this.gltf.images[t.source];return this._loadImage(s).then(e=>{const r=this.gltf.samplers[t.sampler];return {image:{array:e.data,width:e.width,height:e.height,index:t.source,mimeType:s.mimeType,name:s.name,extras:s.extras},sampler:r}})}getBaseColorTexture(e){const t=this.gltf.materials[e];let s,r;if(t.instanceTechnique&&t.instanceTechnique.values?(s=t.instanceTechnique,r=s.values.diffuse):(s=t,r=s.values.tex||s.values.diffuseTex||s.values.diffuse),void 0===r||void 0===this.gltf.textures)return null;const n=this.gltf.textures[r];if(!n)return null;const i=this.gltf.samplers[n.sampler];return {format:n.format||6408,internalFormat:n.internalFormat||6408,type:n.type||5121,sampler:i,source:this.gltf.images[n.source]}}getMaterial(){return null}getAnimations(){return null}}class O$2 extends x$2{constructor(e,t,s,r,n,i){super(r,n,i),this.rootPath=e,this.gltf=t,this.glbBuffer=s,this.buffers={},this.requests={},this.accessor=new E$2(e,t,s);}iterate(e,t){const s=this.gltf[t];if(s)for(let t=0;t<s.length;t++)e(t,s[t],t);}createNode(e){const t={};return o(t,e),!a(e.weights)&&this.gltf.meshes&&a(t.mesh)?t.weights=this.gltf.meshes[t.mesh].weights:e.weights&&(t.weights=e.weights),t}_getTexture(e){const t=this.gltf.textures[e];if(!t)return null;const s=this.gltf.images[t.source];return this._loadImage(s).then(e=>{if(!e)return null;const r={image:{array:e.data,mipmap:e.mipmap,width:e.width,height:e.height,index:t.source,mimeType:s.mimeType,name:s.name,extensions:s.extensions,extras:s.extras}};o(r,t);const n=a(t.sampler)?this.gltf.samplers[t.sampler]:void 0;return n&&(r.sampler=n),e.format&&(r.format=e.format),r})}_loadImage(e){if(!a(e.bufferView))return this.requestExternalImage(e);{const t=this.gltf.bufferViews[e.bufferView],s=this.gltf.buffers[t.buffer];if(s.uri)return this.requestImageFromBufferURI(s,t,e);if(this.glbBuffer)return this._requestFromGlbBuffer(t,e)}return null}_requestFromGlbBuffer(e,t){const s=this._createDataView(e,this.glbBuffer.buffer,this.glbBuffer.byteOffset);return this.getImageByBuffer(s,t)}_createDataView(e,t,s){s=s||0;const r=e.byteOffset+s,n=e.byteLength;return new Uint8Array(t,r,n)}_transformArrayBufferToBase64(e,t){const s=new Array(e.byteLength);for(let t=0;t<e.byteLength;t++)s[t]=String.fromCharCode(e[t]);s.join("");return "data:"+(t=t||"image/png")+";base64,"+function(e){return "undefined"!=typeof self?self.btoa(e):window.btoa(e)}(unescape(encodeURIComponent(s)))}getAnimations(e){const t=[];return e.forEach(e=>{t.push(this.getSamplers(e.samplers));}),Promise.all(t).then(t=>{for(let s=0;s<t.length;s++)e[s].samplers=t[s];return e})}getSamplers(e){const t=[];for(let s=0;s<e.length;s++)(a(e[s].input)||a(e[s].output))&&(t.push(this.accessor._requestData("input",e[s].input)),t.push(this.accessor._requestData("output",e[s].output)));return Promise.all(t).then(t=>{for(let s=0;s<t.length/2;s++)e[s].input=t[2*s],e[s].output=t[2*s+1],e[s].interpolation||(e[s].interpolation="LINEAR");return e})}}const R$3="undefined"!=typeof TextDecoder?new TextDecoder("utf-8"):null,N$2=1313821514,B$2=5130562;class A$3{static read(e,t=0,s=0){s||(s=e.byteLength);const r=new DataView(e,t,s),n=r.getUint32(4,!0);if(1===n)return A$3.readV1(r,t);if(2===n)return A$3.readV2(e,t);throw new Error("Unsupported glb version : "+n)}static readV1(e,t){const s=e.getUint32(8,!0),r=e.getUint32(12,!0);if(s!==e.byteLength)throw new Error("Length in GLB header is inconsistent with glb's byte length.");const n=P$2(e.buffer,20+t,r);return {json:JSON.parse(n),glbBuffer:{byteOffset:20+t+r,buffer:e.buffer,byteLength:s}}}static readV2(e,t){let s,r,n;const i=new DataView(e,t+12);let a=0;for(;a<i.byteLength;){const o=i.getUint32(a,!0);a+=4;const f=i.getUint32(a,!0);if(a+=4,f===N$2)s=P$2(e,t+12+a,o);else if(f===B$2){n=t+12+a,r=o;break}a+=o;}return {json:JSON.parse(s),glbBuffer:{byteOffset:n,buffer:e,byteLength:r}}}}function P$2(e,t,s){if(R$3){const r=new Uint8Array(e,t,s);return R$3.decode(r)}return function(e){const t=e.length;let s="";for(let r=0;r<t;){let n=e[r++];if(128&n){let s=S$2[n>>3&7];if(!(64&n)||!s||r+s>t)return null;for(n&=63>>s;s>0;s-=1){const t=e[r++];if(128!=(192&t))return null;n=n<<6|63&t;}}s+=String.fromCharCode(n);}return s}(new Uint8Array(e,t,s))}const S$2=[1,1,1,1,2,2,3,0];const q$2=[0,0,0],v$2=[0,0,0,1],V$2=[1,1,1],M$2={TRANSLATION:[0,0,0],ROTATION:[0,0,0,1],SCALE:[1,1,1]},L$2={PREVIOUS:null,NEXT:null,PREINDEX:null,NEXTINDEX:null,INTERPOLATION:null},U$2={_getTRSW(t,r,n,i,o,f,u,h){const c=a(t)?r.animations:[r.animations[0]],l={};for(let r=0;r<c.length;r++){const d=c[r],m=d.name||r;if(a(t)&&m!==t)continue;const g=d.channelsMap[n];if(g)for(let t=0;t<g.length;t++){const r=g[t];"translation"===r.target.path?(this._getAnimateData(o,d.samplers[r.sampler],i,1),l.translation=copy$4(q$2,o)):"rotation"===r.target.path?(this._getQuaternion(f,d.samplers[r.sampler],i,1),l.rotation=copy$2(v$2,f)):"scale"===r.target.path?(this._getAnimateData(u,d.samplers[r.sampler],i,1),l.scale=copy$4(V$2,u)):"weights"===r.target.path&&h&&(this._getAnimateData(h,d.samplers[r.sampler],i,h.length),l.weights=h);}}return l},_getAnimateData(e,t,s,r){switch(t.interpolation){case"LINEAR":{const n=this._getPreNext(L$2,t,s,1*r);n&&(e=function(e,t,s,r){for(let n=0;n<e.length;n++)e[n]=t[n]+r*(s[n]-t[n]);return e}(e,n.PREVIOUS,n.NEXT,n.INTERPOLATION));break}case"STEP":{const n=this._getPreNext(L$2,t,s,1*r);n&&(e=function(e,t){for(let s=0;s<e.length;s++)e[s]=t[s];return e}(e,...n.PREVIOUS));break}case"CUBICSPLINE":{const n=this._getPreNext(L$2,t,s,3*r);n&&(e=this._getCubicSpline(e,n,t.input.array,3*r));break}}return e},_getQuaternion(t,s,n){switch(s.interpolation){case"LINEAR":{const r=this._getPreNext(L$2,s,n,1);r&&slerp(t,r.PREVIOUS,r.NEXT,r.INTERPOLATION);break}case"STEP":{const e=this._getPreNext(L$2,s,n,1);e&&(t=set$3(t,...e.PREVIOUS));break}case"CUBICSPLINE":{const e=this._getPreNext(L$2,s,n,3);if(e){for(let t=0;t<e.PREVIOUS.length;t++)e.PREVIOUS[t]=Math.acos(e.PREVIOUS[t]),e.NEXT[t]=Math.acos(e.NEXT[t]);t=this._getCubicSpline(t,e,s.input.array,3);for(let e=0;e<t.length;e++)t[e]=Math.cos(t[e]);}break}}return t},_search(e,t){const s=e.length;let r,n,i,a=0,o=s-1,f=Math.floor((a+o)/2);for(;a<=s-1&&o>=0;){if(a===o)return null;if(e[f]<=t&&t<=e[f+1]){const s=e[f];return r=f,n=f+1,i=(t-s)/(e[f+1]-s),{preIndx:r,nextIndex:n,interpolation:i}}t<e[f]?(o=f,f=Math.floor((a+o)/2)):e[f+1]<t&&(a=f,f=Math.floor((a+o)/2));}return null},_getPreNext(e,t,s,r){const n=t.input.array,i=t.output.array,a=t.output.itemSize;(s<n[0]||s>n[n.length-1])&&(s=Math.max(n[0],Math.min(n[n.length-1],s))),s===n[n.length-1]&&(s=n[0]);const o=this._search(n,s);if(!o||!o.nextIndex)return null;const{preIndx:f,nextIndex:u,interpolation:h}=o;e.PREINDEX=f,e.NEXTINDEX=u,e.INTERPOLATION=h;const c=a*r;return e.PREVIOUS=i.subarray(e.PREINDEX*c,(e.PREINDEX+1)*c),e.NEXT=i.subarray(e.NEXTINDEX*c,(e.NEXTINDEX+1)*c),e},_getCubicSpline(e,t,s,r){const n=t.INTERPOLATION,i=s[t.PREINDEX],a=s[t.NEXTINDEX];for(let s=0;s<3;s++){const o=t.PREVIOUS[r+s],f=(a-i)*t.PREVIOUS[2*r+s],u=t.NEXT[3+s],h=(a-i)*t.NEXT[s],c=(2*Math.pow(n,3)-3*Math.pow(n,2)+1)*o+(Math.pow(n,3)-2*Math.pow(n,2)+n)*f+(2*-Math.pow(n,3)+3*Math.pow(n,2))*u+(Math.pow(n,3)-Math.pow(n,2))*h;e[s]=c;}return e},getAnimationClip(e,t,n,i){const a=e.nodes[t]&&e.nodes[t].weights;set$4(q$2,...M$2.TRANSLATION),set$3(v$2,...M$2.ROTATION),set$4(V$2,...M$2.SCALE);return this._getTRSW(i,e,t,n,q$2,v$2,V$2,a)},getTimeSpan(e){if(!e.animations)return null;if(e.timeSpan)return e.timeSpan;const t=e.animations;return e.timeSpan={},t.forEach((t,s)=>{let r=-1/0,n=1/0;const i=t.channels;for(let e=0;e<i.length;e++){const s=i[e],a=t.samplers[s.sampler].input.array;a[a.length-1]>r&&(r=a[a.length-1]),a[0]<n&&(n=a[0]);}const a=t.name||s;e.timeSpan[a]={max:r,min:n};}),e.timeSpan},getTimeSpanByName(e,t){const s=this.getTimeSpan(e);return s?a(t)?s[t]:s[Object.keys(s)[0]]:null}};let D$2=!1;if("undefined"!=typeof OffscreenCanvas){let e;try{e=new OffscreenCanvas(2,2).getContext("2d");}catch(e){}e&&"undefined"!=typeof createImageBitmap&&(D$2=!0);}const C$2="undefined"==typeof document?null:document.createElement("canvas");class k$2{constructor(e,t,s){if(this.options=s||{},this.options.decoders||(this.options.decoders={}),t.buffer instanceof ArrayBuffer){const{json:s,glbBuffer:r}=A$3.read(t.buffer,t.byteOffset,t.byteLength);this._init(e,s,r);}else this._init(e,t);this._accessor=new E$2(this.rootPath,this.gltf,this.glbBuffer),this._checkExtensions();}_checkExtensions(){const e=this.gltf.extensionsRequired;if(e){if(e.indexOf("KHR_draco_mesh_compression")>=0&&!this.options.decoders.draco)throw new Error("KHR_draco_mesh_compression is required but @maptalks/transcoders.draco is not loaded");if(e.indexOf("KHR_texture_basisu")>=0&&!this.options.decoders.ktx2)throw new Error("KHR_texture_basisu is required but @maptalks/transcoders.ktx2 is not loaded")}}_loadExtensions(){const e=this.gltf.extensions;return e&&e.KHR_techniques_webgl?this._accessor.requestKHRTechniquesWebgl(e.KHR_techniques_webgl).then(t=>(e.KHR_techniques_webgl=t,e)):Promise.resolve(e)}load(e){e=e||{};const t=this._loadScene(e),s=this._loadAnimations(),r=this._loadTextures(),n=this._loadExtensions();return Promise.all([t,s,r,n]).then(e=>(e[0].animations=e[1],e[0].textures=e[2],e[0].extensions=e[3],e[0].transferables=this.transferables||[],this.createChannelsMap(e[0]),e[0]))}createChannelsMap(e){const t=e.animations;if(t)for(let e=0;e<t.length;e++){const s=t[e];s.channelsMap={};for(let e=0;e<s.channels.length;e++){const t=s.channels[e];s.channelsMap[t.target.node]||(s.channelsMap[t.target.node]=[]),s.channelsMap[t.target.node].push(t);}}}getExternalResources(){const e=[];if(this.gltf){const{buffers:t,images:s}=this.gltf;for(let s=0;s<t.length;s++)t[s].uri&&t[s].uri.indexOf("data:application/octet-stream;base64")<0&&e.push({type:"buffer",uri:t[s].uri});for(let t=0;t<s.length;t++)s[t].uri&&s[t].uri.indexOf("data:image/")<0&&e.push({type:"image",uri:s[t].uri});}return e}static getAnimationClip(e,t,s,r){return U$2.getAnimationClip(e,t,s,r)}static getAnimationTimeSpan(e,t){return U$2.getTimeSpanByName(e,t)}static getTypedArrayCtor(e){return f$1(e)}static readInterleavedArray(e,t,s,r,n,i,a){return b$2(e,t,s,r,n,i,a)}_init(e,t,s){this.gltf=t,this.glbBuffer=s,this.version=t.asset?+t.asset.version:1,this.rootPath=e,this.buffers={},this.requests={},this.options.requestImage=D$2?H$2.bind(this):this.options.requestImage||X$2,this.options.transferable&&(this.transferables=[]),2===this.version?(this.adapter=new O$2(e,t,s,this.options.requestImage,this.options.decoders||{},this.options.supportedFormats||{}),this.adapter.iterate((e,t,s)=>{t.id="buffer_"+s;},"buffers"),this.adapter.iterate((e,t,s)=>{t.id="image_"+s;},"images"),this.adapter.iterate((e,t,s)=>{t.id="accessor_"+s;},"accessors")):(this.adapter=new I$2(e,t,s,this.options.requestImage,this.options.decoders||{},this.options.supportedFormats||{}),this.adapter.iterate((e,t,s)=>{t.id="accessor_"+s;},"accessors"),this.adapter.iterate((e,t,s)=>{t.id="image_"+s;},"images"));}_parseNodes(e,t){if(e.children&&e.children.length>0){if(!(s=e.children[0],"number"==typeof s&&isFinite(s)||function(e){return !i$1(e)&&("string"==typeof e||null!==e.constructor&&e.constructor===String)}(e.children[0])))return e;const r=e.children.map(e=>{const s=t[e];return s.nodeIndex=e,this._parseNodes(s,t)});e.children=r;}var s;return e}_loadScene(e){return this._loadNodes(e).then(e=>{const t=this.scenes=[];let s;for(const t in e)e[t]=this._parseNodes(e[t],e),e[t].nodeIndex=Number(t)?Number(t):t;this.adapter.iterate((r,n,i)=>{const a={};n.name&&(a.name=n.name),n.nodes&&(a.nodes=n.nodes.map(t=>e[t])),this.gltf.scene===r&&(s=i),t.push(a);},"scenes");const r={asset:this.gltf.asset,scene:s,scenes:t,nodes:e,meshes:this.meshes,materials:this.gltf.materials,skins:this.skins};if(this.gltf.extensions&&(r.extensions=this.gltf.extensions),1===this.version){const e=this.adapter._loadMaterials(this.gltf.materials);r.materials=e;}return r})}_loadNodes(e){return this._loadMeshes(e).then(()=>{const e=this.nodes={};return this.adapter.iterate((t,s)=>{const r=this.adapter.createNode(s,this.meshes,this.skins);e[t]=r;},"nodes"),e})}_loadSkins(){this.skins=[];const e=[];return this.adapter.iterate((t,s,r)=>{e.push(this._loadSkin(s).then(e=>{e.index=r,this.skins.push(e);}));},"skins"),e}_loadSkin(e){const t=e.inverseBindMatrices;return this.adapter.accessor._requestData("inverseBindMatrices",t).then(t=>(e.inverseBindMatrices=t,t&&t.buffer&&this.transferables&&this.transferables.indexOf(t.buffer)<0&&this.transferables.push(t.buffer),e))}_loadAnimations(){const e=this.gltf.animations;return a(e)?this.adapter.getAnimations(e):null}_loadMeshes(e){this.meshes={};let t=[];return this.adapter.iterate((s,r,n)=>{t.push(this._loadMesh(r,e).then(e=>{e.index=n,this.meshes[s]=e;}));},"meshes"),t=t.concat(this._loadSkins()),Promise.all(t)}_loadMesh(e,t){const s=e.primitives.map(e=>this._loadPrimitive(e,t)).filter(e=>!!e);return Promise.all(s).then(t=>{const s={};return o(s,e),s.primitives=t,s})}_loadTextures(){const e=this.gltf.textures;if(!e)return null;const t=[];for(const s in e)t.push(this.adapter._getTexture(s));return Promise.all(t).then(t=>{if(this.transferables)for(let e=0;e<t.length;e++){const s=t[e].image.array;if(t[e]&&s){let e;e=s instanceof ImageBitmap?s:s.buffer,e&&this.transferables.indexOf(e)<0&&this.transferables.push(e);}}if(!Array.isArray(e)){const s={},r=Object.keys(e);for(let e=0;e<t.length;e++)t[e]&&(s[r[e]]=t[e]);return s}return t})}_loadPrimitive(e,t){let r;const n=[],i=e.extensions;if(a(e.targets))for(let t=0;t<e.targets.length;t++){const s=e.targets[t];for(const e in s){const r=this.adapter.accessor._requestData(`morphTargets_${e}_${t}`,s[e]);r&&n.push(r);}}if(i&&i.KHR_draco_mesh_compression){if(!this.options.decoders.draco&&(!this.gltf.extensionsRequired||!this.gltf.extensionsRequired.indexOf("KHR_draco_mesh_compression")<0))return null;const e=this.options.decoders.draco,{bufferView:s,attributes:a}=i.KHR_draco_mesh_compression,o=this.gltf.bufferViews[s],f=this._accessor._requestBufferOfBufferView(o).then(s=>{const{buffer:r,byteOffset:n}=s;let{byteOffset:i,byteLength:f}=o;i||(i=0);const u=new DataView(r,n+i,f),h={attributes:a,useUniqueIDs:!1,skipAttributeTransform:t.skipAttributeTransform};return e(u,h).then(e=>{const t=Object.values(e.attributes);return e.indices&&t.push(e.indices),t})});n.push(f),r=Promise.all(n);}else {const t=e.attributes;for(const e in t){const s=this.adapter.accessor._requestData(e,t[e]);s&&n.push(s);}if(a(e.indices)){const t=this.adapter.accessor._requestData("indices",e.indices);t&&n.push(t);}r=Promise.all(n);}return r.then(t=>{if(i&&i.KHR_draco_mesh_compression){const s=e.targets?e.targets.length:0;t[s]=t[s].concat(t.slice(0,s)),t=t[s];}let r,n;const o={attributes:t.reduce((e,t)=>{if("indices"===t.name)r=t;else if(t.name.indexOf("morphTargets_")>-1)n=n||{},n[t.name.slice(13)]=t;else {if(!("POSITION"!==t.name||t.min&&t.max)){const e=[1/0,1/0,1/0],r=[-1/0,-1/0,-1/0],{itemSize:n,array:i}=t,a=i.length/n;for(let t=0;t<a;t++)for(let s=0;s<n;s++){const a=t*n+s;i[a]<e[s]&&(e[s]=i[a]),i[a]>r[s]&&(r[s]=i[a]);}if(t.quantization){const n=t.quantization,i=n.range/(1<<n.quantizationBits),a=n.minValues;scale$4(e,e,i),add$4(e,e,a),scale$4(r,r,i),add$4(r,r,a);}t.min=e,t.max=r;}e[t.name]=t;}return this.transferables&&t.array.buffer&&this.transferables.indexOf(t.array.buffer)<0&&this.transferables.push(t.array.buffer),e},{}),material:e.material};return r&&(o.indices=r),n&&(o.morphTargets=n),o.mode=a(e.mode)?e.mode:4,a(e.extras)&&(o.extras=e.extras),o})}}function X$2(e,t){const s=new Image;s.crossOrigin="",s.onload=()=>{if(!C$2)return void t(new Error("There is no canvas to draw image!"));C$2.width=s.width,C$2.height=s.height;const e=C$2.getContext("2d",{willReadFrequently:!0});e.drawImage(s,0,0,s.width,s.height);const r=e.getImageData(0,0,s.width,s.height),n={width:s.width,height:s.height,data:new Uint8Array(r.data)};t(null,n);},s.onerror=function(e){t(e);},s.src=e;}let j$2,F$2;function H$2(e,t){j$2||(j$2=new OffscreenCanvas(2,2),F$2=j$2.getContext("2d",{willReadFrequently:!0})),fetch(e).then(e=>e.arrayBuffer()).then(e=>{const t=new Blob([new Uint8Array(e)]);return createImageBitmap(t)}).then(e=>{let{width:s,height:r}=e;K$2(s)||(s=z$2(s)),K$2(r)||(r=z$2(r));const n=this.options.maxTextureSize;n&&(s=Math.min(n,s),r=Math.min(n,r)),j$2.width=s,j$2.height=r,F$2.drawImage(e,0,0,s,r),e.close();const i=F$2.getImageData(0,0,s,r);t(null,{width:s,height:r,data:new Uint8Array(i.data)});}).catch(e=>{console.warn(e),t(e);});}function K$2(e){return 0==(e&e-1)&&0!==e}function z$2(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}

	class Vertex {
	    constructor(vertices, index) {
	        this.position = vertices;
	        this.index = index; //index of vertex
	        this.faces = []; // face shared
	        this.neighbors = []; // neighbor vertexes
	    }

	    addUniqueNeighbor(vertex) {
	        if (this.neighbors.indexOf(vertex) === -1) {
	            this.neighbors.push(vertex);
	        }
	    }
	}

	class Triangle {
	    constructor(v1, v2, v3, face) {
	        this.a = face.a;
	        this.b = face.b;
	        this.c = face.c;
	        this.v1 = v1;
	        this.v2 = v2;
	        this.v3 = v3;
	        this.normal = [];
	        this.computeNormal();
	        //add self into v1 vertex as its shared face
	        v1.faces.push(this);
	        v1.addUniqueNeighbor(v2);
	        v1.addUniqueNeighbor(v3);

	        v2.faces.push(this);
	        v2.addUniqueNeighbor(v1);
	        v2.addUniqueNeighbor(v3);

	        v3.faces.push(this);
	        v3.addUniqueNeighbor(v1);
	        v3.addUniqueNeighbor(v2);
	    }

	    computeNormal() {
	        const vA = this.v1.position;
	        const vB = this.v2.position;
	        const vC = this.v3.position;
	        const cb = sub$2([], vC, vB);
	        const ab = sub$2([], vA, vB);
	        const cross = cross$1([], cb, ab);
	        normalize$4(this.normal, cross);
	    }

	    hasVertex(v) {
	        return v === this.v1 || v === this.v2 || v === this.v3;
	    }
	}

	/*!
	 * Contains code from google filament
	 * https://github.com/google/filament/
	 * License Apache-2.0
	 */

	const CHAR_BIT = 8;

	const MAT0 = [];
	const TMP0 = [];
	const TMP1 = [];
	const TMP2 = [];

	function packTangentFrame(q, /* vec3 */n, /* vec4 */t) {
	    const c = cross$1(TMP0, n, t);
	    const mat = toMat3(MAT0, t[0], t[1], t[2], ...c, ...n);
	    q = fromMat3(q, mat);
	    q = normalize$2(q, q);
	    q = positive(q);

	    const storageSize = 2; //sizeof(int16_t)
	    // Ensure w is never 0.0
	    // Bias is 2^(nb_bits - 1) - 1
	    const bias = 1 / ((1 << (storageSize * CHAR_BIT - 1)) - 1);
	    if (q[3] < bias) {
	        q[3] = bias;
	        const factor = Math.sqrt(1.0 - bias * bias);
	        q[0] *= factor;
	        q[1] *= factor;
	        q[2] *= factor;
	    }

	    const b = t[3] > 0 ? cross$1(TMP1, t, n) : cross$1(TMP1, n, t);
	    
	    // If there's a reflection ((n x t) . b <= 0), make sure w is negative
	    const cc = cross$1(TMP2, t, n);
	    if (dot$4(cc, b) < 0) {
	        scale$2(q, q, -1);
	    }
	    return q;
	}

	function toMat3(out, c00, c01, c02, c10, c11, c12, c20, c21, c22) {
	    out[0] = c00;
	    out[1] = c01;
	    out[2] = c02;

	    out[3] = c10;
	    out[4] = c11;
	    out[5] = c12;

	    out[6] = c20;
	    out[7] = c21;
	    out[8] = c22;

	    return out;
	}


	function positive(q) {
	    if (q[3] < 0) {
	        return scale$2(q, q, -1);
	    } else {
	        return q;
	    }
	}


	function buildNormals(positions, indices) {
	    const vertexes = [];
	    const normals = [];
	    let i = 0;
	    //create vertex struct
	    for (i = 0; i < positions.length; i += 3) {
	        const vertex = new Vertex([positions[i], positions[i + 1], positions[i + 2]], i / 3);
	        vertexes.push(vertex);
	    }
	    //create face struct
	    //indicles maybe number
	    if (!indices.length) {
	        const len = indices;
	        indices = [];
	        for (let i = 0; i < len; i++) {
	            indices.push(i);
	        }
	    }
	    for (i = 0; i < indices.length / 3; i++) {
	        const face = {
	            a : indices[i * 3],
	            b : indices[i * 3 + 1],
	            c : indices[i * 3 + 2]
	        };
	        new Triangle(vertexes[face.a], vertexes[face.b], vertexes[face.c], face);
	    }
	    const divide = [];
	    const normal = [0, 0, 0];
	    //Calculate the sum of the normal vectors of the shared faces of each vertex, then average it.
	    for (i = 0; i < vertexes.length; i++) {
	        const vertex = vertexes[i];
	        const vIndex = vertex.index;
	        set$4(normal, 0, 0, 0);
	        let len = vertex.faces.length;
	        for (let j = 0; j < len; j++) {
	            add$4(normal, normal, vertex.faces[j].normal);
	        }
	        len = len || 1;
	        set$4(divide, len, len, len);
	        divide$2(normal, normal, divide);
	        normals[vIndex * 3] = normal[0];
	        normals[vIndex * 3 + 1] = normal[1];
	        normals[vIndex * 3 + 2] = normal[2];
	    }
	    return normals;
	}

	/*!
	 * Contains code from THREE.JS
	 * https://github.com/mrdoob/three.js/
	 * License MIT
	 * 
	 * Generate tangents per vertex.
	 */
	function buildTangents(positions, normals, uvs, indices) {
	    const nVertices = positions.length / 3;

	    const tangents = new Array(4 * nVertices);

	    const tan1 = [], tan2 = [];

	    for (let i = 0; i < nVertices; i++) {

	        tan1[ i ] = [0, 0, 0];
	        tan2[ i ] = [0, 0, 0];

	    }

	    const vA = [0, 0, 0],
	        vB = [0, 0, 0],
	        vC = [0, 0, 0],

	        uvA = [0, 0],
	        uvB = [0, 0],
	        uvC = [0, 0],

	        sdir = [0, 0, 0],
	        tdir = [0, 0, 0];

	    function handleTriangle(a, b, c) {

	        fromArray3(vA, positions, a * 3);
	        fromArray3(vB, positions, b * 3);
	        fromArray3(vC, positions, c * 3);

	        fromArray2(uvA, uvs, a * 2);
	        fromArray2(uvB, uvs, b * 2);
	        fromArray2(uvC, uvs, c * 2);

	        const x1 = vB[0] - vA[0];
	        const x2 = vC[0] - vA[0];

	        const y1 = vB[1] - vA[1];
	        const y2 = vC[1] - vA[1];

	        const z1 = vB[2] - vA[2];
	        const z2 = vC[2] - vA[2];

	        const s1 = uvB[0] - uvA[0];
	        const s2 = uvC[0] - uvA[0];

	        const t1 = uvB[1] - uvA[1];
	        const t2 = uvC[1] - uvA[1];

	        const r = 1.0 / (s1 * t2 - s2 * t1);

	        set$4(
	            sdir,
	            (t2 * x1 - t1 * x2) * r,
	            (t2 * y1 - t1 * y2) * r,
	            (t2 * z1 - t1 * z2) * r
	        );

	        set$4(
	            tdir,
	            (s1 * x2 - s2 * x1) * r,
	            (s1 * y2 - s2 * y1) * r,
	            (s1 * z2 - s2 * z1) * r
	        );

	        add$4(tan1[ a ], tan1[ a ], sdir);
	        add$4(tan1[ b ], tan1[ b ], sdir);
	        add$4(tan1[ c ], tan1[ c ], sdir);

	        add$4(tan2[ a ], tan2[ a ], tdir);
	        add$4(tan2[ b ], tan2[ b ], tdir);
	        add$4(tan2[ c ], tan2[ c ], tdir);

	    }

	    for (let j = 0, jl = indices.length; j < jl; j += 3) {

	        handleTriangle(
	            indices[ j + 0 ],
	            indices[ j + 1 ],
	            indices[ j + 2 ]
	        );

	    }

	    const tmp = [], tmp2 = [];
	    const n = [], n2 = [];
	    let w, t, test;

	    function handleVertex(v) {

	        fromArray3(n, normals, v * 3);
	        copy$4(n2, n);
	        // n2.copy(n);

	        t = tan1[ v ];

	        // Gram-Schmidt orthogonalize

	        copy$4(tmp, t);
	        sub$2(tmp, tmp, scale$4(n, n, dot$4(n, t)));
	        normalize$4(tmp, tmp);
	        // tmp.sub(n.multiplyScalar(n.dot(t))).normalize();

	        // Calculate handedness

	        cross$1(tmp2, n2, t);
	        test = dot$4(tmp2, tan2[ v ]);
	        // tmp2.crossVectors(n2, t);
	        // test = tmp2.dot(tan2[ v ]);
	        w = (test < 0.0) ? -1.0 : 1.0;

	        tangents[ v * 4 ] = tmp[0];
	        tangents[ v * 4 + 1 ] = tmp[1];
	        tangents[ v * 4 + 2 ] = tmp[2];
	        tangents[ v * 4 + 3 ] = w;

	    }

	    for (let j = 0, jl = indices.length; j < jl; j += 3) {

	        handleVertex(indices[ j + 0 ]);
	        handleVertex(indices[ j + 1 ]);
	        handleVertex(indices[ j + 2 ]);

	    }

	    return tangents;
	}

	function fromArray3(out, array, offset) {
	    out[0] = array[offset];
	    out[1] = array[offset + 1];
	    out[2] = array[offset + 2];
	    return out;
	}

	function fromArray2(out, array, offset) {
	    out[0] = array[offset];
	    out[1] = array[offset + 1];
	    return out;
	}

	/*!
	 * @maptalks/reshader.gl v0.81.2
	 * LICENSE : UNLICENSED
	 * (c) 2016-2023 maptalks.com
	 */

	function c(t) {
	    return !u(t) && ("string" == typeof t || null !== t.constructor && t.constructor === String);
	}

	function u(t) {
	    return null == t;
	}

	function f(t) {
	    return !u(t);
	}

	function d(t) {
	    return !u(t) && ("function" == typeof t || null !== t.constructor && t.constructor === Function);
	}

	const m$1 = "function" == typeof Object.assign;

	function g(t) {
	    if (m$1) Object.assign.apply(Object, arguments); else for (let e = 1; e < arguments.length; e++) {
	        const n = arguments[e];
	        for (const e in n) t[e] = n[e];
	    }
	    return t;
	}

	function p(t) {
	    for (let e = 1; e < arguments.length; e++) {
	        const n = arguments[e];
	        for (const e in n) null != n[e] && (t[e] = n[e]);
	    }
	    return t;
	}

	function _$2(t) {
	    return "number" == typeof t && !isNaN(t);
	}

	function v$1(t, e, n) {
	    return t * (1 - n) + e * n;
	}

	function y$1(t) {
	    return Array.isArray(t) || t instanceof Uint8Array || t instanceof Int8Array || t instanceof Uint16Array || t instanceof Int16Array || t instanceof Uint32Array || t instanceof Int32Array || t instanceof Uint8ClampedArray || t instanceof Float32Array || t instanceof Float64Array;
	}

	function x$1(t) {
	    return (t = Math.abs(t)) < 128 ? Int8Array : t < 32768 ? Int16Array : Float32Array;
	}

	function b$1(t, e, n) {
	    return Math.min(n, Math.max(e, t));
	}

	function w$1(t) {
	    return t && t.hasExtension("oes_vertex_array_object");
	}

	function C$1(t, e) {
	    return Object.prototype.hasOwnProperty.call(t, e);
	}

	function M$1(t) {
	    if (t.data) {
	        if (t.data.BYTES_PER_ELEMENT) return t.data.length * t.data.BYTES_PER_ELEMENT;
	        if (t.data.length) return 4 * t.data.length;
	    } else {
	        if (t.BYTES_PER_ELEMENT) return t.length * t.BYTES_PER_ELEMENT;
	        if (t.length) return 4 * t.length;
	        if (t.buffer && t.buffer.destroy) return t.buffer._buffer.byteLength;
	    }
	    return 0;
	}

	function T$2(t) {
	    return t.width * t.height * P$1(t.format) * S$1(t.type) * ("textureCube" === t._reglType ? 6 : 1);
	}

	function S$1(t) {
	    return "uint8" === t ? 1 : "uint16" === t || "float16" === t || "half float" === t ? 2 : "uint32" === t || "float" === t || "float32" === t ? 4 : 0;
	}

	function P$1(t) {
	    return "depth" === t || "alpha" === t || "luminance" === t ? 1 : "luminance alpha" === t || "depth stencil" === t ? 2 : "srgba" === t || "rgb5 a1" === t || "rgba" === t.substring(0, 4) ? 4 : "srgb" === t || "rgb" === t.substring(0, 3) ? 3 : 1;
	}

	function A$2(e) {
	    if (!e.componentType) return !1;
	    const n = k$2.getTypedArrayCtor(e.componentType);
	    return e.byteStride > 0 && e.byteStride !== e.itemSize * n.BYTES_PER_ELEMENT;
	}

	function E$1(t) {
	    return t && (t.stride > 0 || A$2(t));
	}

	function O$1(t) {
	    let e = 0;
	    const n = t && t.length || 0;
	    if (!n) return e;
	    let i;
	    for (let r = 0; r < n; r++) i = t.charCodeAt(r), e = (e << 5) - e + i, e &= e;
	    return e;
	}

	function R$2(t) {
	    return 0 == (t & t - 1) && 0 !== t;
	}

	function I$1(t) {
	    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
	}

	var k$1 = Object.freeze({
	    __proto__: null,
	    isString: c,
	    isNil: u,
	    defined: f,
	    isFunction: d,
	    extend: g,
	    extend1: p,
	    extend2: function(t) {
	        for (let e = 1; e < arguments.length; e++) {
	            const n = arguments[e];
	            for (const e in n) void 0 === t[e] && (t[e] = n[e]);
	        }
	        return t;
	    },
	    isNumber: _$2,
	    log2: function(t) {
	        if (Math.log2) return Math.log2(t);
	        const e = Math.log(t) * Math.LOG2E, n = Math.round(e);
	        return Math.abs(n - e) < 1e-14 ? n : e;
	    },
	    normalize: function(t, e) {
	        let n = 0;
	        for (let t = 0, i = e.length; t < i; t++) n += e[t];
	        for (let i = 0, r = e.length; i < r; i++) t[i] = e[i] / n;
	        return t;
	    },
	    interpolate: v$1,
	    isArray: y$1,
	    lerp: function(t, e, n, i) {
	        for (let r = 0; r < t.length; r++) t[r] = e[r] + i * (n[r] - e[r]);
	        return t;
	    },
	    set: function(t, e) {
	        for (let n = 0; n < t.length; n++) t[n] = e[n];
	        return t;
	    },
	    getPosArrayType: x$1,
	    clamp: b$1,
	    isSupportVAO: w$1,
	    hasOwn: C$1,
	    getBufferSize: M$1,
	    getTexMemorySize: T$2,
	    getTextureByteWidth: S$1,
	    getTextureChannels: P$1,
	    isInStride: A$2,
	    isInterleaved: E$1,
	    getSupportedFormats: function(t) {
	        return {
	            etc: !!t.getExtension("WEBGL_compressed_texture_etc"),
	            etc1: !!t.getExtension("WEBGL_compressed_texture_etc1"),
	            s3tc: !!t.getExtension("WEBGL_compressed_texture_s3tc"),
	            pvrtc: !!t.getExtension("WEBGL_compressed_texture_pvrtc"),
	            astc: !!t.getExtension("WEBGL_compressed_texture_astc"),
	            bc7: !!t.getExtension("EXT_texture_compression_bptc")
	        };
	    },
	    hashCode: O$1,
	    isPowerOfTwo: R$2,
	    floorPowerOfTwo: I$1
	});

	const D$1 = t => class extends t {
	    on(t, e) {
	        return this._events || (this._events = {
	            type: [ e ]
	        }), this._events[t] = this._events[t] || [], this._events[t].push(e), this;
	    }
	    once(t, e) {
	        return this.on(t, this._wrapOnce(t, e));
	    }
	    off(t, e) {
	        return this._events && this._events[t] ? (this._events[t].splice(this._events[t].indexOf(e), 1), 
	        this) : this;
	    }
	    fire(t, e = {}) {
	        if (!this._events || !this._events[t]) return this;
	        e.target || (e.target = this);
	        const n = this._events[t].slice(0);
	        for (const t of n) t(e);
	        return this;
	    }
	    _wrapOnce(t, e) {
	        const n = this;
	        let i = !1;
	        return function r(o) {
	            i || (i = !0, e(o), n.off(t, r));
	        };
	    }
	}, L$1 = "__reshader_disposed";

	var z$1 = Object.freeze({
	    __proto__: null,
	    KEY_DISPOSED: L$1,
	    WEBGL_EXTENSIONS: [ "ANGLE_instanced_arrays", "OES_element_index_uint", "OES_standard_derivatives" ],
	    WEBGL_OPTIONAL_EXTENSIONS: [ "OES_vertex_array_object", "OES_texture_half_float", "OES_texture_half_float_linear", "OES_texture_float", "OES_texture_float_linear", "WEBGL_depth_texture", "EXT_shader_texture_lod", "EXT_texture_filter_anisotropic" ]
	});

	var F$1 = D$1(class {
	    constructor(t, e) {
	        if (d(t)) {
	            this._texture = t, t = this.config = {};
	            for (const e in this._texture) C$1(this._texture, e) && (d(this._texture[e]) || (t[e] = this._texture[e]));
	        } else if (this.config = t || {}, this.resLoader = e, !t.url && !t.promise || t.data) t.data && this._needPowerOf2() && (t.data instanceof Image && (t.data = j$1(t.data), 
	        t.width = t.data.width, t.height = t.data.height), t.hdr || !y$1(t.data) || R$2(t.width) && R$2(t.height) || (t.data = function(t, e, n) {
	            let i = e, r = n;
	            R$2(e) || (i = I$1(e));
	            R$2(n) || (r = I$1(n));
	            const o = new ImageData(new Uint8ClampedArray(t), e, n), s = document.createElement("canvas");
	            s.width = e, s.height = n, s.getContext("2d").putImageData(o, 0, 0);
	            const a = document.createElement("canvas");
	            return a.width = i, a.height = r, a.getContext("2d").drawImage(s, 0, 0, i, r), console.warn(`Texture's size is not power of two, resize from (${e}, ${n}) to (${i}, ${r})`), 
	            a;
	        }(t.data, t.width, t.height), t.width = t.data.width, t.height = t.data.height)); else {
	            this._loading = !0;
	            const n = this;
	            let i;
	            if (t.promise) i = t.promise; else {
	                let n;
	                n = t.arrayBuffer ? e.getArrayBuffer : e.get, i = n.call(e, t.url);
	            }
	            t.data = e.getDefaultTexture(t.url), this.promise = i, i.then(t => (delete this.promise, 
	            n._loading = !1, n.config ? (t.data instanceof Image && this._needPowerOf2() && (t.data = j$1(t.data)), 
	            n.onLoad(t), Array.isArray(t) || (t = [ t ]), n.fire("complete", {
	                target: this,
	                resources: t
	            }), t) : t)).catch(t => {
	                console.error("error when loading texture image.", t), n.fire("error", {
	                    target: this,
	                    error: t
	                });
	            });
	        }
	    }
	    isReady() {
	        return !this._loading;
	    }
	    set(t, e) {
	        return this.config[t] = e, this.dirty = !0, this;
	    }
	    get(t) {
	        return this.config[t];
	    }
	    getREGLTexture(t) {
	        return this._texture || (this._texture = this.createREGLTexture(t), this.config.persistent || (this.config.data && (this.config.data instanceof ImageBitmap && this.config.data.close(), 
	        this.config.data = []), this.config.faces && (this.config.faces = []), this.config.image && (this.config.image.array = []), 
	        this.config.mipmap && delete this.config.mipmap)), this.dirty && this._updateREGL(), 
	        this._texture;
	    }
	    getMemorySize() {
	        if (!this.config) return 0;
	        const {width: t, height: e, type: n, format: i} = this.config, r = S$1(n || "uint8"), o = P$1(i || "rgba");
	        return this.config.faces ? t * e * r * o * 6 : t * e * r * o;
	    }
	    _updateREGL() {
	        this._texture && !this._texture[L$1] && this._texture(this.config), this.dirty = !1;
	    }
	    dispose() {
	        this.config && this.config.url && (URL.revokeObjectURL(this.config.url), this.resLoader.disposeRes(this.config.url)), 
	        this._texture && !this._texture[L$1] && (this._texture._reshader_refCount && this._texture._reshader_refCount--, 
	        this._texture._reshader_refCount || (this._texture.destroy(), this._texture[L$1] = !0, 
	        delete this._texture)), delete this.resLoader;
	        const t = this.config && this.config.url;
	        delete this.config, t && this.fire("disposed", {
	            target: this,
	            url: t
	        });
	    }
	    _needPowerOf2() {
	        const t = this.config;
	        return t.wrap && "clamp" !== t.wrap || t.wrapS && "clamp" !== t.wrapS || t.wrapT && "clamp" !== t.wrapT || t.min && "nearest" !== t.min && "linear" !== t.min;
	    }
	});

	function j$1(t) {
	    if (R$2(t.width) && R$2(t.height)) return t;
	    let e = t.width, n = t.height;
	    R$2(e) || (e = I$1(e)), R$2(n) || (n = I$1(n));
	    const i = document.createElement("canvas");
	    i.width = e, i.height = n, i.getContext("2d").drawImage(t, 0, 0, e, n);
	    const r = t.src, o = r.lastIndexOf("/") + 1, s = r.substring(o);
	    return console.warn(`Texture(${s})'s size is not power of two, resize from (${t.width}, ${t.height}) to (${e}, ${n})`), 
	    i;
	}

	const H$1 = {};

	class N$1 {
	    constructor(t) {
	        this.regl = t;
	    }
	    render(t, e, n, i) {
	        t.setUniforms(e || H$1), t.setFramebuffer(i);
	        let r = 0;
	        if (n) {
	            const {opaques: e, transparents: i} = n.getSortedMeshes();
	            r += t.draw(this.regl, e), r += t.draw(this.regl, i);
	        } else r += t.draw(this.regl);
	        return r;
	    }
	    clear(t) {
	        this.regl.clear(t);
	    }
	}

	class B$1 extends N$1 {}

	const G$1 = [], V$1 = identity$2([]), U$1 = {
	    min: [],
	    max: []
	};

	class W$1 {
	    constructor(t, e) {
	        this.min = t || [ 1 / 0, 1 / 0, 1 / 0 ], this.max = e || [ -1 / 0, -1 / 0, -1 / 0 ], 
	        this.updateVertex();
	    }
	    static copy(t, e) {
	        copy$4(t.min, e.min), copy$4(t.max, e.max);
	        for (let i = 0; i < e.vertex.length; i++) copy$4(t.vertex[i], e.vertex[i]);
	        return t;
	    }
	    combine(t) {
	        return t ? (Array.isArray(t) && (copy$4(U$1.min, t[0]), copy$4(U$1.max, t[1]), t = U$1), 
	        t.min[0] < this.min[0] && (this.min[0] = t.min[0], this._dirty = !0), t.min[1] < this.min[1] && (this.min[1] = t.min[1], 
	        this._dirty = !0), t.min[2] < this.min[2] && (this.min[2] = t.min[2], this._dirty = !0), 
	        t.max[0] > this.max[0] && (this.max[0] = t.max[0], this._dirty = !0), t.max[1] > this.max[1] && (this.max[1] = t.max[1], 
	        this._dirty = !0), t.max[2] > this.max[2] && (this.max[2] = t.max[2], this._dirty = !0), 
	        this) : this;
	    }
	    dirty() {
	        return this._dirty = !0, this;
	    }
	    getCenter() {
	        return this.center || (this.center = [], this._dirty = !0), this._dirty && (add$4(this.center, this.min, this.max), 
	        scale$4(this.center, this.center, .5)), this._dirty = !1, this.center;
	    }
	    containPoint(t) {
	        const e = this.min, n = this.max;
	        return e[0] <= t[0] && e[1] <= t[1] && e[2] <= t[2] && n[0] >= t[0] && n[1] >= t[1] && n[2] >= t[2];
	    }
	    isFinite() {
	        const t = this.min, e = this.max;
	        return isFinite(t[0]) && isFinite(t[1]) && isFinite(t[2]) && isFinite(e[0]) && isFinite(e[1]) && isFinite(e[2]);
	    }
	    updateVertex() {
	        if (!this.vertex) {
	            this.vertex = [];
	            for (let t = 0; t < 8; t++) this.vertex.push([]);
	        }
	        return this.vertex[0][0] = this.min[0], this.vertex[0][1] = this.min[1], this.vertex[0][2] = this.min[2], 
	        this.vertex[1][0] = this.min[0], this.vertex[1][1] = this.min[1], this.vertex[1][2] = this.max[2], 
	        this.vertex[2][0] = this.min[0], this.vertex[2][1] = this.max[1], this.vertex[2][2] = this.max[2], 
	        this.vertex[3][0] = this.min[0], this.vertex[3][1] = this.max[1], this.vertex[3][2] = this.min[2], 
	        this.vertex[4][0] = this.max[0], this.vertex[4][1] = this.min[1], this.vertex[4][2] = this.min[2], 
	        this.vertex[5][0] = this.max[0], this.vertex[5][1] = this.min[1], this.vertex[5][2] = this.max[2], 
	        this.vertex[6][0] = this.max[0], this.vertex[6][1] = this.max[1], this.vertex[6][2] = this.max[2], 
	        this.vertex[7][0] = this.max[0], this.vertex[7][1] = this.max[1], this.vertex[7][2] = this.min[2], 
	        this.vertex;
	    }
	    copy() {
	        return new W$1(this.min.slice(), this.max.slice());
	    }
	    equals(t) {
	        if (!equals$4(this.min, t.min) || !equals$4(this.max, t.max)) return !1;
	        const e = t.vertex;
	        for (let t = 0; t < this.vertex.length; t++) if (!equals$4(e[t], this.vertex[t])) return !1;
	        return !0;
	    }
	    transform(t, i) {
	        if (t = t || V$1, (i = i || V$1)[1] || i[2] || i[4] || i[6] || i[8] || i[9]) {
	            const r = this.vertex, o = multiply$5(G$1, i, t);
	            for (let t = 0; t < r.length; t++) transformMat4$2(this.vertex[t], this.vertex[t], o);
	            const s = this.vertex.map(t => t[0]), a = this.vertex.map(t => t[1]), h = this.vertex.map(t => t[2]), l = Math.min(...s), c = Math.max(...s), u = Math.min(...a), f = Math.max(...a), d = Math.min(...h), m = Math.max(...h);
	            set$4(this.min, l, u, d), set$4(this.max, c, f, m);
	        } else {
	            const r = multiply$5(G$1, i, t);
	            transformMat4$2(this.min, this.min, r), transformMat4$2(this.max, this.max, r);
	        }
	        return this;
	    }
	}

	const Z$1 = [], X$1 = {
	    5120: "int8",
	    5122: "int16",
	    5124: "int32",
	    5121: "uint8",
	    5123: "uint16",
	    5125: "uint32",
	    5126: "float"
	}, J$1 = {
	    5120: 1,
	    5122: 2,
	    5124: 4,
	    5121: 1,
	    5123: 2,
	    5125: 4,
	    5126: 4
	}, q$1 = {
	    positionSize: 3,
	    primitive: "triangles",
	    positionAttribute: "aPosition",
	    normalAttribute: "aNormal",
	    uv0Attribute: "aTexCoord",
	    uv1Attribute: "aTexCoord1",
	    color0Attribute: "aColor0",
	    tangentAttribute: "aTangent",
	    pickingIdAttribute: "aPickingId",
	    textureCoordMatrixAttribute: "aTextureCoordMatrix"
	};

	let Y$1 = 1;

	const K$1 = "_reshader_refCount";

	class Q$1 {
	    constructor(t, e, n, i) {
	        this._version = 0, this.data = t, this.elements = e, this.desc = g({}, q$1, i);
	        const r = t[this.desc.positionAttribute];
	        n || (e ? n = $$1(e) : r && r.length ? n = r.length / this.desc.positionSize : r && r.interleavedArray ? n = r.interleavedArray.length / this.desc.positionSize : r && r.array && (n = r.array.length / this.desc.positionSize)), 
	        this.count = n, this.elements || (this.elements = n), this.properties = {}, this._buffers = {}, 
	        this._vao = {}, this.getVertexCount(), this._prepareData(), this.updateBoundingBox();
	    }
	    set version(t) {
	        throw new Error("Geometry.version is read only.");
	    }
	    get version() {
	        return this._version;
	    }
	    _prepareData() {
	        if (!this.data) return;
	        const t = this._buffers || {};
	        for (const e in this.data) {
	            const n = this.data[e];
	            if (n) if (n.buffer && n.buffer.destroy) {
	                const t = n.buffer;
	                t[K$1] || (t[K$1] = 0), t[K$1]++;
	            } else if (n && n.array) if (A$2(n)) {
	                let i = n.array.buffer.__id;
	                i || (i = n.array.buffer.__id = Y$1++), this.data[e] = {
	                    buffer: i,
	                    offset: n.byteOffset,
	                    stride: n.byteStride,
	                    type: X$1[n.componentType],
	                    size: n.itemSize,
	                    count: n.count,
	                    componentType: n.componentType
	                }, t[i] || (t[i] = {
	                    data: n.array.buffer
	                });
	            } else this.data[e] = n.array;
	        }
	        this._buffers = t;
	        const e = this.elements;
	        e && e.array && (this.elements = this.elements.array);
	    }
	    getAttrData(t) {
	        const e = t.key, n = !this._reglData || !this._reglData[e];
	        if (this._reglData || (this._reglData = {}), n) {
	            const t = this._reglData[e] = {}, n = this.data, {positionAttribute: i, normalAttribute: r, uv0Attribute: o, uv1Attribute: s, tangentAttribute: a, color0Attribute: h, pickingIdAttribute: l, textureCoordMatrixAttribute: c} = this.desc;
	            g(t, this.data), t.aPosition = n[i], n[r] && (t.aNormal = n[r]), n[o] && (t.aTexCoord = n[o]), 
	            n[s] && (t.aTexCoord1 = n[s]), n[a] && (t.aTangent = n[a]), n[h] && (t.aColor0 = n[h]), 
	            n[l] && (t.aPickingId = n[l]), n[c] && (t.aTextureCoordMatrix = n[c]);
	        }
	        return this._reglData[e];
	    }
	    getREGLData(t, e, n) {
	        this.getAttrData(e);
	        const i = !this._reglData || !this._reglData[e.key];
	        if (w$1(t) && !n) {
	            const n = e && e.key || "default";
	            if (!this._vao[n] || i || this._elementsUpdated) {
	                const i = this._reglData[e.key], r = this._vertexCount, o = [];
	                for (let t = 0; t < e.length; t++) {
	                    const n = e[t].name, s = i[n] && i[n].buffer;
	                    if (s && s.destroy) o.push(void 0 !== i[n].stride ? i[n] : s); else {
	                        const t = i[n];
	                        if (!t) {
	                            o.push(this.desc.fillEmptyDataInMissingAttribute ? new Uint8Array(4 * r) : Z$1);
	                            continue;
	                        }
	                        const e = (t.data && y$1(t.data) ? t.data.length : t.length) / r;
	                        t.data ? (t.dimension = e, o.push(t)) : o.push({
	                            data: t,
	                            dimension: e
	                        });
	                    }
	                }
	                const s = {
	                    attributes: o,
	                    primitive: this.getPrimitive()
	                };
	                if (this.elements && !_$2(this.elements)) if (this.elements.destroy) s.elements = this.elements; else {
	                    s.elements = {
	                        primitive: this.getPrimitive(),
	                        data: this.elements
	                    };
	                    const t = this.getElementsType(this.elements);
	                    t && (s.elements.type = t);
	                }
	                this._vao[n] ? this._vao[n].vao(s) : this._vao[n] = {
	                    vao: t.vao(s)
	                }, delete this._elementsUpdated;
	            }
	            return this._vao[n];
	        }
	        return this._reglData[e.key];
	    }
	    _isAttrChanged(t) {
	        if (t === this._activeAttributes) return !1;
	        if (t.length !== this._activeAttributes.length) return !0;
	        for (let e = 0; e < t.length; e++) if (t[e] !== this._activeAttributes[e]) return !0;
	        return !1;
	    }
	    generateBuffers(t) {
	        const e = this._buffers;
	        for (const n in e) e[n].buffer || (e[n].buffer = t.buffer(e[n].data)), delete e[n].data;
	        const n = this.data, i = this._vertexCount, r = {};
	        for (const o in n) if (n[o]) {
	            if (void 0 === n[o].buffer || n[o].buffer instanceof ArrayBuffer) {
	                const e = n[o].data ? n[o] : {
	                    data: n[o]
	                };
	                e.dimension = (n[o].data ? n[o].data : n[o]).length / i;
	                const s = t.buffer(e);
	                s[K$1] = 1, r[o] = {
	                    buffer: s
	                };
	            } else n[o].buffer.destroy ? r[o] = n[o] : e[n[o].buffer] && (r[o] = g({}, n[o]), 
	            r[o].buffer = e[n[o].buffer].buffer);
	            delete n[o].array;
	        }
	        if (this.data = r, delete this._reglData, this.elements && !_$2(this.elements)) {
	            const e = {
	                primitive: this.getPrimitive(),
	                data: this.elements
	            }, n = this.getElementsType(this.elements);
	            n && (e.type = n), this.elements = this.elements.destroy ? this.elements : t.elements(e);
	            const i = this.elements;
	            i[K$1] || (i[K$1] = 0), i[K$1]++;
	        }
	    }
	    getVertexCount() {
	        const {positionAttribute: t, positionSize: e, color0Attribute: n} = this.desc;
	        let i = this.data[t];
	        i.data && (i = i.data), i.array && (i = i.array), y$1(i) ? this._vertexCount = Math.ceil(i.length / e) : i && void 0 !== i.count && (this._vertexCount = i.count);
	        const r = n;
	        if (this.data[r]) {
	            const t = this.data[r].data || this.data[r].array || this.data[r];
	            Array.isArray(t) ? this._color0Size = t.length / this._vertexCount : t && t.count ? this._color0Size = t.count / this._vertexCount : this.data[r].buffer && this.data[r].buffer.destroy && (this._color0Size = this.data[r].buffer._buffer.dimension);
	        }
	        return this._vertexCount;
	    }
	    getColor0Size() {
	        return this._color0Size || 0;
	    }
	    addBuffer(t, e) {
	        return this._buffers[t] = {
	            data: e
	        }, delete this._reglData, this._deleteVAO(), this;
	    }
	    updateBuffer(t, e) {
	        if (!this._buffers[t]) throw new Error(`invalid buffer ${t} in geometry`);
	        return this._buffers[t].buffer ? this._buffers[t].buffer.subdata(e) : this._buffers[t].data = e, 
	        delete this._reglData, this._deleteVAO(), this;
	    }
	    updateData(t, e) {
	        const n = this.data[t];
	        if (!n) return this;
	        let i;
	        this._incrVersion(), this.data[t] = e, n.buffer && n.buffer.destroy && (i = n);
	        const r = this._vertexCount;
	        t === this.desc.positionAttribute && this.updateBoundingBox();
	        const o = this.getVertexCount();
	        return i && (o <= r ? i.buffer.subdata(e) : i.buffer(e), this.data[t] = i), this._prepareData(), 
	        this.desc.positionAttribute === t && (this._posDirty = !0), delete this._reglData, 
	        this;
	    }
	    updateSubData(t, e, n) {
	        const i = this.data[t];
	        if (!i) return this;
	        let r;
	        if (this._incrVersion(), i.buffer && i.buffer.destroy && (r = i), t === this.desc.positionAttribute && this._updateSubBoundingBox(e), 
	        r) {
	            const t = J$1[r.buffer._buffer.dtype];
	            if (e.BYTES_PER_ELEMENT !== t) {
	                e = new (function(t, e) {
	                    if (t instanceof Uint8Array || t instanceof Uint16Array || t instanceof Uint32Array || t instanceof Uint8ClampedArray) return 1 === e ? Uint8Array : 2 === e ? Uint16Array : Uint32Array;
	                    if (t instanceof Int8Array || t instanceof Int16Array || t instanceof Int32Array) return 1 === e ? Int8Array : 2 === e ? Int16Array : Int32Array;
	                    if (t instanceof Float32Array || t instanceof Float64Array) return 4 === e ? Float32Array : Float64Array;
	                }(e, t))(e);
	            }
	            r.buffer.subdata(e, n * t);
	        } else {
	            const i = this.data[t].data ? this.data[t].data : this.data[t];
	            for (let t = 0; t < e.length; t++) i[n + t] = e[t];
	        }
	        return this._prepareData(), this.desc.positionAttribute === t && (this._posDirty = !0), 
	        delete this._reglData, this;
	    }
	    getPrimitive() {
	        return this.desc.primitive;
	    }
	    getElements() {
	        return this.elements;
	    }
	    setElements(t, e) {
	        if (!t) throw new Error("elements data is invalid");
	        this._incrVersion();
	        const n = this.elements;
	        return this.count = void 0 === e ? $$1(t) : e, this.elements = t && t.destroy ? t : n.destroy ? n(t) : t, 
	        this._elementsUpdated = !0, this;
	    }
	    setDrawCount(t) {
	        return this._incrVersion(), this.count1 = t, this;
	    }
	    getDrawCount() {
	        return this.count1 || this.count;
	    }
	    setDrawOffset(t) {
	        return this._incrVersion(), this.offset = t, this;
	    }
	    getDrawOffset() {
	        return this.offset || 0;
	    }
	    dispose() {
	        this._deleteVAO(), this._forEachBuffer(t => {
	            if (!t[L$1]) {
	                let e = t[K$1];
	                e && e--, e <= 0 ? (t[L$1] = !0, t.destroy()) : t[K$1] = e;
	            }
	        }), this.data = {}, this._buffers = {}, delete this._reglData, delete this._attributes, 
	        this.count = 0, this.elements = [], delete this._tempPosArray, this._disposed = !0;
	    }
	    isDisposed() {
	        return !!this._disposed;
	    }
	    updateBoundingBox() {
	        let t = this.boundingBox;
	        t || (t = this.boundingBox = new W$1);
	        let e, i, r = this.data[this.desc.positionAttribute];
	        if (y$1(r) || (r.data ? r = r.data : E$1(r) ? r = this._getAttributeData(this.desc.positionAttribute) : r.array && (e = r.min, 
	        i = r.max, r = r.array)), r && r.length) {
	            const o = t.min, s = t.max;
	            if (e && i) set$4(o, ...e), set$4(s, ...i); else {
	                set$4(o, r[0], r[1], r[2]), set$4(s, r[0], r[1], r[2]);
	                for (let t = 3; t < r.length; ) {
	                    const e = r[t++], n = r[t++], i = r[t++];
	                    e < o[0] && (o[0] = e), n < o[1] && (o[1] = n), i < o[2] && (o[2] = i), e > s[0] && (s[0] = e), 
	                    n > s[1] && (s[1] = n), i > s[2] && (s[2] = i);
	                }
	            }
	            t.updateVertex(), t.dirty();
	        }
	    }
	    _updateSubBoundingBox(t) {
	        const e = this.boundingBox, n = e.min, i = e.max, r = this.desc.positionSize;
	        for (let e = 0; e < t.length; ) {
	            const o = t[e++], s = t[e++];
	            let a = 0;
	            3 === r && (a = t[e++]), o < n[0] && (n[0] = o), s < n[1] && (n[1] = s), a < n[2] && (n[2] = a), 
	            o > i[0] && (i[0] = o), s > i[1] && (i[1] = s), a > i[2] && (i[2] = a);
	        }
	        e.updateVertex(), e.dirty();
	    }
	    _getAttributeData(e) {
	        const n = this.data[e], i = n.buffer;
	        if (E$1(n)) {
	            const r = this._buffers[i] ? this._buffers[i].data : n.array, {count: o, size: s, stride: a, offset: h, componentType: l} = n, c = k$2.getTypedArrayCtor(l);
	            if ((0 === a || a === s * c.BYTES_PER_ELEMENT) && h % c.BYTES_PER_ELEMENT == 0) return new c(r, h, o * s);
	            if (e === this.desc.positionAttribute) return !this._tempPosArray || this._tempPosArray && this._tempPosArray.length < s * o ? (this._tempPosArray = new c(s * o), 
	            k$2.readInterleavedArray(this._tempPosArray, r, o, s, a, h, l)) : this._posDirty ? (this._posDirty = !1, 
	            k$2.readInterleavedArray(this._tempPosArray, r, o, s, a, h, l)) : this._tempPosArray;
	            {
	                const e = new c(s * o);
	                return k$2.readInterleavedArray(e, r, o, s, a, h, l);
	            }
	        }
	        return n;
	    }
	    createTangent(t = "aTangent") {
	        this._incrVersion();
	        const {normalAttribute: e, positionAttribute: r, uv0Attribute: o} = this.desc, s = this._getAttributeData(e), l = this._getAttributeData(r), c = buildTangents(l, s, this.data[o], this.elements), u = this.data[t] = new Float32Array(c.length), f = [], d = [], m = [];
	        for (let t = 0; t < c.length; t += 4) {
	            const e = t / 4 * 3;
	            set$4(d, s[e], s[e + 1], s[e + 2]), set$3(f, c[t], c[t + 1], c[t + 2], c[t + 3]), 
	            packTangentFrame(m, d, f), copy$3(u.subarray(t, t + 4), m);
	        }
	        delete this._reglData;
	    }
	    createNormal(t = "aNormal") {
	        this._incrVersion();
	        const e = this._getAttributeData(this.desc.positionAttribute);
	        this.data[t] = buildNormals(e.array || e, this.elements), delete this._reglData;
	    }
	    createBarycentric(t = "aBarycentric") {
	        if ("triangles" !== this.desc.primitive) throw new Error("Primitive must be triangles to create bary centric data");
	        this._incrVersion();
	        const e = new Uint8Array(3 * this._vertexCount);
	        for (let t = 0, n = this.elements.length; t < n; ) for (let n = 0; n < 3; n++) {
	            e[3 * this.elements[t++] + n] = 1;
	        }
	        this.data[t] = e, delete this._reglData;
	    }
	    buildUniqueVertex() {
	        this._incrVersion();
	        const t = this.data, e = this.elements;
	        if (!y$1(e)) throw new Error("elements must be array to build unique vertex.");
	        const n = Object.keys(t), i = {};
	        let r = t[this.desc.positionAttribute];
	        if (r = r.length ? r : r.array, !y$1(r)) throw new Error(this.desc.positionAttribute + " must be array to build unique vertex.");
	        const o = this._vertexCount, s = e.length;
	        for (let e = 0; e < n.length; e++) {
	            const r = n[e], a = y$1(t[r]) ? t[r] : t[r].array, h = a.length / o;
	            if (!y$1(a)) throw new Error(r + " must be array to build unique vertex.");
	            i[r] = a, i[r].size = h, t[r] = new a.constructor(s * h);
	        }
	        let a = 0;
	        for (let r = 0; r < s; r++) {
	            const o = e[r];
	            for (let e = 0; e < n.length; e++) {
	                const r = n[e], s = t[r], h = i[r].size;
	                for (let t = 0; t < h; t++) s[a * h + t] = i[r][o * h + t];
	            }
	            e[r] = a++;
	        }
	        delete this._reglData;
	    }
	    getMemorySize() {
	        let t = 0;
	        for (const e in this.data) C$1(this.data, e) && (t += M$1(this.data[e]));
	        if (this.elements) {
	            const e = this.elements;
	            e.destroy ? t += e._elements.buffer.byteLength : e.BYTES_PER_ELEMENT ? t += e.length * e.BYTES_PER_ELEMENT : e.length && (t += 4 * e.length);
	        }
	        return t;
	    }
	    _deleteVAO() {
	        for (const t in this._vao) this._vao[t].vao.destroy();
	        this._vao = {};
	    }
	    _forEachBuffer(t) {
	        this.elements && this.elements.destroy && t(this.elements);
	        for (const e in this.data) C$1(this.data, e) && this.data[e] && this.data[e].buffer && this.data[e].buffer.destroy && t(this.data[e].buffer);
	        for (const e in this._buffers) C$1(this._buffers, e) && this._buffers[e] && this._buffers[e].buffer && this._buffers[e].buffer.destroy && t(this._buffers[e].buffer);
	    }
	    getElementsType(t) {
	        return t instanceof Uint8Array ? "uint8" : t instanceof Uint16Array ? "uint16" : t instanceof Uint32Array ? "uint32" : void 0;
	    }
	    _incrVersion() {
	        this._version++;
	    }
	}

	function $$1(t) {
	    if (_$2(t)) return t;
	    if (void 0 !== t.count) return t.count;
	    if (t.destroy) return t._elements.vertCount;
	    if (void 0 !== t.length) return t.length;
	    if (t.data) return t.data.length;
	    throw new Error("invalid elements length");
	}

	var tt$1 = D$1(class {
	    constructor(t = {}, e) {
	        this._version = 0, this.uniforms = p({}, e || {}, t);
	        for (const e in t) {
	            const n = Object.getOwnPropertyDescriptor(t, e).get;
	            n && Object.defineProperty(this.uniforms, e, {
	                get: n
	            });
	        }
	        this._reglUniforms = {}, this.refCount = 0, this._bindedOnTextureComplete = this._onTextureComplete.bind(this), 
	        this._genUniformKeys(), this._checkTextures();
	    }
	    set version(t) {
	        throw new Error("Material.version is read only.");
	    }
	    get version() {
	        return this._version;
	    }
	    isReady() {
	        return this._loadingCount <= 0;
	    }
	    set(t, e) {
	        const n = u(this.uniforms[t]) && !u(e) || !u(this.uniforms[t]) && u(e);
	        return this.uniforms[t] && this.isTexture(t) && this.uniforms[t].dispose(), u(e) ? u(this.uniforms[t]) || delete this.uniforms[t] : this.uniforms[t] = e, 
	        this._dirtyUniforms = !0, this.isTexture(t) && this._checkTextures(), n && (this._genUniformKeys(), 
	        this._incrVersion()), this;
	    }
	    get(t) {
	        return this.uniforms[t];
	    }
	    isDirty() {
	        return this._uniformVer !== this.version;
	    }
	    appendDefines(t) {
	        const e = this.uniforms;
	        return e.jointTexture && (t.HAS_SKIN = 1), e.morphWeights1 && (t.HAS_MORPH = 1), 
	        (e.khr_offset || e.khr_rotation || e.khr_scale) && (t.HAS_KHR_TEXTURE_TRANSFORM = 1), 
	        t;
	    }
	    hasSkinAnimation() {
	        return this.uniforms && this.uniforms.jointTexture && this.uniforms.skinAnimation;
	    }
	    getUniforms(t) {
	        if (this._reglUniforms && !this.isDirty()) return this._reglUniforms;
	        const e = this.uniforms, n = {};
	        for (const i in e) this.isTexture(i) ? Object.defineProperty(n, i, {
	            enumerable: !0,
	            configurable: !0,
	            get: function() {
	                return e[i].getREGLTexture(t);
	            }
	        }) : Object.defineProperty(n, i, {
	            enumerable: !0,
	            configurable: !0,
	            get: function() {
	                return e[i];
	            }
	        });
	        return this._reglUniforms = n, this._uniformVer = this.version, n;
	    }
	    isTexture(t) {
	        return this.uniforms[t] instanceof F$1;
	    }
	    dispose() {
	        for (const t in this.uniforms) {
	            const e = this.uniforms[t];
	            e && (e.dispose ? e.dispose() : e.destroy && !e[L$1] && (e.destroy(), e[L$1] = !0));
	        }
	        delete this.uniforms, delete this._reglUniforms, this._disposed = !0;
	    }
	    isDisposed() {
	        return !!this._disposed;
	    }
	    _checkTextures() {
	        this._loadingCount = 0;
	        for (const t in this.uniforms) if (this.isTexture(t)) {
	            const e = this.uniforms[t];
	            e.isReady() || (this._loadingCount++, e.on("complete", this._bindedOnTextureComplete));
	        }
	    }
	    _onTextureComplete() {
	        this._loadingCount--, this._incrVersion(), this._loadingCount <= 0 && (this._disposed || this.fire("complete"));
	    }
	    getUniformKeys() {
	        return this._uniformKeys;
	    }
	    _genUniformKeys() {
	        const t = [];
	        for (const e in this.uniforms) C$1(this.uniforms, e) && !u(this.uniforms[e]) && t.push(e);
	        this._uniformKeys = t.join();
	    }
	    _incrVersion() {
	        this._version++;
	    }
	    getMemorySize() {
	        const t = this.uniforms;
	        let e = 0;
	        for (const n in t) this.isTexture(n) ? e += t[n].getMemorySize() : this.uniforms[n].destroy && (e += T$2(this.uniforms[n]));
	        return e;
	    }
	});

	const et$1 = {
	    time: 0,
	    seeThrough: !0,
	    thickness: .03,
	    fill: [ 1, .5137254902, .98, 1 ],
	    stroke: [ .7019607843, .9333333333, .2274509804, 1 ],
	    dashEnabled: !1,
	    dashAnimate: !1,
	    dashRepeats: 1,
	    dashLength: .8,
	    dashOverlap: !0,
	    insideAltColor: !1,
	    squeeze: !1,
	    squeezeMin: .5,
	    squeezeMax: 1,
	    dualStroke: !1,
	    secondThickness: .05,
	    opacity: 1,
	    noiseEnable: !1
	};

	class nt$1 extends tt$1 {
	    constructor(t) {
	        super(t, et$1);
	    }
	}

	const it$1 = {
	    baseColorFactor: [ 1, 1, 1, 1 ],
	    materialShininess: 32,
	    environmentExposure: 1,
	    specularStrength: 32,
	    opacity: 1,
	    extrusionOpacity: 0,
	    extrusionOpacityRange: [ 0, 1.8 ],
	    baseColorTexture: null,
	    normalTexture: null,
	    emissiveTexture: null,
	    occlusionTexture: null,
	    uvScale: [ 1, 1 ],
	    uvOffset: [ 0, 0 ]
	};

	class rt$1 extends tt$1 {
	    constructor(t) {
	        super(t, it$1);
	    }
	    static convertFrom(t) {
	        const e = {};
	        for (const n in it$1) e[n] = t.get(n);
	        return new rt$1(e);
	    }
	    appendDefines(t, e) {
	        super.appendDefines(t, e);
	        const n = this.uniforms;
	        n.extrusionOpacity && (t.HAS_EXTRUSION_OPACITY = 1), e.data[e.desc.colorAttribute] && (t.HAS_COLOR = 1);
	        return e.data[e.desc.color0Attribute] && (t.HAS_COLOR0 = 1, t.COLOR0_SIZE = e.getColor0Size()), 
	        e.data[e.desc.uv0Attribute] ? (n.baseColorTexture && (t.HAS_BASECOLOR_MAP = 1), 
	        n.occlusionTexture && (t.HAS_AO_MAP = 1), n.emissiveTexture && (t.HAS_EMISSIVE_MAP = 1), 
	        n.normalTexture && (t.HAS_NORMAL_MAP = 1), (t.HAS_BASECOLOR_MAP || t.HAS_AO_MAP || t.HAS_EMISSIVE_MAP || t.HAS_NORMAL_MAP) && (t.HAS_MAP = 1), 
	        t) : t;
	    }
	}

	const ot$1 = {
	    toons: 4,
	    specularToons: 2
	};

	class st$1 extends rt$1 {
	    constructor(t) {
	        super(t, ot$1);
	    }
	}

	const at$1 = {
	    diffuseFactor: [ 1, 1, 1, 1 ],
	    specularFactor: [ 1, 1, 1 ],
	    glossinessFactor: 1,
	    diffuseTexture: null,
	    specularGlossinessTexture: null,
	    normalTexture: null,
	    emissiveTexture: null,
	    occlusionTexture: null
	}, ht$1 = t => class extends t {
	    constructor(t) {
	        super(t = g({}, at$1, t || {}));
	    }
	    appendDefines(t, e) {
	        if (super.appendDefines(t, e), t.SHADING_MODEL_SPECULAR_GLOSSINESS = 1, !e.data[e.desc.uv0Attribute]) return t;
	        const n = this.uniforms;
	        return n.diffuseTexture && (t.HAS_DIFFUSE_MAP = 1), n.specularGlossinessTexture && (t.HAS_SPECULARGLOSSINESS_MAP = 1), 
	        (t.HAS_SPECULARGLOSSINESS_MAP || t.HAS_DIFFUSE_MAP) && (t.HAS_MAP = 1), t;
	    }
	};

	class lt$1 extends(ht$1(rt$1)){}

	const ct$1 = [];

	let ut$1 = 0;

	class ft$1 {
	    constructor(t, n, i = {}) {
	        this._version = 0, this._geometry = t, this._material = n, this.transparent = !!i.transparent, 
	        this.bloom = !!i.bloom, this.ssr = !!i.ssr, this.castShadow = u(i.castShadow) || i.castShadow, 
	        this.picking = !!i.picking, this.disableVAO = !!i.disableVAO, this.uniforms = {}, 
	        this._localTransform = identity$2(new Array(16)), this._positionMatrix = identity$2(new Array(16)), 
	        this.properties = {}, this._dirtyUniforms = !0, this._dirtyGeometry = !0, Object.defineProperty(this, "uuid", {
	            value: ut$1++
	        }), ut$1 > Number.MAX_VALUE - 10 && (ut$1 = 0);
	    }
	    set material(t) {
	        this._material !== t && this.setMaterial(t);
	    }
	    get material() {
	        return this._material;
	    }
	    set version(t) {
	        throw new Error("Mesh.version is read only.");
	    }
	    get version() {
	        return this._version;
	    }
	    get geometry() {
	        return this._geometry;
	    }
	    set geometry(t) {
	        this._geometry !== t && (this._incrVersion(), this._dirtyGeometry = !0), this._geometry = t;
	    }
	    set localTransform(t) {
	        this._prevTMat || (this._prevTMat = []), Array.isArray(t) && !exactEquals$5(this._prevTMat, t) && (this._incrVersion(), 
	        this._prevTMat = copy$5(this._prevTMat, t)), this._localTransform = t;
	    }
	    get localTransform() {
	        return this._localTransform;
	    }
	    set positionMatrix(t) {
	        this._prevPMat || (this._prevPMat = []), Array.isArray(t) && !exactEquals$5(this._prevPMat, t) && (this._incrVersion(), 
	        this._prevPMat = copy$5(this._prevPMat, t)), this._positionMatrix = t;
	    }
	    get positionMatrix() {
	        return this._positionMatrix;
	    }
	    get config() {
	        return this._cfg || (this._cfg = {}), this._cfg.transparent = this.transparent, 
	        this._cfg.castShadow = this.castShadow, this._cfg.bloom = this.bloom, this._cfg.ssr = this.ssr, 
	        this._cfg.picking = this.picking, this._cfg;
	    }
	    get defines() {
	        return this._getDefines();
	    }
	    set defines(t) {
	        this.setDefines(t);
	    }
	    setMaterial(t) {
	        return this._material = t, this._dirtyUniforms = !0, delete this._materialVer, this.dirtyDefines = !0, 
	        this;
	    }
	    setParent(t) {
	        return this.parent = t, this;
	    }
	    setLocalTransform(t) {
	        return this.localTransform = t, this;
	    }
	    setPositionMatrix(t) {
	        this.positionMatrix = t;
	    }
	    setUniform(t, e) {
	        return void 0 === this.uniforms[t] && (this._dirtyUniforms = !0), this.uniforms[t] = e, 
	        this;
	    }
	    getUniform(t) {
	        return this.uniforms[t];
	    }
	    getDefines() {
	        const t = {};
	        return g(t, this._getDefines()), this._material && this._geometry && this._material.appendDefines(t, this._geometry), 
	        t;
	    }
	    _getDefines() {
	        this._defines || (this._defines = {});
	        const t = this._geometry, e = t.data[t.desc.positionAttribute], n = t.data[t.desc.uv0Attribute], i = t.data[t.desc.normalAttribute];
	        return e && e.quantization && (this._defines.HAS_DECODE_POSITION = 1), n && n.quantization && (this._defines.HAS_DECODE_TEXCOORD = 1), 
	        i && i.quantization && (this._defines.HAS_DECODE_NORMAL = 1), this._defines;
	    }
	    setDefines(t) {
	        const e = this._bakDefines;
	        return this._defines = t, this.dirtyDefines = this.dirtyDefines || !!e != !!t || !function(t, e) {
	            if (!t && !e) return !0;
	            const n = Object.getOwnPropertyNames(t), i = Object.getOwnPropertyNames(e);
	            if (n.length !== i.length) return !1;
	            for (let i = 0; i < n.length; i++) if (t[n[i]] !== e[n[i]]) return !1;
	            return !0;
	        }(e, t), this.dirtyDefines && (this._bakDefines = g({}, t)), this;
	    }
	    hasSkinAnimation() {
	        return this._material && this._material.hasSkinAnimation();
	    }
	    _getDefinesKey() {
	        return this.dirtyDefines = !1, this._createDefinesKey(this.getDefines());
	    }
	    getCommandKey() {
	        if (!this._commandKey || this.dirtyDefines || this._material && this._materialKeys !== this._material.getUniformKeys()) {
	            let t = this._getDefinesKey();
	            t += "_" + (_$2(this.getElements()) ? "count" : "elements"), t += "_" + +!!this.disableVAO, 
	            this._commandKey = t, this._material && (this._materialKeys = this._material.getUniformKeys());
	        }
	        return this._commandKey;
	    }
	    getUniforms(t) {
	        if (this._dirtyUniforms || this._dirtyGeometry || this._material && this._materialVer !== this._material.version) {
	            if (this._realUniforms = {}, this._getUniformsForDraco(), this._material) {
	                const e = this._material.getUniforms(t);
	                for (const t in e) C$1(e, t) && Object.defineProperty(this._realUniforms, t, {
	                    enumerable: !0,
	                    configurable: !0,
	                    get: function() {
	                        return e[t];
	                    }
	                });
	            }
	            const e = this.uniforms;
	            for (const t in this.uniforms) C$1(this.uniforms, t) && Object.defineProperty(this._realUniforms, t, {
	                enumerable: !0,
	                configurable: !0,
	                get: function() {
	                    return e[t];
	                }
	            });
	            this._dirtyUniforms = !1, this._dirtyGeometry = !1, this._materialVer = this._material && this._material.version;
	        }
	        return this._realUniforms.modelMatrix = d(this._localTransform) ? this._localTransform() : this._localTransform, 
	        this._realUniforms.positionMatrix = d(this._positionMatrix) ? this._positionMatrix() : this._positionMatrix, 
	        this._realUniforms;
	    }
	    _getUniformsForDraco() {
	        const t = this._geometry, e = t.data[t.desc.positionAttribute], n = t.data[t.desc.uv0Attribute], i = t.data[t.desc.normalAttribute];
	        if (e && e.quantization) {
	            const t = e.quantization, n = t.range / (1 << t.quantizationBits);
	            this._defineUniformsProperty(this._realUniforms, "minValues_pos", t.minValues), 
	            this._defineUniformsProperty(this._realUniforms, "gltf_u_dec_position_normConstant", n);
	        }
	        if (n && n.quantization) {
	            const t = n.quantization;
	            this._defineUniformsProperty(this._realUniforms, "minValues_tex", t.minValues);
	            this._defineUniformsProperty(this._realUniforms, "gltf_u_dec_texcoord_0_normConstant", t.range / (1 << t.quantizationBits));
	        }
	        if (i && i.quantization) {
	            this._defineUniformsProperty(this._realUniforms, "gltf_u_dec_normal_rangeConstant", (1 << i.quantization.quantizationBits) - 1);
	        }
	    }
	    _defineUniformsProperty(t, e, n) {
	        f(t[e]) || Object.defineProperty(t, e, {
	            enumerable: !0,
	            configurable: !0,
	            get: function() {
	                return n;
	            }
	        });
	    }
	    getMaterial() {
	        return this._material;
	    }
	    getElements() {
	        return this._geometry.getElements();
	    }
	    _getREGLAttrData(t, e) {
	        return this._geometry.getREGLData(t, e, this.disableVAO);
	    }
	    getREGLProps(t, e) {
	        const n = this.getUniforms(t);
	        return g(n, this._getREGLAttrData(t, e)), w$1(t) && !this.disableVAO || (n.elements = this._geometry.getElements()), 
	        n.meshProperties = this.properties, n.meshConfig = this.config, n.count = this._geometry.getDrawCount(), 
	        n.offset = this._geometry.getDrawOffset(), n.primitive = this._geometry.getPrimitive(), 
	        n;
	    }
	    dispose() {
	        const t = this.properties.oldElementsBeforeHighlight;
	        return t && !t[L$1] && t !== this._geometry.elements && t.destroy && (t.destroy(), 
	        t[L$1] = !0), delete this.properties.oldElementsBeforeHighlight, delete this.properties.hasInvisible, 
	        delete this._geometry, delete this._material, this.uniforms = {}, this;
	    }
	    isValid() {
	        return this._geometry && !this._geometry.isDisposed() && (!this._material || !this._material.isDisposed());
	    }
	    getBoundingBox() {
	        return this._bbox || this.updateBoundingBox(), multiply$5(ct$1, this._localTransform, this._positionMatrix), 
	        exactEquals$5(ct$1, this._currentTransform) && this._geometry.boundingBox.equals(this._geoBox) || this.updateBoundingBox(), 
	        this._bboxArr;
	    }
	    updateBoundingBox() {
	        const t = this._geometry.boundingBox;
	        this._bbox || (this._bbox = new W$1), this._bboxArr || (this._bboxArr = [ [], [] ]), 
	        this._geoBox || (this._geoBox = new W$1), W$1.copy(this._bbox, t), this._bbox.updateVertex(), 
	        "InstancedMesh" === this.constructor.name ? (this._bbox.transform(this._localTransform, this._positionMatrix), 
	        this._currentTransform = multiply$5(this._currentTransform || [], this._positionMatrix, this._localTransform)) : (this._bbox.transform(this._positionMatrix, this._localTransform), 
	        this._currentTransform = multiply$5(this._currentTransform || [], this._localTransform, this._positionMatrix)), 
	        W$1.copy(this._geoBox, t), copy$4(this._bboxArr[0], this._bbox.min), copy$4(this._bboxArr[1], this._bbox.max);
	    }
	    _createDefinesKey(t) {
	        const e = [];
	        for (const n in t) e.push(n, t[n]);
	        return e.join(",");
	    }
	    _incrVersion() {
	        this._version++;
	    }
	    getMemorySize() {
	        return (this.geometry && this.geometry.getMemorySize() || 0) + (this.material && this.material.getMemorySize() || 0);
	    }
	}

	ft$1.prototype.getWorldTransform = function() {
	    const t = [];
	    return function() {
	        const n = this.parent;
	        return n ? multiply$5(t, n.getWorldTransform(), this._localTransform) : this._localTransform;
	    };
	}();

	class dt$1 extends ft$1 {
	    constructor(t, e, n, i, r = {}) {
	        super(n, i, r), this._instanceCount = e, this.instancedData = t || {}, this._checkInstancedProp(), 
	        this._vao = {};
	    }
	    get instanceCount() {
	        return this._instanceCount;
	    }
	    set instanceCount(t) {
	        this._incrVersion(), this._instanceCount = t;
	    }
	    getMemorySize() {
	        return super.getMemorySize() + this._getInstanceMemorySize();
	    }
	    _getInstanceMemorySize() {
	        let t = 0;
	        for (const e in this.instancedData) C$1(this.instancedData, e) && (t += M$1(this.instancedData[e]));
	        return t;
	    }
	    _checkInstancedProp() {
	        for (const t in this.instancedData) if (this.geometry.data[t]) throw new Error(`Duplicate attribute ${t} defined in geometry and instanced data`);
	    }
	    _getREGLAttrData(t, e) {
	        const n = this.geometry.getAttrData(e);
	        if (w$1(t)) {
	            const i = e.key;
	            if (!this._vao[i] || this._instanceDataUpdated) {
	                const r = e.map(t => t.name), o = [];
	                for (let t = 0; t < r.length; t++) {
	                    const e = n[r[t]];
	                    o.push(e && e.buffer ? e.buffer : this.instancedData[r[t]]);
	                }
	                const s = {
	                    attributes: o,
	                    primitive: this.geometry.getPrimitive()
	                };
	                this._vao[i] ? this._vao[i].vao(s) : this._vao[i] = {
	                    vao: t.vao(s)
	                }, delete this._instanceDataUpdated;
	            }
	            return this._vao[i];
	        }
	        return n;
	    }
	    getDefines() {
	        const t = super.getDefines();
	        return t.HAS_INSTANCE = 1, t;
	    }
	    getCommandKey(t) {
	        return "i_" + super.getCommandKey(t);
	    }
	    updateInstancedData(t, e) {
	        const n = this.instancedData[t];
	        return n ? (this._incrVersion(), this.instancedData[t] = e, n.buffer && n.buffer.destroy && n.buffer.destroy(), 
	        this._instanceDataUpdated = !0, this) : this;
	    }
	    generateInstancedBuffers(t) {
	        const e = this.instancedData, n = {};
	        for (const i in e) e[i] && (void 0 !== e[i].buffer && e[i].buffer.destroy ? (n[i] = e[i], 
	        n[i].divisor && (n[i].divisor = 1)) : n[i] = e[i].destroy ? {
	            buffer: e[i],
	            divisor: 1
	        } : {
	            buffer: t.buffer({
	                data: e[i],
	                dimension: e[i].length / this._instanceCount
	            }),
	            divisor: 1
	        });
	        return this.instancedData = n, this;
	    }
	    getREGLProps(t, e) {
	        const n = super.getREGLProps(t, e);
	        return w$1(t) || g(n, this.instancedData), n.elements = this.geometry.getElements(), 
	        n.instances = this._instanceCount, n;
	    }
	    disposeInstanceData() {
	        const t = this.instancedData;
	        if (t) for (const e in t) t[e] && t[e].destroy && !t[e][L$1] && (t[e][L$1] = 1, t[e].destroy());
	        this.instancedData = {};
	        for (const t in this._vao) this._vao[t].vao.destroy();
	        this._vao = {};
	    }
	    _getBytesPerElement(t) {
	        switch (t) {
	          case 5120:
	          case 5121:
	            return 1;

	          case 5122:
	          case 5123:
	            return 2;

	          case 5124:
	          case 5125:
	          case 5126:
	            return 4;
	        }
	        throw new Error("unsupported data type: " + t);
	    }
	}

	const mt$1 = {
	    getArrayBuffer: (t, e) => mt$1.get(t, {
	        responseType: "arraybuffer"
	    }, e),
	    get: function(t, e, n) {
	        const i = mt$1._getClient(n);
	        if (i.open("GET", t, !0), e) {
	            for (const t in e.headers) i.setRequestHeader(t, e.headers[t]);
	            i.withCredentials = "include" === e.credentials, e.responseType && (i.responseType = e.responseType);
	        }
	        return i.send(null), i;
	    },
	    _wrapCallback: function(t, e) {
	        return function() {
	            if (4 === t.readyState) if (200 === t.status) if ("arraybuffer" === t.responseType) {
	                0 === t.response.byteLength ? e(new Error("http status 200 returned without content.")) : e(null, {
	                    data: t.response,
	                    cacheControl: t.getResponseHeader("Cache-Control"),
	                    expires: t.getResponseHeader("Expires"),
	                    contentType: t.getResponseHeader("Content-Type")
	                });
	            } else e(null, t.responseText); else e(new Error(t.statusText + "," + t.status));
	        };
	    },
	    _getClient: function(t) {
	        let e;
	        try {
	            e = new XMLHttpRequest;
	        } catch (t) {
	            try {
	                e = new ActiveXObject("Msxml2.XMLHTTP");
	            } catch (t) {
	                try {
	                    e = new ActiveXObject("Microsoft.XMLHTTP");
	                } catch (t) {}
	            }
	        }
	        return e.onreadystatechange = mt$1._wrapCallback(e, t), e;
	    }
	};

	var gt$1 = D$1(class {
	    constructor(t) {
	        this.defaultTexture = t, this.defaultCubeTexture = new Array(6), this.resources = {};
	    }
	    get(t) {
	        return Array.isArray(t) ? this._loadImages(t) : this._loadImage(t);
	    }
	    getArrayBuffer(t) {
	        if (Array.isArray(t)) {
	            const e = t.map(t => this.getArrayBuffer(t));
	            return Promise.all(e);
	        }
	        return new Promise((e, n) => {
	            mt$1.getArrayBuffer(t, (i, r) => {
	                i ? n(i) : e({
	                    url: t,
	                    data: r
	                });
	            });
	        });
	    }
	    disposeRes(t) {
	        return Array.isArray(t) ? t.forEach(t => this._disposeOne(t)) : this._disposeOne(t), 
	        this;
	    }
	    isLoading() {
	        return this._count && this._count > 0;
	    }
	    getDefaultTexture(t) {
	        return Array.isArray(t) ? this._getBlankTextures(t.length) : this.defaultTexture;
	    }
	    _disposeOne(t) {
	        const e = this.resources;
	        e[t] && (e[t].count--, e[t].count <= 0 && delete e[t]);
	    }
	    _loadImage(t) {
	        const e = this.resources;
	        if (e[t]) return Promise.resolve({
	            url: t,
	            data: e[t].image
	        });
	        return new Promise((n, i) => {
	            const r = new Image;
	            r.crossOrigin = "anonymous", r.onload = function() {
	                e[t] = {
	                    image: r,
	                    count: 1
	                }, n({
	                    url: t,
	                    data: r
	                });
	            }, r.onerror = function(t) {
	                i(t);
	            }, r.onabort = function() {
	                i(`image(${t}) loading aborted.`);
	            }, r.src = t;
	        });
	    }
	    _loadImages(t) {
	        const e = t.map(t => this._loadImage(t, !0));
	        return Promise.all(e);
	    }
	    _getBlankTextures(t) {
	        const e = new Array(t);
	        for (let t = 0; t < 6; t++) e.push(this.defaultTexture);
	        return e;
	    }
	});

	const pt$1 = [], _t$1 = [];

	let vt$1 = 0;

	class yt$1 {
	    constructor(t) {
	        this._id = vt$1++, this.sortedMeshes = {}, this.setMeshes(t), this._compareBinded = this._compare.bind(this), 
	        this.dirty();
	    }
	    setMeshes(t) {
	        if (this.clear(), !t || Array.isArray(t) && !t.length || t === this.meshes) return this;
	        t = Array.isArray(t) ? t : [ t ], this.meshes = [];
	        for (let e = 0; e < t.length; e++) {
	            const n = t[e];
	            n && (n._scenes = n._scenes || {}, n._scenes[this._id] = 1, this.meshes.push(n));
	        }
	        return this.dirty(), this;
	    }
	    addMesh(t) {
	        return !t || Array.isArray(t) && !t.length || (Array.isArray(t) ? t.forEach(t => {
	            t._scenes = t._scenes || {}, t._scenes[this._id] || (t._scenes[this._id] = 1, this.meshes.push(t), 
	            this.dirty());
	        }) : (t._scenes = t._scenes || {}, t._scenes[this._id] || (t._scenes[this._id] = 1, 
	        this.meshes.push(t), this.dirty()))), this;
	    }
	    removeMesh(t) {
	        if (!t || Array.isArray(t) && !t.length) return this;
	        if (Array.isArray(t)) {
	            let e = !1;
	            for (let n = 0; n < t.length; n++) t[n]._scenes && t[n]._scenes[this._id] && (e = !0, 
	            this.dirty(), delete t[n]._scenes[this._id]);
	            e && (this.meshes = this.meshes.filter(e => t.indexOf(e) < 0));
	        } else {
	            if (!t._scenes || !t._scenes[this._id]) return this;
	            const e = this.meshes.indexOf(t);
	            e >= 0 && this.meshes.splice(e, 1), delete t._scenes[this._id], this.dirty();
	        }
	        return this;
	    }
	    getMeshes() {
	        return this.meshes;
	    }
	    clear() {
	        if (this.meshes) for (let t = 0; t < this.meshes.length; t++) delete this.meshes[t]._scenes[this._id];
	        return this.meshes = [], this.sortedMeshes.opaques = [], this.sortedMeshes.transparents = [], 
	        this;
	    }
	    dirty() {
	        return this._dirty = !0, this;
	    }
	    sortMeshes(t) {
	        const e = this.meshes;
	        this.sortFunction && e.sort(this.sortFunction);
	        let n = this.sortedMeshes.transparents;
	        if (this._dirty) {
	            const t = this.sortedMeshes.opaques = [];
	            n = this.sortedMeshes.transparents = [];
	            for (let i = 0, r = e.length; i < r; i++) e[i].transparent ? n.push(e[i]) : t.push(e[i]);
	        }
	        t && n.length > 1 && (this._cameraPosition = t, n.sort(this._compareBinded), delete this._cameraPosition), 
	        this._dirty = !1;
	    }
	    getSortedMeshes() {
	        return this._dirty && this.sortMeshes(), this.sortedMeshes;
	    }
	    _compare(t, e) {
	        return transformMat4$2(pt$1, t.geometry.boundingBox.getCenter(), t.localTransform), 
	        transformMat4$2(_t$1, e.geometry.boundingBox.getCenter(), e.localTransform), dist$2(_t$1, this._cameraPosition) - dist$2(pt$1, this._cameraPosition);
	    }
	}

	var xt$1 = String.fromCharCode;

	function bt$1(t, e, n, i) {
	    if (t[3] > 0) {
	        var r = Math.pow(2, t[3] - 128 - 8 + i);
	        e[n + 0] = t[0] * r, e[n + 1] = t[1] * r, e[n + 2] = t[2] * r;
	    } else e[n + 0] = 0, e[n + 1] = 0, e[n + 2] = 0;
	    return e[n + 3] = 1, e;
	}

	function wt$1(t, e, n) {
	    let i = t[e] / n, r = t[e + 1] / n, o = t[e + 2] / n, s = b$1(Math.max(Math.max(i, r), Math.max(o, 1e-6)), 0, 1);
	    s = Math.ceil(255 * s) / 255, t[e] = Math.min(255, i / s * 255), t[e + 1] = Math.min(255, r / s * 255), 
	    t[e + 2] = Math.min(255, o / s * 255), t[e + 3] = Math.min(255, 255 * s);
	}

	function Ct$1(t, e, n, i) {
	    for (var r, o, s = 0, a = 0, h = i; h > 0; ) if (t[a][0] = e[n++], t[a][1] = e[n++], 
	    t[a][2] = e[n++], t[a][3] = e[n++], 1 === t[a][0] && 1 === t[a][1] && 1 === t[a][2]) {
	        for (var l = t[a][3] << s >>> 0; l > 0; l--) (o = t[a])[0] = (r = t[a - 1])[0], 
	        o[1] = r[1], o[2] = r[2], o[3] = r[3], a++, h--;
	        s += 8;
	    } else a++, h--, s = 0;
	    return n;
	}

	function Mt$1(t, e, n, i) {
	    if (i < 8 | i > 32767) return Ct$1(t, e, n, i);
	    var r = e[n++];
	    if (2 !== r) return Ct$1(t, e, n - 1, i);
	    if (t[0][1] = e[n++], t[0][2] = e[n++], r = e[n++], (t[0][2] << 8 >>> 0 | r) >>> 0 !== i) return null;
	    for (let r = 0; r < 4; r++) for (let a = 0; a < i; ) {
	        var o = e[n++];
	        if (o > 128) {
	            o = (127 & o) >>> 0;
	            for (var s = e[n++]; o--; ) t[a++][r] = s;
	        } else for (;o--; ) t[a++][r] = e[n++];
	    }
	    return n;
	}

	function Tt$1(t, e = 0, n = 9) {
	    var i = new Uint8Array(t), r = i.length;
	    if ("#?" !== function(t, e, n) {
	        for (var i = "", r = e; r < n; r++) i += xt$1(t[r]);
	        return i;
	    }(i, 0, 2)) return null;
	    for (var o = 2; o < r && ("\n" !== xt$1(i[o]) || "\n" !== xt$1(i[o + 1])); o++) ;
	    if (o >= r) return null;
	    o += 2;
	    for (var s = ""; o < r; o++) {
	        var a = xt$1(i[o]);
	        if ("\n" === a) break;
	        s += a;
	    }
	    var h = s.split(" "), l = parseInt(h[1]), c = parseInt(h[3]);
	    if (!c || !l) return null;
	    for (var u = o + 1, f = [], d = 0; d < c; d++) {
	        f[d] = [];
	        for (var m = 0; m < 4; m++) f[d][m] = 0;
	    }
	    var g = 0, p = new Array(c * l * 4), _ = 0;
	    for (let t = 0; t < l; t++) {
	        if (!(u = Mt$1(f, i, u, c))) return null;
	        for (let t = 0; t < c; t++) bt$1(f[t], p, _, e), g = Math.max(g, p[_], p[_ + 1], p[_ + 2], p[_ + 3]), 
	        _ += 4;
	    }
	    g = Math.min(g, n), _ = 0;
	    for (let t = 0; t < l; t++) for (let t = 0; t < c; t++) wt$1(p, _, g), _ += 4;
	    return {
	        width: c,
	        height: l,
	        pixels: p,
	        rgbmRange: g
	    };
	}

	const St$1 = [ "points", "lines", "line strip", "line loop", "triangles", "triangle strip", "triangle fan" ];

	function Pt$1(t) {
	    return St$1[t];
	}

	const At$1 = {
	    5121: "uint8",
	    5123: "uint16",
	    5125: "uint32",
	    5126: "float",
	    36193: "half float"
	};

	function Et$1(t) {
	    return At$1[t];
	}

	const Ot$1 = {
	    6406: "alpha",
	    6407: "rgb",
	    6408: "rgba",
	    6409: "luminance",
	    6410: "luminance alpha",
	    33776: "rgb s3tc dxt1",
	    33777: "rgba s3tc dxt1",
	    33778: "rgba s3tc dxt3",
	    33779: "rgba s3tc dxt5",
	    35840: "rgb pvrtc 4bppv1",
	    35841: "rgb pvrtc 2bppv1",
	    35842: "rgba pvrtc 4bppv1",
	    35843: "rgba pvrtc 2bppv1",
	    35986: "rgb atc",
	    35987: "rgba atc explicit alpha",
	    34798: "rgba atc interpolated alpha",
	    36196: "rgb etc1"
	};

	function Rt$1(t) {
	    return Ot$1[t];
	}

	const It$1 = {
	    9729: "linear",
	    9728: "nearest"
	};

	function kt$1(t) {
	    return It$1[t];
	}

	const Dt$1 = {
	    9729: "linear",
	    9728: "nearest",
	    9984: "nearest mipmap nearest",
	    9985: "linear mipmap nearest",
	    9986: "nearest mipmap linear",
	    9987: "linear mipmap linear"
	};

	function Lt$1(t) {
	    return Dt$1[t];
	}

	const zt$1 = {
	    10497: "repeat",
	    33071: "clamp",
	    33648: "mirror"
	};

	function Ft$1(t) {
	    return zt$1[t];
	}

	const jt$1 = "__reshader_webgl_buffer", Ht$1 = "__reshader_webgl_tex";

	function Nt$1(t, e, n) {
	    let i;
	    if (y$1(e) ? e.buffer && void 0 !== e.byteOffset && (i = e) : e.array && e.array.buffer && void 0 !== e.array.byteOffset && (i = e.array), 
	    !i) return null;
	    const r = i.buffer, o = i.byteOffset;
	    r[jt$1] || (r[jt$1] = {});
	    let s = r[jt$1][o];
	    if (!s) {
	        const e = {};
	        n && g(e, n), e.data = i, s = t.buffer(e), r[jt$1][o] = s;
	    }
	    return s;
	}

	function Bt$1(t, e) {
	    const n = e.data;
	    if (!n || !n.buffer) return t.texture(e);
	    const i = n.buffer, r = n.byteOffset;
	    i[Ht$1] || (i[Ht$1] = {});
	    let o = i[Ht$1][r];
	    return o || (o = t.texture(e), i[Ht$1][r] = o), o;
	}

	var Gt$1 = Object.freeze({
	    __proto__: null,
	    getPrimitive: Pt$1,
	    getMaterialType: Et$1,
	    getMaterialFormat: Rt$1,
	    getTextureMagFilter: kt$1,
	    getTextureMinFilter: Lt$1,
	    getTextureWrap: Ft$1,
	    getUniqueREGLBuffer: Nt$1,
	    getUniqueTexture: Bt$1
	});

	class Vt$1 extends F$1 {
	    onLoad({data: t}) {
	        const e = this.config;
	        if (e) {
	            if (e.hdr) {
	                if (!(t = Tt$1(t.data, 0, e.maxRange))) throw new Error("Invalid hdr data" + (e.url ? ":" + e.url : ""));
	                this.rgbmRange = t.rgbmRange, e.data = t.pixels;
	            } else e.data = t;
	            e.width = e.width || t.width, e.height = e.height || t.height, this._updateREGL();
	        }
	    }
	    createREGLTexture(t) {
	        if (y$1(this.config.data) || y$1(this.config.mipmap)) {
	            const e = Bt$1(t, this.config);
	            return e._reshader_refCount || (e._reshader_refCount = 0), e._reshader_refCount++, 
	            e;
	        }
	        return t.texture(this.config);
	    }
	}

	class Ut$1 extends F$1 {
	    onLoad(t) {
	        const e = this.config;
	        if (!e) return;
	        const n = this._createFaces(t);
	        e.faces = n.map(t => t.data), this._updateREGL();
	    }
	    createREGLTexture(t) {
	        return t.cube(this.config);
	    }
	    _createFaces() {
	        return [];
	    }
	}

	class Wt$1 extends Q$1 {
	    constructor(t) {
	        super({
	            aPosition: new (x$1(t = t || 0))([ -1, -1, t, 1, -1, t, -1, 1, t, 1, 1, t ]),
	            aNormal: new Int8Array([ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ])
	        }, new Uint16Array([ 0, 1, 3, 3, 2, 0 ]));
	    }
	}

	const Zt$1 = {
	    vsm_shadow_vert: "\nuniform mat4 shadow_lightProjViewModelMatrix;\nvarying vec4 shadow_vLightSpacePos;\nvoid shadow_computeShadowPars(vec4 position) {\n    shadow_vLightSpacePos = shadow_lightProjViewModelMatrix * position;\n}",
	    vsm_shadow_frag: "\nuniform sampler2D shadow_shadowMap;\nuniform float shadow_opacity;\nuniform vec3 shadow_color;\n#if defined(USE_ESM)\n    uniform float esm_shadow_threshold;\n#endif\nvarying vec4 shadow_vLightSpacePos;\n#ifdef PACK_FLOAT\n    #include <common_pack_float>\n#endif\n#if defined(USE_ESM)\nfloat esm(vec3 projCoords, vec4 shadowTexel) {\n    float compare = projCoords.z;\n    float c = 120.0;\n    #ifdef PACK_FLOAT\n        float depth = common_decodeDepth(shadowTexel);\n        if (depth >= 1.0 - 1E-6 || compare <= depth) {\n            return 1.0;\n        }\n    #else\n        float depth = shadowTexel.r;\n    #endif\n    depth = exp(-c * min(compare - depth, 0.05));\n    return clamp(depth, esm_shadow_threshold, 1.0);\n}\n#endif\n#if defined(USE_VSM)\nfloat vsm_shadow_chebyshevUpperBound(vec3 projCoords, vec4 shadowTexel){\n    vec2 moments = shadowTexel.rg;\n    float distance = projCoords.z;\n    if (distance >= 1.0 || distance <= moments.x)\n        return 1.0 ;\n    float variance = moments.y - (moments.x * moments.x);\n    variance = max(variance, 0.00002);\n    float d = distance - moments.x;\n    float p_max = variance / (variance + d * d);\n    return p_max;\n}\n#endif\nfloat shadow_computeShadow_coeff(sampler2D shadowMap, vec3 projCoords) {\n    vec2 uv = projCoords.xy;\n    vec4 shadowTexel = texture2D(shadowMap, uv);\n    #if defined(USE_ESM)\n        float esm_coeff = esm(projCoords, shadowTexel);\n        float coeff = esm_coeff * esm_coeff;\n    #endif\n    #if defined(USE_VSM)\n        float vsm_coeff = vsm_shadow_chebyshevUpperBound(projCoords, shadowTexel);\n        float coeff = vsm_coeff;\n    #endif\n    return 1.0 - (1.0 - coeff) * shadow_opacity;\n}\nfloat shadow_computeShadow() {\n    vec3 projCoords = shadow_vLightSpacePos.xyz / shadow_vLightSpacePos.w;\n    projCoords = projCoords * 0.5 + 0.5;\n    if(projCoords.z >= 1.0 || projCoords.x < 0.0 || projCoords.x > 1.0 || projCoords.y < 0.0 || projCoords.y > 1.0) return 1.0;\n    return shadow_computeShadow_coeff(shadow_shadowMap, projCoords);\n}\nvec3 shadow_blend(vec3 color, float coeff) {\n    color = color * coeff + shadow_color * shadow_opacity * (1.0 - coeff);\n    return color;\n}",
	    fbo_picking_vert: "\n#ifdef ENABLE_PICKING\n#if HAS_PICKING_ID == 1\nattribute float aPickingId;\n#elif HAS_PICKING_ID == 2\nuniform float uPickingId;\n#endif\nvarying float vPickingId;\nvarying float vFbo_picking_viewZ;\nvarying float vFbo_picking_visible;\n#endif\nvarying float vFbo_picking_fragDepth;\nvoid fbo_picking_setData(float viewPosZ, bool visible) {\n    #ifdef ENABLE_PICKING\n    #if HAS_PICKING_ID == 1\n       vPickingId = aPickingId;\n    #elif HAS_PICKING_ID == 2\n        vPickingId = uPickingId;\n    #endif\n        vFbo_picking_viewZ = viewPosZ;\n    #endif\n    vFbo_picking_visible = visible ? 1.0 : 0.0;\n    vFbo_picking_fragDepth = viewPosZ + 1.0;\n}",
	    common_pack_float: "const float COMMON_FLOAT_MAX =  1.70141184e38;\nconst float COMMON_FLOAT_MIN = 1.17549435e-38;\nfloat common_packFloat(vec4 val){\n    vec4 scl = floor(255.0 * val + 0.5);\n    float sgn = (scl.a < 128.0) ? 1.0 : -1.0;\n    float exn = mod(scl.a * 2.0, 256.0) + floor(scl.b / 128.0) - 127.0;\n    float man = 1.0 +\n        (scl.r / 8388608.0) +\n        (scl.g / 32768.0) +\n        mod(scl.b, 128.0) / 128.0;\n    return sgn * man * pow(2.0, exn);\n}\nvec4 common_unpackFloat(highp float v) {\n    highp float av = abs(v);\n    if(av < COMMON_FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > COMMON_FLOAT_MAX) {\n        return vec4(127.0, 128.0, 0.0, 0.0) / 255.0;\n    } else if(v < -COMMON_FLOAT_MAX) {\n        return vec4(255.0, 128.0, 0.0, 0.0) / 255.0;\n    }\n    highp vec4 c = vec4(0,0,0,0);\n    highp float e = floor(log2(av));\n    highp float m = av * pow(2.0, -e) - 1.0;\n    c[1] = floor(128.0 * m);\n    m -= c[1] / 128.0;\n    c[2] = floor(32768.0 * m);\n    m -= c[2] / 32768.0;\n    c[3] = floor(8388608.0 * m);\n    highp float ebias = e + 127.0;\n    c[0] = floor(ebias / 2.0);\n    ebias -= c[0] * 2.0;\n    c[1] += floor(ebias) * 128.0;\n    c[0] += 128.0 * step(0.0, -v);\n    return c / 255.0;\n}\nvec4 common_encodeDepth(const in float depth) {\n    float alpha = 1.0;\n    vec4 pack = vec4(0.0);\n    pack.a = alpha;\n    const vec3 code = vec3(1.0, 255.0, 65025.0);\n    pack.rgb = vec3(code * depth);\n    pack.gb = fract(pack.gb);\n    pack.rg -= pack.gb * (1.0 / 256.0);\n    pack.b -= mod(pack.b, 4.0 / 255.0);\n    return pack;\n}\nfloat common_decodeDepth(const in vec4 pack) {\n    return pack.r + pack.g / 255.0;\n}",
	    invert_matrix: "mat4 invert_matrix(mat4 matrix) {\n    #if __VERSION__ == 300\n        return inverse(matrix);\n    #else\n        vec4 vector1 = matrix[0], vector2 = matrix[1], vector3 = matrix[2], vector4 = matrix[3];\n        float a00 = vector1.x, a01 = vector1.y, a02 = vector1.z, a03 = vector1.w;\n        float a10 = vector2.x, a11 = vector2.y, a12 = vector2.z, a13 = vector2.w;\n        float a20 = vector3.x, a21 = vector3.y, a22 = vector3.z, a23 = vector3.w;\n        float a30 = vector4.x, a31 = vector4.y, a32 = vector4.z, a33 = vector4.w;\n        float b00 = a00 * a11 - a01 * a10;\n        float b01 = a00 * a12 - a02 * a10;\n        float b02 = a00 * a13 - a03 * a10;\n        float b03 = a01 * a12 - a02 * a11;\n        float b04 = a01 * a13 - a03 * a11;\n        float b05 = a02 * a13 - a03 * a12;\n        float b06 = a20 * a31 - a21 * a30;\n        float b07 = a20 * a32 - a22 * a30;\n        float b08 = a20 * a33 - a23 * a30;\n        float b09 = a21 * a32 - a22 * a31;\n        float b10 = a21 * a33 - a23 * a31;\n        float b11 = a22 * a33 - a23 * a32;\n        float det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n        det = 1.0 / det;\n        mat4 m = mat4(\n            (a11 * b11 - a12 * b10 + a13 * b09) * det,\n            (a02 * b10 - a01 * b11 - a03 * b09) * det,\n            (a31 * b05 - a32 * b04 + a33 * b03) * det,\n            (a22 * b04 - a21 * b05 - a23 * b03) * det,\n            (a12 * b08 - a10 * b11 - a13 * b07) * det,\n            (a00 * b11 - a02 * b08 + a03 * b07) * det,\n            (a32 * b02 - a30 * b05 - a33 * b01) * det,\n            (a20 * b05 - a22 * b02 + a23 * b01) * det,\n            (a10 * b10 - a11 * b08 + a13 * b06) * det,\n            (a01 * b08 - a00 * b10 - a03 * b06) * det,\n            (a30 * b04 - a31 * b02 + a33 * b00) * det,\n            (a21 * b02 - a20 * b04 - a23 * b00) * det,\n            (a11 * b07 - a10 * b09 - a12 * b06) * det,\n            (a00 * b09 - a01 * b07 + a02 * b06) * det,\n            (a31 * b01 - a30 * b03 - a32 * b00) * det,\n            (a20 * b03 - a21 * b01 + a22 * b00) * det\n        );\n        return m;\n    #endif\n}\nmat4 transpose_matrix(mat4 matrix) {\n    #if __VERSION__ == 300\n        return transpose(matrix);\n    #else\n        vec4 vector1 = matrix[0], vector2 = matrix[1], vector3 = matrix[2], vector4 = matrix[3];\n        float a01 = vector1.y, a02 = vector1.z, a03 = vector1.w;\n        float a12 = vector2.z, a13 = vector2.w;\n        float a23 = vector3.w;\n        mat4 m = mat4(\n            vector1.x,\n            vector2.x,\n            vector3.x,\n            vector4.x,\n            a01,\n            vector2.y,\n            vector3.y,\n            vector4.y,\n            a02,\n            a12,\n            vector3.z,\n            vector4.z,\n            a03,\n            a13,\n            a23,\n            vector4.w\n        );\n        return m;\n    #endif\n}",
	    get_output: "#include <invert_matrix>\n#include <draco_decode_vert>\n#ifdef HAS_INSTANCE\n    #include <instance_vert>\n    #ifdef HAS_INSTANCE_COLOR\n        varying vec4 vInstanceColor;\n    #endif\n#endif\n#ifdef HAS_SKIN\n    uniform int skinAnimation;\n    #include <skin_vert>\n#endif\n#include <mask_vert>\n#ifdef HAS_MORPH\n    attribute vec3 POSITION0;\n    attribute vec3 POSITION1;\n    attribute vec3 POSITION2;\n    attribute vec3 POSITION3;\n    attribute vec3 POSITION4;\n    attribute vec3 POSITION5;\n    attribute vec3 POSITION6;\n    attribute vec3 POSITION7;\n    #ifdef HAS_MORPHNORMALS\n        attribute vec3 NORMAL0;\n        attribute vec3 NORMAL1;\n        attribute vec3 NORMAL2;\n        attribute vec3 NORMAL3;\n    #endif\n    uniform vec4 morphWeights1;\n    uniform vec4 morphWeights2;\n#endif\nmat4 getPositionMatrix() {\n    mat4 worldMatrix;\n    #ifdef HAS_INSTANCE\n        #ifdef HAS_INSTANCE_COLOR\n            vInstanceColor = instance_getInstanceColor();\n        #endif\n        mat4 attributeMatrix = instance_getAttributeMatrix();\n        #ifdef HAS_SKIN\n            if (skinAnimation == 1) {\n                worldMatrix = attributeMatrix * positionMatrix * skin_getSkinMatrix();\n            } else {\n                worldMatrix = attributeMatrix * positionMatrix;\n            }\n        #else\n            worldMatrix = attributeMatrix * positionMatrix;\n        #endif\n    #else\n        #ifdef HAS_SKIN\n            if (skinAnimation == 1) {\n                worldMatrix = skin_getSkinMatrix() * positionMatrix;\n            } else {\n                worldMatrix = positionMatrix;\n            }\n        #else\n            worldMatrix = positionMatrix;\n        #endif\n    #endif\n    return worldMatrix;\n}\nvec4 getPosition(vec3 aPosition) {\n    vec3 position = getPositionAsDraco(aPosition);\n    #ifdef HAS_MORPH\n        vec4 POSITION = vec4(position + morphWeights1[0] * POSITION0 + morphWeights1[1] * POSITION1 + morphWeights1[2] * POSITION2 + morphWeights1[3] * POSITION3\n        + morphWeights2[0] * POSITION4 + morphWeights2[1] * POSITION5 + morphWeights2[2] * POSITION6 + morphWeights2[3] * POSITION7\n        , 1.0);\n    #else\n        vec4 POSITION = vec4(position, 1.0);\n    #endif\n    return POSITION;\n}\nvec3 appendMorphNormal(vec3 NORMAL) {\n    #ifdef HAS_MORPHNORMALS\n        vec3 normal = NORMAL + morphWeights1[0] * NORMAL0 + morphWeights1[1] * NORMAL1 + morphWeights1[2] * NORMAL2 + morphWeights1[3] * NORMAL3;\n    #else\n        vec3 normal = NORMAL;\n    #endif\n    return normal;\n}",
	    instance_vert: "attribute vec4 instance_vectorA;\nattribute vec4 instance_vectorB;\nattribute vec4 instance_vectorC;\nmat4 instance_getAttributeMatrix() {\n    mat4 mat =  mat4(\n        instance_vectorA.x, instance_vectorB.x, instance_vectorC.x, 0.0,\n        instance_vectorA.y, instance_vectorB.y, instance_vectorC.y, 0.0,\n        instance_vectorA.z, instance_vectorB.z, instance_vectorC.z, 0.0,\n        instance_vectorA.w, instance_vectorB.w, instance_vectorC.w, 1.0\n    );\n    return mat;\n}\n#ifdef HAS_INSTANCE_COLOR\n    attribute vec4 instance_color;\n    vec4 instance_getInstanceColor() {\n        return instance_color;\n    }\n#endif",
	    skin_vert: "attribute vec4 WEIGHTS_0;\nattribute vec4 JOINTS_0;\nuniform sampler2D jointTexture;\nuniform vec2 jointTextureSize;\nuniform float numJoints;\n#define ROW0_U ((0.5 + 0.0) / 4.)\n#define ROW1_U ((0.5 + 1.0) / 4.)\n#define ROW2_U ((0.5 + 2.0) / 4.)\n#define ROW3_U ((0.5 + 3.0) / 4.)\nmat4 skin_getBoneMatrix(float jointNdx) {\n    float v = (jointNdx + 0.5) / numJoints;\n    return mat4(\n        texture2D(jointTexture, vec2(ROW0_U, v)),\n        texture2D(jointTexture, vec2(ROW1_U, v)),\n        texture2D(jointTexture, vec2(ROW2_U, v)),\n        texture2D(jointTexture, vec2(ROW3_U, v)));\n}\nmat4 skin_getSkinMatrix() {\n        mat4 skinMatrix = skin_getBoneMatrix(JOINTS_0[0]) * WEIGHTS_0[0] +\n                        skin_getBoneMatrix(JOINTS_0[1]) * WEIGHTS_0[1] +\n                        skin_getBoneMatrix(JOINTS_0[2]) * WEIGHTS_0[2] +\n                        skin_getBoneMatrix(JOINTS_0[3]) * WEIGHTS_0[3];\n        return skinMatrix;\n}",
	    heatmap_render_vert: "#ifdef HAS_HEATMAP\nvarying vec2 heatmap_vTexCoord;\nvoid heatmap_compute(mat4 matrix, vec3 position) {\n    vec4 pos = matrix * vec4(position.xy, 0., 1.);\n    heatmap_vTexCoord = (1. + pos.xy / pos.w) / 2.;\n}\n#endif",
	    heatmap_render_frag: "#ifdef HAS_HEATMAP\nuniform sampler2D heatmap_inputTexture;\nuniform sampler2D heatmap_colorRamp;\nuniform float heatmap_heatmapOpacity;\nvarying vec2 heatmap_vTexCoord;\nvec4 heatmap_getColor(vec4 color) {\n    float t = texture2D(heatmap_inputTexture, heatmap_vTexCoord).r;\n    vec4 heatmapColor = texture2D(heatmap_colorRamp, vec2(t, 0.5)) * heatmap_heatmapOpacity;\n    return color * (1.0 - heatmapColor.a) + heatmapColor * heatmapColor.a;\n}\n#endif",
	    line_extrusion_vert: "#ifdef IS_LINE_EXTRUSION\n    #define ALTITUDE_SCALE 32767.0;\n    #define EXTRUDE_SCALE 63.0;\n    attribute vec2 aExtrude;\n    #ifdef HAS_LINE_WIDTH\n        attribute float aLineWidth;\n    #else\n        uniform float lineWidth;\n    #endif\n    #ifdef HAS_LINE_HEIGHT\n        attribute float aLineHeight;\n    #else\n        uniform float lineHeight;\n    #endif\n    uniform float linePixelScale;\n    vec3 getLineExtrudePosition(vec3 position) {\n        #ifdef HAS_LINE_WIDTH\n            float lineWidth = aLineWidth / 2.0;\n        #endif\n        #ifdef HAS_LINE_HEIGHT\n            float lineHeight = aLineHeight / 10.0;\n        #endif\n        float halfwidth = lineWidth / 2.0;\n        float outset = halfwidth;\n        vec2 dist = outset * aExtrude / EXTRUDE_SCALE;\n        position.z *= lineHeight / ALTITUDE_SCALE;\n        return position + vec3(dist, 0.0) * linePixelScale;\n    }\n#endif",
	    gl2_vert: "#if __VERSION__ == 300\n    #define texture2D texture\n    #define varying out\n    #define attribute in\n#endif",
	    gl2_frag: "#if __VERSION__ == 300\n    #define varying in\n    #define gl_FragDepthEXT gl_FragDepth\n    #define texture2D texture\n    #define textureCube texture\n    #define texture2DProj textureProj\n    #define texture2DLodEXT textureLod\n    #define texture2DProjLodEXT textureProjLod\n    #define textureCubeLodEXT textureLod\n    #define texture2DGradEXT textureGrad\n    #define texture2DProjGradEXT textureProjGrad\n    #define textureCubeGradEXT textureGrad\n    #define texture2D texture\n    out vec4 glFragColor;\n#else\n    vec4 glFragColor;\n#endif",
	    hsv_frag: "\nconst mediump vec4 HSV_K0 = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\nconst mediump vec4 HSV_K1 = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nconst mediump float HSV_E = 1.0e-10;\nvec3 hsv_rgb2hsv(vec3 c) {\n    vec4 K = HSV_K0;\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = HSV_E;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv_hsv2rgb(vec3 c) {\n    vec4 K = HSV_K1;\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec4 hsv_apply(vec4 c, vec3 hsvOffset) {\n    vec3 hsv = hsv_rgb2hsv(c.rgb);\n    hsv += hsv * hsvOffset;\n    hsv = clamp(hsv, 0.0, 1.0);\n    return vec4(hsv_hsv2rgb(hsv), c.a);\n}\nvec3 hsv_apply(vec3 c, vec3 hsvOffset) {\n    vec3 hsv = hsv_rgb2hsv(c.rgb);\n    hsv += hsv * hsvOffset;\n    hsv = clamp(hsv, 0.0, 1.0);\n    return hsv_hsv2rgb(hsv);\n}\nmat4 contrastMatrix(float contrast)\n{\n    float t = (1.0 - contrast) / 2.0;\n    return mat4(\n        contrast, 0., 0., 0.,\n        0., contrast, 0., 0.,\n        0., 0., contrast, 0.,\n        t, t, t, 1\n    );\n}",
	    snow_frag: "#ifdef HAS_SNOW\n    float lerp(float a, float b, float w) {\n        return a + w * (b - a);\n    }\n    vec3 snow(vec4 sceneColor, vec3 normalColor, float height) {\n        float snowIntense = normalColor.b;\n        vec3 fixedC = vec3(1.0, 1.0, 1.0);\n        if (height < 1.0) {\n            float r = lerp(0.5, fixedC.x, snowIntense);\n            float g = lerp(0.5, fixedC.y, snowIntense);\n            float b = lerp(0.5, fixedC.z, snowIntense);\n            return vec3(r, g, b);\n        } else {\n            float r = lerp(sceneColor.r, fixedC.x, snowIntense);\n            float g = lerp(sceneColor.g, fixedC.y, snowIntense);\n            float b = lerp(sceneColor.b, fixedC.z, snowIntense);\n            return vec3(r, g, b);\n        }\n    }\n#endif",
	    draco_decode_vert: "#if defined(HAS_TANGENT)\n    attribute vec4 aTangent;\n#elif defined(HAS_NORMAL)\n    #ifdef HAS_DECODE_NORMAL\n        attribute vec2 aNormal;\n        uniform float gltf_u_dec_normal_rangeConstant;\n    #else\n        attribute vec3 aNormal;\n    #endif\n#endif\n#ifdef HAS_DECODE_POSITION\n    uniform float gltf_u_dec_position_normConstant;\n    uniform vec3 minValues_pos;\n    vec3 decodeDracoPosition(vec3 aPosition) {\n        return minValues_pos + aPosition * gltf_u_dec_position_normConstant;\n    }\n#endif\n#ifdef HAS_DECODE_TEXCOORD\n    uniform vec2 minValues_tex;\n    uniform float gltf_u_dec_texcoord_0_normConstant;\n    vec2 decodeDracoTexcoord(vec2 aTexCoord) {\n        return minValues_tex + aTexCoord * gltf_u_dec_texcoord_0_normConstant;\n    }\n#endif\n#ifdef HAS_DECODE_NORMAL\n    float czm_signNotZero(float value) {\n        return value >= 0.0 ? 1.0 : -1.0;\n    }\n    vec2 czm_signNotZero(vec2 value) {\n        return vec2(czm_signNotZero(value.x), czm_signNotZero(value.y));\n    }\n    vec3 decodeDracoNormal(vec2 encoded, float range)\n    {\n        if (encoded.x == 0.0 && encoded.y == 0.0) {\n            return vec3(0.0, 0.0, 0.0);\n        }\n        encoded = encoded / range * 2.0 - 1.0;\n        vec3 v = vec3(encoded.x, encoded.y, 1.0 - abs(encoded.x) - abs(encoded.y));\n        if (v.z < 0.0) {\n            v.xy = (1.0 - abs(v.yx)) * czm_signNotZero(v.xy);\n        }\n        return normalize(v);\n    }\n    vec3 getNormal(vec2 aNormal) {\n        return decodeDracoNormal(aNormal, gltf_u_dec_normal_rangeConstant).zxy;\n    }\n#endif\nvec3 getPositionAsDraco(vec3 aPosition) {\n    #ifdef HAS_DECODE_POSITION\n        return decodeDracoPosition(aPosition);\n    #else\n        return aPosition;\n    #endif\n}\nvec2 getTexcoord(vec2 aTexCoord) {\n    #ifdef HAS_DECODE_TEXCOORD\n        return decodeDracoTexcoord(aTexCoord);\n    #else\n        return aTexCoord;\n    #endif\n}",
	    highlight_vert: "#if defined(HAS_HIGHLIGHT_COLOR)\n    attribute vec4 aHighlightColor;\n    varying vec4 vHighlightColor;\n#endif\n#if defined(HAS_HIGHLIGHT_OPACITY)\n    attribute float aHighlightOpacity;\n    varying float vHighlightOpacity;\n#endif\nvoid highlight_setVarying() {\n    #if defined(HAS_HIGHLIGHT_COLOR)\n        vHighlightColor = aHighlightColor / 255.0;\n    #endif\n    #if defined(HAS_HIGHLIGHT_OPACITY)\n        vHighlightOpacity = aHighlightOpacity / 255.0;\n    #endif\n}",
	    highlight_frag: "#if defined(HAS_HIGHLIGHT_COLOR)\n\tvarying vec4 vHighlightColor;\n#endif\n#if defined(HAS_HIGHLIGHT_OPACITY)\n    varying float vHighlightOpacity;\n#endif\nvec4 highlight_blendColor(vec4 color) {\n\tvec4 outColor;\n\t#if defined(HAS_HIGHLIGHT_COLOR)\n\t\tcolor.rgb = color.rgb * (1.0 - vHighlightColor.a) + vHighlightColor.rgb * vHighlightColor.a;\n\t\t#ifndef HAS_HIGHLIGHT_COLOR_POINT\n        \tcolor.a = color.a * (1.0 - vHighlightColor.a) + vHighlightColor.a;\n        #endif\n        outColor = color;\n\t#else\n\t\toutColor = color;\n\t#endif\n\t#if defined(HAS_HIGHLIGHT_OPACITY)\n\t\toutColor *= vHighlightOpacity;\n\t#endif\n\treturn outColor;\n}",
	    mask_vert: "#ifdef HAS_MASK_EXTENT\n    uniform vec4 mask_extent;\n    uniform sampler2D mask_colorExtent;\n    uniform sampler2D mask_modeExtent;\n    uniform float mask_maskMode;\n    uniform float mask_hasFlatOut;\n    uniform mat4 viewMatrix;\n    uniform float mask_heightRatio;\n    uniform float mask_heightOffset;\n    varying vec4 vWorldPosition;\n    varying vec2 vUVInExtent;\n    varying float vHeightRatio;\n    varying float vHeightOffset;\n    float random (vec2 st) {\n        return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123) * 0.1;\n    }\n    bool isInExtent(vec4 color) {\n        if (color.r > 0.0 || color.g > 0.0 || color.b > 0.0 || color.a > 0.0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    vec4 getMaskPosition(vec4 position, mat4 modelMatrix) {\n        vWorldPosition = modelMatrix * position;\n        float w = mask_extent.z - mask_extent.x;\n        float h = mask_extent.y - mask_extent.w;\n        vec2 uvInExtent = vec2((vWorldPosition.x - mask_extent.x) / w, 1.0 - (vWorldPosition.y - mask_extent.w) / h);\n        vec4 extentColor = texture2D(mask_colorExtent, uvInExtent);\n        vec3 maskOptionColor = texture2D(mask_modeExtent, uvInExtent).rgb;\n        float maskMode = maskOptionColor.r;\n        float flatHeight = maskOptionColor.g / mask_heightRatio + mask_heightOffset;\n        float height = flatHeight + random(uvInExtent);\n        vec4 wPosition = vec4(vWorldPosition.x, vWorldPosition.y, height, vWorldPosition.w);\n        vUVInExtent = uvInExtent;\n        vHeightRatio = mask_heightRatio;\n        vHeightOffset = mask_heightOffset;\n        if (maskMode <= 0.4 && maskMode > 0.3) {\n            return viewMatrix * modelMatrix * position;\n        } else if (mask_hasFlatOut == 1.0) {\n            return viewMatrix * wPosition;\n        }\n        if (isInExtent(extentColor) == true && maskMode <= 0.3 && maskMode > 0.2) {\n            return viewMatrix * wPosition;\n        } else {\n            return viewMatrix * modelMatrix * position;\n        }\n    }\n#endif",
	    mask_frag: "#ifdef HAS_MASK_EXTENT\n    uniform sampler2D mask_colorExtent;\n    uniform sampler2D mask_modeExtent;\n    uniform float mask_hasClipOut;\n    varying float vHeightRatio;\n    varying float vHeightOffset;\n    varying vec2 vUVInExtent;\n    varying vec4 vWorldPosition;\n    bool isInExtent(vec4 color) {\n        if (color.r > 0.0 || color.g > 0.0 || color.b > 0.0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    vec4 setMask(vec4 glFragColor) {\n        vec4 extentColor = texture2D(mask_colorExtent, vUVInExtent);\n        vec4 modeColor = texture2D(mask_modeExtent, vUVInExtent);\n        float maskMode = modeColor.r;\n        float minHeight = modeColor.b / vHeightRatio + vHeightOffset;\n        float maxHeight = modeColor.a / vHeightRatio + vHeightOffset;\n        if (maskMode > 0.1 && maskMode <= 0.2) {\n            return glFragColor;\n        } else if (mask_hasClipOut == 1.0) {\n            discard;\n        }\n        if (isInExtent(extentColor) == true && maskMode > 0.0 && maskMode <= 0.1) {\n            discard;\n        } else if (isInExtent(extentColor) == true && maskMode <= 0.5 && maskMode > 0.4) {\n            if (minHeight == 0.0 && maxHeight == 0.0) {\n                glFragColor = vec4(mix(extentColor.rgb, glFragColor.rgb, 1.0 - extentColor.a), glFragColor.a);\n            } else if (vWorldPosition.z >= minHeight && vWorldPosition.z <= maxHeight) {\n                glFragColor = vec4(mix(extentColor.rgb, glFragColor.rgb, 1.0 - extentColor.a), glFragColor.a);\n            }\n        }\n        return glFragColor;\n    }\n#endif",
	    computeTexcoord_frag: "#ifdef HAS_KHR_TEXTURE_TRANSFORM\n    uniform vec2 khr_offset;\n    uniform float khr_rotation;\n    uniform vec2 khr_scale;\n    vec2 khr_tex_transformTexCoord(vec2 texCoords, vec2 offset, float rotation, vec2 scale) {\n        rotation = -rotation;\n        mat3 transform = mat3(\n        cos(rotation) * scale.x, sin(rotation) * scale.x, 0.0, -sin(rotation) * scale.y, cos(rotation) * scale.y, 0.0, offset.x, offset.y, 1.0);\n        vec2 transformedTexCoords = (transform * vec3(fract(texCoords), 1.0)).xy;\n        return transformedTexCoords;\n    }\n#endif\nvarying highp vec2 vTexCoord;\n#ifdef HAS_I3S_UVREGION\n    varying vec4 vUvRegion;\n#endif\nvec2 computeTexCoord() {\n    #ifdef HAS_I3S_UVREGION\n        vec2 atlasScale = vUvRegion.zw - vUvRegion.xy;\n        vec2 uvAtlas = fract(vTexCoord) * atlasScale + vUvRegion.xy;\n        return uvAtlas;\n    #elif defined(HAS_KHR_TEXTURE_TRANSFORM)\n        return khr_tex_transformTexCoord(vTexCoord, khr_offset, khr_rotation, khr_scale);\n    #else\n        return vTexCoord;;\n    #endif\n}"
	};

	var Xt$1 = {
	    register(t, e) {
	        if (Zt$1[t]) throw new Error(`Key of ${t} is already registered in ShaderLib.`);
	        Zt$1[t] = e;
	    },
	    compile: t => qt$1(t)
	};

	const Jt$1 = /^[ \t]*#include +<([\w\d.]+)>/gm;

	function qt$1(t) {
	    return t.replace(Jt$1, Yt$1);
	}

	function Yt$1(t, e) {
	    const n = Zt$1[e];
	    if (!n) throw new Error("Can not resolve #include <" + e + ">");
	    return qt$1(n);
	}

	const Kt$1 = "function", Qt$1 = "array";

	let $t$1 = 0;

	const te$1 = {};

	class ee$1 {
	    constructor({vert: t, frag: e, uniforms: n, defines: i, extraCommandProps: r}) {
	        this.vert = t, this.frag = e;
	        const o = $t$1++;
	        Object.defineProperty(this, "uid", {
	            enumerable: !0,
	            configurable: !1,
	            get: () => o
	        }), this.shaderDefines = i && g({}, i) || {}, n = this.uniforms = (n || []).slice(), 
	        this.contextDesc = {};
	        for (let t = 0, e = n.length; t < e; t++) {
	            const e = n[t];
	            if (c(e)) if (e.indexOf("[") > 0) {
	                const {name: t, len: n} = ne$1(e);
	                this.contextDesc[t] = {
	                    name: t,
	                    type: "array",
	                    length: n
	                };
	            } else this.contextDesc[e] = null; else if (e.name.indexOf("[") > 0) {
	                const {name: t, len: n} = ne$1(e.name);
	                this.contextDesc[t] = {
	                    name: t,
	                    type: "array",
	                    length: n,
	                    fn: e.fn
	                };
	            } else this.contextDesc[e.name] = e;
	        }
	        this.extraCommandProps = r && g({}, r) || {}, this.commands = {}, this._compileSource();
	    }
	    set shaderDefines(t) {
	        this._shaderDefines = t, this.dkey = Object.keys(this._shaderDefines).join();
	    }
	    get shaderDefines() {
	        return this._shaderDefines || {};
	    }
	    setDefines(t) {
	        this.shaderDefines = t;
	    }
	    setFramebuffer(t) {
	        return this.context.framebuffer = t, this;
	    }
	    appendDescUniforms(t, e) {
	        const n = e, i = this.contextDesc;
	        for (const r in i) if (i[r]) if ("array" === i[r].type) {
	            const o = r, s = i[r].length;
	            let a = e[r];
	            if (i[r].fn && (a = i[r].fn(null, e)), !a) continue;
	            if (a.length !== s) throw new Error(`${o} uniform's length is not ${s}`);
	            n[o] = n[o] || {};
	            for (let e = 0; e < s; e++) n[o]["" + e] = a[e].getREGLTexture ? a[e].getREGLTexture(t) : a[e];
	        } else "function" === i[r].type && (Object.getOwnPropertyDescriptor(n, r) || Object.defineProperty(n, r, {
	            configurable: !1,
	            enumerable: !0,
	            get: function() {
	                return i[r].fn(null, e);
	            }
	        }));
	        return n;
	    }
	    setUniforms(t) {
	        if (t.modelMatrix || t.positionMatrix) throw new Error("modelMatrix or positionMatrix is reserved uniform name for Mesh, please change to another name");
	        return this.contextKeys = t ? Object.keys(t).join() : null, this.context = t, this;
	    }
	    getVersion(t, e) {
	        if ("#version" === e.substring(0, 8)) return "";
	        return 0 === t.limits.version.indexOf("WebGL 2.0") && 300 === this.version ? "#version 300 es\n" : "#version 100\n";
	    }
	    getActiveVars(t, e, n, i) {
	        const r = i;
	        if (te$1[r]) return te$1[r];
	        const o = t._gl, s = o.createProgram(), a = o.createShader(35633);
	        o.shaderSource(a, e), o.compileShader(a);
	        const h = o.createShader(35632);
	        o.shaderSource(h, n), o.compileShader(h), o.attachShader(s, h), o.attachShader(s, a), 
	        o.linkProgram(s);
	        const l = o.getProgramParameter(s, 35721), c = [];
	        for (let t = 0; t < l; ++t) {
	            const e = o.getActiveAttrib(s, t);
	            e && c.push({
	                name: e.name,
	                type: e.type
	            });
	        }
	        const u = o.getProgramParameter(s, 35718), f = [];
	        for (let t = 0; t < u; ++t) {
	            const e = o.getActiveUniform(s, t);
	            let n = e.name;
	            e.name.indexOf("[") > 0 && (n = n.replace("[0]", "")), f.push(n);
	        }
	        return o.deleteProgram(s), o.deleteShader(a), o.deleteShader(h), te$1[r] = {
	            activeUniforms: f,
	            activeAttributes: c
	        }, te$1[r];
	    }
	    createREGLCommand(t, e, n, i, r) {
	        const o = w$1(t) && !r, s = g({}, this.shaderDefines || {}, e || {}), a = this._insertDefines(this.vert, s), h = this.getVersion(t, a) + a, l = this._insertDefines(this.frag, s), c = this.getVersion(t, l) + l, u = O$1(h) + "_" + O$1(c), {activeAttributes: f, activeUniforms: d} = this.getActiveVars(t, h, c, u), m = {};
	        f.forEach((e, n) => {
	            const i = e.name;
	            m[i] = o ? n : t.prop(i);
	        });
	        const p = {};
	        d.forEach(e => {
	            p[e] = t.prop(e);
	        });
	        const v = this.contextDesc;
	        for (const e in v) if (v[e] && v[e].type === Kt$1) p[e] = v[e].fn; else if (v[e] && v[e].type === Qt$1) {
	            const n = v[e].name, i = v[e].length;
	            for (let e = 0; e < i; e++) {
	                const i = `${n}[${e}]`;
	                p[i] = t.prop(i);
	            }
	        } else p[e] = t.prop(e);
	        const y = {
	            vert: h,
	            frag: c,
	            uniforms: p,
	            attributes: m
	        };
	        o && (y.vao = t.prop("vao")), o && !i || !n || _$2(n) || (y.elements = t.prop("elements")), 
	        y.count = t.prop("count"), y.offset = t.prop("offset"), y.primitive = t.prop("primitive"), 
	        y.framebuffer = t.prop("framebuffer"), i && (y.instances = t.prop("instances")), 
	        g(y, this.extraCommandProps);
	        const x = t(y);
	        return f.key = f.map(t => t.name).join(), x.activeAttributes = f, x;
	    }
	    dispose() {
	        for (const t in this.commands) {
	            const e = this.commands[t];
	            e && (e.destroy && !e[L$1] && (e[L$1] = !0, e.destroy()));
	        }
	        this.commands = {}, delete this.vert, delete this.frag;
	    }
	    _insertDefines(t, e) {
	        const n = [];
	        for (const t in e) C$1(e, t) && !d(e[t]) && n.push(`#define ${t} ${e[t]}\n`);
	        return n.join("") + t;
	    }
	    _compileSource() {
	        this.vert = Xt$1.compile(this.vert), this.frag = Xt$1.compile(this.frag);
	    }
	}

	function ne$1(t) {
	    const e = t.indexOf("["), n = t.indexOf("]");
	    return {
	        name: t.substring(0, e),
	        len: +t.substring(e + 1, n)
	    };
	}

	class ie$1 extends ee$1 {
	    draw(t, e) {
	        if (!e || !e.length) return 0;
	        const n = [];
	        let i, r = 0;
	        for (let o = 0, s = e.length; o < s; o++) {
	            if (!e[o].isValid()) {
	                o === s - 1 && i && n.length && i(n);
	                continue;
	            }
	            if (!e[o].geometry.getDrawCount() || !this._runFilter(e[o])) {
	                o === s - 1 && i && n.length && i(n);
	                continue;
	            }
	            const a = this.getMeshCommand(t, e[o]);
	            n.length && i !== a && (i(n), n.length = 0);
	            const h = e[o].getREGLProps(t, a.activeAttributes);
	            this._ensureContextDefines(h), h.shaderContext = this.context, this.appendDescUniforms(t, h), 
	            n.push(h), r++, o < s - 1 ? i = a : o === s - 1 && a(n);
	        }
	        return r;
	    }
	    _ensureContextDefines(t) {
	        if (this.context && (t.contextKeys || (t.contextKeys = {}), t.contextKeys[this.uid] !== this.contextKeys)) {
	            for (const e in this.context) Object.getOwnPropertyDescriptor(t, e) || Object.defineProperty(t, e, {
	                configurable: !1,
	                enumerable: !0,
	                get: function() {
	                    return this.shaderContext && this.shaderContext[e];
	                }
	            });
	            t.contextKeys[this.uid] = this.contextKeys;
	        }
	    }
	    _runFilter(t) {
	        const e = this.filter;
	        if (!e) return !0;
	        if (Array.isArray(e)) {
	            for (let n = 0; n < e.length; n++) if (!e[n](t)) return !1;
	            return !0;
	        }
	        return e(t);
	    }
	    getMeshCommand(t, e) {
	        this._cmdKeys || (this._cmdKeys = {});
	        const n = this.dkey || "default";
	        let i = this._cmdKeys[n];
	        i || (i = this._cmdKeys[n] = {});
	        const r = e.getCommandKey(t);
	        i[r] || (i[r] = n + "_" + e.getCommandKey(t));
	        const o = i[r];
	        let s = this.commands[o];
	        if (!s) {
	            const n = e.getDefines(), i = e.getMaterial();
	            if (i) {
	                i.doubleSided && this.extraCommandProps && this.extraCommandProps.cull && (this.extraCommandProps.cull.enable = !1);
	            }
	            s = this.commands[o] = this.createREGLCommand(t, n, e.getElements(), e instanceof dt$1, e.disableVAO);
	        }
	        return s;
	    }
	}

	class re$1 extends ie$1 {
	    constructor(t = {}) {
	        let n = t.extraCommandProps || {};
	        const i = [];
	        n = g({}, n, {
	            blend: {
	                enable: !0,
	                func: {
	                    src: "src alpha",
	                    dst: "one minus src alpha"
	                },
	                equation: "add"
	            },
	            sample: {
	                alpha: !0
	            }
	        }), super({
	            vert: "#include <gl2_vert>\nattribute vec3 aPosition;\nattribute vec3 aBarycentric;\nvarying vec3 vBarycentric;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projMatrix;\nuniform mat4 positionMatrix;\nvarying vec3 vPosition;\n#include <get_output>\nvoid main() {\n  mat4 c = getPositionMatrix();\n  vec4 d = getPosition(aPosition);\n#ifdef HAS_MASK_EXTENT\ngl_Position = projMatrix * getMaskPosition(c * d, modelMatrix);\n#else\ngl_Position = projMatrix * modelViewMatrix * c * d;\n#endif\nvBarycentric = aBarycentric;\n  vPosition = aPosition;\n}",
	            frag: "#if __VERSION__ == 100\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n#endif\nprecision mediump float;\n#include <gl2_frag>\nvarying vec3 vBarycentric;\nuniform float time;\nuniform float thickness;\nuniform float secondThickness;\nuniform float dashRepeats;\nuniform float dashLength;\nuniform bool dashOverlap;\nuniform bool dashEnabled;\nuniform bool dashAnimate;\nuniform bool seeThrough;\nuniform bool insideAltColor;\nuniform bool dualStroke;\nuniform bool squeeze;\nuniform float squeezeMin;\nuniform float squeezeMax;\nuniform vec4 stroke;\nuniform vec4 fill;\nuniform float opacity;\nuniform bool noiseEnable;\nvarying vec3 vPosition;\n#ifdef HAS_INSTANCE\nvarying vec4 vInstanceColor;\n#endif\n#include <mask_frag>\n#define F4 0.309016994374947451\n#define halfDist 0.5\nvec4 c(vec4 x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\nfloat c(float x) {\n  return x - floor(x * (1. / 289.)) * 289.;\n}\nvec4 d(vec4 x) {\n  return c((x * 34. + 1.) * x);\n}\nfloat d(float x) {\n  return c((x * 34. + 1.) * x);\n}\nvec4 e(vec4 r) {\n  return 1.79284291400159 - .85373472095314 * r;\n}\nfloat e(float r) {\n  return 1.79284291400159 - .85373472095314 * r;\n}\nvec4 f(float h, vec4 i) {\n  const vec4 k = vec4(1., 1., 1., -1.);\n  vec4 p, s;\n  p.xyz = floor(fract(vec3(h) * i.xyz) * 7.) * i.z - 1.;\n  p.w = 1.5 - dot(abs(p.xyz), k.xyz);\n  s = vec4(lessThan(p, vec4(.0)));\n  p.xyz = p.xyz + (s.xyz * 2. - 1.) * s.www;\n  return p;\n}\nfloat l(vec4 m) {\n  const vec4 n = vec4(.138196601125011, .276393202250021, .414589803375032, -.447213595499958);\n  vec4 o = floor(m + dot(m, vec4(F4)));\n  vec4 u = m - o + dot(o, n.xxxx);\n  vec4 A;\n  vec3 B = step(u.yzw, u.xxx);\n  vec3 D = step(u.zww, u.yyz);\n  A.x = B.x + B.y + B.z;\n  A.yzw = 1. - B;\n  A.y += D.x + D.y;\n  A.zw += 1. - D.xy;\n  A.z += D.z;\n  A.w += 1. - D.z;\n  vec4 E = clamp(A, .0, 1.);\n  vec4 F = clamp(A - 1., .0, 1.);\n  vec4 G = clamp(A - 2., .0, 1.);\n  vec4 H = u - G + n.xxxx;\n  vec4 I = u - F + n.yyyy;\n  vec4 J = u - E + n.zzzz;\n  vec4 K = u + n.wwww;\n  o = c(o);\n  float L = d(d(d(d(o.w) + o.z) + o.y) + o.x);\n  vec4 M = d(d(d(d(o.w + vec4(G.w, F.w, E.w, 1.)) + o.z + vec4(G.z, F.z, E.z, 1.)) + o.y + vec4(G.y, F.y, E.y, 1.)) + o.x + vec4(G.x, F.x, E.x, 1.));\n  vec4 i = vec4(1. / 294., 1. / 49., 1. / 7., .0);\n  vec4 N = f(L, i);\n  vec4 O = f(M.x, i);\n  vec4 P = f(M.y, i);\n  vec4 Q = f(M.z, i);\n  vec4 R = f(M.w, i);\n  vec4 S = e(vec4(dot(N, N), dot(O, O), dot(P, P), dot(Q, Q)));\n  N *= S.x;\n  O *= S.y;\n  P *= S.z;\n  Q *= S.w;\n  R *= e(dot(R, R));\n  vec3 T = max(.6 - vec3(dot(u, u), dot(H, H), dot(I, I)), .0);\n  vec2 U = max(.6 - vec2(dot(J, J), dot(K, K)), .0);\n  T = T * T;\n  U = U * U;\n  return 49. * (dot(T * T, vec3(dot(N, u), dot(O, H), dot(P, I))) + dot(U * U, vec2(dot(Q, J), dot(R, K))));\n}\nconst float V = 3.14159265359;\nfloat W(float X, float Y) {\n  float Z = fwidth(Y) * halfDist;\n  return smoothstep(X - Z, X + Z, Y);\n}\nvec4 ba(vec3 bb) {\n  float bc = min(min(bb.x, bb.y), bb.z);\n  float bd = .0;\n  if(noiseEnable)\n    bd += l(vec4(vPosition.xyz * 80.0, time * halfDist)) * .12;\n  bc += bd;\n  float be = max(bb.x, bb.y);\n  if(bb.y < bb.x && bb.y < bb.z) {\n    be = 1. - be;\n  }\n  float bf = thickness;\n  if(squeeze) {\n    bf *= mix(squeezeMin, squeezeMax, (1. - sin(be * V)));\n  }\n  if(dashEnabled) {\n    float bg = 1. / dashRepeats * dashLength / 2.;\n    if(!dashOverlap) {\n      bg += 1. / dashRepeats / 2.;\n    }\n    if(dashAnimate) {\n      bg += time * .22;\n    }\n    float bh = fract((be + bg) * dashRepeats);\n    bf *= 1. - W(dashLength, bh);\n  }\n  float bi = 1. - W(bf, bc);\n#ifdef HAS_INSTANCE\nvec4 bj = vInstanceColor;\n#else\nvec4 bj = stroke;\n#endif\nvec4 bk = vec4(.0);\n  if(seeThrough) {\n    bk = vec4(bj.xyz, bi);\n    if(insideAltColor && !gl_FrontFacing) {\n      bk.rgb = fill.xyz;\n    }\n  } else {\n    vec3 bl = mix(fill.xyz, bj.xyz, bi);\n    bk.a = fill.a;\n    if(dualStroke) {\n      float bm = 1. - W(secondThickness, bc);\n      vec3 bn = mix(fill.xyz, stroke.xyz, abs(bm - bi));\n      bk.rgb = bn;\n    } else {\n      bk.rgb = bl;\n    }\n  }\n  return bk;\n}\nvoid main() {\n  glFragColor = ba(vBarycentric);\n  glFragColor *= halfDist + opacity;\n#ifdef HAS_MASK_EXTENT\nglFragColor = setMask(glFragColor);\n#endif\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",
	            uniforms: [ {
	                name: "modelViewMatrix",
	                type: "function",
	                fn: (t, n) => multiply$5(i, n.viewMatrix, n.modelMatrix)
	            } ],
	            extraCommandProps: n
	        }), this.version = 300;
	    }
	}

	var oe$1 = "precision mediump float;\n#include <gl2_frag>\nuniform vec4 baseColorFactor;\nuniform float materialShininess;\nuniform float environmentExposure;\nuniform float specularStrength;\nuniform vec3 light0_viewDirection;\nuniform vec3 ambientColor;\nuniform vec4 light0_diffuse;\nuniform vec3 lightSpecular;\nuniform vec3 cameraPosition;\n#ifdef HAS_TOON\nuniform float toons;\nuniform float specularToons;\n#endif\n#ifdef HAS_TANGENT\nvarying vec4 vTangent;\n#endif\n#ifdef HAS_MAP\n#include <computeTexcoord_frag>\n#endif\nvarying vec3 vNormal;\nvarying vec3 vFragPos;\n#ifdef HAS_INSTANCE_COLOR\nvarying vec4 vInstanceColor;\n#endif\n#ifdef HAS_BASECOLOR_MAP\nuniform sampler2D baseColorTexture;\n#endif\n#ifdef HAS_EXTRUSION_OPACITY\nuniform vec2 extrusionOpacityRange;\nvarying float vExtrusionOpacity;\n#endif\n#if defined(HAS_COLOR) || defined(HAS_COLOR0)\nvarying vec4 vColor;\n#elif defined(IS_LINE_EXTRUSION)\nuniform vec4 lineColor;\n#else\nuniform vec4 polygonFill;\n#endif\n#ifdef IS_LINE_EXTRUSION\nuniform float lineOpacity;\n#else\nuniform float polygonOpacity;\n#endif\n#ifdef HAS_OCCLUSION_MAP\nuniform sampler2D occlusionTexture;\n#endif\n#ifdef HAS_NORMAL_MAP\nuniform sampler2D normalTexture;\n#endif\n#ifdef HAS_EMISSIVE_MAP\nuniform sampler2D emissiveTexture;\n#endif\n#ifdef SHADING_MODEL_SPECULAR_GLOSSINESS\nuniform vec4 diffuseFactor;\nuniform vec3 specularFactor;\n#ifdef HAS_DIFFUSE_MAP\nuniform sampler2D diffuseTexture;\n#endif\n#ifdef HAS_SPECULARGLOSSINESS_MAP\nuniform sampler2D specularGlossinessTexture;\n#endif\n#endif\n#include <heatmap_render_frag>\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n#include <vsm_shadow_frag>\n#endif\n#include <highlight_frag>\n#include <mask_frag>\nvec3 c() {\n  \n#if defined(HAS_NORMAL_MAP)\nvec3 d = normalize(vNormal);\n  vec3 e = texture2D(normalTexture, computeTexCoord()).xyz * 2. - 1.;\n#if defined(HAS_TANGENT)\nvec3 t = normalize(vTangent.xyz);\n  vec3 b = normalize(cross(d, t) * sign(vTangent.w));\n  mat3 f = mat3(t, b, d);\n  return normalize(f * e);\n#else\nreturn normalize(e);\n#endif\n#else\nreturn normalize(vNormal);\n#endif\n}\nvec4 h(const in vec4 i) {\n  return vec4(i.r < .0031308 ? i.r * 12.92 : 1.055 * pow(i.r, 1. / 2.4) - .055, i.g < .0031308 ? i.g * 12.92 : 1.055 * pow(i.g, 1. / 2.4) - .055, i.b < .0031308 ? i.b * 12.92 : 1.055 * pow(i.b, 1. / 2.4) - .055, i.a);\n}\nvec4 j() {\n  \n#if defined(HAS_BASECOLOR_MAP)\nreturn texture2D(baseColorTexture, computeTexCoord());\n#elif defined(HAS_DIFFUSE_MAP)\nreturn texture2D(diffuseTexture, computeTexCoord());\n#elif defined(SHADING_MODEL_SPECULAR_GLOSSINESS)\nreturn diffuseFactor;\n#else\nreturn baseColorFactor;\n#endif\n}\nvec3 k() {\n  \n#if defined(HAS_SPECULARGLOSSINESS_MAP)\nreturn texture2D(specularGlossinessTexture, computeTexCoord()).rgb;\n#elif defined(SHADING_MODEL_SPECULAR_GLOSSINESS)\nreturn specularFactor;\n#else\nreturn vec3(1.);\n#endif\n}\nvoid main() {\n  vec4 l = j();\n  vec3 m = environmentExposure * ambientColor * l.rgb;\n#ifdef HAS_INSTANCE_COLOR\nm *= vInstanceColor.rgb;\n#endif\nvec3 o = c();\n  vec3 u = normalize(-light0_viewDirection);\n  float v = max(dot(o, u), .0);\n#ifdef HAS_TOON\nfloat A = floor(v * toons);\n  v = A / toons;\n#endif\nvec3 B = light0_diffuse.rgb * v * l.rgb;\n#if defined(HAS_COLOR) || defined(HAS_COLOR0)\nvec3 i = vColor.rgb;\n#elif defined(IS_LINE_EXTRUSION)\nvec3 i = lineColor.rgb;\n#else\nvec3 i = polygonFill.rgb;\n#endif\n#ifdef HAS_INSTANCE_COLOR\ni *= vInstanceColor.rgb;\n#endif\nm *= i.rgb;\n  B *= i.rgb;\n  vec3 C = normalize(cameraPosition - vFragPos);\n  vec3 D = normalize(u + C);\n  float E = pow(max(dot(o, D), .0), materialShininess);\n#ifdef HAS_TOON\nfloat F = floor(E * specularToons);\n  E = F / specularToons;\n#endif\nvec3 G = specularStrength * lightSpecular * E * k();\n#ifdef HAS_OCCLUSION_MAP\nfloat H = texture2D(occlusionTexture, computeTexCoord()).r;\n  m *= H;\n#endif\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\nfloat I = shadow_computeShadow();\n  B = shadow_blend(B, I).rgb;\n  G = shadow_blend(G, I).rgb;\n#endif\nvec3 J = m + B + G;\n#ifdef HAS_EMISSIVE_MAP\nvec3 K = texture2D(emissiveTexture, computeTexCoord()).rgb;\n  J += K;\n#endif\n#ifdef IS_LINE_EXTRUSION\nglFragColor = vec4(J, lineOpacity);\n#else\nglFragColor = vec4(J, polygonOpacity);\n#endif\n#if defined(HAS_COLOR) || defined(HAS_COLOR0)\nfloat L = vColor.a;\n#elif defined(IS_LINE_EXTRUSION)\nfloat L = lineColor.a;\n#else\nfloat L = polygonFill.a;\n#endif\nglFragColor *= L;\n#ifdef HAS_EXTRUSION_OPACITY\nfloat M = extrusionOpacityRange.x;\n  float N = extrusionOpacityRange.y;\n  float O = M + vExtrusionOpacity * (N - M);\n  O = clamp(O, .0, 1.);\n  glFragColor *= O;\n#endif\n#ifdef HAS_HEATMAP\nglFragColor = heatmap_getColor(glFragColor);\n#endif\nglFragColor = highlight_blendColor(glFragColor);\n#ifdef HAS_MASK_EXTENT\nglFragColor = setMask(glFragColor);\n#endif\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}", se$1 = "#include <gl2_vert>\nattribute vec3 aPosition;\n#include <line_extrusion_vert>\n#ifdef HAS_MAP\nuniform vec2 uvScale;\nuniform vec2 uvOffset;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\n#ifdef HAS_I3S_UVREGION\nattribute vec4 uvRegion;\nvarying vec4 vUvRegion;\n#endif\n#endif\n#if defined(HAS_COLOR)\nattribute vec4 aColor;\n#elif defined(HAS_COLOR0)\n#if COLOR0_SIZE == 3\nattribute vec3 aColor0;\n#else\nattribute vec4 aColor0;\n#endif\nvarying vec4 vColor;\n#endif\nvarying vec3 vFragPos;\nvarying vec3 vNormal;\nuniform mat4 projMatrix;\nuniform mat3 modelNormalMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 positionMatrix;\nuniform vec2 halton;\nuniform vec2 outSize;\nuniform mat4 projViewMatrix;\n#include <highlight_vert>\n#include <get_output>\n#include <heatmap_render_vert>\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n#include <vsm_shadow_vert>\n#endif\n#ifdef HAS_EXTRUSION_OPACITY\nattribute float aExtrusionOpacity;\nvarying float vExtrusionOpacity;\n#endif\n#if defined(HAS_TANGENT)\nvarying vec4 vTangent;\n#endif\nvoid c(const highp vec4 q, out highp vec3 d) {\n  d = vec3(.0, .0, 1.) + vec3(2., -2., -2.) * q.x * q.zwx + vec3(2., 2., -2.) * q.y * q.wzy;\n}\nvoid c(const highp vec4 q, out highp vec3 d, out highp vec3 t) {\n  c(q, d);\n  t = vec3(1., .0, .0) + vec3(-2., 2., -2.) * q.y * q.yxw + vec3(-2., 2., 2.) * q.z * q.zwx;\n}\nvoid main() {\n  \n#ifdef IS_LINE_EXTRUSION\nvec4 e = getPosition(getLineExtrudePosition(aPosition));\n#else\nvec4 e = getPosition(aPosition);\n#endif\nmat4 f = getPositionMatrix();\n  vFragPos = vec3(modelMatrix * f * e);\n#if defined(HAS_NORMAL) || defined(HAS_TANGENT)\nmat3 h = modelNormalMatrix * mat3(f);\n  vec3 i;\n#if defined(HAS_TANGENT)\nvec3 t;\n  c(aTangent, i, t);\n  vTangent = vec4(h * t, aTangent.w);\n#else\n#ifdef HAS_DECODE_NORMAL\ni = getNormal(aNormal);\n#else\ni = aNormal;\n#endif\n#endif\nvec3 j = appendMorphNormal(i);\n  vNormal = normalize(h * j);\n#else\nvNormal = vec3(.0);\n#endif\nmat4 k = projMatrix;\n  k[2].xy += halton.xy / outSize.xy;\n#ifdef HAS_MASK_EXTENT\ngl_Position = k * getMaskPosition(f * e, modelMatrix);\n#else\ngl_Position = k * modelViewMatrix * f * e;\n#endif\n#ifdef HAS_MAP\nvec2 l = getTexcoord(aTexCoord);\n  vTexCoord = l * uvScale + uvOffset;\n#endif\n#ifdef HAS_EXTRUSION_OPACITY\nvExtrusionOpacity = aExtrusionOpacity;\n#endif\n#if defined(HAS_COLOR)\nvColor = aColor / 255.;\n#elif defined(HAS_COLOR0)\n#if COLOR0_SIZE == 3\nvColor = vec4(aColor0 / 255., 1.);\n#else\nvColor = aColor0 / 255.;\n#endif\n#endif\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\nshadow_computeShadowPars(f * e);\n#endif\n#ifdef HAS_HEATMAP\nheatmap_compute(projMatrix * modelViewMatrix * f, e);\n#endif\n#ifdef HAS_I3S_UVREGION\nvUvRegion = uvRegion / 65535.;\n#endif\nhighlight_setVarying();\n}";

	class ae$1 extends ie$1 {
	    constructor(t = {}) {
	        const n = [], i = [], o = t.uniforms, s = [ {
	            name: "modelNormalMatrix",
	            type: "function",
	            fn: function(t, e) {
	                return fromMat4$1(n, e.modelMatrix);
	            }
	        }, {
	            name: "modelViewMatrix",
	            type: "function",
	            fn: function(t, n) {
	                return multiply$5(i, n.viewMatrix, n.modelMatrix);
	            }
	        } ];
	        o && s.push(...o), super({
	            vert: t.vert || se$1,
	            frag: t.frag || oe$1,
	            uniforms: s,
	            defines: t.defines || {},
	            extraCommandProps: t.extraCommandProps || {}
	        }), this.version = 300;
	    }
	    getGeometryDefines(t) {
	        const e = {};
	        return t.data[t.desc.tangentAttribute] ? e.HAS_TANGENT = 1 : t.data[t.desc.normalAttribute] && (e.HAS_NORMAL = 1), 
	        e;
	    }
	}

	class he$1 extends ie$1 {
	    constructor(t = {}) {
	        const n = [];
	        super({
	            vert: "attribute vec3 aPosition;\n#ifdef HAS_COLOR0\nattribute vec4 aColor0;\nvarying vec4 vColor;\n#endif\nuniform mat4 modelMatrix;\nuniform mat4 projMatrix;\nuniform mat4 positionMatrix;\nuniform mat4 projViewModelMatrix;\nuniform float pointSize;\n#if defined(HAS_MAP)\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\n#endif\n#include <get_output>\n#include <heatmap_render_vert>\n#ifdef HAS_FLOODANALYSE\nvarying float vHeight;\n#endif\nvoid main() {\n  vec4 c = getPosition(aPosition);\n  mat4 d = getPositionMatrix();\n  gl_PointSize = pointSize;\n#ifdef HAS_MASK_EXTENT\ngl_Position = projMatrix * getMaskPosition(d * c, modelMatrix);\n#else\ngl_Position = projViewModelMatrix * d * c;\n#endif\n#ifdef HAS_COLOR0\nvColor = aColor0 / 255.;\n#endif\n#ifdef HAS_MAP\nvTexCoord = aTexCoord;\n#endif\n#ifdef HAS_HEATMAP\nheatmap_compute(projMatrix * modelViewMatrix * d, c);\n#endif\n}",
	            frag: "precision mediump float;\n#include <gl2_frag>\n#if defined(HAS_COLOR0)\nvarying vec4 vColor;\n#endif\n#include <heatmap_render_frag>\nuniform vec4 baseColorFactor;\n#if defined(HAS_MAP)\n#if defined(HAS_ALBEDO_MAP)\nuniform sampler2D baseColorTexture;\n#endif\n#if defined(HAS_DIFFUSE_MAP)\nuniform sampler2D diffuseTexture;\n#endif\nvarying vec2 vTexCoord;\n#endif\n#include <mask_frag>\nvoid main() {\n  \n#ifdef HAS_COLOR0\nglFragColor = vColor * baseColorFactor;\n#else\nglFragColor = vec4(1.) * baseColorFactor;\n#endif\n#ifdef HAS_MAP\n#ifdef HAS_ALBEDO_MAP\nglFragColor *= texture2D(baseColorTexture, vTexCoord);\n#endif\n#ifdef HAS_DIFFUSE_MAP\nglFragColor *= texture2D(diffuseTexture, vTexCoord);\n#endif\n#endif\n#ifdef HAS_HEATMAP\nglFragColor = heatmap_getColor(glFragColor);\n#endif\n#ifdef HAS_MASK_EXTENT\nglFragColor = setMask(glFragColor);\n#endif\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",
	            uniforms: [ {
	                name: "projViewModelMatrix",
	                type: "function",
	                fn: (t, i) => multiply$5(n, i.projViewMatrix, i.modelMatrix)
	            } ],
	            defines: t.defines || {},
	            extraCommandProps: t.extraCommandProps || {}
	        });
	    }
	}

	class le$1 extends ae$1 {
	    constructor(t = {}) {
	        super({
	            vert: se$1,
	            frag: oe$1,
	            defines: t.defines || {},
	            extraCommandProps: t.extraCommandProps || {}
	        });
	    }
	}

	var ce$1 = "#if __VERSION__ == 300\n#define attribute in\n#define varying out\n#endif\nattribute vec2 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n  gl_Position = vec4(aPosition, 0., 1.);\n  vTexCoord = aTexCoord;\n}";

	const ue$1 = new Int8Array([ -1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, -1 ]), fe = new Uint8Array([ 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0 ]);

	class de extends ie$1 {
	    constructor(t) {
	        t.vert = t.vert || ce$1, t.extraCommandProps = t.extraCommandProps || {}, t.extraCommandProps.depth || (t.extraCommandProps.depth = {
	            enable: !1,
	            mask: !1
	        }), t.extraCommandProps.stencil || (t.extraCommandProps.stencil = {
	            enable: !1
	        }), super(t);
	    }
	    draw(t) {
	        return this._quadMesh || this._createQuadMesh(t), super.draw(t, this._quadMesh);
	    }
	    getMeshCommand(t) {
	        const e = this.dkey || "";
	        return this.commands[e + "_quad"] || (this.commands[e + "_quad"] = this.createREGLCommand(t, null, this._quadMesh[0].getElements())), 
	        this.commands[e + "_quad"];
	    }
	    _createQuadMesh(t) {
	        const e = new Q$1({
	            aPosition: ue$1,
	            aTexCoord: fe
	        }, null, ue$1.length / 2, {
	            positionSize: 2,
	            primitive: "triangles"
	        });
	        e.generateBuffers(t), this._quadMesh = [ new ft$1(e) ];
	    }
	    dispose() {
	        if (this._quadMesh) {
	            const t = this._quadMesh[0];
	            t.geometry.dispose(), t.dispose();
	        }
	        return delete this._quadMesh, super.dispose();
	    }
	}

	class me extends de {
	    constructor() {
	        super({
	            vert: ce$1,
	            frag: "#define SHADER_NAME FXAA\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#define FXAA_SPAN_MAX     8.0\nprecision mediump float;\nvarying vec2 vTexCoord;\nuniform float enableFXAA;\nuniform float enableToneMapping;\nuniform float enableSharpen;\nuniform vec2 resolution;\nuniform sampler2D textureSource;\n#ifdef HAS_NOAA_TEX\nuniform sampler2D noAaTextureSource;\n#endif\n#ifdef HAS_POINT_TEX\nuniform sampler2D pointTextureSource;\n#endif\n#ifdef HAS_TAA_TEX\nuniform sampler2D taaTextureSource;\n#ifdef HAS_FXAA_TEX\nuniform sampler2D fxaaTextureSource;\n#endif\n#endif\nuniform float pixelRatio;\nuniform float sharpFactor;\n#ifdef HAS_OUTLINE_TEX\nuniform sampler2D textureOutline;\nuniform float enableOutline;\nuniform float highlightFactor;\nuniform float outlineFactor;\nuniform float outlineWidth;\nuniform vec3 outlineColor;\n#endif\nvec2 c;\nvec4 d(vec2 e) {\n  \n#ifdef HAS_TAA_TEX\nvec4 f = texture2D(textureSource, e);\n  vec4 taa = texture2D(taaTextureSource, e);\n#ifdef HAS_FXAA_TEX\nvec4 h = texture2D(fxaaTextureSource, e);\n#else\nvec4 h = vec4(.0);\n#endif\nvec4 i = taa + f * (1. - taa.a);\n  return h + i * (1. - h.a);\n#else\nreturn texture2D(textureSource, e);\n#endif\n}\nvec4 j(vec2 k) {\n  vec4 l;\n  mediump vec2 m = vec2(1. / resolution.x, 1. / resolution.y);\n  vec3 n = d((k + vec2(-1., -1.)) * m).xyz;\n  vec3 o = d((k + vec2(1., -1.)) * m).xyz;\n  vec3 u = d((k + vec2(-1., 1.)) * m).xyz;\n  vec3 v = d((k + vec2(1.)) * m).xyz;\n  vec4 A = d(k * m);\n  vec3 B = A.xyz;\n  vec3 C = vec3(.299, .587, .114);\n  float D = dot(n, C);\n  float E = dot(o, C);\n  float F = dot(u, C);\n  float G = dot(v, C);\n  float H = dot(B, C);\n  float I = min(H, min(min(D, E), min(F, G)));\n  float J = max(H, max(max(D, E), max(F, G)));\n  mediump vec2 K;\n  K.x = -((D + E) - (F + G));\n  K.y = (D + F) - (E + G);\n  float L = max((D + E + F + G) * (.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n  float M = 1. / (min(abs(K.x), abs(K.y)) + L);\n  K = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), K * M)) * m;\n  vec4 N = .5 * (d(k * m + K * (1. / 3. - .5)) + d(k * m + K * (2. / 3. - .5)));\n  vec4 O = N * .5 + .25 * (d(k * m + K * -.5) + d(k * m + K * .5));\n  float P = dot(O.xyz, C);\n  if(P < I || P > J)\n    l = N;\n  else\n    l = O;\n  return l;\n}\nvec3 Q(const in vec3 l, const float R) {\n  vec2 S = pixelRatio / resolution.xy;\n  float T = .0;\n  vec4 n = texture2D(textureSource, c + S * vec2(-1., -1.));\n  n.rgb = mix(vec3(.0), n.rgb, sign(n.a));\n  T += mix(.0, 1., sign(n.a));\n  vec4 v = texture2D(textureSource, c + S * vec2(1.));\n  v.rgb = mix(vec3(.0), v.rgb, sign(v.a));\n  T += mix(.0, 1., sign(v.a));\n  vec4 o = texture2D(textureSource, c + S * vec2(1., -1.));\n  o.rgb = mix(vec3(.0), o.rgb, sign(o.a));\n  T += mix(.0, 1., sign(o.a));\n  vec4 u = texture2D(textureSource, c + S * vec2(-1., 1.));\n  u.rgb = mix(vec3(.0), u.rgb, sign(u.a));\n  T += mix(.0, 1., sign(u.a));\n  return l + R * (T * l - n.rgb - o.rgb - u.rgb - v.rgb);\n}\nvec4 U(const in vec4 l) {\n  return vec4(Q(l.rgb, sharpFactor), l.a);\n}\nvec3 V(const vec3 x) {\n  const float a = 2.51;\n  const float b = .03;\n  const float W = 2.43;\n  const float X = .59;\n  const float Y = .14;\n  return (x * (a * x + b)) / (x * (W * x + X) + Y);\n}\nvec3 Z(vec3 l) {\n  l = l / (l + vec3(1.));\n  return l = pow(l, vec3(1. / 2.2));\n}\n#ifdef HAS_OUTLINE_TEX\nvec4 ba() {\n  float bb = 2.;\n  float bc = 1.;\n  float bd = pixelRatio / resolution[0] * outlineWidth;\n  float be = pixelRatio / resolution[1] * outlineWidth;\n  vec4 bf = (texture2D(textureOutline, c + vec2(bd, be)));\n  vec4 bg = (texture2D(textureOutline, c + vec2(bd, .0)));\n  vec4 bh = (texture2D(textureOutline, c + vec2(bd, -be)));\n  vec4 bi = (texture2D(textureOutline, c + vec2(.0, -be)));\n  vec4 bj = (texture2D(textureOutline, c + vec2(-bd, -be)));\n  vec4 bk = (texture2D(textureOutline, c + vec2(-bd, .0)));\n  vec4 bl = (texture2D(textureOutline, c + vec2(-bd, be)));\n  vec4 bm = (texture2D(textureOutline, c + vec2(.0, be)));\n  vec4 bn = -bb * bk + bb * bg + -bc * bl + bc * bf + -bc * bj + bc * bh;\n  vec4 bo = -bb * bi + bb * bm + -bc * bj + bc * bl + -bc * bh + bc * bf;\n  float bp = sqrt(dot(bo, bo) + dot(bn, bn));\n  bool bq = bp < 1. / 65025.;\n  vec3 br = (texture2D(textureOutline, c)).r * outlineColor;\n  if(br == vec3(.0) || (highlightFactor == .0 && bq)) {\n    return vec4(.0);\n  }\n  float bs = bq ? highlightFactor : min(1., sqrt(bp) * outlineFactor);\n  return bs * vec4(br, 1.);\n}\nvec4 bt(const in vec4 l) {\n  vec4 ba = ba();\n  return ba + vec4(l) * (1. - ba.a);\n}\n#endif\nvoid main() {\n  c = vTexCoord;\n  vec4 l;\n  if(enableFXAA == 1.) {\n    l = j(c * resolution);\n  } else {\n    l = d(vTexCoord);\n  }\n  if(enableSharpen == 1.) {\n    l = U(l);\n  }\n#if defined(HAS_NOAA_TEX) || defined(HAS_POINT_TEX)\nvec4 bu = vec4(.0);\n  vec4 bv = vec4(.0);\n#ifdef HAS_POINT_TEX\nbu = texture2D(pointTextureSource, vTexCoord);\n#endif\n#ifdef HAS_NOAA_TEX\nbv = texture2D(noAaTextureSource, vTexCoord);\n#endif\nvec4 bw = bu + bv * (1. - bu.a);\n  l = bw + l * (1. - bw.a);\n#endif\nif(enableToneMapping == 1.) {\n    l.rgb = Z(l.rgb);\n  }\n#ifdef HAS_OUTLINE_TEX\nl = bt(l);\n#endif\ngl_FragColor = l;\n}",
	            extraCommandProps: {
	                viewport: {
	                    x: 0,
	                    y: 0,
	                    width: (t, e) => e.resolution[0],
	                    height: (t, e) => e.resolution[1]
	                }
	            }
	        });
	    }
	    getMeshCommand(t, e) {
	        const n = this.dkey || "";
	        return this.commands[n + "_fxaa"] || (this.commands[n + "_fxaa"] = this.createREGLCommand(t, null, e.getElements())), 
	        this.commands[n + "_fxaa"];
	    }
	}

	class ge extends de {
	    constructor({blurOffset: t}) {
	        super({
	            vert: ce$1,
	            frag: "precision highp float;\nvarying vec2 vTexCoord;\nuniform sampler2D textureSource;\nuniform vec2 resolution;\nuniform float ignoreTransparent;\nvoid main() {\n  vec4 c = vec4(.0);\n  float d = .0;\n  for(int x = -BOXBLUR_OFFSET; x <= BOXBLUR_OFFSET; ++x)\n    for(int y = -BOXBLUR_OFFSET; y <= BOXBLUR_OFFSET; ++y) {\n      vec2 e = vTexCoord.st + vec2(float(x) / resolution.x, float(y) / resolution.y);\n      e = clamp(e, .0, 1.);\n      vec4 f = texture2D(textureSource, e);\n      float h;\n      if(ignoreTransparent == 1.) {\n        h = sign(f.a);\n      } else {\n        h = 1.;\n      }\n      d += h;\n      c += h * f;\n    }\n  gl_FragColor = c / max(d, 1.) * clamp(sign(d - 1.), .0, 1.);\n}",
	            defines: {
	                BOXBLUR_OFFSET: t || 2
	            },
	            extraCommandProps: {
	                viewport: {
	                    x: 0,
	                    y: 0,
	                    width: (t, e) => e.resolution[0],
	                    height: (t, e) => e.resolution[1]
	                }
	            }
	        }), this._blurOffset = t || 2;
	    }
	    getMeshCommand(t, e) {
	        const n = "box_blur_" + this._blurOffset;
	        return this.commands[n] || (this.commands[n] = this.createREGLCommand(t, null, e.getElements())), 
	        this.commands[n];
	    }
	}

	class pe extends de {
	    constructor() {
	        super({
	            vert: ce$1,
	            frag: "precision mediump float;\n#define SHADER_NAME SSAO_BLUR\nstruct MaterialParams {\n  float farPlaneOverEdgeDistance;\n  vec2 axis;\n  vec2 resolution;\n};\nuniform sampler2D materialParams_ssao;\nuniform sampler2D TextureInput;\nuniform MaterialParams materialParams;\nvarying vec2 vTexCoord;\nconst int c = 6;\nfloat d[8];\nvoid e() {\n  d[0] = .099736;\n  d[1] = .096667;\n  d[2] = .088016;\n  d[3] = .075284;\n  d[4] = .060493;\n  d[5] = .045662;\n}\nfloat f(vec2 h) {\n  return (h.x * (256. / 257.) + h.y * (1. / 257.));\n}\nvoid tap(inout float i, inout float j, float k, float h, vec2 l) {\n  vec3 m = texture2D(materialParams_ssao, l).rgb;\n  float n = k;\n  i += m.r * n;\n  j += n;\n}\nvoid main() {\n  e();\n  highp vec2 o = vTexCoord;\n  vec3 m = texture2D(materialParams_ssao, o).rgb;\n  if(m.g * m.b == 1.) {\n    if(materialParams.axis.y > .0) {\n      vec4 u = texture2D(TextureInput, o);\n      gl_FragColor = u;\n    } else {\n      gl_FragColor = vec4(m, 1.);\n    }\n    return;\n  }\n  float h = f(m.gb);\n  float j = d[0];\n  float i = m.r * j;\n  vec2 v = materialParams.axis / materialParams.resolution;\n  vec2 A = v;\n  for(int B = 1; B < c; B++) {\n    float k = d[B];\n    tap(i, j, k, h, o + A);\n    tap(i, j, k, h, o - A);\n    A += v;\n  }\n  float C = i * (1. / j);\n  vec2 gb = m.gb;\n  if(materialParams.axis.y > .0) {\n    vec4 u = texture2D(TextureInput, o);\n    gl_FragColor = vec4(u.rgb * C, u.a);\n  } else {\n    gl_FragColor = vec4(C, gb, 1.);\n  }\n}",
	            extraCommandProps: {
	                viewport: {
	                    x: 0,
	                    y: 0,
	                    width: (t, e) => e.outputSize[0],
	                    height: (t, e) => e.outputSize[1]
	                }
	            }
	        });
	    }
	    getMeshCommand(t, e) {
	        return this.commands.ssao_blur || (this.commands.ssao_blur = this.createREGLCommand(t, null, e.getElements())), 
	        this.commands.ssao_blur;
	    }
	}

	const _e = [ -2e-6, 0, 2e-6, -.095089, .004589, -.031253, .01518, -.025586, .003765, .073426, .021802, .002778, .094587, .043218, .089148, -.009509, .051369, .019673, .139973, -.101685, .10857, -.103804, .219853, -.043016, .004841, -.033988, .094187, .028011, .058466, -.25711, -.051031, .074993, .259843, .118822, -.186537, -.134192, .063949, -.094894, -.072683, .108176, .327108, -.254058, -.04718, .21918, .263895, -.407709, .240834, -.200352 ];

	class ve extends de {
	    constructor() {
	        super({
	            vert: ce$1,
	            frag: "#if __VERSION__ == 100\n#if defined(GL_OES_standard_derivatives)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#endif\nprecision highp float;\n#include <gl2_frag>\nvarying vec2 vTexCoord;\n#define saturate(x)        clamp(x, 0.0, 1.0)\n#define SHADER_NAME SSAO_EXTRACT\n#define PI 3.14159265359\nconst float c = .0625;\nstruct MaterialParams {\n  mat4 projMatrix;\n  mat4 invProjMatrix;\n  vec4 resolution;\n  float radius;\n  float bias;\n  float power;\n  vec2 cameraNearFar;\n};\nuniform MaterialParams materialParams;\nuniform sampler2D materialParams_depth;\n#define NOISE_NONE      0\n#define NOISE_PATTERN   1\n#define NOISE_RANDOM    2\n#define NOISE_TYPE      NOISE_PATTERN\nconst int d = 16;\nuniform vec3 kSphereSamples[16];\nvec3 e(const int x) {\n  if(x == 0) {\n    return vec3(-.078247, -.749924, -.656880);\n  } else if(x == 1) {\n    return vec3(-.572319, -.102379, -.813615);\n  } else if(x == 2) {\n    return vec3(.048653, -.380791, .923380);\n  } else if(x == 3) {\n    return vec3(.281202, -.656664, -.699799);\n  } else if(x == 4) {\n    return vec3(.711911, -.235841, -.661485);\n  } else if(x == 5) {\n    return vec3(-.445893, .611063, .654050);\n  } else if(x == 6) {\n    return vec3(-.703598, .674837, .222587);\n  } else if(x == 7) {\n    return vec3(.768236, .507457, .390257);\n  } else if(x == 8) {\n    return vec3(-.670286, -.470387, .573980);\n  } else if(x == 9) {\n    return vec3(.199235, .849336, -.488808);\n  } else if(x == 10) {\n    return vec3(-.768068, -.583633, -.263520);\n  } else if(x == 11) {\n    return vec3(-.897330, .328853, .294372);\n  } else if(x == 12) {\n    return vec3(-.570930, -.531056, -.626114);\n  } else if(x == 13) {\n    return vec3(.699014, .063283, -.712303);\n  } else if(x == 14) {\n    return vec3(.207495, .976129, -.064172);\n  } else if(x == 15) {\n    return vec3(-.060901, -.869738, -.489742);\n  } else {\n    return vec3(.0);\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n}\nvec2 f(highp float h) {\n  highp float z = clamp(h * 1. / -materialParams.cameraNearFar.y, .0, 1.);\n  highp float t = floor(256. * z);\n  mediump float i = t * (1. / 256.);\n  mediump float j = 256. * z - t;\n  return vec2(i, j);\n}\nfloat k(highp vec2 l) {\n  l = fract(l * vec2(5.3987, 5.4421));\n  l += dot(l.yx, l.xy + vec2(21.5351, 14.3137));\n  highp float xy = l.x * l.y;\n  return fract(xy * 95.4307) + fract(xy * 75.04961) * .5;\n}\nvec3 m(const vec2 o) {\n  \n#if NOISE_TYPE == NOISE_RANDOM\nreturn normalize(2. * vec3(k(o), k(o * 2.), k(o * 4.)) - vec3(1.));\n#elif NOISE_TYPE == NOISE_PATTERN\nvec2 xy = floor(gl_FragCoord.xy);\n  float u = mod(xy.x, 4.);\n  float v = mod(xy.y, 4.);\n  return e(int(u + v * 4.));\n#else\nreturn vec3(.0);\n#endif\n}\nhighp mat4 A() {\n  return materialParams.projMatrix;\n}\nhighp mat4 B() {\n  return materialParams.invProjMatrix;\n}\nhighp float C(const vec2 o) {\n  return texture2D(materialParams_depth, o).r;\n}\nhighp float D(highp float h) {\n  highp mat4 E = A();\n  highp float z = h * 2. - 1.;\n  return -E[3].z / (z + E[2].z);\n}\nhighp float F(const vec2 o) {\n  return D(texture2D(materialParams_depth, o).r);\n}\nhighp vec3 G(in vec2 p, highp float H) {\n  p = p * 2. - 1.;\n  highp mat4 I = B();\n  p.x *= I[0].x;\n  p.y *= I[1].y;\n  return vec3(p * -H, H);\n}\nhighp vec3 J(const highp vec3 K) {\n  highp vec3 L = dFdx(K);\n  highp vec3 M = dFdy(K);\n  return cross(L, M);\n}\nhighp vec3 J(const highp vec3 K, const vec2 o) {\n  vec2 N = o + vec2(materialParams.resolution.z, .0);\n  vec2 O = o + vec2(.0, materialParams.resolution.w);\n  highp vec3 px = G(N, F(N));\n  highp vec3 py = G(O, F(O));\n  highp vec3 L = px - K;\n  highp vec3 M = py - K;\n  return cross(L, M);\n}\nfloat P(const highp vec3 Q, const highp float R, mat3 S, const vec3 T, const vec3 U) {\n  highp mat4 E = A();\n  float V = materialParams.radius;\n  float W = materialParams.bias;\n  highp vec3 X = S * U;\n  float Y = dot(X, T);\n  X = sign(Y) * X;\n  X = Q + X * V;\n  highp vec4 Z = E * vec4(X, 1.);\n  Z.xy = Z.xy * (.5 / Z.w) + .5;\n  highp float ba = C(Z.xy);\n  ba = D(ba);\n  float t = saturate(V / abs(R - ba));\n  float bb = t * t * (3. - 2. * t);\n  return (ba >= X.z + W ? bb : .0);\n}\nvoid main() {\n  highp vec2 o = vTexCoord;\n  highp float h = C(o);\n  highp float bc = D(h);\n  highp vec3 Q = G(o, bc);\n  highp vec3 T = J(Q, o);\n  T = normalize(T);\n  vec3 bd = m(o);\n  vec3 be = bd.xyz;\n  vec3 bf = normalize(be - T * dot(be, T));\n  vec3 bg = cross(T, bf);\n  mat3 S = mat3(bf, bg, T);\n  float bh = .0;\n  for(int bi = 0; bi < d; bi++) {\n    bh += P(Q, bc, S, T, kSphereSamples[bi]);\n  }\n  float bj = 1. - bh / float(d);\n  bj = mix(bj, bj * bj, materialParams.power);\n  glFragColor = vec4(bj, f(Q.z), 1.);\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",
	            uniforms: [ {
	                name: "kSphereSamples",
	                type: "function",
	                fn: function() {
	                    return _e;
	                }
	            } ],
	            extraCommandProps: {
	                viewport: {
	                    x: 0,
	                    y: 0,
	                    width: (t, e) => e.outputSize[0],
	                    height: (t, e) => e.outputSize[1]
	                }
	            }
	        }), this.version = 300;
	    }
	    getMeshCommand(t, e) {
	        return this.commands.ssao_extract || (this.commands.ssao_extract = this.createREGLCommand(t, null, e.getElements())), 
	        this.commands.ssao_extract;
	    }
	}

	const ye = [];

	class xe {
	    constructor(t) {
	        this._renderer = t;
	    }
	    render(t, e, n) {
	        const {width: i, height: r} = n;
	        return this._initShaders(), this._extractFBO || this._createTextures(n), this._extract(t, i, r, n), 
	        this._blurAndCombine(e, t.cameraFar, i, r);
	    }
	    _blurAndCombine(t, e, n, i) {
	        const r = Math.floor(n / 2), o = Math.floor(i / 2);
	        this._blurHTex.width === r && this._blurHTex.height === o || (this._blurHFBO.resize(r, o), 
	        this._blurVFBO.resize(n, i));
	        const s = [ n, i ], a = [ 1, 0 ];
	        return this._renderer.render(this._ssaoBlurShader, {
	            TextureInput: t,
	            materialParams_ssao: this._extractTex,
	            materialParams: {
	                axis: a,
	                farPlaneOverEdgeDistance: -e / .0625,
	                resolution: s
	            },
	            outputSize: [ r, o ]
	        }, null, this._blurHFBO), a[0] = 0, a[1] = 1, this._renderer.render(this._ssaoBlurShader, {
	            TextureInput: t,
	            materialParams_ssao: this._blurHTex,
	            materialParams: {
	                axis: a,
	                farPlaneOverEdgeDistance: -e / .0625,
	                resolution: s
	            },
	            outputSize: [ n, i ]
	        }, null, this._blurVFBO), this._blurVTex;
	    }
	    _extract(t, n, i, r) {
	        const o = Math.floor(n / 2), s = Math.floor(i / 2);
	        this._extractFBO.width === o && this._extractFBO.height === s || this._extractFBO.resize(o, s);
	        const {projMatrix: a} = t, h = invert$2(ye, a);
	        this._renderer.render(this._ssaoExtractShader, {
	            materialParams_depth: r,
	            materialParams: {
	                projMatrix: a,
	                invProjMatrix: h,
	                resolution: [ o, s, 1 / o, 1 / s ],
	                radius: t.radius,
	                bias: t.bias,
	                power: t.power || 1,
	                cameraNearFar: [ t.cameraNear, t.cameraFar ]
	            },
	            outputSize: [ o, s ]
	        }, null, this._extractFBO);
	    }
	    _createTextures(t) {
	        const e = Math.floor(t.width / 2), n = Math.floor(t.height / 2);
	        this._extractTex = this._createTex(e, n, "uint8"), this._extractFBO = this._createFBO(this._extractTex), 
	        this._blurHTex = this._createTex(e, n, "uint8"), this._blurHFBO = this._createFBO(this._blurHTex), 
	        this._blurVTex = this._createTex(t.width, t.height, "uint8"), this._blurVFBO = this._createFBO(this._blurVTex);
	    }
	    _createTex(t, e, n) {
	        return this._renderer.regl.texture({
	            min: "linear",
	            mag: "linear",
	            wrap: "clamp",
	            type: n,
	            width: t,
	            height: e
	        });
	    }
	    _createFBO(t) {
	        return this._renderer.regl.framebuffer({
	            width: t.width,
	            height: t.height,
	            colors: [ t ],
	            depth: !1,
	            stencil: !1
	        });
	    }
	    dispose() {
	        this._extractFBO && (this._extractFBO.destroy(), delete this._extractFBO, this._blurVFBO.destroy(), 
	        this._blurHFBO.destroy(), this._ssaoExtractShader.dispose(), this._ssaoBlurShader.dispose(), 
	        delete this._ssaoExtractShader);
	    }
	    _initShaders() {
	        this._ssaoExtractShader || (this._ssaoExtractShader = new ve, this._ssaoBlurShader = new pe);
	    }
	}

	class be extends de {
	    constructor() {
	        super({
	            vert: ce$1,
	            frag: "precision mediump float;\nvarying vec2 vTexCoord;\nuniform vec2 resolution;\nuniform sampler2D textureSource;\nuniform float enableVignette;\nuniform float enableGrain;\nuniform float enableLut;\nuniform float timeGrain;\nuniform float grainFactor;\nuniform vec2 lensRadius;\nuniform float frameMod;\nuniform sampler2D lookupTable;\nfloat c(const in vec2 d) {\n  vec3 e = fract(vec3(d.xyx) * .1031);\n  e += dot(e, e.yzx + 19.19);\n  return fract((e.x + e.y) * e.z);\n}\nfloat f() {\n  float h = c(gl_FragCoord.xy + 1000.0 * fract(timeGrain));\n  float i = h * 2. - 1.;\n  h = i * inversesqrt(abs(i));\n  h = max(-1., h);\n  h = h - sign(i) + .5;\n  return (h + .5) * .5;\n}\nvec4 j(const in vec4 k) {\n  float l = f();\n  return vec4(mix(k.rgb, k.rgb * (k.rgb + (1. - k.rgb) * 2. * l), grainFactor), k.a);\n}\nfloat m(const in float k) {\n  return k < .0031308 ? k * 12.92 : 1.055 * pow(k, 1. / 2.4) - .055;\n}\nvec3 m(const in vec3 k) {\n  return vec3(k.r < .0031308 ? k.r * 12.92 : 1.055 * pow(k.r, 1. / 2.4) - .055, k.g < .0031308 ? k.g * 12.92 : 1.055 * pow(k.g, 1. / 2.4) - .055, k.b < .0031308 ? k.b * 12.92 : 1.055 * pow(k.b, 1. / 2.4) - .055);\n}\nvec4 m(const in vec4 k) {\n  return vec4(k.r < .0031308 ? k.r * 12.92 : 1.055 * pow(k.r, 1. / 2.4) - .055, k.g < .0031308 ? k.g * 12.92 : 1.055 * pow(k.g, 1. / 2.4) - .055, k.b < .0031308 ? k.b * 12.92 : 1.055 * pow(k.b, 1. / 2.4) - .055, k.a);\n}\nfloat n(const in float k) {\n  return k < .04045 ? k * (1. / 12.92) : pow((k + .055) * (1. / 1.055), 2.4);\n}\nvec3 n(const in vec3 k) {\n  return vec3(k.r < .04045 ? k.r * (1. / 12.92) : pow((k.r + .055) * (1. / 1.055), 2.4), k.g < .04045 ? k.g * (1. / 12.92) : pow((k.g + .055) * (1. / 1.055), 2.4), k.b < .04045 ? k.b * (1. / 12.92) : pow((k.b + .055) * (1. / 1.055), 2.4));\n}\nvec4 n(const in vec4 k) {\n  return vec4(k.r < .04045 ? k.r * (1. / 12.92) : pow((k.r + .055) * (1. / 1.055), 2.4), k.g < .04045 ? k.g * (1. / 12.92) : pow((k.g + .055) * (1. / 1.055), 2.4), k.b < .04045 ? k.b * (1. / 12.92) : pow((k.b + .055) * (1. / 1.055), 2.4), k.a);\n}\nfloat o(const in vec2 d, const in float u) {\n  vec3 v = vec3(.06711056, .00583715, 52.9829189);\n  return fract(v.z * fract(dot(d.xy + u * vec2(47., 17.) * .695, v.xy)));\n}\nfloat A() {\n  vec2 B = lensRadius;\n  B.y = min(B.y, B.x - 1e-4);\n  float C = o(gl_FragCoord.xy, frameMod);\n  C = (B.x - B.y) * (B.x + B.y) * .07 * (C - .5);\n  return smoothstep(B.x, B.y, C + distance(vTexCoord, vec2(.5)));\n}\nvec4 D(const in vec4 k) {\n  float l = A();\n  return vec4(m(n(k.rgb) * l), clamp(k.a + (1. - l), .0, 1.));\n}\nvec4 E(in vec4 F, in sampler2D G) {\n  mediump float H = F.b * 63.;\n  mediump vec2 I;\n  I.y = floor(floor(H) / 8.);\n  I.x = floor(H) - I.y * 8.;\n  mediump vec2 J;\n  J.y = floor(ceil(H) / 8.);\n  J.x = ceil(H) - J.y * 8.;\n  highp vec2 K;\n  K.x = I.x * .125 + .5 / 512. + (.125 - 1. / 512.) * F.r;\n  K.y = I.y * .125 + .5 / 512. + (.125 - 1. / 512.) * F.g;\n#ifdef LUT_FLIP_Y\nK.y = 1. - K.y;\n#endif\nhighp vec2 L;\n  L.x = J.x * .125 + .5 / 512. + (.125 - 1. / 512.) * F.r;\n  L.y = J.y * .125 + .5 / 512. + (.125 - 1. / 512.) * F.g;\n#ifdef LUT_FLIP_Y\nL.y = 1. - L.y;\n#endif\nlowp vec4 M = texture2D(G, K);\n  lowp vec4 N = texture2D(G, L);\n  lowp vec4 O = mix(M, N, fract(H));\n  return O;\n}\nvoid main() {\n  vec4 k = texture2D(textureSource, vTexCoord);\n  if(enableLut == 1.) {\n    k = E(k, lookupTable);\n  }\n  if(enableVignette == 1.) {\n    k = D(k);\n  }\n  if(enableGrain == 1.) {\n    k = j(k);\n  }\n  gl_FragColor = k;\n}",
	            extraCommandProps: {
	                viewport: {
	                    x: 0,
	                    y: 0,
	                    width: (t, e) => e.resolution[0],
	                    height: (t, e) => e.resolution[1]
	                }
	            }
	        });
	    }
	    getMeshCommand(t, e) {
	        return this.commands.postprocess || (this.commands.postprocess = this.createREGLCommand(t, null, e.getElements())), 
	        this.commands.postprocess;
	    }
	}

	class we extends de {
	    constructor() {
	        super({
	            vert: ce$1,
	            frag: "#define SHADER_NAME TAA\nprecision mediump float;\n#define saturate(x)        clamp(x, 0.0, 1.0)\n#if defined(TARGET_METAL_ENVIRONMENT) || defined(TARGET_VULKAN_ENVIRONMENT)\n#define TEXTURE_SPACE_UP    -1\n#define TEXTURE_SPACE_DN     1\n#else\n#define TEXTURE_SPACE_UP     1\n#define TEXTURE_SPACE_DN    -1\n#endif\n#define BOX_TYPE_AABB           0\n#define BOX_TYPE_VARIANCE       1\n#define BOX_TYPE_AABB_VARIANCE  2\n#define VARIANCE_GAMMA          1.0\n#define BOX_CLIPPING_ACCURATE   0\n#define BOX_CLIPPING_CLAMP      1\n#define BOX_CLIPPING_NONE       2\n#if defined(TARGET_MOBILE)\n#define BOX_CLIPPING            BOX_CLIPPING_ACCURATE\n#define BOX_TYPE                BOX_TYPE_VARIANCE\n#define USE_YCoCg               0\n#define FILTER_INPUT            1\n#define FILTER_HISTORY          0\n#else\n#define BOX_CLIPPING            BOX_CLIPPING_ACCURATE\n#define BOX_TYPE                BOX_TYPE_AABB_VARIANCE\n#define USE_YCoCg               0\n#define FILTER_INPUT            0\n#define FILTER_HISTORY          0\n#endif\n#define HISTORY_REPROJECTION    1\n#define PREVENT_FLICKERING      0\nstruct MaterialParams {\n  float alpha;\n  mat4 reprojection;\n};\nuniform sampler2D materialParams_color;\nuniform sampler2D materialParams_history;\nuniform vec2 materialParams_history_size;\nuniform vec2 textureOutputSize;\nuniform sampler2D materialParams_depth;\nuniform MaterialParams materialParams;\nfloat c(const vec3 d) {\n  return dot(d, vec3(.2126, .7152, .0722));\n}\nfloat e(const vec3 f) {\n  \n#if USE_YCoCg\nreturn f.x;\n#else\nreturn c(f);\n#endif\n}\nvec3 h(const vec3 i) {\n  float j = dot(i.rgb, vec3(1, 2, 1) * .25);\n  float k = dot(i.rgb, vec3(2, 0, -2) * .25);\n  float l = dot(i.rgb, vec3(-1, 2, -1) * .25);\n  return vec3(j, k, l);\n}\nvec3 m(const vec3 i) {\n  float j = i.x;\n  float k = i.y;\n  float l = i.z;\n  float r = j + k - l;\n  float g = j + l;\n  float b = j - k - l;\n  return vec3(r, g, b);\n}\nvec4 n(const int o, const vec3 u, const vec3 v, const vec4 i, const vec4 A) {\n  const float B = .0001;\n  if(o == BOX_CLIPPING_ACCURATE) {\n    vec4 r = i - A;\n    vec3 C = 1. / (B + r.rgb);\n    vec3 D = (v - A.rgb) * C;\n    vec3 E = (u - A.rgb) * C;\n    vec3 F = min(D, E);\n    return A + r * saturate(max(max(F.x, F.y), F.z));\n  } else if(o == BOX_CLIPPING_CLAMP) {\n    return vec4(clamp(A.rgb, u, v), A.a);\n  }\n  return A;\n}\nvec4 G(const sampler2D H, const highp vec2 I, const highp vec2 J) {\n  highp vec2 K = I * J;\n  highp vec2 L = floor(K - .5) + .5;\n  highp vec2 M = K - L;\n  highp vec2 N = M * M;\n  highp vec2 O = N * M;\n  vec2 P = N - .5 * (O + M);\n  vec2 Q = 1.5 * O - 2.5 * N + 1.;\n  vec2 R = .5 * (O - N);\n  vec2 S = 1. - P - Q - R;\n  vec2 T = Q + S;\n  highp vec2 U = L - vec2(1.);\n  highp vec2 V = L + vec2(2.);\n  highp vec2 W = L + S / T;\n  highp vec2 X = 1. / J;\n  U *= X;\n  V *= X;\n  W *= X;\n  float Z = T.x * P.y;\n  float ba = P.x * T.y;\n  float bb = T.x * T.y;\n  float bc = R.x * T.y;\n  float bd = T.x * R.y;\n  vec4 be = texture2D(H, vec2(W.x, U.y)) * Z + texture2D(H, vec2(U.x, W.y)) * ba + texture2D(H, vec2(W.x, W.y)) * bb + texture2D(H, vec2(V.x, W.y)) * bc + texture2D(H, vec2(W.x, V.y)) * bd;\n  be *= 1. / (Z + ba + bb + bc + bd);\n  return be;\n}\nvec4 bf(sampler2D H, vec2 I, float bg, ivec2 bh) {\n  return texture2D(H, I + vec2(bh));\n}\nvoid main() {\n  highp vec4 I = (gl_FragCoord.xy / textureOutputSize.xy).xyxy;\n  float bi = texture2D(materialParams_depth, I.xy).r;\n#if HISTORY_REPROJECTION\n#if defined(TARGET_METAL_ENVIRONMENT) || defined(TARGET_VULKAN_ENVIRONMENT)\nI.w = 1. - I.w;\n#endif\nhighp vec4 q = materialParams.reprojection * vec4(I.zw, bi, 1.);\n  I.zw = (q.xy * (1. / q.w)) * .5 + .5;\n#if defined(TARGET_METAL_ENVIRONMENT) || defined(TARGET_VULKAN_ENVIRONMENT)\nI.w = 1. - I.w;\n#endif\n#endif\nvec4 f = bf(materialParams_color, I.xy, .0, ivec2(0));\n#if FILTER_HISTORY\nvec4 bj = G(materialParams_history, I.zw, materialParams_history_size);\n#else\nvec4 bj = texture2D(materialParams_history, I.zw);\n#endif\n#if USE_YCoCg\nbj.rgb = h(bj.rgb);\n#endif\nvec3 s[9];\n  s[0] = bf(materialParams_color, I.xy, .0, ivec2(-1, TEXTURE_SPACE_DN)).rgb;\n  s[1] = bf(materialParams_color, I.xy, .0, ivec2(0, TEXTURE_SPACE_DN)).rgb;\n  s[2] = bf(materialParams_color, I.xy, .0, ivec2(1, TEXTURE_SPACE_DN)).rgb;\n  s[3] = bf(materialParams_color, I.xy, .0, ivec2(-1, 0)).rgb;\n  s[4] = f.rgb;\n  s[5] = bf(materialParams_color, I.xy, .0, ivec2(1, 0)).rgb;\n  s[6] = bf(materialParams_color, I.xy, .0, ivec2(-1, TEXTURE_SPACE_UP)).rgb;\n  s[7] = bf(materialParams_color, I.xy, .0, ivec2(0, TEXTURE_SPACE_UP)).rgb;\n  s[8] = bf(materialParams_color, I.xy, .0, ivec2(1, TEXTURE_SPACE_UP)).rgb;\n#if USE_YCoCg\nfor(int bk = 0; bk < 9; bk++) {\n    s[bk] = h(s[bk]);\n  }\n  f.rgb = s[4].rgb;\n#endif\n#if FILTER_INPUT\n#else\nvec4 bl = f;\n#endif\n#if BOX_TYPE == BOX_TYPE_AABB || BOX_TYPE == BOX_TYPE_AABB_VARIANCE\nvec3 u = min(s[4], min(min(s[1], s[3]), min(s[5], s[7])));\n  vec3 v = max(s[4], max(max(s[1], s[3]), max(s[5], s[7])));\n  vec3 bm = min(u, min(min(s[0], s[2]), min(s[6], s[8])));\n  vec3 bn = max(v, max(max(s[0], s[2]), max(s[6], s[8])));\n  u = (u + bm) * .5;\n  v = (v + bn) * .5;\n#endif\n#if BOX_TYPE == BOX_TYPE_VARIANCE || BOX_TYPE == BOX_TYPE_AABB_VARIANCE\nvec3 bo = s[4];\n  vec3 bp = s[4] * s[4];\n  for(int bk = 1; bk < 9; bk += 2) {\n    bo += s[bk];\n    bp += s[bk] * s[bk];\n  }\n  vec3 bq = bo * (1. / 5.);\n  vec3 br = bp * (1. / 5.);\n  vec3 bs = sqrt(br - bq * bq);\n#if BOX_TYPE == BOX_TYPE_VARIANCE\nvec3 u = bq - VARIANCE_GAMMA * bs;\n  vec3 v = bq + VARIANCE_GAMMA * bs;\n#else\nu = min(u, bq - VARIANCE_GAMMA * bs);\n  v = max(v, bq + VARIANCE_GAMMA * bs);\n#endif\n#endif\nfloat bt = e(bl.rgb);\n  float bu = e(bj.rgb);\n  float bv = materialParams.alpha;\n#if PREVENT_FLICKERING\nfloat bw = 1. - abs(bt - bu) / (.001 + max(bt, bu));\n  bv *= bw * bw;\n#endif\nbl.rgb *= 1. / (1. + bt);\n  bj.rgb *= 1. / (1. + bu);\n  vec4 be = mix(bj, bl, bv);\n  be.rgb *= 1. / (1. - e(be.rgb));\n#if USE_YCoCg\nbe.rgb = m(be.rgb);\n#endif\nbe = max(vec4(0), be);\n  gl_FragColor = be;\n}",
	            extraCommandProps: {
	                viewport: {
	                    x: 0,
	                    y: 0,
	                    width: (t, e) => e.materialParams_color.width,
	                    height: (t, e) => e.materialParams_color.height
	                },
	                blend: {
	                    enable: !1
	                }
	            }
	        });
	    }
	    getMeshCommand(t, e) {
	        return this.commands.taa || (this.commands.taa = this.createREGLCommand(t, null, e.getElements())), 
	        this.commands.taa;
	    }
	}

	const Ce = [ 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, -2, 0, -1, -1, 1, 1 ];

	class Me {
	    constructor(t, e) {
	        this._jitter = e, this._renderer = t, this._halton = [], this._counter = 0;
	    }
	    needToRedraw() {
	        return this._counter < this._jitter.getSampleCount();
	    }
	    render(t, n, i, r) {
	        const s = this._jitter;
	        this._initShaders(), this._createTextures(t), r && (this._counter = 0), this._counter++;
	        const a = s.getSampleCount();
	        if (this._counter >= a) return this._prevTex;
	        this._fbo.width === t.width && this._fbo.height === t.height || this._fbo.resize(t.width, t.height);
	        const h = this._outputTex, l = this._prevTex, c = this._uniforms || {
	            materialParams_history_size: [ l.width, l.height ],
	            textureOutputSize: [],
	            materialParams: {
	                alpha: 1,
	                reprojection: [],
	                filterWeights: []
	            }
	        };
	        c.materialParams.alpha = 1 / this._counter;
	        const u = c.materialParams.reprojection;
	        multiply$5(u, this._prevProjMatrix || i, invert$2(u, i)), multiply$5(u, u, Ce), 
	        set(c.materialParams_history_size, l.width, l.height), set(c.textureOutputSize, t.width, t.height), 
	        c.materialParams_depth = n, c.materialParams_color = t, c.materialParams_history = l, 
	        this._renderer.render(this._shader, c, null, this._fbo);
	        const f = this._outputTex, d = this._fbo;
	        return this._outputTex = this._prevTex, this._fbo = this._prevFbo, this._prevTex = f, 
	        this._prevFbo = d, this._prevProjMatrix = copy$5(this._prevProjMatrix || [], i), 
	        h;
	    }
	    dispose() {
	        this._shader && (this._shader.dispose(), delete this._shader), this._fbo && this._fbo.destroy(), 
	        this._prevFbo && this._prevFbo.destroy(), delete this._uniforms;
	    }
	    _createTextures(t) {
	        if (this._outputTex) return;
	        const e = this._renderer.regl;
	        this._outputTex = this._createColorTex(t), this._fbo = e.framebuffer({
	            width: t.width,
	            height: t.height,
	            colors: [ this._outputTex ],
	            depth: !1,
	            stencil: !1
	        }), this._prevTex = this._createColorTex(t), this._prevFbo = e.framebuffer({
	            width: t.width,
	            height: t.height,
	            colors: [ this._prevTex ],
	            depth: !1,
	            stencil: !1
	        });
	    }
	    _createColorTex(t) {
	        return this._renderer.regl.texture({
	            min: "linear",
	            mag: "linear",
	            type: "uint8",
	            width: t.width,
	            height: t.height
	        });
	    }
	    _initShaders() {
	        this._shader || (this._shader = new we);
	    }
	}

	const Te = [ [ .263385, -.0252475 ], [ -.38545, .054485 ], [ -.139795, -.5379925 ], [ -.2793775, .6875475 ], [ .7139025, .4710925 ], [ .90044, -.16422 ], [ .4481775, -.82799 ], [ -.9253375, -.2910625 ], [ .3468025, 1.02292 ], [ -1.13742, .33522 ], [ -.7676225, -.9123175 ], [ -.2005775, -1.1774125 ], [ -.926525, .96876 ], [ 1.12909, -.7500325 ], [ .9603, 1.14625 ] ], Se = Te.length, Pe = [ 0, 0 ];

	for (let t = 0; t < Te.length; t++) Pe[0] += Te[t][0], Pe[1] += Te[t][1];

	Pe[0] /= Se, Pe[1] /= Se;

	class Ae {
	    constructor(t) {
	        this._frameNum = 0, this._ratio = t || .05, this._avg = [ Pe[0] * this._ratio, Pe[1] * this._ratio ];
	    }
	    getRatio() {
	        return this._ratio;
	    }
	    setRatio(t) {
	        this._ratio !== t && (this._ratio = t, this.reset()), this._avg = [ Pe[0] * this._ratio, Pe[1] * this._ratio ];
	    }
	    getAverage() {
	        return this._avg;
	    }
	    reset() {
	        this._frameNum = 0;
	    }
	    getJitter(t) {
	        const e = this._frameNum % Se, n = this._ratio;
	        return set(t, Te[e][0] * n, Te[e][1] * n), t;
	    }
	    frame() {
	        this._frameNum++, this._frameNum % Se == 0 && (this._frameNum = 0);
	    }
	    getSampleCount() {
	        return Se;
	    }
	}

	class Ee {
	    constructor(t, e, n = 5) {
	        this._regl = t, this._renderer = new N$1(t), this._inputRGBM = e, this._level = n;
	    }
	    render(t, e) {
	        this._initShaders(), this._createTextures(t), this._blur(t, e || 0);
	        const n = {
	            blurTex0: this._blur01Tex,
	            blurTex1: this._blur11Tex,
	            blurTex2: this._blur21Tex,
	            blurTex3: this._blur31Tex,
	            blurTex4: this._blur41Tex
	        };
	        return this._level > 5 && (n.blurTex5 = this._blur51Tex, n.blurTex6 = this._blur61Tex), 
	        n;
	    }
	    _blur(t, e) {
	        let n = this._blurUniforms;
	        n || (n = this._blurUniforms = {
	            rgbmRange: 7,
	            blurDir: [ 0, 0 ],
	            outSize: [ 0, 0 ],
	            pixelRatio: [ 1, 1 ],
	            outputSize: [ 0, 0 ]
	        }), set(n.outSize, t.width, t.height), this._blurOnce(this._blur0Shader, t, this._blur00FBO, this._blur01FBO, .5, e), 
	        this._blurOnce(this._blur1Shader, this._blur01FBO.color[0], this._blur10FBO, this._blur11FBO, .5), 
	        this._blurOnce(this._blur2Shader, this._blur11FBO.color[0], this._blur20FBO, this._blur21FBO, .5), 
	        this._blurOnce(this._blur3Shader, this._blur21FBO.color[0], this._blur30FBO, this._blur31FBO, .5), 
	        this._blurOnce(this._blur4Shader, this._blur31FBO.color[0], this._blur40FBO, this._blur41FBO, .5), 
	        this._level > 5 && (this._blurOnce(this._blur5Shader, this._blur41FBO.color[0], this._blur50FBO, this._blur51FBO, .5), 
	        this._blurOnce(this._blur6Shader, this._blur51FBO.color[0], this._blur60FBO, this._blur51FBO, .5));
	    }
	    _blurOnce(t, e, n, i, r, s) {
	        const a = Math.ceil(r * e.width), h = Math.ceil(r * e.height);
	        n.width === a && n.height === h || n.resize(a, h), i.width === a && i.height === h || i.resize(a, h);
	        const l = this._blurUniforms;
	        l.luminThreshold = s, l.TextureBlurInput = e, l.inputRGBM = +this._inputRGBM, set(l.blurDir, 0, 1), 
	        set(l.outputSize, n.width, n.height), this._renderer.render(t, l, null, n), l.luminThreshold = 0, 
	        l.inputRGBM = 1, set(l.blurDir, 1, 0), l.TextureBlurInput = n.color[0], this._renderer.render(t, l, null, i);
	    }
	    dispose() {
	        this._blur0Shader && (this._blur0Shader.dispose(), delete this._blur0Shader, this._blur1Shader.dispose(), 
	        this._blur2Shader.dispose(), this._blur3Shader.dispose(), this._blur4Shader.dispose(), 
	        this._blur5Shader && (this._blur5Shader.dispose(), this._blur6Shader.dispose(), 
	        delete this._blur5Shader)), this._blur00Tex && (delete this._blur00Tex, this._blur00FBO.destroy(), 
	        this._blur01FBO.destroy(), this._blur10FBO.destroy(), this._blur11FBO.destroy(), 
	        this._blur20FBO.destroy(), this._blur21FBO.destroy(), this._blur30FBO.destroy(), 
	        this._blur31FBO.destroy(), this._blur40FBO.destroy(), this._blur41FBO.destroy(), 
	        this._blur50FBO && (this._blur50FBO.destroy(), this._blur51FBO.destroy(), this._blur60FBO.destroy(), 
	        this._blur61FBO.destroy()));
	    }
	    _createTextures(t) {
	        if (this._blur00Tex) return;
	        let e = t.width, n = t.height;
	        this._blur00Tex = this._createColorTex(t, e, n), this._blur00FBO = this._createBlurFBO(this._blur00Tex), 
	        this._blur01Tex = this._createColorTex(t), this._blur01FBO = this._createBlurFBO(this._blur01Tex), 
	        e = Math.ceil(e / 2), n = Math.ceil(n / 2), this._blur10Tex = this._createColorTex(t, e, n), 
	        this._blur10FBO = this._createBlurFBO(this._blur10Tex), this._blur11Tex = this._createColorTex(t, e, n), 
	        this._blur11FBO = this._createBlurFBO(this._blur11Tex), e = Math.ceil(e / 2), n = Math.ceil(n / 2), 
	        this._blur20Tex = this._createColorTex(t, e, n), this._blur20FBO = this._createBlurFBO(this._blur20Tex), 
	        this._blur21Tex = this._createColorTex(t, e, n), this._blur21FBO = this._createBlurFBO(this._blur21Tex), 
	        e = Math.ceil(e / 2), n = Math.ceil(n / 2), this._blur30Tex = this._createColorTex(t, e, n), 
	        this._blur30FBO = this._createBlurFBO(this._blur30Tex), this._blur31Tex = this._createColorTex(t, e, n), 
	        this._blur31FBO = this._createBlurFBO(this._blur31Tex), e = Math.ceil(e / 2), n = Math.ceil(n / 2), 
	        this._blur40Tex = this._createColorTex(t, e, n), this._blur40FBO = this._createBlurFBO(this._blur40Tex), 
	        this._blur41Tex = this._createColorTex(t, e, n), this._blur41FBO = this._createBlurFBO(this._blur41Tex), 
	        this._level > 5 && (e = Math.ceil(e / 2), n = Math.ceil(n / 2), this._blur50Tex = this._createColorTex(t, e, n), 
	        this._blur50FBO = this._createBlurFBO(this._blur50Tex), this._blur51Tex = this._createColorTex(t, e, n), 
	        this._blur51FBO = this._createBlurFBO(this._blur51Tex), e = Math.ceil(e / 2), n = Math.ceil(n / 2), 
	        this._blur60Tex = this._createColorTex(t, e, n), this._blur60FBO = this._createBlurFBO(this._blur60Tex), 
	        this._blur61Tex = this._createColorTex(t, e, n), this._blur61FBO = this._createBlurFBO(this._blur61Tex));
	    }
	    _createColorTex(t, e, n) {
	        return this._regl.texture({
	            min: "linear",
	            mag: "linear",
	            type: "uint8",
	            width: e || t.width,
	            height: n || t.height
	        });
	    }
	    _createBlurFBO(t) {
	        return this._regl.framebuffer({
	            width: t.width,
	            height: t.height,
	            colors: [ t ],
	            depth: !1,
	            stencil: !1
	        });
	    }
	    _initShaders() {
	        if (!this._blur0Shader) {
	            const t = {
	                vert: ce$1,
	                extraCommandProps: {
	                    viewport: {
	                        x: 0,
	                        y: 0,
	                        width: (t, e) => e.outputSize[0],
	                        height: (t, e) => e.outputSize[1]
	                    }
	                },
	                frag: "#version 100\nprecision highp float;\nuniform float rgbmRange;\nuniform sampler2D TextureBlurInput;\nuniform sampler2D TextureInput;\nuniform vec2 blurDir;\nuniform vec2 pixelRatio;\nuniform vec2 outputSize;\nuniform float inputRGBM;\nuniform float luminThreshold;\n#define SHADER_NAME GAUSSIAN_BLUR0\nconst vec3 c = vec3(.2126, .7152, .0722);\nfloat d(const in vec3 e) {\n  return dot(e, c);\n}\nvec4 f(vec4 e) {\n  float h = max(sign(d(e.rgb) - luminThreshold), .0);\n  return e * h;\n}\nvec2 i;\nvec4 j(const in vec3 e, const in float k) {\n  vec4 l;\n  vec3 m = e / k;\n  l.a = clamp(max(max(m.r, m.g), max(m.b, 1e-6)), .0, 1.);\n  l.a = ceil(l.a * 255.) / 255.;\n  l.rgb = m / l.a;\n  return l;\n}\nvec3 n(const in vec4 e, const in float k) {\n  if(inputRGBM == .0)\n    return e.rgb;\n  return k * e.rgb * e.a;\n}\nvec4 o() {\n  vec3 u = .375 * (f(vec4(n(texture2D(TextureBlurInput, i.xy), rgbmRange), 1.))).rgb;\n  vec2 v;\n  vec2 A = pixelRatio.xy * blurDir.xy / outputSize.xy;\n  v = A * 1.2;\n  u += .3125 * (f(vec4(n(texture2D(TextureBlurInput, i.xy + v.xy), rgbmRange), 1.))).rgb;\n  u += .3125 * (f(vec4(n(texture2D(TextureBlurInput, i.xy - v.xy), rgbmRange), 1.))).rgb;\n  return vec4(u, 1.);\n}\nvoid main(void) {\n  i = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = o();\n  e = j(e.rgb, rgbmRange);\n  gl_FragColor = e;\n}"
	            };
	            this._blur0Shader = new de(t), t.frag = "#version 100\nprecision highp float;\nuniform float rgbmRange;\nuniform sampler2D TextureBlurInput;\nuniform sampler2D TextureInput;\nuniform vec2 blurDir;\nuniform vec2 pixelRatio;\nuniform vec2 outputSize;\n#define SHADER_NAME GAUSSIAN_BLUR1\nvec2 c;\nvec4 d(const in vec3 e, const in float f) {\n  if(f <= .0)\n    return vec4(e, 1.);\n  vec4 h;\n  vec3 i = e / f;\n  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);\n  h.a = ceil(h.a * 255.) / 255.;\n  h.rgb = i / h.a;\n  return h;\n}\nvec3 j(const in vec4 e, const in float f) {\n  if(f <= .0)\n    return e.rgb;\n  return f * e.rgb * e.a;\n}\nvec4 k() {\n  vec3 l = .3125 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;\n  vec2 m;\n  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;\n  m = n * 1.2857142857142858;\n  l += .328125 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .328125 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  return vec4(l, 1.);\n}\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = k();\n  e = d(e.rgb, rgbmRange);\n  gl_FragColor = e;\n}", 
	            this._blur1Shader = new de(t), t.frag = "#version 100\nprecision highp float;\nuniform float rgbmRange;\nuniform sampler2D TextureBlurInput;\nuniform sampler2D TextureInput;\nuniform vec2 blurDir;\nuniform vec2 pixelRatio;\nuniform vec2 outputSize;\n#define SHADER_NAME GAUSSIAN_BLUR2\nvec2 c;\nvec4 d(const in vec3 e, const in float f) {\n  if(f <= .0)\n    return vec4(e, 1.);\n  vec4 h;\n  vec3 i = e / f;\n  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);\n  h.a = ceil(h.a * 255.) / 255.;\n  h.rgb = i / h.a;\n  return h;\n}\nvec3 j(const in vec4 e, const in float f) {\n  if(f <= .0)\n    return e.rgb;\n  return f * e.rgb * e.a;\n}\nvec4 k() {\n  vec3 l = .2734375 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;\n  vec2 m;\n  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;\n  m = n * 1.3333333333333333;\n  l += .328125 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .328125 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 3.111111111111111;\n  l += .03515625 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .03515625 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  return vec4(l, 1.);\n}\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = k();\n  e = d(e.rgb, rgbmRange);\n  gl_FragColor = e;\n}", 
	            this._blur2Shader = new de(t), t.frag = "#version 100\nprecision highp float;\nuniform float rgbmRange;\nuniform sampler2D TextureBlurInput;\nuniform sampler2D TextureInput;\nuniform vec2 blurDir;\nuniform vec2 pixelRatio;\nuniform vec2 outputSize;\n#define SHADER_NAME GAUSSIAN_BLUR3\nvec2 c;\nvec4 d(const in vec3 e, const in float f) {\n  if(f <= .0)\n    return vec4(e, 1.);\n  vec4 h;\n  vec3 i = e / f;\n  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);\n  h.a = ceil(h.a * 255.) / 255.;\n  h.rgb = i / h.a;\n  return h;\n}\nvec3 j(const in vec4 e, const in float f) {\n  if(f <= .0)\n    return e.rgb;\n  return f * e.rgb * e.a;\n}\nvec4 k() {\n  vec3 l = .24609375 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;\n  vec2 m;\n  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;\n  m = n * 1.3636363636363635;\n  l += .322265625 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .322265625 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 3.1818181818181817;\n  l += .0537109375 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .0537109375 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  return vec4(l, 1.);\n}\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = k();\n  e = d(e.rgb, rgbmRange);\n  gl_FragColor = e;\n}", 
	            this._blur3Shader = new de(t), t.frag = "#version 100\nprecision highp float;\nuniform float rgbmRange;\nuniform sampler2D TextureBlurInput;\nuniform sampler2D TextureInput;\nuniform vec2 blurDir;\nuniform vec2 pixelRatio;\nuniform vec2 outputSize;\n#define SHADER_NAME GAUSSIAN_BLUR4\nvec2 c;\nvec4 d(const in vec3 e, const in float f) {\n  if(f <= .0)\n    return vec4(e, 1.);\n  vec4 h;\n  vec3 i = e / f;\n  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);\n  h.a = ceil(h.a * 255.) / 255.;\n  h.rgb = i / h.a;\n  return h;\n}\nvec3 j(const in vec4 e, const in float f) {\n  if(f <= .0)\n    return e.rgb;\n  return f * e.rgb * e.a;\n}\nvec4 k() {\n  vec3 l = .2255859375 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;\n  vec2 m;\n  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;\n  m = n * 1.3846153846153846;\n  l += .314208984375 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .314208984375 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 3.230769230769231;\n  l += .06982421875 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .06982421875 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 5.076923076923077;\n  l += .003173828125 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .003173828125 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  return vec4(l, 1.);\n}\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = k();\n  e = d(e.rgb, rgbmRange);\n  gl_FragColor = e;\n}", 
	            this._blur4Shader = new de(t), this._level > 5 && (t.frag = "precision highp float;\nuniform float rgbmRange;\nuniform sampler2D TextureBlurInput;\nuniform sampler2D TextureInput;\nuniform vec2 blurDir;\nuniform vec2 outSize;\nuniform vec2 pixelRatio;\nuniform vec2 outputSize;\n#define SHADER_NAME GAUSSIAN_BLUR5\nvec2 c;\nvec4 d(const in vec3 e, const in float f) {\n  if(f <= .0)\n    return vec4(e, 1.);\n  vec4 h;\n  vec3 i = e / f;\n  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);\n  h.a = ceil(h.a * 255.) / 255.;\n  h.rgb = i / h.a;\n  return h;\n}\nvec3 j(const in vec4 e, const in float f) {\n  if(f <= .0)\n    return e.rgb;\n  return f * e.rgb * e.a;\n}\nvec4 k() {\n  vec3 l = .20947265625 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;\n  vec2 m;\n  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;\n  n *= outSize.y * .00075;\n  m = n * 1.4;\n  l += .30548095703125 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .30548095703125 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 3.2666666666666666;\n  l += .08331298828125 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .08331298828125 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 5.133333333333334;\n  l += .00640869140625 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .00640869140625 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  return vec4(l, 1.);\n}\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = k();\n  e = d(e.rgb, rgbmRange);\n  gl_FragColor = e;\n}", 
	            this._blur5Shader = new de(t), t.frag = "#version 100\nprecision highp float;\nuniform float rgbmRange;\nuniform sampler2D TextureBlurInput;\nuniform sampler2D TextureInput;\nuniform vec2 blurDir;\nuniform vec2 outSize;\nuniform vec2 pixelRatio;\nuniform vec2 outputSize;\n#define SHADER_NAME GAUSSIAN_BLUR6\nvec2 c;\nvec4 d(const in vec3 e, const in float f) {\n  if(f <= .0)\n    return vec4(e, 1.);\n  vec4 h;\n  vec3 i = e / f;\n  h.a = clamp(max(max(i.r, i.g), max(i.b, 1e-6)), .0, 1.);\n  h.a = ceil(h.a * 255.) / 255.;\n  h.rgb = i / h.a;\n  return h;\n}\nvec3 j(const in vec4 e, const in float f) {\n  if(f <= .0)\n    return e.rgb;\n  return f * e.rgb * e.a;\n}\nvec4 k() {\n  vec3 l = .196380615234375 * (vec4(j(texture2D(TextureBlurInput, c.xy), rgbmRange), 1.)).rgb;\n  vec2 m;\n  vec2 n = pixelRatio.xy * blurDir.xy / outputSize.xy;\n  n *= outSize.y * .00075;\n  m = n * 1.411764705882353;\n  l += .2967529296875 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .2967529296875 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 3.2941176470588234;\n  l += .09442138671875 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .09442138671875 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  m = n * 5.176470588235294;\n  l += .0103759765625 * (vec4(j(texture2D(TextureBlurInput, c.xy + m.xy), rgbmRange), 1.)).rgb;\n  l += .0103759765625 * (vec4(j(texture2D(TextureBlurInput, c.xy - m.xy), rgbmRange), 1.)).rgb;\n  return vec4(l, 1.);\n}\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = k();\n  e = d(e.rgb, rgbmRange);\n  gl_FragColor = e;\n}", 
	            this._blur6Shader = new de(t));
	        }
	    }
	}

	class Oe {
	    constructor(t) {
	        this._regl = t, this._renderer = new N$1(t);
	    }
	    render(t, e, n, i, r, o, s, a, h) {
	        this._initShaders(), this._createTextures(t);
	        const l = this._blurPass.render(e, n);
	        return this._combine(t, l, e, i, r, o, s, a, h);
	    }
	    _combine(t, e, n, i, r, s, a, h, l) {
	        l || this._combineTex.width === t.width && this._combineTex.height === t.height || this._combineFBO.resize(t.width, t.height);
	        let c = this._combineUniforms;
	        const {blurTex0: u, blurTex1: f, blurTex2: d, blurTex3: m, blurTex4: g} = e;
	        c || (c = this._combineUniforms = {
	            bloomFactor: 0,
	            bloomRadius: 0,
	            rgbmRange: 7,
	            TextureBloomBlur1: u,
	            TextureBloomBlur2: f,
	            TextureBloomBlur3: d,
	            TextureBloomBlur4: m,
	            TextureBloomBlur5: g,
	            TextureInput: null,
	            TextureSource: null,
	            outputSize: [ 0, 0 ]
	        }), c.noAaTextureSource = s, c.pointTextureSource = a, c.enableAA = h, c.bloomFactor = i, 
	        c.bloomRadius = r, c.TextureInput = n, c.TextureSource = t, set(c.outputSize, t.width, t.height);
	        const p = {};
	        return s ? p.HAS_NOAA_TEX = 1 : delete p.HAS_NOAA_TEX, a ? p.HAS_POINT_TEX = 1 : delete p.HAS_POINT_TEX, 
	        this._combineShader.setDefines(p), this._renderer.render(this._combineShader, c, null, l ? null : this._combineFBO), 
	        l ? null : this._combineTex;
	    }
	    dispose() {
	        this._combineFBO && (this._combineFBO.destroy(), delete this._combineFBO), this._blurPass && (this._blurPass.dispose(), 
	        delete this._blurPass), delete this._uniforms;
	    }
	    _createTextures(t) {
	        if (this._combineTex) return;
	        this._combineTex = this._createColorTex(t, t.width, t.height, "uint8"), this._combineFBO = this._createBlurFBO(this._combineTex);
	    }
	    _createColorTex(t, e, n, i) {
	        const r = this._renderer.regl, o = i || (r.hasExtension("OES_texture_half_float") ? "float16" : "float");
	        return r.texture({
	            min: "linear",
	            mag: "linear",
	            type: o,
	            width: e || t.width,
	            height: n || t.height
	        });
	    }
	    _createBlurFBO(t) {
	        return this._renderer.regl.framebuffer({
	            width: t.width,
	            height: t.height,
	            colors: [ t ],
	            depth: !1,
	            stencil: !1
	        });
	    }
	    _initShaders() {
	        if (!this._combineShader) {
	            const t = {
	                x: 0,
	                y: 0,
	                width: (t, e) => e.outputSize[0],
	                height: (t, e) => e.outputSize[1]
	            };
	            this._blurPass = new Ee(this._regl, !1), this._combineShader = new de({
	                vert: ce$1,
	                frag: "#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#define FXAA_SPAN_MAX     8.0\nprecision highp float;\nuniform float bloomFactor;\nuniform float bloomRadius;\nuniform float rgbmRange;\nuniform sampler2D TextureBloomBlur1;\nuniform sampler2D TextureBloomBlur2;\nuniform sampler2D TextureBloomBlur3;\nuniform sampler2D TextureBloomBlur4;\nuniform sampler2D TextureBloomBlur5;\nuniform sampler2D TextureInput;\nuniform sampler2D TextureSource;\n#ifdef HAS_NOAA_TEX\nuniform sampler2D noAaTextureSource;\n#endif\n#ifdef HAS_POINT_TEX\nuniform sampler2D pointTextureSource;\n#endif\nuniform float enableAA;\nuniform vec2 outputSize;\n#define SHADER_NAME bloomCombine\nvec2 c;\nvec3 d(const in vec3 e) {\n  return vec3(e.r < .0031308 ? e.r * 12.92 : 1.055 * pow(e.r, 1. / 2.4) - .055, e.g < .0031308 ? e.g * 12.92 : 1.055 * pow(e.g, 1. / 2.4) - .055, e.b < .0031308 ? e.b * 12.92 : 1.055 * pow(e.b, 1. / 2.4) - .055);\n}\nvec3 f(const in vec4 e, const in float h) {\n  if(h <= .0)\n    return e.rgb;\n  return h * e.rgb * e.a;\n}\nfloat i(const float j, const float k) {\n  return mix(j, k * 2. - j, bloomRadius);\n}\nvec4 l(sampler2D m, vec2 n) {\n  vec4 e;\n  mediump vec2 o = vec2(1. / outputSize.x, 1. / outputSize.y);\n  vec3 u = texture2D(m, (n + vec2(-1., -1.)) * o).xyz;\n  vec3 v = texture2D(m, (n + vec2(1., -1.)) * o).xyz;\n  vec3 A = texture2D(m, (n + vec2(-1., 1.)) * o).xyz;\n  vec3 B = texture2D(m, (n + vec2(1.)) * o).xyz;\n  vec4 C = texture2D(m, n * o);\n  vec3 D = C.xyz;\n  vec3 E = vec3(.299, .587, .114);\n  float F = dot(u, E);\n  float G = dot(v, E);\n  float H = dot(A, E);\n  float I = dot(B, E);\n  float J = dot(D, E);\n  float K = min(J, min(min(F, G), min(H, I)));\n  float L = max(J, max(max(F, G), max(H, I)));\n  mediump vec2 M;\n  M.x = -((F + G) - (H + I));\n  M.y = (F + H) - (G + I);\n  float N = max((F + G + H + I) * (.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n  float O = 1. / (min(abs(M.x), abs(M.y)) + N);\n  M = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), M * O)) * o;\n  vec4 P = .5 * (texture2D(m, n * o + M * (1. / 3. - .5)) + texture2D(m, n * o + M * (2. / 3. - .5)));\n  vec4 Q = P * .5 + .25 * (texture2D(m, n * o + M * -.5) + texture2D(m, n * o + M * .5));\n  float R = dot(Q.xyz, E);\n  if(R < K || R > L)\n    e = P;\n  else\n    e = Q;\n  return e;\n}\nvec4 S() {\n  vec3 T = vec3(.0);\n  const float U = .6;\n  const float V = 1.1;\n  const float W = .9;\n  const float X = .6;\n  const float Y = .3;\n  const float Z = .1;\n  T += (vec4(f(texture2D(TextureBloomBlur1, c), rgbmRange), 1.)).rgb * i(V, U);\n  T += (vec4(f(texture2D(TextureBloomBlur2, c), rgbmRange), 1.)).rgb * i(W, U);\n  T += (vec4(f(texture2D(TextureBloomBlur3, c), rgbmRange), 1.)).rgb * i(X, U);\n  T += (vec4(f(texture2D(TextureBloomBlur4, c), rgbmRange), 1.)).rgb * i(Y, U);\n  T += (vec4(f(texture2D(TextureBloomBlur5, c), rgbmRange), 1.)).rgb * i(Z, U);\n  vec4 ba;\n  if(enableAA == 1.) {\n    ba = l(TextureInput, gl_FragCoord.xy);\n  } else {\n    ba = texture2D(TextureInput, c);\n  }\n  ba.rgb = mix(vec3(.0), ba.rgb, sign(ba.a));\n  vec4 bb = texture2D(TextureSource, c);\n#ifdef HAS_NOAA_TEX\nvec4 bc = texture2D(noAaTextureSource, c);\n  bb = bc + bb * (1. - bc.a);\n#endif\nvec4 bd = vec4(.0);\n#ifdef HAS_POINT_TEX\nbd = texture2D(pointTextureSource, c);\n#endif\nfloat be = sqrt((T.r + T.g + T.b) / 3.);\n  vec4 bf = vec4(d(T * bloomFactor), be);\n  return bd + (ba + bb * (1. - ba.a)) * (1. - bd.a) + bf;\n}\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 e = S();\n  gl_FragColor = e;\n}",
	                extraCommandProps: {
	                    viewport: t
	                }
	            });
	        }
	    }
	}

	class Re extends de {
	    constructor() {
	        const t = [];
	        super({
	            vert: ce$1,
	            frag: "precision highp float;\n#include <gl2_frag>\n#define SHADER_NAME COPY_DEPTH\nuniform sampler2D TextureDepth;\nuniform vec2 textureSize;\n#include <common_pack_float>\nvoid main(void) {\n  vec2 c = gl_FragCoord.xy / textureSize.xy;\n  float d = texture2D(TextureDepth, c).r;\n  glFragColor = common_encodeDepth(d);\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",
	            uniforms: [ {
	                name: "textureSize",
	                type: "function",
	                fn: (e, n) => (t[0] = n.TextureDepth.width, t[1] = n.TextureDepth.height, t)
	            } ],
	            extraCommandProps: {
	                viewport: {
	                    x: 0,
	                    y: 0,
	                    width: (t, e) => e.TextureDepth.width,
	                    height: (t, e) => e.TextureDepth.height
	                }
	            }
	        }), this.version = 300;
	    }
	    getMeshCommand(t, e) {
	        return this.commands.copy_depth || (this.commands.copy_depth = this.createREGLCommand(t, null, e.getElements())), 
	        this.commands.copy_depth;
	    }
	}

	class Ie {
	    static getUniformDeclares() {
	        const t = [ [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], n = new Array(16);
	        return [ {
	            name: "invProjMatrix",
	            type: "function",
	            fn: (t, i) => invert$2(n, i.projMatrix)
	        }, {
	            name: "outputFovInfo",
	            type: "array",
	            length: 2,
	            fn: function(e, n) {
	                const r = Math.tan(.5 * n.fov), o = n.outSize[0] / n.outSize[1] * r;
	                return set$3(t[0], o, r, o, -r), set$3(t[1], -o, r, -o, -r), t;
	            }
	        }, {
	            name: "reprojViewProjMatrix",
	            type: "function",
	            fn: (t, n) => multiply$5([], n.prevProjViewMatrix, n.cameraWorldMatrix)
	        } ];
	    }
	    static getDefines() {
	        return {
	            HAS_SSR: 1
	        };
	    }
	    constructor(t) {
	        this._regl = t, this._renderer = new N$1(t), this._inputRGBM = 0;
	    }
	    setup(t) {
	        this._initShaders(), this._createTextures(t);
	    }
	    getSSRUniforms(t, e, n) {
	        if (!this._depthCopy) return null;
	        const i = this._depthCopy;
	        return {
	            TextureDepth: i,
	            TextureReflected: this.getMipmapTexture(),
	            ssrFactor: e || 1,
	            ssrQuality: n || 2,
	            outSize: [ i.width, i.height ],
	            fov: t.getFov() * Math.PI / 180,
	            prevProjViewMatrix: this._projViewMatrix || t.projViewMatrix,
	            cameraWorldMatrix: t.cameraWorldMatrix
	        };
	    }
	    genMipMap(t, n, i) {
	        return this.setup(t), this._mipmap(t), this.copyDepthTex(n), this._projViewMatrix || (this._projViewMatrix = []), 
	        copy$5(this._projViewMatrix, i), delete this._depthCopied, this._outputTex;
	    }
	    getPrevProjViewMatrix() {
	        return this._projViewMatrix;
	    }
	    copyDepthTex(t) {
	        if (this._depthCopied) return null;
	        if (this.setup(t), this._depthCopy) t.width === this._depthCopy.width && t.height === this._depthCopy.height || this._depthCopyFBO.resize(t.width, t.height); else {
	            this._depthCopy = this._regl.texture({
	                min: "nearest",
	                mag: "nearest",
	                mipmap: !1,
	                type: "uint8",
	                width: t.width,
	                height: t.height
	            });
	            this._depthCopyFBO = this._regl.framebuffer({
	                width: t.width,
	                height: t.height,
	                colors: [ this._depthCopy ],
	                colorFormat: "rgba"
	            });
	        }
	        return this._renderer.render(this._copyDepthShader, {
	            TextureDepth: t
	        }, null, this._depthCopyFBO), this._depthCopied = !0, this._depthCopy;
	    }
	    _mipmap(t) {
	        const e = this._targetFBO, n = Math.ceil(.5 * t.width), i = Math.ceil(.5 * t.height);
	        e.width === n && e.height === i || e.resize(n, i);
	        let r = this._blurUniforms;
	        r || (r = this._blurUniforms = {
	            rgbmRange: 7,
	            outputSize: [ 0, 0 ]
	        }), r.TextureInput = t, r.inputRGBM = +this._inputRGBM, set(r.outputSize, e.width, e.height), 
	        this._renderer.render(this._ssrQuadShader, r, null, e);
	    }
	    getMipmapTexture() {
	        return this._outputTex || (this._outputTex = this._renderer.regl.texture({
	            type: "uint8",
	            width: 2,
	            height: 2
	        })), this._outputTex;
	    }
	    dispose() {
	        this._copyDepthShader && (this._ssrQuadShader.dispose(), this._copyDepthShader.dispose(), 
	        this._targetFBO.destroy(), delete this._copyDepthShader), this._depthCopy && (this._depthCopyFBO.destroy(), 
	        delete this._depthCopy, delete this._depthCopyFBO);
	    }
	    _initShaders() {
	        if (!this._copyDepthShader) {
	            this._copyDepthShader = new Re;
	            this._ssrQuadShader = new de({
	                vert: ce$1,
	                frag: "#version 100\nprecision mediump float;\nuniform sampler2D TextureInput;\nuniform vec2 outputSize;\n#define SHADER_NAME QUAD\nvec2 c;\nvoid main(void) {\n  c = gl_FragCoord.xy / outputSize.xy;\n  vec4 d = texture2D(TextureInput, c.xy);\n  gl_FragColor = d;\n}",
	                extraCommandProps: {
	                    viewport: {
	                        x: 0,
	                        y: 0,
	                        width: (t, e) => e.outputSize[0],
	                        height: (t, e) => e.outputSize[1]
	                    }
	                }
	            });
	        }
	    }
	    _createTextures(t) {
	        if (!this._targetFBO) {
	            const e = this._regl;
	            this._outputTex && this._outputTex.destroy(), this._outputTex = e.texture({
	                min: "linear",
	                mag: "linear",
	                type: "uint8",
	                width: t.width,
	                height: t.height
	            }), this._targetFBO = e.framebuffer({
	                width: t.width,
	                height: t.height,
	                colors: [ this._outputTex ],
	                depth: !1,
	                stencil: !1
	            });
	        }
	    }
	}

	class ke extends ie$1 {
	    constructor(t) {
	        const n = [];
	        super({
	            vert: "#define SHADER_NAME HEATMAP\nfloat c(const vec2 d, const float t) {\n  return mix(d[0], d[1], t);\n}\nuniform mat4 projViewModelMatrix;\nuniform float extrudeScale;\nuniform float heatmapIntensity;\nattribute vec3 aPosition;\nvarying vec2 vExtrude;\n#ifdef HAS_HEAT_WEIGHT\nuniform lowp float heatmapWeightT;\nattribute highp vec2 aWeight;\nvarying highp float weight;\n#else\nuniform highp float heatmapWeight;\n#endif\nuniform mediump float heatmapRadius;\nconst highp float e = 1. / 255. / 16.;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n  \n#ifdef HAS_HEAT_WEIGHT\nweight = c(aWeight, heatmapWeightT);\n#else\nhighp float f = heatmapWeight;\n#endif\nmediump float h = heatmapRadius;\n  vec2 i = vec2(mod(aPosition.xy, 2.) * 2. - 1.);\n  float j = sqrt(-2. * log(e / f / heatmapIntensity / GAUSS_COEF)) / 3.;\n  vExtrude = j * i;\n  vec2 k = vExtrude * h * extrudeScale;\n  vec4 l = vec4(floor(aPosition.xy * .5) + k, aPosition.z, 1);\n  gl_Position = projViewModelMatrix * l;\n}",
	            frag: "#define SHADER_NAME HEATMAP\nprecision mediump float;\nuniform highp float heatmapIntensity;\nvarying vec2 vExtrude;\n#ifdef HAS_HEAT_WEIGHT\nvarying highp float weight;\n#else\nuniform highp float heatmapWeight;\n#endif\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n  \n#ifndef HAS_HEAT_WEIGHT\nhighp float c = heatmapWeight;\n#endif\nfloat d = -.5 * 3. * 3. * dot(vExtrude, vExtrude);\n  float e = c * heatmapIntensity * GAUSS_COEF * exp(d);\n  gl_FragColor = vec4(e, 1., 1., 1.);\n}",
	            uniforms: [ {
	                name: "extrudeScale",
	                type: "function",
	                fn: function(t, e) {
	                    return e.resolution / e.dataResolution * e.tileRatio;
	                }
	            }, {
	                name: "projViewModelMatrix",
	                type: "function",
	                fn: function(t, i) {
	                    return multiply$5(n, i.projViewMatrix, i.modelMatrix);
	                }
	            } ],
	            extraCommandProps: g({}, t && t.extraCommandProps || {}, {
	                blend: {
	                    enable: !0,
	                    func: {
	                        src: "one",
	                        dst: "one"
	                    },
	                    equation: "add"
	                }
	            })
	        });
	    }
	}

	var De = [ -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, 1, -1, 1 ], Le = "#define SHADER_NAME SKYBOX\n#if __VERSION__ == 100\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod(tex, uv, lod) textureCubeLodEXT(tex, uv, lod)\n#else\n#define textureCubeLod(tex, uv, lod) textureCube(tex, uv, lod)\n#endif\n#else\n#define textureCubeLod(tex, uv, lod) textureLod(tex, uv, lod)\n#endif\nprecision highp float;\n#include <gl2_frag>\n#include <hsv_frag>\nuniform vec3 hsv;\nvarying vec3 vWorldPos;\n#ifdef USE_AMBIENT\nuniform vec3 diffuseSPH[9];\n#else\nuniform samplerCube cubeMap;\nuniform float bias;\nuniform float size;\n#endif\nuniform float environmentExposure;\n#if defined(INPUT_RGBM) || defined(ENC_RGBM)\nuniform float rgbmRange;\n#endif\nvec4 c(const in vec3 d, const in float e) {\n  if(e <= .0)\n    return vec4(d, 1.);\n  vec4 f;\n  vec3 h = d / e;\n  f.a = clamp(max(max(h.r, h.g), max(h.b, 1e-6)), .0, 1.);\n  f.a = ceil(f.a * 255.) / 255.;\n  f.rgb = h / f.a;\n  return f;\n}\nvec3 i(const in vec4 d, const in float e) {\n  if(e <= .0)\n    return d.rgb;\n  return e * d.rgb * d.a;\n}\nvec4 j(const in samplerCube k, const in vec3 l, const in float m, const in float n) {\n  vec3 o = l;\n  return textureCubeLod(k, o, n);\n}\nvec3 u(const in vec3 v, const in vec3 A[9]) {\n  float x = v.x;\n  float y = v.y;\n  float z = v.z;\n  vec3 B = (A[0] + A[1] * x + A[2] * y + A[3] * z + A[4] * z * x + A[5] * y * z + A[6] * y * x + A[7] * (3. * z * z - 1.) + A[8] * (x * x - y * y));\n  return max(B, vec3(.0));\n}\nfloat C(const in vec2 D) {\n  vec3 E = fract(vec3(D.xyx) * .1031);\n  E += dot(E, E.yzx + 19.19);\n  return fract((E.x + E.y) * E.z);\n}\nvoid main() {\n  vec4 F;\n#ifdef USE_AMBIENT\nvec3 v = normalize(vWorldPos + mix(-.5 / 255., .5 / 255., C(gl_FragCoord.xy)) * 2.);\n  F = vec4(u(v, diffuseSPH), 1.);\n  if(length(hsv) > .0) {\n    F.rgb = hsv_apply(F.rgb, hsv);\n  }\n#else\nF = j(cubeMap, vWorldPos, size, bias);\n#endif\nF.rgb *= environmentExposure;\n#ifdef ENC_RGBM\n#if !defined(USE_AMBIENT) && defined(INPUT_RGBM)\nif(length(hsv) > .0) {\n    F.rgb = hsv_apply(i(F, rgbmRange).rgb, hsv);\n    F = c(F.rgb, rgbmRange);\n  }\n#else\nF = c(F.rgb, rgbmRange);\n#endif\nglFragColor = F;\n#elif !defined(USE_AMBIENT) && defined(INPUT_RGBM)\nglFragColor = vec4(i(F, rgbmRange), 1.);\n  if(length(hsv) > .0) {\n    glFragColor.rgb = hsv_apply(clamp(glFragColor.rgb, .0, 1.), hsv);\n  }\n#else\nif(length(hsv) > .0) {\n    F.rgb = hsv_apply(F.rgb, hsv);\n  }\n  glFragColor = F;\n#endif\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}";

	class ze extends ie$1 {
	    constructor() {
	        super({
	            vert: "#include <gl2_vert>\nattribute vec3 aPosition;\nuniform mat4 projMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 transformMatrix;\nvarying vec3 vWorldPos;\nvoid main() {\n  vWorldPos = aPosition;\n  mat4 c = mat4(mat3(viewMatrix) * transformMatrix);\n  vec4 d = projMatrix * c * vec4(vWorldPos, 1.);\n  gl_Position = d.xyww;\n}",
	            frag: Le,
	            extraCommandProps: {
	                depth: {
	                    enable: !0,
	                    range: [ 1, 1 ],
	                    func: "lequal"
	                },
	                viewport: {
	                    x: 0,
	                    y: 0,
	                    width: (t, e) => e.resolution[0],
	                    height: (t, e) => e.resolution[1]
	                }
	            }
	        }), this.version = 300;
	    }
	    setMode(t, e, n) {
	        const i = {};
	        return t && (i.INPUT_RGBM = 1), e && (i.ENC_RGBM = 1), 0 === n && (i.USE_AMBIENT = 1), 
	        this._skyboxMesh ? this._skyboxMesh[0].setDefines(i) : this._meshDefines = i, this;
	    }
	    draw(t) {
	        return this._skyboxMesh || this._createSkyboxMesh(t), super.draw(t, this._skyboxMesh);
	    }
	    _createSkyboxMesh(t) {
	        const e = new Q$1({
	            aPosition: new Int8Array(De)
	        }, null, De.length / 3);
	        e.generateBuffers(t), this._skyboxMesh = [ new ft$1(e) ], this._meshDefines && (this._skyboxMesh[0].setDefines(this._meshDefines), 
	        delete this._meshDefines);
	    }
	    dispose() {
	        if (this._skyboxMesh) {
	            const t = this._skyboxMesh[0];
	            t.geometry.dispose(), t.dispose();
	        }
	        return delete this._skyboxMesh, super.dispose();
	    }
	}

	class Fe extends ie$1 {
	    constructor(t, n) {
	        const i = {
	            blend: {
	                enable: !0,
	                func: {
	                    src: "one",
	                    dst: "one minus src alpha"
	                },
	                equation: "add"
	            },
	            viewport: t
	        };
	        n && n.extraCommandProps && g(i, n.extraCommandProps);
	        const r = [];
	        super({
	            vert: "#define SHADER_NAME HEATMAP_DISPLAY\nuniform mat4 projViewModelMatrix;\nattribute vec3 aPosition;\nvoid main() {\n  gl_Position = projViewModelMatrix * vec4(aPosition, 1.);\n}",
	            frag: "#define SHADER_NAME HEATMAP_DISPLAY\nprecision mediump float;\nuniform sampler2D inputTexture;\nuniform sampler2D colorRamp;\nuniform vec2 textureOutputSize;\nuniform float heatmapOpacity;\nvoid main() {\n  vec2 c = gl_FragCoord.xy / textureOutputSize.xy;\n  float t = texture2D(inputTexture, c).r;\n  vec4 d = texture2D(colorRamp, vec2(t, .5));\n  gl_FragColor = d * heatmapOpacity;\n}",
	            uniforms: [ {
	                name: "projViewModelMatrix",
	                type: "function",
	                fn: function(t, n) {
	                    return multiply$5(r, n.projViewMatrix, n.modelMatrix);
	                }
	            } ],
	            extraCommandProps: i
	        });
	    }
	}

	class je extends ie$1 {
	    constructor(t = {}) {
	        super({
	            vert: "precision highp float;\nprecision highp sampler2D;\nconst float c = 3.141592653589793;\nuniform mat4 projMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 modelMatrix;\nattribute vec3 aPosition;\nattribute vec2 aTexCoord;\nattribute vec3 aNormal;\nvarying vec2 vuv;\nvarying vec3 vpos;\nvarying vec3 vnormal;\nvarying mat3 vtbnMatrix;\nvec4 d(mat4 e, mat4 f, vec3 h) {\n  return e * modelMatrix * f * vec4(h, 1.);\n}\nvec3 i(in vec3 h, in vec3 j) {\n  return normalize(h + j);\n}\nmat3 k(in vec3 l) {\n  vec3 t = normalize(cross(vec3(.0, .0, 1.), l));\n  vec3 b = normalize(cross(l, t));\n  return mat3(t, b, l);\n}\nvoid m() {\n  \n}\nvoid main(void) {\n  vuv = aTexCoord;\n  vpos = (modelMatrix * vec4(aPosition, 1.)).xyz;\n  vnormal = aNormal;\n  vtbnMatrix = k(vnormal);\n  gl_Position = d(projMatrix, viewMatrix, vpos);\n  m();\n}",
	            frag: "precision highp float;\nprecision highp sampler2D;\nuniform sampler2D texWaveNormal;\nuniform sampler2D texWavePerturbation;\nuniform vec3 octaveTextureRepeat;\nuniform vec4 waveParams;\nuniform vec2 waveDirection;\nuniform vec4 waterColor;\nuniform vec3 lightingDirection;\nuniform vec3 lightingIntensity;\nuniform vec3 camPos;\nuniform float timeElapsed;\nvarying vec2 vuv;\nvarying vec3 vpos;\nvarying vec3 vnormal;\nvarying mat3 vtbnMatrix;\nconst vec2 c = vec2(6. / 25., 5. / 24.);\nvec2 d(sampler2D e, vec2 f) {\n  return 2. * texture2D(e, f).rg - 1.;\n}\nfloat h(vec2 f) {\n  return texture2D(texWavePerturbation, f).b;\n}\nvec3 i(sampler2D e, vec2 f) {\n  return 2. * texture2D(e, f).rgb - 1.;\n}\nfloat j(vec2 f, float k) {\n  return fract(k);\n}\nfloat l(vec2 f, float k) {\n  float m = j(f, k);\n  return 1. - abs(1. - 2. * m);\n}\nvec3 n(sampler2D o, vec2 f, float k, float u) {\n  float v = waveParams[2];\n  float A = waveParams[3];\n  vec2 B = d(o, f) * v;\n  float m = j(f, k + u);\n  float C = l(f, k + u);\n  vec2 D = f;\n  D -= B * (m + A);\n  D += u;\n  D += (k - m) * c;\n  return vec3(D, C);\n}\nconst float E = .3737;\nconst float F = 7.77;\nvec3 G(sampler2D H, sampler2D I, vec2 f, vec2 J, float k) {\n  float K = waveParams[0];\n  vec2 L = k * -J;\n  float M = h(f * E) * F;\n  vec3 N = n(I, f + L, k + M, .0);\n  vec3 O = n(I, f + L, k + M, .5);\n  vec3 P = i(H, N.xy) * N.z;\n  vec3 Q = i(H, O.xy) * O.z;\n  vec3 R = normalize(P + Q);\n  R.xy *= K;\n  R.z = sqrt(1. - dot(R.xy, R.xy));\n  return R;\n}\nvec3 S(vec2 f, float k) {\n  float T = waveParams[1];\n  return G(texWaveNormal, texWavePerturbation, f * T, waveDirection, k);\n}\nconst float U = 3.141592653589793;\nconst float V = 1. / U;\nconst float W = .3183098861837907;\nconst float X = 1.570796326794897;\nstruct PBRShadingWater {\n  float NdotL;\n  float NdotV;\n  float NdotH;\n  float VdotH;\n  float LdotH;\n  float VdotN;\n};\nfloat Y = 2.2;\nvec3 Z(float ba, vec3 bb, float bc) {\n  return bb + (bc - bb) * pow(1. - ba, 5.);\n}\nfloat bd(float be, float bf) {\n  float bg = bf * bf;\n  float bh = be * be;\n  float bi = pow((bh * (bg - 1.) + 1.), Y) * U;\n  return bg / bi;\n}\nfloat bj(float bk) {\n  return .25 / (bk * bk);\n}\nvec3 bl(in PBRShadingWater bm, float bf, vec3 bn, float bo) {\n  vec3 bp = Z(bm.VdotH, bn, bo);\n  float bq = bd(bm.NdotH, bf);\n  float br = bj(bm.LdotH);\n  return (bq * br) * bp;\n}\nvec3 bs(const vec3 x) {\n  return (x * (2.51 * x + .03)) / (x * (2.43 * x + .59) + .14);\n}\nconst float bt = 2.2;\nconst float bu = .4545454545;\nvec4 bv(vec4 bw) {\n  return vec4(pow(bw.rgb, vec3(bu)), bw.w);\n}\nvec3 bx(vec3 bw) {\n  return pow(bw, vec3(bt));\n}\nconst vec3 by = vec3(.02, 1., 5.);\nconst vec2 bz = vec2(.02, .1);\nconst float bf = .06;\nconst vec3 bA = vec3(0, .6, .9);\nconst vec3 bB = vec3(.72, .92, 1.);\nPBRShadingWater bC;\nvec3 bD(in float bE, in vec3 bF, in vec3 bG) {\n  float bH = pow((1. - bE), by[2]);\n  return mix(bG, bF, bH);\n}\nvec3 bI(in vec3 bJ, in vec3 bK, in vec3 bL, vec3 bw, in vec3 bM, in vec3 bN, in float bO) {\n  vec3 bP = bx(bw);\n  vec3 bQ = normalize(bL + bK);\n  bC.NdotL = clamp(dot(bJ, bL), .0, 1.);\n  bC.NdotV = clamp(dot(bJ, bK), .001, 1.);\n  bC.VdotN = clamp(dot(bK, bJ), .001, 1.);\n  bC.NdotH = clamp(dot(bJ, bQ), .0, 1.);\n  bC.VdotH = clamp(dot(bK, bQ), .0, 1.);\n  bC.LdotH = clamp(dot(bL, bQ), .0, 1.);\n  float bR = max(dot(bN, bK), .0);\n  vec3 bS = bx(bB);\n  vec3 bT = bx(bA);\n  vec3 bB = bD(bR, bS, bT);\n  float bU = max(dot(bN, bL), .0);\n  bB *= .1 + bU * .9;\n  float bV = clamp(bO, .8, 1.);\n  vec3 bW = Z(bC.VdotN, vec3(by[0]), by[1]) * bB * bV;\n  vec3 bX = bP * mix(bB, bU * bM * V, 2. / 3.) * bV;\n  vec3 bY = vec3(.0);\n  if(bR > .0 && bU > .0) {\n    vec3 bZ = bl(bC, bf, vec3(bz[0]), bz[1]);\n    vec3 ca = bM * V * bO;\n    bY = bC.NdotL * ca * bZ;\n  }\n  return bs(bW + bX + bY);\n}\nvoid main() {\n  vec3 bN = vnormal;\n  vec3 cb = S(vuv, timeElapsed);\n  vec3 bJ = normalize(vtbnMatrix * cb);\n  vec3 bK = -normalize(vpos - camPos);\n  vec3 bL = normalize(-lightingDirection);\n  float bO = 1.;\n  vec4 cc = vec4(bI(bJ, bK, bL, waterColor.rgb, lightingIntensity, bN, bO), waterColor.w);\n  gl_FragColor = bv(cc);\n}",
	            defines: t.defines || {},
	            extraCommandProps: t.extraCommandProps || {}
	        });
	    }
	}

	class He extends de {
	    constructor() {
	        super({
	            vert: ce$1,
	            frag: "precision highp float;\nuniform sampler2D texture;\nuniform vec2 size;\nuniform float enableSharpen;\nuniform float sharpFactor;\nuniform float pixelRatio;\nvec2 c;\nvec3 d(const in vec3 e, const float f) {\n  vec2 h = pixelRatio / size.xy;\n  float i = .0;\n  vec4 j = texture2D(texture, c + h * vec2(-1., -1.));\n  j.rgb = mix(vec3(.0), j.rgb, sign(j.a));\n  i += mix(.0, 1., sign(j.a));\n  vec4 k = texture2D(texture, c + h * vec2(1.));\n  k.rgb = mix(vec3(.0), k.rgb, sign(k.a));\n  i += mix(.0, 1., sign(k.a));\n  vec4 l = texture2D(texture, c + h * vec2(1., -1.));\n  l.rgb = mix(vec3(.0), l.rgb, sign(l.a));\n  i += mix(.0, 1., sign(l.a));\n  vec4 m = texture2D(texture, c + h * vec2(-1., 1.));\n  m.rgb = mix(vec3(.0), m.rgb, sign(m.a));\n  i += mix(.0, 1., sign(m.a));\n  return e + f * (i * e - j.rgb - l.rgb - m.rgb - k.rgb);\n}\nvoid main() {\n  c = gl_FragCoord.xy / size;\n  vec4 e = texture2D(texture, c);\n  if(enableSharpen == 1.) {\n    e.rgb = d(e.rgb, sharpFactor);\n  }\n  gl_FragColor = e;\n}",
	            extraCommandProps: {
	                viewport: {
	                    x: 0,
	                    y: 0,
	                    width: (t, e) => e.size[0],
	                    height: (t, e) => e.size[1]
	                }
	            }
	        });
	    }
	    getMeshCommand(t, e) {
	        return this.commands.copy || (this.commands.copy = this.createREGLCommand(t, null, e.getElements())), 
	        this.commands.copy;
	    }
	}

	const Ne = [];

	class Be {
	    constructor(t, e) {
	        this._regl = t, this._viewport = e, this._init();
	    }
	    _init() {
	        this._shader = new ie$1({
	            vert: "attribute vec3 aPosition;\nuniform mat4 projMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 positionMatrix;\nvarying vec4 vWorldPosition;\n#include <get_output>\nvoid main() {\n  vec4 c = getPosition(aPosition);\n  mat4 d = getPositionMatrix();\n  vec4 e = modelMatrix * d * c;\n  gl_Position = projMatrix * modelViewMatrix * d * c;\n  vWorldPosition = e;\n}",
	            frag: "precision mediump float;\nvarying vec4 vWorldPosition;\nuniform vec2 fogDist;\nuniform vec3 cameraPosition;\nvoid main() {\n  vec3 c = vec3(vWorldPosition[0] - cameraPosition[0], vWorldPosition[1] - cameraPosition[1], vWorldPosition[2] - cameraPosition[2]);\n  float d = length(c);\n  float e = clamp(1. - (d - fogDist.x) / (fogDist.y - fogDist.x), .0, 1.);\n  if(vWorldPosition[2] < .01) {\n    gl_FragColor = vec4(e, .0, .0, 1.);\n  } else {\n    gl_FragColor = vec4(e, 1., .0, 1.);\n  }\n}",
	            uniforms: [ {
	                name: "modelViewMatrix",
	                type: "function",
	                fn: function(t, n) {
	                    return multiply$5(Ne, n.viewMatrix, n.modelMatrix);
	                }
	            } ],
	            extraCommandProps: {
	                viewport: this._viewport
	            }
	        }), this._fbo = this._regl.framebuffer({
	            color: this._regl.texture({
	                width: this._viewport.width(),
	                height: this._viewport.height(),
	                wrap: "clamp",
	                mag: "linear",
	                min: "linear"
	            }),
	            depth: !0
	        }), this._scene = new yt$1, this.renderer = new N$1(this._regl);
	    }
	    render(t, e) {
	        this._resize(), this.renderer.clear({
	            color: [ 0, 0, 0, 1 ],
	            depth: 1,
	            framebuffer: this._fbo
	        }), this._scene.setMeshes(t);
	        return this.renderer.render(this._shader, {
	            projMatrix: e.projMatrix,
	            viewMatrix: e.viewMatrix,
	            cameraPosition: e.cameraPosition,
	            fogDist: e.fogDist
	        }, this._scene, this._fbo), this._fbo;
	    }
	    dispose() {
	        this._fbo && this._fbo.destroy(), this._shader && this._shader.dispose();
	    }
	    _resize() {
	        const t = d(this._viewport.width.data) ? this._viewport.width.data() : this._viewport.width, e = d(this._viewport.height.data) ? this._viewport.height.data() : this._viewport.height;
	        !this._fbo || this._fbo.width === t && this._fbo.height === e || this._fbo.resize(t, e);
	    }
	}

	class Ge extends de {
	    constructor() {
	        super({
	            vert: ce$1,
	            frag: "#if __VERSION__ == 100\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n#endif\nprecision mediump float;\n#include <gl2_frag>\nvarying vec2 vTexCoord;\n#ifdef HAS_RAIN\nuniform sampler2D ripplesMap;\n#endif\n#ifdef HAS_SNOW\nuniform sampler2D normalMap;\n#endif\n#ifdef HAS_FOG\nuniform vec3 fogColor;\n#endif\nuniform sampler2D sceneMap;\nuniform sampler2D mixFactorMap;\nuniform float time;\nuniform vec2 resolution;\nfloat c(float a, float b, float w) {\n  return a + w * (b - a);\n}\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec3(.1031, .1030, .0973, .1099)\nfloat d = .1;\nfloat e = .2;\nfloat f = .5;\nfloat h = 10.;\nfloat i(float p) {\n  vec3 j = fract(vec3(p) * HASHSCALE1);\n  j += dot(j, j.yzx + 19.19);\n  return fract((j.x + j.y) * j.z);\n}\nvec2 k(vec2 p) {\n  vec3 j = fract(vec3(p.xyx) * HASHSCALE3);\n  j += dot(j, j.yzx + 19.19);\n  return fract((j.xx + j.yz) * j.zy);\n}\nvec2 l(vec2 m) {\n  float x = fract(sin(dot(m.xy, vec2(122.9898, 783.233))) * 43758.5453);\n  float y = fract(sin(dot(m.xy, vec2(457.6537, 537.2793))) * 37573.5913);\n  return vec2(x, y);\n}\nvec3 n(vec2 o, float u) {\n  vec3 v = vec3(.0);\n  o = o * (2. + u);\n  float A = o.y * (((i(u) * 2. - 1.) * .5 + 1.) * e);\n  float B = (f * time);\n  o += vec2(A, B);\n  vec2 C = k(floor(o) + 31.1759 * u);\n  o = fract(o);\n  o -= (C * 2. - 1.) * .35;\n  o -= .5;\n  float r = length(o);\n  float D = .05 * (1. + .3 * sin(time * d));\n  float E = smoothstep(D, -D, r);\n  vec3 F = vec3(E) * C.x;\n  return F;\n}\nvec3 G() {\n  vec3 v = vec3(0);\n  vec2 o = gl_FragCoord.xy / resolution.xy;\n  o *= vec2(resolution.x / resolution.y, 1.);\n  for(float H = 0.; H < h; H++) {\n    v += n(o, H);\n  }\n  return v;\n}\nvec3 I(vec4 J, vec4 K, float L) {\n  float M = K.b;\n  vec3 N = vec3(1.);\n  if(L < 1.) {\n    float r = c(.5, N.x, M);\n    float g = c(.5, N.y, M);\n    float b = c(.5, N.z, M);\n    return vec3(r, g, b);\n  } else {\n    float r = c(J.r, N.x, M);\n    float g = c(J.g, N.y, M);\n    float b = c(J.b, N.z, M);\n    return vec3(r, g, b);\n  }\n}\nvoid main() {\n  vec4 J = texture2D(sceneMap, vTexCoord);\n  glFragColor = J;\n  vec4 O = texture2D(mixFactorMap, vTexCoord);\n#ifdef HAS_RAIN\nvec4 P = texture2D(ripplesMap, vTexCoord);\n  if(O.g < 1.) {\n    J = mix(J, P, .4);\n  }\n  glFragColor = J;\n#endif\n#ifdef HAS_SNOW\nvec3 Q = G();\n  glFragColor = vec4(J.rgb + Q, J.a);\n#endif\n#ifdef HAS_FOG\nfloat R = O.r;\n  vec3 S = mix(fogColor, glFragColor.rgb, R);\n  glFragColor = vec4(S, J.a);\n#endif\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",
	            extraCommandProps: {
	                viewport: {
	                    x: 0,
	                    y: 0,
	                    width: (t, e) => e.resolution[0],
	                    height: (t, e) => e.resolution[1]
	                }
	            }
	        });
	    }
	}

	const Ve = [], Ue = [ .03, .03, .03 ], We = [], Ze = [], Xe = [], Je = fromRotationTranslation$1([], fromEuler([], 90, 0, 0), [ 0, 0, 0 ]);

	class qe {
	    constructor(t, e) {
	        this._regl = t, this._viewport = e, this._init();
	    }
	    _init() {
	        this._shader = new ie$1({
	            vert: "#include <gl2_vert>\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\nuniform mat4 projMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 positionMatrix;\nvarying vec2 vTexCoord;\n#include <get_output>\nvoid main() {\n  vec4 c = getPosition(aPosition);\n  mat4 d = getPositionMatrix();\n  gl_Position = projMatrix * modelViewMatrix * d * c;\n  vTexCoord = aTexCoord;\n}",
	            frag: "#if __VERSION__ == 100\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n#endif\nprecision mediump float;\n#include <gl2_frag>\nvarying vec2 vTexCoord;\nuniform float rippleRadius;\nuniform float density;\nuniform float time;\nvec3 c(vec2 p) {\n  vec3 q = vec3(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)), dot(p, vec2(419.2, 371.9)));\n  return fract(sin(q) * 43758.5453);\n}\nfloat d(in vec2 x) {\n  vec2 e = x * density / 4000.0;\n  vec2 p = floor(e);\n  vec2 f = fract(e);\n  float h = .0;\n  for(int i = -4; i <= 4; i++)\n    for(int k = -4; k <= 4; k++) {\n      vec2 g = vec2(float(k), float(i));\n      vec3 l = c(p + g);\n      vec2 r = g - f + l.xy;\n      float m = sqrt(dot(r, r));\n      float n = max(mix(smoothstep(.99, .999, max(cos(m - time * 2. + (l.x + l.y) * 5.), 0.)), 0., m), 0.);\n      h += n;\n    }\n  return h;\n}\nvoid main() {\n  vec2 u = vTexCoord;\n  float A = 24. / (rippleRadius * .01);\n  float f = d(A * u) * smoothstep(.0, .4, sin(u.x * 3.151592) * sin(u.y * 3.141592));\n  vec3 B = vec3(-dFdx(f), -dFdy(f), -dFdy(f));\n  glFragColor = vec4(B, 1.);\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",
	            uniforms: [ {
	                name: "modelViewMatrix",
	                type: "function",
	                fn: function(t, n) {
	                    return multiply$5(Ve, n.viewMatrix, n.modelMatrix);
	                }
	            } ],
	            extraCommandProps: {
	                viewport: this._viewport
	            }
	        }), this._shader.version = 300, this._fbo = this._regl.framebuffer({
	            color: this._regl.texture({
	                width: this._viewport.width(),
	                height: this._viewport.height(),
	                wrap: "clamp",
	                mag: "linear",
	                min: "linear"
	            }),
	            depth: !0
	        }), this._scene = new yt$1, this.renderer = new N$1(this._regl);
	    }
	    _transformRipples(t) {
	        const i = t.coordinateToPointAtRes(t.getCenter(), t.getGLRes());
	        let r = t.getGLScale() / t.getGLScale(this._fixZoom);
	        const o = set$4(Ze, r, r, r), a = multiply$4(o, Ue, o), h = identity$2(Xe);
	        fromRotationTranslationScale(h, fromEuler(We, 0, 0, 0), [ i.x, i.y, 0 ], a), 
	        multiply$5(h, h, Je), this._mesh.setLocalTransform(h);
	    }
	    _createRipplesMask(t) {
	        this._fixZoom = t.getZoom();
	        const e = 800 * Math.pow(2, 16.685648411389433 - this._fixZoom), n = {};
	        n.POSITION = [ -e, 0, -e, e, 0, -e, -e, 0, e, e, 0, e ], n.NORMAL = [ 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0 ], 
	        n.TEXCOORD_0 = [ 0, 0, 1, 0, 0, 1, 1, 1 ];
	        const i = new Q$1(n, [ 3, 1, 0, 0, 2, 3 ], 0, {
	            positionAttribute: "POSITION",
	            normalAttribute: "NORMAL",
	            uv0Attribute: "TEXCOORD_0"
	        });
	        i.generateBuffers(this._regl);
	        const r = new tt$1;
	        return new ft$1(i, r);
	    }
	    render(t, e) {
	        this._resize(), this.renderer.clear({
	            color: [ 0, 0, 0, 1 ],
	            depth: 1,
	            framebuffer: this._fbo
	        }), this._mesh = this._mesh || this._createRipplesMask(t), this._scene.setMeshes(this._mesh), 
	        this._transformRipples(t);
	        return this.renderer.render(this._shader, {
	            projMatrix: e.projMatrix,
	            viewMatrix: e.viewMatrix,
	            time: e.time,
	            rippleRadius: e.rippleRadius,
	            density: e.density
	        }, this._scene, this._fbo), this._fbo;
	    }
	    dispose() {
	        this._fbo && this._fbo.destroy(), this._shader && this._shader.dispose();
	    }
	    _resize() {
	        const t = d(this._viewport.width.data) ? this._viewport.width.data() : this._viewport.width, e = d(this._viewport.height.data) ? this._viewport.height.data() : this._viewport.height;
	        !this._fbo || this._fbo.width === t && this._fbo.height === e || this._fbo.resize(t, e);
	    }
	}

	var Ye, Ke = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, Qe = {
	    exports: {}
	};

	Ye = Qe, function(t) {
	    var e, n, i = "fulfilled", r = "undefined", o = function() {
	        var e = [], i = 0;
	        function o() {
	            for (;e.length - i; ) {
	                try {
	                    e[i]();
	                } catch (e) {
	                    t.console && t.console.error(e);
	                }
	                e[i++] = n, 1024 == i && (e.splice(0, 1024), i = 0);
	            }
	        }
	        var s = function() {
	            if (typeof MutationObserver === r) return typeof process !== r && "function" == typeof process.nextTick ? function() {
	                process.nextTick(o);
	            } : typeof setImmediate !== r ? function() {
	                setImmediate(o);
	            } : function() {
	                setTimeout(o, 0);
	            };
	            var t = document.createElement("div");
	            return new MutationObserver(o).observe(t, {
	                attributes: !0
	            }), function() {
	                t.setAttribute("a", 0);
	            };
	        }();
	        return function(t) {
	            e.push(t), e.length - i == 1 && s();
	        };
	    }();
	    function s(t) {
	        if (!(this instanceof s)) throw new TypeError("Zousan must be created with the new keyword");
	        if ("function" == typeof t) {
	            var e = this;
	            try {
	                t((function(t) {
	                    e.resolve(t);
	                }), (function(t) {
	                    e.reject(t);
	                }));
	            } catch (t) {
	                e.reject(t);
	            }
	        } else if (0 < arguments.length) throw new TypeError("Zousan resolver " + t + " is not a function");
	    }
	    function a(t, e) {
	        if ("function" == typeof t.y) try {
	            var i = t.y.call(n, e);
	            t.p.resolve(i);
	        } catch (e) {
	            t.p.reject(e);
	        } else t.p.resolve(e);
	    }
	    function h(t, e) {
	        if ("function" == typeof t.n) try {
	            var i = t.n.call(n, e);
	            t.p.resolve(i);
	        } catch (e) {
	            t.p.reject(e);
	        } else t.p.reject(e);
	    }
	    s.prototype = {
	        resolve: function(t) {
	            if (this.state === e) {
	                if (t === this) return this.reject(new TypeError("Attempt to resolve promise with self"));
	                var n = this;
	                if (t && ("function" == typeof t || "object" == typeof t)) try {
	                    var r = !0, s = t.then;
	                    if ("function" == typeof s) return void s.call(t, (function(t) {
	                        r && (r = !1, n.resolve(t));
	                    }), (function(t) {
	                        r && (r = !1, n.reject(t));
	                    }));
	                } catch (s) {
	                    return void (r && this.reject(s));
	                }
	                this.state = i, this.v = t, n.c && o((function() {
	                    for (var e = 0, i = n.c.length; e < i; e++) a(n.c[e], t);
	                }));
	            }
	        },
	        reject: function(n) {
	            if (this.state === e) {
	                var i = this;
	                this.state = "rejected", this.v = n;
	                var r = this.c;
	                o(r ? function() {
	                    for (var t = 0, e = r.length; t < e; t++) h(r[t], n);
	                } : function() {
	                    i.handled || !s.suppressUncaughtRejectionError && t.console && s.warn("You upset Zousan. Please catch rejections: ", n, n ? n.stack : null);
	                });
	            }
	        },
	        then: function(t, n) {
	            var r = new s, l = {
	                y: t,
	                n,
	                p: r
	            };
	            if (this.state === e) this.c ? this.c.push(l) : this.c = [ l ]; else {
	                var c = this.state, u = this.v;
	                this.handled = !0, o((function() {
	                    c === i ? a(l, u) : h(l, u);
	                }));
	            }
	            return r;
	        },
	        catch: function(t) {
	            return this.then(null, t);
	        },
	        finally: function(t) {
	            return this.then(t, t);
	        },
	        timeout: function(t, e) {
	            e = e || "Timeout";
	            var n = this;
	            return new s((function(i, r) {
	                setTimeout((function() {
	                    r(Error(e));
	                }), t), n.then((function(t) {
	                    i(t);
	                }), (function(t) {
	                    r(t);
	                }));
	            }));
	        }
	    }, s.resolve = function(t) {
	        var e = new s;
	        return e.resolve(t), e;
	    }, s.reject = function(t) {
	        var e = new s;
	        return e.c = [], e.reject(t), e;
	    }, s.all = function(t) {
	        var e = [], n = 0, i = new s;
	        function r(r, o) {
	            r && "function" == typeof r.then || (r = s.resolve(r)), r.then((function(r) {
	                e[o] = r, ++n == t.length && i.resolve(e);
	            }), (function(t) {
	                i.reject(t);
	            }));
	        }
	        for (var o = 0; o < t.length; o++) r(t[o], o);
	        return t.length || i.resolve(e), i;
	    }, s.warn = console.warn, Ye.exports && (Ye.exports = s), t.define && t.define.amd && t.define([], (function() {
	        return s;
	    })), (t.Zousan = s).soon = o;
	}(Ke);

	var $e = Qe.exports, tn = {
	    exports: {}
	}, en = {
	    exports: {}
	};

	en.exports = function() {
	    function t(t, e, n) {
	        var i = t[e];
	        t[e] = t[n], t[n] = i;
	    }
	    function e(t, e) {
	        return t < e ? -1 : t > e ? 1 : 0;
	    }
	    return function(n, i, r, o, s) {
	        !function e(n, i, r, o, s) {
	            for (;o > r; ) {
	                if (o - r > 600) {
	                    var a = o - r + 1, h = i - r + 1, l = Math.log(a), c = .5 * Math.exp(2 * l / 3), u = .5 * Math.sqrt(l * c * (a - c) / a) * (h - a / 2 < 0 ? -1 : 1), f = Math.max(r, Math.floor(i - h * c / a + u)), d = Math.min(o, Math.floor(i + (a - h) * c / a + u));
	                    e(n, i, f, d, s);
	                }
	                var m = n[i], g = r, p = o;
	                for (t(n, r, i), s(n[o], m) > 0 && t(n, r, o); g < p; ) {
	                    for (t(n, g, p), g++, p--; s(n[g], m) < 0; ) g++;
	                    for (;s(n[p], m) > 0; ) p--;
	                }
	                0 === s(n[r], m) ? t(n, r, p) : (p++, t(n, p, o)), p <= i && (r = p + 1), i <= p && (o = p - 1);
	            }
	        }(n, i, r || 0, o || n.length - 1, s || e);
	    };
	}(), tn.exports = rn, tn.exports.default = rn;

	var nn = en.exports;

	function rn(t, e) {
	    if (!(this instanceof rn)) return new rn(t, e);
	    this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), 
	    e && this._initFormat(e), this.clear();
	}

	function on(t, e, n) {
	    if (!n) return e.indexOf(t);
	    for (var i = 0; i < e.length; i++) if (n(t, e[i])) return i;
	    return -1;
	}

	function sn(t, e) {
	    an(t, 0, t.children.length, e, t);
	}

	function an(t, e, n, i, r) {
	    r || (r = gn(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0;
	    for (var o, s = e; s < n; s++) o = t.children[s], hn(r, t.leaf ? i(o) : o);
	    return r;
	}

	function hn(t, e) {
	    return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), 
	    t.maxY = Math.max(t.maxY, e.maxY), t;
	}

	function ln(t, e) {
	    return t.minX - e.minX;
	}

	function cn(t, e) {
	    return t.minY - e.minY;
	}

	function un(t) {
	    return (t.maxX - t.minX) * (t.maxY - t.minY);
	}

	function fn(t) {
	    return t.maxX - t.minX + (t.maxY - t.minY);
	}

	function dn(t, e) {
	    return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY;
	}

	function mn(t, e) {
	    return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY;
	}

	function gn(t) {
	    return {
	        children: t,
	        height: 1,
	        leaf: !0,
	        minX: 1 / 0,
	        minY: 1 / 0,
	        maxX: -1 / 0,
	        maxY: -1 / 0
	    };
	}

	function pn(t, e, n, i, r) {
	    for (var o, s = [ e, n ]; s.length; ) (n = s.pop()) - (e = s.pop()) <= i || (o = e + Math.ceil((n - e) / i / 2) * i, 
	    nn(t, o, e, n, r), s.push(e, o, o, n));
	}

	rn.prototype = {
	    all: function() {
	        return this._all(this.data, []);
	    },
	    search: function(t) {
	        var e = this.data, n = [], i = this.toBBox;
	        if (!mn(t, e)) return n;
	        for (var r, o, s, a, h = []; e; ) {
	            for (r = 0, o = e.children.length; r < o; r++) s = e.children[r], mn(t, a = e.leaf ? i(s) : s) && (e.leaf ? n.push(s) : dn(t, a) ? this._all(s, n) : h.push(s));
	            e = h.pop();
	        }
	        return n;
	    },
	    collides: function(t) {
	        var e = this.data, n = this.toBBox;
	        if (!mn(t, e)) return !1;
	        for (var i, r, o, s, a = []; e; ) {
	            for (i = 0, r = e.children.length; i < r; i++) if (o = e.children[i], mn(t, s = e.leaf ? n(o) : o)) {
	                if (e.leaf || dn(t, s)) return !0;
	                a.push(o);
	            }
	            e = a.pop();
	        }
	        return !1;
	    },
	    load: function(t) {
	        if (!t || !t.length) return this;
	        if (t.length < this._minEntries) {
	            for (var e = 0, n = t.length; e < n; e++) this.insert(t[e]);
	            return this;
	        }
	        var i = this._build(t.slice(), 0, t.length - 1, 0);
	        if (this.data.children.length) if (this.data.height === i.height) this._splitRoot(this.data, i); else {
	            if (this.data.height < i.height) {
	                var r = this.data;
	                this.data = i, i = r;
	            }
	            this._insert(i, this.data.height - i.height - 1, !0);
	        } else this.data = i;
	        return this;
	    },
	    insert: function(t) {
	        return t && this._insert(t, this.data.height - 1), this;
	    },
	    clear: function() {
	        return this.data = gn([]), this;
	    },
	    remove: function(t, e) {
	        if (!t) return this;
	        for (var n, i, r, o, s = this.data, a = this.toBBox(t), h = [], l = []; s || h.length; ) {
	            if (s || (s = h.pop(), i = h[h.length - 1], n = l.pop(), o = !0), s.leaf && -1 !== (r = on(t, s.children, e))) return s.children.splice(r, 1), 
	            h.push(s), this._condense(h), this;
	            o || s.leaf || !dn(s, a) ? i ? (n++, s = i.children[n], o = !1) : s = null : (h.push(s), 
	            l.push(n), n = 0, i = s, s = s.children[0]);
	        }
	        return this;
	    },
	    toBBox: function(t) {
	        return t;
	    },
	    compareMinX: ln,
	    compareMinY: cn,
	    toJSON: function() {
	        return this.data;
	    },
	    fromJSON: function(t) {
	        return this.data = t, this;
	    },
	    _all: function(t, e) {
	        for (var n = []; t; ) t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children), 
	        t = n.pop();
	        return e;
	    },
	    _build: function(t, e, n, i) {
	        var r, o = n - e + 1, s = this._maxEntries;
	        if (o <= s) return sn(r = gn(t.slice(e, n + 1)), this.toBBox), r;
	        i || (i = Math.ceil(Math.log(o) / Math.log(s)), s = Math.ceil(o / Math.pow(s, i - 1))), 
	        (r = gn([])).leaf = !1, r.height = i;
	        var a, h, l, c, u = Math.ceil(o / s), f = u * Math.ceil(Math.sqrt(s));
	        for (pn(t, e, n, f, this.compareMinX), a = e; a <= n; a += f) for (pn(t, a, l = Math.min(a + f - 1, n), u, this.compareMinY), 
	        h = a; h <= l; h += u) c = Math.min(h + u - 1, l), r.children.push(this._build(t, h, c, i - 1));
	        return sn(r, this.toBBox), r;
	    },
	    _chooseSubtree: function(t, e, n, i) {
	        for (var r, o, s, a, h, l, c, u, f, d; i.push(e), !e.leaf && i.length - 1 !== n; ) {
	            for (c = u = 1 / 0, r = 0, o = e.children.length; r < o; r++) h = un(s = e.children[r]), 
	            f = t, d = s, (l = (Math.max(d.maxX, f.maxX) - Math.min(d.minX, f.minX)) * (Math.max(d.maxY, f.maxY) - Math.min(d.minY, f.minY)) - h) < u ? (u = l, 
	            c = h < c ? h : c, a = s) : l === u && h < c && (c = h, a = s);
	            e = a || e.children[0];
	        }
	        return e;
	    },
	    _insert: function(t, e, n) {
	        var i = n ? t : (0, this.toBBox)(t), r = [], o = this._chooseSubtree(i, this.data, e, r);
	        for (o.children.push(t), hn(o, i); e >= 0 && r[e].children.length > this._maxEntries; ) this._split(r, e), 
	        e--;
	        this._adjustParentBBoxes(i, r, e);
	    },
	    _split: function(t, e) {
	        var n = t[e], i = n.children.length, r = this._minEntries;
	        this._chooseSplitAxis(n, r, i);
	        var o = this._chooseSplitIndex(n, r, i), s = gn(n.children.splice(o, n.children.length - o));
	        s.height = n.height, s.leaf = n.leaf, sn(n, this.toBBox), sn(s, this.toBBox), e ? t[e - 1].children.push(s) : this._splitRoot(n, s);
	    },
	    _splitRoot: function(t, e) {
	        this.data = gn([ t, e ]), this.data.height = t.height + 1, this.data.leaf = !1, 
	        sn(this.data, this.toBBox);
	    },
	    _chooseSplitIndex: function(t, e, n) {
	        var i, r, o, s, a, h, l, c, u, f, d, m, g, p;
	        for (h = l = 1 / 0, i = e; i <= n - e; i++) r = an(t, 0, i, this.toBBox), o = an(t, i, n, this.toBBox), 
	        u = r, f = o, d = void 0, m = void 0, g = void 0, p = void 0, d = Math.max(u.minX, f.minX), 
	        m = Math.max(u.minY, f.minY), g = Math.min(u.maxX, f.maxX), p = Math.min(u.maxY, f.maxY), 
	        s = Math.max(0, g - d) * Math.max(0, p - m), a = un(r) + un(o), s < h ? (h = s, 
	        c = i, l = a < l ? a : l) : s === h && a < l && (l = a, c = i);
	        return c;
	    },
	    _chooseSplitAxis: function(t, e, n) {
	        var i = t.leaf ? this.compareMinX : ln, r = t.leaf ? this.compareMinY : cn;
	        this._allDistMargin(t, e, n, i) < this._allDistMargin(t, e, n, r) && t.children.sort(i);
	    },
	    _allDistMargin: function(t, e, n, i) {
	        t.children.sort(i);
	        var r, o, s = this.toBBox, a = an(t, 0, e, s), h = an(t, n - e, n, s), l = fn(a) + fn(h);
	        for (r = e; r < n - e; r++) o = t.children[r], hn(a, t.leaf ? s(o) : o), l += fn(a);
	        for (r = n - e - 1; r >= e; r--) o = t.children[r], hn(h, t.leaf ? s(o) : o), l += fn(h);
	        return l;
	    },
	    _adjustParentBBoxes: function(t, e, n) {
	        for (var i = n; i >= 0; i--) hn(e[i], t);
	    },
	    _condense: function(t) {
	        for (var e, n = t.length - 1; n >= 0; n--) 0 === t[n].children.length ? n > 0 ? (e = t[n - 1].children).splice(e.indexOf(t[n]), 1) : this.clear() : sn(t[n], this.toBBox);
	    },
	    _initFormat: function(t) {
	        var e = [ "return a", " - b", ";" ];
	        this.compareMinX = new Function("a", "b", e.join(t[0])), this.compareMinY = new Function("a", "b", e.join(t[1])), 
	        this.toBBox = new Function("a", "return {minX: a" + t[0] + ", minY: a" + t[1] + ", maxX: a" + t[2] + ", maxY: a" + t[3] + "};");
	    }
	};

	var _n = tn.exports, vn = {
	    exports: {}
	};

	!function(t) {
	    !function() {
	        function e(t, e, n) {
	            var i = e.x, r = e.y, o = n.x - i, s = n.y - r;
	            if (0 !== o || 0 !== s) {
	                var a = ((t.x - i) * o + (t.y - r) * s) / (o * o + s * s);
	                a > 1 ? (i = n.x, r = n.y) : a > 0 && (i += o * a, r += s * a);
	            }
	            return (o = t.x - i) * o + (s = t.y - r) * s;
	        }
	        function n(t, n) {
	            var i = t.length - 1, r = [ t[0] ];
	            return function t(n, i, r, o, s) {
	                for (var a, h = o, l = i + 1; l < r; l++) {
	                    var c = e(n[l], n[i], n[r]);
	                    c > h && (a = l, h = c);
	                }
	                h > o && (a - i > 1 && t(n, i, a, o, s), s.push(n[a]), r - a > 1 && t(n, a, r, o, s));
	            }(t, 0, i, n, r), r.push(t[i]), r;
	        }
	        function i(t, e, i) {
	            if (t.length <= 2) return t;
	            var r = void 0 !== e ? e * e : 1;
	            return t = n(t = i ? t : function(t, e) {
	                for (var n, i, r, o, s, a = t[0], h = [ a ], l = 1, c = t.length; l < c; l++) o = void 0, 
	                s = void 0, (o = (i = n = t[l]).x - (r = a).x) * o + (s = i.y - r.y) * s > e && (h.push(n), 
	                a = n);
	                return a !== n && h.push(n), h;
	            }(t, r), r);
	        }
	        t.exports = i, t.exports.default = i;
	    }();
	}(vn);

	for (var yn = vn.exports, xn = [], bn = 0
	/*!
	* Contains code from THREE.js
	* MIT License
	* https://github.com/mrdoob/three.js
	*/; bn < 6; bn++) xn[bn] = [];

	var wn = [];

	function Cn(t, e, n) {
	    var i, r, o, s, a, h, l, c, u, f, d, m, g, p, _, v, y;
	    o = (i = t)[1], s = i[2], l = i[5], c = i[6], d = i[9], m = i[10], _ = i[13], v = i[14], 
	    Mn(xn[0], (a = i[3]) - (r = i[0]), (u = i[7]) - (h = i[4]), (g = i[11]) - (f = i[8]), (y = i[15]) - (p = i[12])), 
	    Mn(xn[1], a + r, u + h, g + f, y + p), Mn(xn[2], a + o, u + l, g + d, y + _), Mn(xn[3], a - o, u - l, g - d, y - _), 
	    Mn(xn[4], a - s, u - c, g - m, y - v), Mn(xn[5], a + s, u + c, g + m, y + v);
	    for (var x = 0; x < 6; x++) if (!n || "0" !== n.charAt(x)) {
	        var b = xn[x];
	        if (wn[0] = b[0] > 0 ? e[1][0] : e[0][0], wn[1] = b[1] > 0 ? e[1][1] : e[0][1], 
	        wn[2] = b[2] > 0 ? e[1][2] : e[0][2], Tn(b, wn) < 0) return !1;
	    }
	    return !0;
	}

	function Mn(t, e, n, i, r) {
	    return t[0] = e * (1 / 6), t[1] = n * (1 / 6), t[2] = i * (1 / 6), t[3] = r * (1 / 6), 
	    t;
	}

	function Tn(t, e) {
	    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3];
	}

	/*!
	 * maptalks v1.0.0-rc.14
	 * LICENSE : BSD-3-Clause
	 * (c) 2016-2022 maptalks.org
	 */ var Sn = [ "MultiPoint", "MultiLineString", "MultiPolygon", "GeometryCollection" ], Pn = [ "FeatureCollection", "Feature", "Point", "LineString", "Polygon" ].concat(Sn), An = [ "markerFile", "polygonPatternFile", "linePatternFile", "markerFillPatternFile", "markerLinePatternFile" ], En = [ [ "markerWidth", "markerHeight" ], [], [ null, "lineWidth" ], [], [ null, "markerLineWidth" ] ], On = {
	    lineWidth: 1,
	    lineOpacity: 1,
	    lineDx: 1,
	    lineDy: 1,
	    polygonOpacity: 1,
	    markerWidth: 1,
	    markerHeight: 1,
	    markerDx: 1,
	    markerDy: 1,
	    markerOpacity: 1,
	    markerFillOpacity: 1,
	    markerLineWidth: 1,
	    markerLineOpacity: 1,
	    textSize: 1,
	    textOpacity: 1,
	    textHaloRadius: 1,
	    textWrapWidth: 1,
	    textLineSpacing: 1,
	    textDx: 1,
	    textDy: 1
	}, Rn = [ "lineColor", "polygonFill", "markerFill", "markerLineColor", "textFill" ];

	function In() {
	    return Date.now();
	}

	function kn(t) {
	    for (var e = 1; e < arguments.length; e++) {
	        var n = arguments[e];
	        for (var i in n) t[i] = n[i];
	    }
	    return t;
	}

	function Dn(t) {
	    return null == t;
	}

	function Ln(t) {
	    return "number" == typeof t && !isNaN(t);
	}

	function zn(t) {
	    return (0 | t) === t;
	}

	function Fn(t) {
	    return "object" == typeof t && !!t;
	}

	function jn(t) {
	    return !Dn(t) && ("string" == typeof t || null !== t.constructor && t.constructor === String);
	}

	function Hn(t) {
	    return !Dn(t) && ("function" == typeof t || null !== t.constructor && t.constructor === Function);
	}

	var Nn = Object.prototype.hasOwnProperty;

	function Bn(t, e) {
	    return Nn.call(t, e);
	}

	var Gn = Math.PI / 180;

	function Vn(t) {
	    return t * Gn;
	}

	function Un(t) {
	    return t / Gn;
	}

	var Wn = "[object process]" === Object.prototype.toString.call("undefined" != typeof process ? process : 0) && !process.versions.electron && !process.versions.nw && !process.versions["node-webkit"], Zn = {}, Xn = {};

	function Jn() {
	    return window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI;
	}

	if (!Wn) {
	    var qn = navigator.userAgent.toLowerCase(), Yn = document.documentElement, Kn = "ActiveXObject" in window, Qn = -1 !== qn.indexOf("webkit"), $n = -1 !== qn.indexOf("phantom"), ti$1 = -1 !== qn.search("android [23]"), ei$1 = -1 !== qn.indexOf("chrome"), ni$1 = -1 !== qn.indexOf("gecko") && !Qn && !window.opera && !Kn, ii$1 = "undefined" != typeof orientation || -1 !== qn.indexOf("mobile"), ri$1 = !window.PointerEvent && window.MSPointerEvent, oi$1 = window.PointerEvent && navigator.pointerEnabled || ri$1, si$1 = Kn && "transition" in Yn.style, ai$1 = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix && !ti$1, hi$1 = "MozPerspective" in Yn.style, li$1 = "OTransition" in Yn.style, ci$1 = (si$1 || ai$1 || hi$1) && !li$1 && !$n, ui$1 = "undefined" != typeof window && Hn(window.createImageBitmap), fi$1 = "undefined" != typeof window && Hn(window.ResizeObserver), di$1 = "undefined" != typeof window && Hn(window.btoa), mi$1 = 0;
	    ei$1 && (mi$1 = qn.match(/chrome\/([\d.]+)/)[1]);
	    var gi$1 = !$n && (oi$1 || "ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch), pi$1 = "undefined" != typeof window && "WebGLRenderingContext" in window, _i$1 = Jn(), vi$1 = !1;
	    try {
	        new OffscreenCanvas(2, 2).getContext("2d"), vi$1 = !0;
	    } catch (t) {
	        vi$1 = !1;
	    }
	    var yi$1 = !1;
	    try {
	        window.addEventListener("testPassive", (function() {}), {
	            get passive() {
	                yi$1 = !0;
	            }
	        });
	    } catch (t) {}
	    if (Zn = {
	        ie: Kn,
	        ielt9: Kn && !document.addEventListener,
	        edge: "msLaunchUri" in navigator && !("documentMode" in document),
	        webkit: Qn,
	        gecko: ni$1,
	        android: -1 !== qn.indexOf("android"),
	        android23: ti$1,
	        chrome: ei$1,
	        chromeVersion: mi$1,
	        safari: !ei$1 && -1 !== qn.indexOf("safari"),
	        phantomjs: $n,
	        ie3d: si$1,
	        webkit3d: ai$1,
	        gecko3d: hi$1,
	        opera12: li$1,
	        any3d: ci$1,
	        mobile: ii$1,
	        mobileWebkit: ii$1 && Qn,
	        mobileWebkit3d: ii$1 && ai$1,
	        mobileOpera: ii$1 && window.opera,
	        mobileGecko: ii$1 && ni$1,
	        touch: !!gi$1,
	        msPointer: !!ri$1,
	        pointer: !!oi$1,
	        retina: _i$1 > 1,
	        devicePixelRatio: _i$1,
	        language: navigator.browserLanguage ? navigator.browserLanguage : navigator.language,
	        ie9: Kn && 9 === document.documentMode,
	        ie10: Kn && 10 === document.documentMode,
	        webgl: pi$1,
	        imageBitMap: ui$1,
	        resizeObserver: fi$1,
	        btoa: di$1,
	        decodeImageInWorker: vi$1,
	        monitorDPRChange: !0,
	        supportsPassive: yi$1,
	        removeDPRListening: function(t) {
	            t && delete Xn[t.id];
	        },
	        checkDevicePixelRatio: function() {
	            if ("undefined" != typeof window && Zn.monitorDPRChange) {
	                var t = Jn(), e = t !== Zn.devicePixelRatio;
	                return e && (Zn.devicePixelRatio = t), e;
	            }
	            return !1;
	        },
	        addDPRListening: function(t) {
	            t && (Xn[t.id] = t);
	        }
	    }, "undefined" != typeof window && window.matchMedia) for (var xi$1 = 1; xi$1 < 500; xi$1++) {
	        var bi$1 = (.01 * xi$1).toFixed(2), wi$1 = window.matchMedia("screen and (resolution: " + bi$1 + "dppx)");
	        wi$1 && (wi$1.addEventListener ? wi$1.addEventListener("change", Zn.checkDevicePixelRatio) : wi$1.addListener && wi$1.addListener(Zn.checkDevicePixelRatio));
	    }
	    if (Zn.devicePixelRatio) {
	        var Ci$1 = Zn.devicePixelRatio;
	        Object.defineProperty(Zn, "devicePixelRatio", {
	            get: function() {
	                return Ci$1;
	            },
	            set: function(t) {
	                if (t !== Ci$1 && (Ci$1 = t, Zn.monitorDPRChange)) for (var e in Xn) {
	                    var n = Xn[e];
	                    if (n && n.options && !n.options.devicePixelRatio && n.checkSize && n.getRenderer) n.getRenderer() && n.checkSize(!0);
	                }
	            }
	        });
	    }
	}

	var Mi$1 = Zn;

	function Ti$1(t, e) {
	    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
	}

	function Si$1(t) {
	    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	    return t;
	}

	var Pi$1, Ai$1, Ei$1 = function() {
	    function t(t, e, n) {
	        if (Dn(t) || Dn(e) ? Dn(t.x) || Dn(t.y) ? Array.isArray(t) && (this.x = +t[0], this.y = +t[1], 
	        this.z = t[2]) : (this.x = +t.x, this.y = +t.y, this.z = t.z) : (this.x = +t, this.y = +e, 
	        this.z = n), this._isNaN()) throw new Error("Position is NaN");
	    }
	    var e = t.prototype;
	    return e.set = function(t, e, n) {
	        return this.x = t, this.y = e, this.z = n || 0, this;
	    }, e.abs = function() {
	        return new this.constructor(Math.abs(this.x), Math.abs(this.y));
	    }, e._abs = function() {
	        return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
	    }, e._round = function() {
	        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
	    }, e.round = function() {
	        return new this.constructor(Math.round(this.x), Math.round(this.y));
	    }, e._ceil = function() {
	        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
	    }, e.ceil = function() {
	        return new this.constructor(Math.ceil(this.x), Math.ceil(this.y));
	    }, e.distanceTo = function(t) {
	        var e = t.x - this.x, n = t.y - this.y;
	        return Math.sqrt(e * e + n * n);
	    }, e.mag = function() {
	        return Math.sqrt(this.x * this.x + this.y * this.y);
	    }, e._floor = function() {
	        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
	    }, e.floor = function() {
	        return new this.constructor(Math.floor(this.x), Math.floor(this.y));
	    }, e.copy = function() {
	        return new this.constructor(this.x, this.y, this.z);
	    }, e._add = function(t, e) {
	        return Dn(t.x) ? Dn(t[0]) ? (this.x += t, this.y += e) : (this.x += t[0], this.y += t[1]) : (this.x += t.x, 
	        this.y += t.y), this;
	    }, e.add = function(t, e) {
	        var n, i;
	        return Dn(t.x) ? Dn(t[0]) ? (n = this.x + t, i = this.y + e) : (n = this.x + t[0], 
	        i = this.y + t[1]) : (n = this.x + t.x, i = this.y + t.y), new this.constructor(n, i);
	    }, e._sub = function(t, e) {
	        return Dn(t.x) ? Dn(t[0]) ? (this.x -= t, this.y -= e) : (this.x -= t[0], this.y -= t[1]) : (this.x -= t.x, 
	        this.y -= t.y), this;
	    }, e._substract = function() {
	        return this._sub.apply(this, arguments);
	    }, e.sub = function(t, e) {
	        var n, i;
	        return Dn(t.x) ? Dn(t[0]) ? (n = this.x - t, i = this.y - e) : (n = this.x - t[0], 
	        i = this.y - t[1]) : (n = this.x - t.x, i = this.y - t.y), new this.constructor(n, i);
	    }, e.substract = function() {
	        return this.sub.apply(this, arguments);
	    }, e.multi = function(t) {
	        return new this.constructor(this.x * t, this.y * t);
	    }, e._multi = function(t) {
	        return this.x *= t, this.y *= t, this;
	    }, e.div = function(t) {
	        return this.multi(1 / t);
	    }, e._div = function(t) {
	        return this._multi(1 / t);
	    }, e.equals = function(t) {
	        return t instanceof this.constructor && (this.x === t.x && this.y === t.y && this.z === t.z);
	    }, e._isNaN = function() {
	        return isNaN(this.x) || isNaN(this.y);
	    }, e.isZero = function() {
	        return 0 === this.x && 0 === this.y;
	    }, e.toArray = function() {
	        return Ln(this.z) ? [ this.x, this.y, this.z ] : [ this.x, this.y ];
	    }, e.toFixed = function(t) {
	        return new this.constructor(this.x.toFixed(t), this.y.toFixed(t));
	    }, e.toJSON = function() {
	        return {
	            x: this.x,
	            y: this.y
	        };
	    }, t;
	}(), Oi$1 = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.closeTo = function(t, e) {
	        return e || (e = 0), this.x >= t.x - e && this.x <= t.x + e && this.y >= t.y - e && this.y <= t.y + e;
	    }, n.mag = function() {
	        return Math.sqrt(this.x * this.x + this.y * this.y);
	    }, n.unit = function() {
	        return this.copy()._unit();
	    }, n._unit = function() {
	        return this._div(this.mag()), this;
	    }, n.perp = function() {
	        return this.copy()._perp();
	    }, n._perp = function() {
	        var t = this.y;
	        return this.y = this.x, this.x = -t, this;
	    }, n.angleWith = function(t) {
	        return this.angleWithSep(t.x, t.y);
	    }, n.angleWithSep = function(t, e) {
	        return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);
	    }, n._rotate = function(t) {
	        var e = Math.cos(t), n = Math.sin(t), i = n * this.x + e * this.y;
	        return this.x = e * this.x - n * this.y, this.y = i, this;
	    }, n.rotate = function(t) {
	        return this.copy()._rotate(t);
	    }, e;
	}(Ei$1);

	function Ri$1(t) {
	    return t.length > 4 && ".svg" === t.slice(-4) ? 1 : "data:image/svg+xml" === t.slice(0, "data:image/svg+xml".length) ? 2 : 0;
	}

	function Ii$1(t, e) {
	    Wn && Ii$1.node ? Ii$1.node(t, e) : t.src = e[0];
	}

	!function() {
	    if (Wn) return Pi$1 = function(t) {
	        return setTimeout(t, 16);
	    }, void (Ai$1 = clearTimeout);
	    var t, e;
	    function n(t) {
	        return setTimeout(t, 1e3 / 30);
	    }
	    function i(t) {
	        return window["webkit" + t] || window["moz" + t] || window["ms" + t];
	    }
	    "undefined" != typeof window ? (t = window.requestAnimationFrame || i("RequestAnimationFrame") || n, 
	    e = window.cancelAnimationFrame || i("CancelAnimationFrame") || i("CancelRequestAnimationFrame") || function(t) {
	        window.clearTimeout(t);
	    }) : (t = n, e = clearTimeout), Pi$1 = function(e) {
	        return t(e);
	    }, Ai$1 = function(t) {
	        t && e(t);
	    };
	}();

	var ki$1 = 0;

	function Di$1() {
	    return ki$1++;
	}

	var Li$1 = Di$1;

	function zi$1(t) {
	    return t && jn(t) ? JSON.parse(t) : t;
	}

	function Fi$1(t) {
	    for (var e = 1; e < arguments.length; e++) {
	        var n = arguments[e];
	        if (n) for (var i = 0, r = n.length; i < r; i++) t.push(n[i]);
	    }
	    return t.length;
	}

	function ji$1(t, e) {
	    var n = e.indexOf(t);
	    n > -1 && e.splice(n, 1);
	}

	function Hi$1(t, e, n) {
	    if (!Array.isArray(t)) return n ? e.call(n, t) : e(t);
	    for (var i, r, o = [], s = 0, a = t.length; s < a; s++) Dn(i = t[s]) ? o.push(null) : Array.isArray(i) ? o.push(Hi$1(i, e, n)) : (r = n ? e.call(n, i) : e(i), 
	    o.push(r));
	    return o;
	}

	function Ni$1(t, e) {
	    return void 0 === t ? e : t;
	}

	function Bi$1(t) {
	    return Math.sign ? Math.sign(t) : 0 === (t = +t) || isNaN(t) ? Number(t) : t > 0 ? 1 : -1;
	}

	function Gi$1(t) {
	    if (Math.log2) return Math.log2(t);
	    var e = Math.log(t) * Math.LOG2E, n = Math.round(e);
	    return Math.abs(n - e) < 1e-14 ? n : e;
	}

	function Vi$1(t, e, n) {
	    return t * (1 - n) + e * n;
	}

	function Ui$1(t, e, n) {
	    if (t === n || t === e) return t;
	    var i = n - e;
	    return ((t - e) % i + i) % i + e;
	}

	function Wi$1(t, e, n) {
	    return Math.min(n, Math.max(e, t));
	}

	function Zi$1(t) {
	    return Array.isArray(t) && t.length > 0;
	}

	var Xi$1 = /^([a-z][a-z\d+\-.]*:)?\/\//i;

	var Ji$1 = /^url\((['"])(.+)\1\)$/i, qi$1 = /^url\(([^'"].*[^'"])\)$/i;

	function Yi$1(t) {
	    return jn(t) ? qi$1.test(t) ? 1 : Ji$1.test(t) ? 2 : 3 : 0;
	}

	function Ki$1(t) {
	    var e = Yi$1(t);
	    return 3 === e ? t : 1 === e ? qi$1.exec(t)[1] : 2 === e ? Ji$1.exec(t)[2] : t;
	}

	function Qi$1(t) {
	    if (Mi$1.btoa) return window.btoa(t);
	    for (var e, n, i = String(t), r = "", o = 0, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; i.charAt(0 | o) || (s = "=", 
	    o % 1); r += s.charAt(63 & e >> 8 - o % 1 * 8)) {
	        if ((n = i.charCodeAt(o += 3 / 4)) > 255) throw new Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
	        e = e << 8 | n;
	    }
	    return r;
	}

	function $i$1(t, e) {
	    for (var n = atob(t), i = new ArrayBuffer(n.length), r = new Uint8Array(i), o = 0; o < n.length; o++) r[o] = 255 & n.charCodeAt(o);
	    return new Blob([ i ], {
	        type: e
	    });
	}

	function tr(t, e, n, i) {
	    return Math.atan2(i - e, n - t);
	}

	var er, nr = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";

	function ir(t, e) {
	    if (!t && !e) return !0;
	    if (!t || !e) return !1;
	    for (var n in t) if ("center" === n) {
	        if (!e[n] || !rr(t[n][0], e[n][0]) || !rr(t[n][1], e[n][1])) return !1;
	    } else if (t[n] !== e[n]) return !1;
	    return !0;
	}

	function rr(t, e, n) {
	    return null == n && (n = 1e-6), t >= e - n && t <= e + n;
	}

	function or(t, e, n, i) {
	    t || (t = 100), e || (e = 4);
	    var r = this;
	    return e *= 2, this._flashTimeout && clearTimeout(this._flashTimeout), this._flashTimeout = setTimeout((function o() {
	        if (0 === e) return r.show(), void (n && (i ? n.call(i) : n()));
	        e % 2 == 0 ? r.hide() : r.show(), e--, r._flashTimeout = setTimeout(o, t);
	    }), t), this;
	}

	function sr(t, e) {
	    void 0 === t && (t = []), void 0 === e && (e = "_pt");
	    for (var n = [], i = 0, r = t.length; i < r; i++) {
	        var o = t[i];
	        if (o) {
	            o[e] || (o[e] = new Oi$1(0, 0));
	            var s = o[e];
	            s.x = 0, s.y = 0, n.push(s);
	        } else n.push(null);
	    }
	    return n;
	}

	if (Mi$1.decodeImageInWorker) {
	    var ar = document.createElement("canvas");
	    ar.width = 1, ar.height = 1, er = ar.getContext("2d");
	}

	function hr(t, e) {
	    var n = er.createImageData(t.width, t.height);
	    n.data.set(t.data), createImageBitmap(n).then((function(t) {
	        e(t);
	    }));
	}

	function lr(t) {
	    if (t && 0 === t.indexOf("http://") || 0 === t.indexOf("https://")) return t;
	    var e = document.createElement("a");
	    return e.href = t, t = e.href, e = null, t;
	}

	var cr = {
	    cssWidth: "1px",
	    cssHeight: "1px",
	    width: 1,
	    height: 1
	};

	function ur(t, e) {
	    void 0 === e && (e = 1);
	    var n = t.width, i = t.height;
	    return cr.cssWidth = n + "px", cr.cssHeight = i + "px", cr.width = Math.round(n * e), 
	    cr.height = Math.round(i * e), cr;
	}

	function fr(t, e) {
	    for (var n = 0; n < t.stops.length; n++) if (e === t.stops[n][0]) return t.stops[n][1];
	    return t.default;
	}

	function dr(t, e) {
	    for (var n = 0; n < t.stops.length && !(e < t.stops[n][0]); n++) ;
	    return t.stops[Math.max(n - 1, 0)][1];
	}

	function mr(t, e) {
	    for (var n = void 0 !== t.base ? t.base : 1, i = 0; !(i >= t.stops.length || e <= t.stops[i][0]); ) i++;
	    return 0 === i ? t.stops[i][1] : i === t.stops.length ? t.stops[i - 1][1] : function t(e, n, i, r, o, s) {
	        return "function" == typeof o ? function() {
	            var a = o.apply(void 0, arguments), h = s.apply(void 0, arguments);
	            return t(e, n, i, r, a, h);
	        } : o.length ? function(t, e, n, i, r, o) {
	            for (var s = [], a = 0; a < r.length; a++) s[a] = pr(t, e, n, i, r[a], o[a]);
	            return s;
	        }(e, n, i, r, o, s) : pr(e, n, i, r, o, s);
	    }(e, n, t.stops[i - 1][0], t.stops[i][0], t.stops[i - 1][1], t.stops[i][1]);
	}

	function gr(t, e) {
	    return i = t.default, void 0 !== (n = e) ? n : void 0 !== i ? i : void 0 !== r ? r : null;
	    var n, i, r;
	}

	function pr(t, e, n, i, r, o) {
	    var s, a = i - n, h = t - n;
	    return r * (1 - (s = 1 === e ? h / a : (Math.pow(e, h) - 1) / (Math.pow(e, a) - 1))) + o * s;
	}

	function _r(t) {
	    return t && "object" == typeof t && (t.stops || t.property && "identity" === t.type);
	}

	function vr(t) {
	    for (var e in t) if (_r(t[e])) return !0;
	    return !1;
	}

	function yr(t) {
	    return function t(e, n) {
	        if (!_r(e)) return function() {
	            return e;
	        };
	        e = JSON.parse(JSON.stringify(e));
	        var i = !0, r = !0, o = e.stops;
	        if (o) for (var s = 0; s < o.length; s++) if (_r(o[s][1])) {
	            var a = t(o[s][1], n);
	            i = i && a.isZoomConstant, r = r && a.isFeatureConstant, o[s] = [ o[s][0], a ];
	        }
	        var h = function t(e, n) {
	            var i, r, o;
	            if (_r(e)) {
	                var s, a = e.stops && "object" == typeof e.stops[0][0], h = a || !(a || void 0 !== e.property), l = e.type || n || "exponential";
	                if ("exponential" === l) s = mr; else if ("interval" === l) s = dr; else if ("categorical" === l) s = fr; else {
	                    if ("identity" !== l) throw new Error('Unknown function type "' + l + '"');
	                    s = gr;
	                }
	                if (a) {
	                    for (var c = {}, u = [], f = 0; f < e.stops.length; f++) {
	                        var d = e.stops[f];
	                        void 0 === c[d[0].zoom] && (c[d[0].zoom] = {
	                            zoom: d[0].zoom,
	                            type: e.type,
	                            property: e.property,
	                            default: e.default,
	                            stops: []
	                        }), c[d[0].zoom].stops.push([ d[0].value, d[1] ]);
	                    }
	                    for (var m in c) u.push([ c[m].zoom, t(c[m]) ]);
	                    i = function(t, n) {
	                        var i = mr({
	                            stops: u,
	                            base: e.base
	                        }, t)(t, n);
	                        return "function" == typeof i ? i(t, n) : i;
	                    }, r = !1, o = !1;
	                } else h ? (i = function(t) {
	                    var n = s(e, t);
	                    return "function" == typeof n ? n(t) : n;
	                }, r = !0, o = !1) : (i = function(t, n) {
	                    var i = s(e, n ? n[e.property] : null);
	                    return "function" == typeof i ? i(t, n) : i;
	                }, r = !1, o = !0);
	            } else i = function() {
	                return e;
	            }, r = !0, o = !0;
	            return i.isZoomConstant = o, i.isFeatureConstant = r, i;
	        }(e, n);
	        return h.isZoomConstant = i && h.isZoomConstant, h.isFeatureConstant = r && h.isFeatureConstant, 
	        h;
	    }(t, "exponential");
	}

	function xr(t, e) {
	    if (!t) return null;
	    var n = !1;
	    if (Array.isArray(t)) {
	        for (var i, r = [], o = 0; o < t.length; o++) (i = xr(t[o], e)) ? (r.push(i), n = !0) : r.push(t[o]);
	        return n ? r : t;
	    }
	    var s, a = {
	        __fn_types_loaded: !0
	    }, h = [];
	    for (s in t) t.hasOwnProperty(s) && h.push(s);
	    for (var l = function(t) {
	        Object.defineProperty(a, t, {
	            get: function() {
	                return this["__fn_" + t] || (this["__fn_" + t] = yr(this["_" + t])), this["__fn_" + t].apply(this, e());
	            },
	            set: function(e) {
	                this["_" + t] = e;
	            },
	            configurable: !0,
	            enumerable: !0
	        });
	    }, c = 0, u = h.length; c < u; c++) _r(t[s = h[c]]) ? (n = !0, a["_" + s] = t[s], 
	    l(s)) : a[s] = t[s];
	    return n ? a : t;
	}

	function br(t) {
	    if (!t || !t.stops) return [];
	    for (var e = [], n = 0, i = t.stops.length; n < i; n++) e.push(t.stops[n][1]);
	    return e;
	}

	var wr = [ "Unknown", "Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon", "GeometryCollection" ];

	function Cr(t) {
	    return new Function("f", "var p = (f && f.properties || {}); return " + Mr(t));
	}

	function Mr(t) {
	    if (!t) return "true";
	    var e = t[0];
	    return t.length <= 1 ? "any" === e ? "false" : "true" : "(" + ("==" === e ? Sr(t[1], t[2], "===", !1) : "!=" === e ? Sr(t[1], t[2], "!==", !1) : "<" === e || ">" === e || "<=" === e || ">=" === e ? Sr(t[1], t[2], e, !0) : "any" === e ? Pr(t.slice(1), "||") : "all" === e ? Pr(t.slice(1), "&&") : "none" === e ? Or(Pr(t.slice(1), "||")) : "in" === e ? Ar(t[1], t.slice(2)) : "!in" === e ? Or(Ar(t[1], t.slice(2))) : "has" === e ? Er(t[1]) : "!has" === e ? Or(Er(t[1])) : "true") + ")";
	}

	function Tr(t) {
	    return "$" === t[0] ? "f." + t.substring(1) : "p[" + JSON.stringify(t) + "]";
	}

	function Sr(t, e, n, i) {
	    var r = Tr(t), o = "$type" === t ? wr.indexOf(e) : JSON.stringify(e);
	    return (i ? "typeof " + r + "=== typeof " + o + "&&" : "") + r + n + o;
	}

	function Pr(t, e) {
	    return t.map(Mr).join(e);
	}

	function Ar(t, e) {
	    "$type" === t && (e = e.map((function(t) {
	        return wr.indexOf(t);
	    })));
	    var n = JSON.stringify(e.sort(Rr)), i = Tr(t);
	    return e.length <= 200 ? n + ".indexOf(" + i + ") !== -1" : "function(v, a, i, j) {\n        while (i <= j) { var m = (i + j) >> 1;\n            if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;\n        }\n    return false; }(" + i + ", " + n + ",0," + (e.length - 1) + ")";
	}

	function Er(t) {
	    return "$id" === t ? '"id" in f' : JSON.stringify(t) + " in p";
	}

	function Or(t) {
	    return "!(" + t + ")";
	}

	function Rr(t, e) {
	    return t < e ? -1 : t > e ? 1 : 0;
	}

	function Ir(t) {
	    var e = t._toJSON(), n = e.feature;
	    return n.type = wr.indexOf(n.geometry.type), n.subType = e.subType, n;
	}

	function kr(t) {
	    for (var e = 1; e < arguments.length; e++) {
	        var n = arguments[e];
	        for (var i in n) t[i] = n[i];
	    }
	    return t;
	}

	var Dr = [], Lr = {};

	function zr(t, e) {
	    return xr(t, (function() {
	        var t = e.getMap();
	        return function(t, e, n) {
	            return t[0] = e, t[1] = n, t;
	        }(Dr, t ? t.getZoom() : 12, kn({}, e.getProperties(), function(t, e, n, i) {
	            return t["{bearing}"] = e, t["{pitch}"] = n, t["{zoom}"] = i, t;
	        }(Lr, t && t.getBearing() || 0, t && t.getPitch() || 0, t ? t.getZoom() : 10)));
	    }));
	}

	function Fr(t) {
	    var e = {
	        stroke: {
	            stroke: t.markerLineColor,
	            "stroke-width": t.markerLineWidth,
	            "stroke-opacity": t.markerLineOpacity,
	            "stroke-dasharray": null,
	            "stroke-linecap": "butt",
	            "stroke-linejoin": "round"
	        },
	        fill: {
	            fill: t.markerFill,
	            "fill-opacity": t.markerFillOpacity
	        }
	    };
	    return 0 === e.stroke["stroke-width"] && (e.stroke["stroke-opacity"] = 0), e;
	}

	function jr(t, e, n) {
	    if (!t.markerPath) return null;
	    var i = 1, r = Fr(t);
	    Ln(t.markerOpacity) && (i = t.markerOpacity), Ln(t.opacity) && (i *= t.opacity);
	    var o = {};
	    if (r) {
	        for (var s in r.stroke) r.stroke.hasOwnProperty(s) && (Dn(r.stroke[s]) || (o[s] = r.stroke[s]));
	        for (var a in r.fill) r.fill.hasOwnProperty(a) && (Dn(r.fill[a]) || (o[a] = r.fill[a]));
	    }
	    for (var h, l = Array.isArray(t.markerPath) ? t.markerPath : [ t.markerPath ], c = [], u = 0; u < l.length; u++) (h = kn({}, h = jn(l[u]) ? {
	        path: l[u]
	    } : l[u], o)).d = h.path, delete h.path, c.push(h);
	    var f = [ '<svg version="1.1"', 'xmlns="http://www.w3.org/2000/svg"' ];
	    i < 1 && f.push('opacity="' + i + '"'), t.markerPathWidth && t.markerPathHeight && f.push('viewBox="0 0 ' + t.markerPathWidth + " " + t.markerPathHeight + '"'), 
	    f.push('preserveAspectRatio="none"'), e && f.push('width="' + e + '"'), n && f.push('height="' + n + '"'), 
	    f.push("><defs></defs>");
	    for (var d = 0; d < c.length; d++) {
	        var m = "<path ";
	        for (var g in c[d]) c[d].hasOwnProperty(g) && (m += " " + g + '="' + c[d][g] + '"');
	        f.push(m += "></path>");
	    }
	    return f.push("</svg>"), "data:image/svg+xml;base64," + Qi$1(f.join(" "));
	}

	function Hr(t, e) {
	    if (!t) return [];
	    var n = t;
	    Array.isArray(t) || (n = [ t ]);
	    for (var i, r, o, s, a = [], h = An, l = n.length - 1; l >= 0; l--) if (t = n[l]) {
	        e && (t = Nr(t));
	        for (var c = 0; c < h.length; c++) if (_r(i = t[h[c]]) && (i = br(i)), i) {
	            Array.isArray(i) || (i = [ i ]);
	            for (var u = 0; u < i.length; u++) "url(" === i[u].slice(0, 4) && (i[u] = Ki$1(i[u])), 
	            a.push([ i[u], t[(r = En[c])[0]], t[r[1]] ]);
	        }
	        if ("path" === t.markerType && t.markerPath) if (o = _r(t.markerWidth) ? 200 : t.markerWidth, 
	        s = _r(t.markerHeight) ? 200 : t.markerHeight, _r(t.markerPath)) {
	            i = br(t.markerPath);
	            for (var f = t.markerPath, d = 0; d < i.length; d++) t.markerPath = i[d], a.push([ jr(t), o, s ]);
	            t.markerPath = f;
	        } else a.push([ jr(t), o, s ]);
	    }
	    return a;
	}

	function Nr(t) {
	    if (!t) return null;
	    var e = t;
	    if (Wn) return e;
	    for (var n, i = An, r = 0, o = i.length; r < o; r++) (n = e[i[r]]) && (e[i[r]] = Br(n));
	    return e;
	}

	function Br(t) {
	    if (_r(t)) {
	        for (var e = t.stops, n = 0; n < e.length; n++) e[n][1] = Br(e[n][1]);
	        return t;
	    }
	    return "url(" === t.slice(0, 4) && (t = Ki$1(t)), t;
	}

	var Gr = function() {
	    function t(t, e) {
	        Ln(t) && Ln(e) ? (this.width = t, this.height = e) : Ln(t.width) ? (this.width = t.width, 
	        this.height = t.height) : Array.isArray(t) && (this.width = t[0], this.height = t[1]);
	    }
	    var e = t.prototype;
	    return e.copy = function() {
	        return new t(this.width, this.height);
	    }, e.add = function(e, n) {
	        var i, r;
	        return e instanceof t ? (i = this.width + e.width, r = this.height + e.height) : (i = this.width + e, 
	        r = this.height + n), new t(i, r);
	    }, e.equals = function(t) {
	        return this.width === t.width && this.height === t.height;
	    }, e.multi = function(e) {
	        return new t(this.width * e, this.height * e);
	    }, e._multi = function(t) {
	        return this.width *= t, this.height *= t, this;
	    }, e._round = function() {
	        return this.width = Math.round(this.width), this.height = Math.round(this.height), 
	        this;
	    }, e.toPoint = function() {
	        return new Oi$1(this.width, this.height);
	    }, e.toArray = function() {
	        return [ this.width, this.height ];
	    }, e.toJSON = function() {
	        return {
	            width: this.width,
	            height: this.height
	        };
	    }, t;
	}();

	function Vr(t) {
	    return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "");
	}

	var Ur = /[\b\t\r\v\f]/gim;

	function Wr(t) {
	    return jn(t) ? t.replace(Ur, "") : t;
	}

	function Zr(t) {
	    return Vr(t).split(/\s+/);
	}

	var Xr = "undefined" != typeof document ? document.createElement("canvas").getContext("2d") : null;

	function Jr(t, e) {
	    return Jr.node ? Jr.node(t, e) : (Xr.font = e, Xr.measureText(t).width);
	}

	function qr(t, e, n) {
	    var i = Jr(t, e);
	    return new Gr(i, n || 14);
	}

	function Yr(t, e, n, i) {
	    if (!t || 0 === t.length) return [ {
	        text: "",
	        width: 0
	    } ];
	    var r = Dn(i) ? Jr(t, e) : i, o = r / t.length, s = Math.floor(n / o / 2);
	    if (o >= n || s <= 0) return [ {
	        text: "",
	        width: n
	    } ];
	    if (r <= n) return [ {
	        text: t,
	        width: r
	    } ];
	    for (var a = [], h = t.substring(0, s), l = o * s, c = s, u = t.length; c < u; c++) {
	        var f = t[c], d = Jr(h + f);
	        d >= n ? (a.push({
	            text: h,
	            width: l
	        }), h = t.substring(c, s + c), c += s - 1, l = o * s) : (h += f, l = d), c >= u - 1 && (l = Jr(h), 
	        a.push({
	            text: h,
	            width: l
	        }));
	    }
	    return a;
	}

	var Kr = /\{([\w_]+)\}/g;

	function Qr(t, e) {
	    return jn(t) ? t.replace(Kr, (function(t, n) {
	        if (!e) return "";
	        var i = e[n];
	        return Dn(i) ? "" : Array.isArray(i) ? i.join() : i;
	    })) : t;
	}

	function $r(t, e) {
	    Ln(t) && (t += "");
	    var n = e.textMaxHeight || 0, i = no(t = t || "", e);
	    return n && n < i.size.height && (i.size.height = n), i;
	}

	function to(t, e, n) {
	    var i = t.width, r = t.height;
	    return new Oi$1("left" === e ? -i : "right" === e ? 0 : -i / 2, "top" === n ? -r : "bottom" === n ? 0 : -r / 2);
	}

	function eo(t) {
	    return t.textFont ? t.textFont : (t.textStyle && "normal" !== t.textStyle ? t.textStyle + " " : "") + (t.textWeight && "normal" !== t.textWeight ? t.textWeight + " " : "") + t.textSize + "px " + (t.textFaceName ? '"' === t.textFaceName[0] ? t.textFaceName : '"' + t.textFaceName + '"' : "monospace");
	}

	function no(t, e) {
	    var n = eo(e), i = e.textLineSpacing || 0, r = qr(t, n, e.textSize), o = r.width, s = r.height, a = e.textWrapCharacter, h = [], l = e.textWrapWidth;
	    (!l || l > o) && (l = o), jn(t) || (t += "");
	    var c = 0;
	    if (a && t.indexOf(a) >= 0) for (var u = t.split(a), f = 0, d = u.length; f < d; f++) {
	        var m = u[f], g = Jr(m, n);
	        if (g > l) for (var p = Yr(m, n, l, g), _ = 0, v = p.length; _ < v; _++) {
	            var y = p[_].width;
	            y > c && (c = y), h.push({
	                text: p[_].text,
	                size: new Gr(y, s)
	            });
	        } else g > c && (c = g), h.push({
	            text: m,
	            size: new Gr(g, s)
	        });
	    } else if (o > l) for (var x = Yr(t, n, l, o), b = 0; b < x.length; b++) {
	        var w = x[b].width;
	        w > c && (c = w), h.push({
	            text: x[b].text,
	            size: new Gr(w, s)
	        });
	    } else o > c && (c = o), h.push({
	        text: t,
	        size: r
	    });
	    var C = h.length;
	    return {
	        total: C,
	        size: new Gr(c, s * C + i * (C - 1)),
	        rows: h,
	        rawSize: r
	    };
	}

	function io(t) {
	    var e = 0, n = t && t.length || 0;
	    if (!n) return e;
	    for (var i = 0; i < n; i++) e = (e << 5) - e + t.charCodeAt(i), e &= e;
	    return e;
	}

	function ro(t) {
	    return t && t.colorStops;
	}

	function oo(t) {
	    var e = [ t.type ];
	    if (t.places && e.push(t.places.join()), t.colorStops) {
	        for (var n = [], i = t.colorStops.length - 1; i >= 0; i--) n.push(t.colorStops[i].join());
	        e.push(n.join(","));
	    }
	    return e.join("_");
	}

	function so(t, e) {
	    if (!t) return 1;
	    var n = [];
	    if (Array.isArray(t)) {
	        for (var i = 0; i < t.length; i++) n.push(so(t[i], e));
	        return n.sort().join(",");
	    }
	    var r = Object.keys(t).sort().reduce((function(n, i) {
	        return e && 0 !== i.indexOf(e) || (n[i] = t[i]), n;
	    }), {});
	    return io(JSON.stringify(r));
	}

	function ao(t, e) {
	    function n(t, e) {
	        Dn(t.opacity) ? t.opacity = e : t.opacity *= e;
	    }
	    var i;
	    if (Array.isArray(t)) {
	        i = [];
	        for (var r = 0; r < t.length; r++) {
	            var o = kn({}, t[r]);
	            n(o, e), i.push(o);
	        }
	    } else n(i = kn({}, t), e);
	    return i;
	}

	function ho(t) {
	    var e = Array.prototype.slice.call(arguments, 1);
	    if (e && e.length || (e = [ {} ]), Array.isArray(t)) {
	        for (var n, i, r = [], o = 0, s = t.length; o < s; o++) {
	            n = t[o], i = {};
	            for (var a = 0, h = e.length; a < h; a++) Array.isArray(e[a]) ? Dn(e[a][o]) ? kn(i, n || {}) : kn(i, n, e[a][o]) : kn(i, n, e[a] ? e[a] : {});
	            r.push(i);
	        }
	        return r;
	    }
	    var l = [ {}, t ];
	    return l.push.apply(l, e), kn.apply(this, l);
	}

	function lo(t) {
	    if (t.symbol && (t = [ t ]), Array.isArray(t)) return t;
	    var e = t.$root, n = t.$iconset;
	    if (t = t.style, e || n) {
	        e && "/" === e[e.length - 1] && (e = e.substring(0, e.length - 1)), n && "/" === n[n.length - 1] && (n = n.substring(0, n.length - 1));
	        co(t, (function(t) {
	            return "{$root}" === t ? e : "{$iconset}" === t ? n : null;
	        }));
	    }
	    return t;
	}

	function co(t, e) {
	    for (var n = 0; n < t.length; n++) {
	        var i = t[n].symbol;
	        i && fo(i, e);
	    }
	}

	var uo = /(\{\$root\}|\{\$iconset\})/g;

	function fo(t, e) {
	    for (var n in t) t.hasOwnProperty(n) && "textName" !== n && (jn(t[n]) && t[n].length > 2 ? t[n] = t[n].replace(uo, e) : _r(t[n]) ? t[n] = mo(t[n], e) : Fn(t[n]) && fo(t[n], e));
	}

	function mo(t, e) {
	    var n = t.default;
	    jn(n) && (t.default = n.replace(uo, e));
	    for (var i = t.stops, r = 0; r < i.length; r++) Array.isArray(i[r]) && (jn(i[r][1]) ? i[r][1] = i[r][1].replace(uo, e) : _r(i[r][1]) && (i[r][1] = mo(i[r][1], e)));
	    return t;
	}

	function go(t) {
	    void 0 === t && (t = []), Array.isArray(t) || (t = [ t ]);
	    for (var e = t.length, n = 0; n < e; n++) {
	        var i = t[n];
	        if (i.style) {
	            var r = i.style, o = r.lineDasharray, s = r.lineWidth;
	            if (s && Ln(s) && s > 0 && o && Array.isArray(o) && o.length) return !0;
	        }
	    }
	    return !1;
	}

	var po = Object.freeze({
	    now: In,
	    extend: kn,
	    isNil: Dn,
	    isNumber: Ln,
	    isInteger: zn,
	    isObject: Fn,
	    isString: jn,
	    isFunction: Hn,
	    hasOwn: Bn,
	    join: function(t, e) {
	        return t.join ? t.join(e || ",") : Array.prototype.join.call(t, e || ",");
	    },
	    isEmpty: function(t) {
	        var e;
	        for (e in t) return !1;
	        return !e;
	    },
	    toRadian: Vn,
	    toDegree: Un,
	    IS_NODE: Wn,
	    get requestAnimFrame() {
	        return Pi$1;
	    },
	    get cancelAnimFrame() {
	        return Ai$1;
	    },
	    isSVG: Ri$1,
	    loadImage: Ii$1,
	    UID: Di$1,
	    GUID: Li$1,
	    parseJSON: zi$1,
	    pushIn: Fi$1,
	    removeFromArray: ji$1,
	    forEachCoord: Hi$1,
	    getValueOrDefault: Ni$1,
	    sign: Bi$1,
	    log2: Gi$1,
	    interpolate: Vi$1,
	    wrap: Ui$1,
	    clamp: Wi$1,
	    isArrayHasData: Zi$1,
	    isURL: function(t) {
	        return Xi$1.test(t);
	    },
	    isCssUrl: Yi$1,
	    extractCssUrl: Ki$1,
	    btoa: Qi$1,
	    b64toBlob: $i$1,
	    computeDegree: tr,
	    emptyImageUrl: nr,
	    equalMapView: ir,
	    flash: or,
	    _defaults: function(t, e) {
	        for (var n = Object.getOwnPropertyNames(e), i = 0; i < n.length; i++) {
	            var r = n[i], o = Object.getOwnPropertyDescriptor(e, r);
	            o && o.configurable && void 0 === t[r] && Object.defineProperty(t, r, o);
	        }
	        return t;
	    },
	    getPointsResultPts: sr,
	    getImageBitMap: hr,
	    getAbsoluteURL: lr,
	    calCanvasSize: ur,
	    translateToSVGStyles: Fr,
	    getMarkerPathBase64: jr,
	    getExternalResources: Hr,
	    convertResourceUrl: Nr,
	    isGradient: ro,
	    getGradientStamp: oo,
	    getSymbolStamp: function(t, e) {
	        return so(t, e);
	    },
	    getSymbolHash: so,
	    lowerSymbolOpacity: ao,
	    extendSymbol: ho,
	    parseStyleRootPath: lo,
	    convertStylePath: co,
	    parseSymbolPath: fo,
	    isDashLine: go,
	    trim: Vr,
	    escapeSpecialChars: Wr,
	    splitWords: Zr,
	    stringWidth: Jr,
	    stringLength: qr,
	    splitContent: Yr,
	    CONTENT_EXPRE: Kr,
	    replaceVariable: Qr,
	    describeText: $r,
	    getAlignPoint: to,
	    getFont: eo,
	    splitTextToRow: no,
	    hashCode: io
	}), _o = Wn ? function(t) {
	    return t[0];
	} : function(t) {
	    for (var e = document.documentElement.style, n = 0; n < t.length; n++) if (t[n] in e) return t[n];
	    return !1;
	}, vo = _o([ "transform", "WebkitTransform", "OTransform", "MozTransform", "msTransform" ]), yo = _o([ "transformOrigin", "WebkitTransformOrigin", "OTransformOrigin", "MozTransformOrigin", "msTransformOrigin" ]), xo = _o([ "transition", "WebkitTransition", "OTransition", "MozTransition", "msTransition" ]);

	function bo(t, e) {
	    var n = document.createElement(t);
	    return e && Lo(n, e), n;
	}

	function wo(t, e, n) {
	    var i = bo(t);
	    return e && Io(i, e), n && n.appendChild(i), i;
	}

	function Co(t) {
	    if (!t) return this;
	    if (Mi$1.ielt9 || Mi$1.ie9) {
	        var e = bo("div");
	        e.appendChild(t), e.innerHTML = "", e = null;
	    } else t.parentNode && t.parentNode.removeChild(t);
	    return this;
	}

	function Mo(t, e, n, i) {
	    if (!(t && t.addEventListener && e && n)) return this;
	    for (var r = function(e) {
	        e || (e = window.event), n.call(i || t, e);
	    }, o = e.split(" "), s = o.length - 1; s >= 0; s--) {
	        var a = o[s];
	        if (a) t["Z__" + a] || (t["Z__" + a] = []), So(t, a, n) >= 0 && (console.warn(t, "find '" + a + "' handler:", n, " The old listener function will be removed"), 
	        To(t, a, n)), t["Z__" + a].push({
	            callback: r,
	            src: n
	        }), t.addEventListener(a, r, !!Mi$1.supportsPassive && {
	            capture: !1,
	            passive: !1
	        });
	    }
	    return this;
	}

	function To(t, e, n) {
	    function i(e, n) {
	        "mousewheel" === e && Mi$1.gecko && (e = "DOMMouseScroll"), t.removeEventListener(e, n, !1);
	    }
	    if (!t || !t.removeEventListener || !e) return this;
	    for (var r = e.split(" "), o = r.length - 1; o >= 0; o--) {
	        var s = r[o];
	        if (s) {
	            if (!n && t["Z__" + s]) {
	                for (var a = t["Z__" + s], h = 0, l = a.length; h < l; h++) i(a[h].callback);
	                return delete t["Z__" + s], this;
	            }
	            var c = So(t, s, n);
	            if (c < 0) return this;
	            i(s, t["Z__" + s][c].callback), t["Z__" + s].splice(c, 1);
	        }
	    }
	    return this;
	}

	function So(t, e, n) {
	    if (!t || !t["Z__" + e] || !n) return -1;
	    for (var i = t["Z__" + e], r = 0, o = i.length; r < o; r++) if (i[r].src === n) return r;
	    return -1;
	}

	function Po(t) {
	    return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this;
	}

	function Ao(t) {
	    return t.stopPropagation ? t.stopPropagation() : t.cancelBubble = !0, this;
	}

	function Eo(t, e) {
	    return t ? (Mi$1.any3d ? function(t, e) {
	        var n = e || new Oi$1(0, 0);
	        t.style[vo] = Mi$1.any3d ? "translate3d(" + n.x + "px," + n.y + "px,0px)" : "translate(" + n.x + "px," + n.y + "px)";
	    }(t, e) : (t.style.left = e.x + "px", t.style.top = e.y + "px"), e) : null;
	}

	function Oo(t) {
	    var e = window.getComputedStyle(t), n = [ parseInt(e["padding-left"]), parseInt(e["padding-top"]) ], i = t.getBoundingClientRect(), r = t.offsetWidth, o = t.offsetHeight;
	    return t.__position = [ i.left + n[0], i.top + n[1], r ? i.width / r : 1, o ? i.height / o : 1 ], 
	    t.__position;
	}

	function Ro(t, e) {
	    t || (t = window.event);
	    var n = e.__position;
	    return n || (n = Oo(e)), new Oi$1((t.clientX - n[0] - e.clientLeft) / n[2], (t.clientY - n[1] - e.clientTop) / n[3]);
	}

	function Io(t, e) {
	    var n, i, r, o = t.style.cssText;
	    return (r = (n = o).length - (i = ";").length) >= 0 && n.indexOf(i, r) === r || (o += ";"), 
	    t.style.cssText = o + e, this;
	}

	function ko(t, e) {
	    if (void 0 !== t.classList) return t.classList.contains(e);
	    var n = zo(t);
	    return n.length > 0 && new RegExp("(^|\\s)" + e + "(\\s|$)").test(n);
	}

	function Do(t, e) {
	    if (void 0 === t.classList || ko(t, e)) {
	        var n = zo(t);
	        Lo(t, (n ? n + " " : "") + e);
	    } else for (var i = Zr(e), r = 0, o = i.length; r < o; r++) t.classList.add(i[r]);
	    return this;
	}

	function Lo(t, e) {
	    return Dn(t.className.baseVal) ? t.className = e : t.className.baseVal = e, this;
	}

	function zo(t) {
	    return Dn(t.className.baseVal) ? t.className : t.className.baseVal;
	}

	function Fo(t, e) {
	    var n, i = ((n = document.createElement(t)).style.cssText = "position:absolute;left:-10000px;top:-10000px;", 
	    document.body.appendChild(n), n);
	    jn(e) ? i.innerHTML = e : i.appendChild(e);
	    var r = new Gr(i.clientWidth, i.clientHeight);
	    return Co(i), r;
	}

	_o([ "filter", "WebkitFilter", "OFilter", "MozFilter", "msFilter" ]);

	var jo, Ho = Mo, No = To, Bo = "function" == typeof Map, Go = function() {}, Vo = function() {
	    function t(t, e) {
	        this.max = t, this.onRemove = e || Go, this.reset();
	    }
	    var e = t.prototype;
	    return e.reset = function() {
	        for (var t in this.data) this.onRemove(this.data[t]);
	        return this.data = {}, this.order = [], this;
	    }, e.clear = function() {
	        this.reset(), delete this.onRemove;
	    }, e.add = function(t, e) {
	        if (this.has(t)) this.order.splice(this.order.indexOf(t), 1), this.data[t] = e, 
	        this.order.push(t); else if (this.data[t] = e, this.order.push(t), this.order.length > this.max) {
	            var n = this.getAndRemove(this.order[0]);
	            n && this.onRemove(n);
	        }
	        return this;
	    }, e.has = function(t) {
	        return t in this.data;
	    }, e.keys = function() {
	        return this.order;
	    }, e.getAndRemove = function(t) {
	        if (!this.has(t)) return null;
	        var e = this.data[t];
	        return delete this.data[t], this.order.splice(this.order.indexOf(t), 1), e;
	    }, e.get = function(t) {
	        return this.has(t) ? this.data[t] : null;
	    }, e.remove = function(t) {
	        if (!this.has(t)) return this;
	        var e = this.data[t];
	        return delete this.data[t], this.onRemove(e), this.order.splice(this.order.indexOf(t), 1), 
	        this;
	    }, e.setMaxSize = function(t) {
	        for (this.max = t; this.order.length > this.max; ) {
	            var e = this.getAndRemove(this.order[0]);
	            e && this.onRemove(e);
	        }
	        return this;
	    }, t;
	}();

	Bo && (jo = function() {
	    function t(t, e) {
	        this.max = t, this.onRemove = e || Go, this.reset();
	    }
	    var e = t.prototype;
	    return e.reset = function() {
	        if (this.data) {
	            var t = this.data.values(), e = Array.isArray(t), n = 0;
	            for (t = e ? t : t[Symbol.iterator](); ;) {
	                var i;
	                if (e) {
	                    if (n >= t.length) break;
	                    i = t[n++];
	                } else {
	                    if ((n = t.next()).done) break;
	                    i = n.value;
	                }
	                this.onRemove(i);
	            }
	        }
	        return this.data = new Map, this;
	    }, e.clear = function() {
	        this.reset(), delete this.onRemove;
	    }, e.add = function(t, e) {
	        return e ? (this.has(t) ? (this.data.delete(t), this.data.set(t, e), this.data.size > this.max && this.shrink()) : this.data.set(t, e), 
	        this) : this;
	    }, e.keys = function() {
	        var t = new Array(this.data.size), e = 0, n = this.data.keys(), i = Array.isArray(n), r = 0;
	        for (n = i ? n : n[Symbol.iterator](); ;) {
	            var o;
	            if (i) {
	                if (r >= n.length) break;
	                o = n[r++];
	            } else {
	                if ((r = n.next()).done) break;
	                o = r.value;
	            }
	            t[e++] = o;
	        }
	        return t;
	    }, e.shrink = function() {
	        for (var t = this.data.keys(), e = t.next(); this.data.size > this.max; ) {
	            var n = this.getAndRemove(e.value);
	            n && this.onRemove(n), e = t.next();
	        }
	    }, e.has = function(t) {
	        return this.data.has(t);
	    }, e.getAndRemove = function(t) {
	        if (!this.has(t)) return null;
	        var e = this.data.get(t);
	        return this.data.delete(t), e;
	    }, e.get = function(t) {
	        return this.has(t) ? this.data.get(t) : null;
	    }, e.remove = function(t) {
	        if (!this.has(t)) return this;
	        var e = this.data.get(t);
	        return this.data.delete(t), this.onRemove(e), this;
	    }, e.setMaxSize = function(t) {
	        return this.max = t, this.data.size > this.max && this.shrink(), this;
	    }, t;
	}());

	var Uo = Bo ? jo : Vo, Wo = {
	    jsonp: function(t, e) {
	        var n = "_maptalks_jsonp_" + Di$1();
	        t.match(/\?/) ? t += "&callback=" + n : t += "?callback=" + n;
	        var i = document.createElement("script");
	        return i.type = "text/javascript", i.src = t, window[n] = function(t) {
	            e(null, t), document.getElementsByTagName("head")[0].removeChild(i), i = null, delete window[n];
	        }, document.getElementsByTagName("head")[0].appendChild(i), this;
	    },
	    get: function(t, e, n) {
	        if (Hn(e)) {
	            var i = n;
	            n = e, e = i;
	        }
	        if (Wn && Wo.get.node) return Wo.get.node(t, n, e);
	        var r = Wo._getClient(n);
	        if (r.open("GET", t, !0), e) {
	            for (var o in e.headers) r.setRequestHeader(o, e.headers[o]);
	            r.withCredentials = "include" === e.credentials, e.responseType && (r.responseType = e.responseType);
	        }
	        return r.send(null), r;
	    },
	    post: function(t, e, n) {
	        var i;
	        if (jn(t)) {
	            if (Hn(e)) {
	                var r = n;
	                n = e, e = r;
	            }
	            i = (e = e || {}).postData;
	        } else {
	            i = e, t = (e = t).url, n = n;
	        }
	        if (Wn && Wo.post.node) return e.url = t, Wo.post.node(e, i, n);
	        var o = Wo._getClient(n);
	        if (o.open("POST", e.url, !0), e.headers || (e.headers = {}), e.headers["Content-Type"] || (e.headers["Content-Type"] = "application/x-www-form-urlencoded"), 
	        "setRequestHeader" in o) for (var s in e.headers) e.headers.hasOwnProperty(s) && o.setRequestHeader(s, e.headers[s]);
	        return jn(i) || (i = JSON.stringify(i)), o.send(i), o;
	    },
	    _wrapCallback: function(t, e) {
	        return function() {
	            4 === t.readyState && (200 === t.status ? "arraybuffer" === t.responseType ? 0 === t.response.byteLength ? e(new Error("http status 200 returned without content.")) : e(null, {
	                data: t.response,
	                cacheControl: t.getResponseHeader("Cache-Control"),
	                expires: t.getResponseHeader("Expires"),
	                contentType: t.getResponseHeader("Content-Type")
	            }) : e(null, t.responseText) : e(new Error(t.statusText + "," + t.status)));
	        };
	    },
	    _getClient: function(t) {
	        var e;
	        try {
	            e = new XMLHttpRequest;
	        } catch (t) {
	            try {
	                e = new ActiveXObject("Msxml2.XMLHTTP");
	            } catch (t) {
	                try {
	                    e = new ActiveXObject("Microsoft.XMLHTTP");
	                } catch (t) {}
	            }
	        }
	        return e.onreadystatechange = Wo._wrapCallback(e, t), e;
	    },
	    getArrayBuffer: function(t, e, n) {
	        if (Hn(e)) {
	            var i = n;
	            n = e, e = i;
	        }
	        return e || (e = {}), e.responseType = "arraybuffer", Wo.get(t, e, n);
	    },
	    getImage: function(t, e, n) {
	        return Wo.getArrayBuffer(e, n, (function(e, n) {
	            if (e) t.onerror && t.onerror(e); else if (n) {
	                var i = window.URL || window.webkitURL, r = t.onload;
	                t.onload = function() {
	                    r && r(), i.revokeObjectURL(t.src);
	                };
	                var o = new Blob([ new Uint8Array(n.data) ], {
	                    type: n.contentType
	                });
	                t.cacheControl = n.cacheControl, t.expires = n.expires, t.src = n.data.byteLength ? i.createObjectURL(o) : nr;
	            }
	        }));
	    },
	    getJSON: function(t, e, n) {
	        if (Hn(e)) {
	            var i = n;
	            n = e, e = i;
	        }
	        var r = function(t, e) {
	            var i = e ? zi$1(e) : null;
	            n(t, i);
	        };
	        return e && e.jsonp ? Wo.jsonp(t, r) : Wo.get(t, e, r);
	    }
	}, Zo = !1, Xo = null, Jo = Math.PI / 180, qo = {
	    setHitTesting: function(t) {
	        Zo = t;
	    },
	    createCanvas: function(t, e, n) {
	        var i;
	        return Wn ? i = new n(t, e) : ((i = bo("canvas")).width = t, i.height = e), i;
	    },
	    prepareCanvasFont: function(t, e) {
	        t.textBaseline = "top", t.font = eo(e);
	        var n = e.textFill;
	        n || (n = "#000"), t.fillStyle = qo.getRgba(n, e.textOpacity);
	    },
	    prepareCanvas: function(t, e, n, i) {
	        if (e) {
	            var r = e.lineWidth;
	            Dn(r) || t.lineWidth === r || (t.lineWidth = r);
	            var o = e.linePatternFile, s = e.lineColor || "#000";
	            if (i) t.strokeStyle = "#000"; else if (o && n) {
	                var a;
	                (e.linePatternDx || e.linePatternDy) && (a = [ e.linePatternDx, e.linePatternDy ]), 
	                qo._setStrokePattern(t, o, r, a, n), e.lineDasharray = [];
	            } else ro(s) ? t.strokeStyle = e.lineGradientExtent ? qo._createGradient(t, s, e.lineGradientExtent) : "#000" : (Array.isArray(s) && (s = qo.normalizeColorToRGBA(s)), 
	            t.strokeStyle = s);
	            e.lineJoin && (t.lineJoin = e.lineJoin), e.lineCap && (t.lineCap = e.lineCap), t.setLineDash && Zi$1(e.lineDasharray) && t.setLineDash(e.lineDasharray);
	            var h = e.polygonPatternFile, l = e.polygonFill || "rgba(255,255,255,0)";
	            if (i) t.fillStyle = "#000"; else if (h && n) {
	                var c = Ko(h), u = n.getImage([ c, null, null ]);
	                if (u || (u = n.getImage([ c + "-texture", null, r ])), Ri$1(c) && u instanceof Image && (Mi$1.edge || Mi$1.ie)) {
	                    var f = u.width || 20, d = u.height || 20, m = qo.createCanvas(f, d);
	                    qo.image(m.getContext("2d"), u, 0, 0, f, d), u = m;
	                }
	                u ? (t.fillStyle = t.createPattern(u, "repeat"), (e.polygonPatternDx || e.polygonPatternDy) && (t.fillStyle.polygonPatternOffset = [ e.polygonPatternDx, e.polygonPatternDy ])) : "undefined" != typeof console && console.warn("img not found for", c);
	            } else ro(l) ? t.fillStyle = e.polygonGradientExtent ? qo._createGradient(t, l, e.polygonGradientExtent) : "rgba(255,255,255,0)" : (Array.isArray(l) && (l = qo.normalizeColorToRGBA(l)), 
	            t.fillStyle = l);
	        }
	    },
	    _createGradient: function(t, e, n) {
	        var i = null, r = e.places, o = n.getMin(), s = n.getMax(), a = n.getWidth(), h = n.getHeight();
	        if (e.type && "linear" !== e.type) {
	            if ("radial" === e.type) {
	                if (r) {
	                    if (6 !== r.length) throw new Error("A radial gradient's places should have 6 numbers.");
	                    r = [ o.x + r[0] * a, o.y + r[1] * h, a * r[2], o.x + r[3] * a, o.y + r[4] * h, a * r[5] ];
	                } else {
	                    var l = n.getCenter()._round();
	                    r = [ l.x, l.y, Math.abs(l.x - o.x), l.x, l.y, 0 ];
	                }
	                i = t.createRadialGradient.apply(t, r);
	            }
	        } else {
	            if (r) {
	                if (4 !== r.length) throw new Error("A linear gradient's places should have 4 numbers.");
	                r = [ o.x + r[0] * a, o.y + r[1] * h, o.x + r[2] * a, o.y + r[3] * h ];
	            } else r = [ o.x, o.y, s.x, o.y ];
	            i = t.createLinearGradient.apply(t, r);
	        }
	        return e.colorStops.forEach((function(t) {
	            i.addColorStop.apply(i, t);
	        })), i;
	    },
	    _setStrokePattern: function(t, e, n, i, r) {
	        var o, s = Ko(e);
	        if (Wn) o = r.getImage([ s, null, n ]); else {
	            var a = s + "-texture-" + n;
	            if (!(o = r.getImage(a))) {
	                var h = r.getImage([ s, null, null ]);
	                if (h) {
	                    var l;
	                    l = h.width && h.height ? Math.round(h.width * n / h.height) : n;
	                    var c = qo.createCanvas(l, n, t.canvas.constructor);
	                    qo.image(c.getContext("2d"), h, 0, 0, l, n), r.addResource([ a, null, n ], c), o = c;
	                }
	            }
	        }
	        o ? (t.strokeStyle = t.createPattern(o, "repeat"), t.strokeStyle.linePatternOffset = i) : "undefined" != typeof console && console.warn("img not found for", s);
	    },
	    clearRect: function(t, e, n, i, r) {
	        t.canvas._drawn = !1, t.clearRect(e, n, i, r);
	    },
	    fillCanvas: function(t, e, n, i) {
	        if (Zo && (e = 1), t.canvas._drawn = !0, 0 !== e) {
	            var r, o = qo._isPattern(t.fillStyle), s = t.fillStyle && t.fillStyle.polygonPatternOffset, a = s ? s[0] : 0, h = s ? s[1] : 0;
	            Dn(e) && (e = 1), e < 1 && (r = t.globalAlpha, t.globalAlpha *= e), o && t.translate((n = n || 0) + a, (i = i || 0) + h), 
	            t.fill(), o && t.translate(-n - a, -i - h), e < 1 && (t.globalAlpha = r);
	        }
	    },
	    getRgba: function(t, e) {
	        return Dn(e) && (e = 1), "#" !== t[0] ? (Array.isArray(t) && (t = qo.normalizeColorToRGBA(t, e)), 
	        t) : (7 === t.length ? (n = parseInt(t.substring(1, 3), 16), i = parseInt(t.substring(3, 5), 16), 
	        r = parseInt(t.substring(5, 7), 16)) : (n = 17 * parseInt(t.substring(1, 2), 16), 
	        i = 17 * parseInt(t.substring(2, 3), 16), r = 17 * parseInt(t.substring(3, 4), 16)), 
	        "rgba(" + n + "," + i + "," + r + "," + e + ")");
	        var n, i, r;
	    },
	    normalizeColorToRGBA: function(t, e) {
	        return void 0 === e && (e = 1), "rgba(" + 255 * t[0] + "," + 255 * t[1] + "," + 255 * t[2] + "," + (4 === t.length ? t[3] : 1) * e + ")";
	    },
	    image: function(t, e, n, i, r, o) {
	        t.canvas._drawn = !0;
	        try {
	            Ln(r) && Ln(o) ? t.drawImage(e, n, i, r, o) : t.drawImage(e, n, i);
	        } catch (t) {
	            console && (console.warn("error when drawing image on canvas:", t), console.warn(e));
	        }
	    },
	    text: function(t, e, n, i, r) {
	        qo._textOnMultiRow(t, r.rows, i, n, r.size, r.rawSize);
	    },
	    _textOnMultiRow: function(t, e, n, i, r, o) {
	        for (var s, a, h = to(r, n.textHorizontalAlignment, n.textVerticalAlignment), l = o.height + n.textLineSpacing, c = i.add(0, h.y), u = n.textMaxHeight, f = 0, d = 0, m = e.length; d < m && (s = e[d].text, 
	        a = to(e[d].size, n.textHorizontalAlignment, n.textVerticalAlignment), qo._textOnLine(t, s, c.add(a.x, d * l), n.textHaloRadius, n.textHaloFill, n.textHaloOpacity), 
	        !(u > 0 && (f += l) + o.height >= u)); d++) ;
	    },
	    _textOnLine: function(t, e, n, i, r, o) {
	        Zo && (o = 1);
	        var s, a, h = 0 !== o && 0 !== i;
	        t.textBaseline = "top";
	        var l = t.shadowBlur, c = t.shadowOffsetX, u = t.shadowOffsetY;
	        if (h) {
	            var f = t.globalAlpha;
	            t.globalAlpha *= o, t.miterLimit = 2, t.lineJoin = "round", t.lineCap = "round", 
	            t.lineWidth = 2 * i, Array.isArray(r) && (r = qo.normalizeColorToRGBA(r)), t.strokeStyle = r, 
	            t.strokeText(e, n.x, n.y + 1), t.miterLimit = 10, t.globalAlpha = f, s = t.globalCompositeOperation, 
	            t.globalCompositeOperation = "destination-out", a = t.fillStyle, t.fillStyle = "#000";
	        }
	        l && h && (t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0), qo.fillText(t, e, n), 
	        s && (t.globalCompositeOperation = s, qo.fillText(t, e, n, a), l && (t.shadowBlur = l, 
	        t.shadowOffsetX = c, t.shadowOffsetY = u));
	    },
	    fillText: function(t, e, n, i) {
	        t.canvas._drawn = !0, i && (t.fillStyle = i), t.fillText(e, n.x, n.y + 1);
	    },
	    _stroke: function(t, e, n, i) {
	        if (Zo && (e = 1), t.canvas._drawn = !0, 0 !== e) {
	            var r, o = t.strokeStyle && t.strokeStyle.linePatternOffset, s = o ? o[0] : 0, a = o ? o[1] : 0, h = qo._isPattern(t.strokeStyle) && (!Dn(n) && !Dn(i) || !Dn(s) && !Dn(a));
	            Dn(e) && (e = 1), e < 1 && (r = t.globalAlpha, t.globalAlpha *= e), h && t.translate((n = n || 0) + s, (i = i || 0) + a), 
	            t.stroke(), h && t.translate(-n - s, -i - a), e < 1 && (t.globalAlpha = r);
	        }
	    },
	    _path: function(t, e, n, i, r) {
	        if (Zi$1(e)) for (var o, s = Zi$1(n), a = !0 !== r && qo._isPattern(t.strokeStyle), h = 0, l = e.length; h < l; h++) if (o = e[h], 
	        !s || t.setLineDash) t.lineTo(o.x, o.y), a && h > 0 && (c(e[h - 1], o), t.beginPath(), 
	        t.moveTo(o.x, o.y)); else if (s) {
	            if (h === l - 1) break;
	            Yo(t, o, e[h + 1], n);
	        }
	        function c(e, n) {
	            var r = tr(e.x, e.y, n.x, n.y);
	            t.save();
	            var o = Math.cos(r);
	            Math.abs(o) < 1e-7 ? t.translate(e.x - t.lineWidth / 2, e.y) : t.translate(e.x, e.y - t.lineWidth / 2 / o), 
	            t.rotate(r), qo._stroke(t, i), t.restore();
	        }
	    },
	    path: function(t, e, n, i, r) {
	        Zi$1(e) && (t.beginPath(), t.moveTo(e[0].x, e[0].y), qo._path(t, e, r, n), qo._stroke(t, n));
	    },
	    _multiClip: function(t, e) {
	        if (e && 0 !== e.length) for (var n = 0, i = (e = e[0]).length; n < i; n++) {
	            var r = e[n], o = r.x, s = r.y;
	            0 === n ? t.moveTo(o, s) : t.lineTo(o, s), n === i - 1 && t.lineTo(o = e[0].x, s = e[0].y);
	        }
	    },
	    polygon: function(t, e, n, i, r, o) {
	        if (t.isMultiClip) qo._multiClip(t, e); else if (Zi$1(e)) {
	            var s = qo._isPattern(t.strokeStyle), a = Zi$1(r) && !t.setLineDash || s && !o;
	            Zi$1(e[0]) || (e = [ e ]);
	            var h, l, c, u = t;
	            if (e.length > 1 && !Wn && (Xo || (Xo = qo.createCanvas(1, 1)), t.canvas._drawn = !1, 
	            Xo.width = t.canvas.width, Xo.height = t.canvas.height, Qo(t = Xo.getContext("2d"), u)), 
	            a) {
	                for (t.save(), l = 0, c = e.length; l < c; l++) Zi$1(e[l]) && (qo._ring(t, e[l], null, 0, !0), 
	                h = i, l > 0 && (t.globalCompositeOperation = "destination-out", h = 1), qo.fillCanvas(t, h, e[l][0].x, e[l][0].y), 
	                l > 0 ? t.globalCompositeOperation = "source-over" : c > 1 && (t.fillStyle = "#fff"), 
	                qo._stroke(t, 0));
	                t.restore();
	            }
	            var f = t.fillStyle;
	            for (l = 0, c = e.length; l < c; l++) Zi$1(e[l]) && (o ? (qo.paintSmoothLine(t, e[l], n, o, !0), 
	            t.closePath()) : qo._ring(t, e[l], r, n), a || (h = i, l > 0 && (t.globalCompositeOperation = "destination-out", 
	            h = 1), qo.fillCanvas(t, h, e[l][0].x, e[l][0].y), l > 0 ? t.globalCompositeOperation = "source-over" : c > 1 && (t.fillStyle = "#fff")), 
	            qo._stroke(t, n));
	            t.fillStyle !== f && (t.fillStyle = f), e.length > 1 && !Wn && (u.drawImage(Xo, 0, 0), 
	            u.canvas._drawn = t.canvas._drawn, Qo(u, t));
	        }
	    },
	    _ring: function(t, e, n, i, r) {
	        var o = qo._isPattern(t.strokeStyle);
	        r || !o || e[0].equals(e[e.length - 1]) || (e = e.concat([ e[0] ])), t.beginPath(), 
	        t.moveTo(e[0].x, e[0].y), qo._path(t, e, n, i, r), o || t.closePath();
	    },
	    paintSmoothLine: function(t, e, n, i, r, o, s) {
	        if (e) if (e.length <= 2 || !i) qo.path(t, e, n); else {
	            var a, h = e.length, l = r ? h : h - 1;
	            t.beginPath(), t.moveTo(e[0].x, e[0].y), void 0 !== s && (l -= Math.max(l - o - 1, 0));
	            for (var c = 0; c < l; c++) {
	                var u = void 0, f = void 0, d = void 0, m = void 0, g = void 0, p = void 0;
	                c - 1 < 0 ? r ? (u = e[l - 1].x, f = e[l - 1].y) : (u = e[c + 1].x, f = e[c + 1].y) : (u = e[c - 1].x, 
	                f = e[c - 1].y), c + 1 < h ? (d = e[c + 1].x, m = e[c + 1].y) : (d = e[c + 1 - h].x, 
	                m = e[c + 1 - h].y), c + 2 < h ? (g = e[c + 2].x, p = e[c + 2].y) : r ? (g = e[c + 2 - h].x, 
	                p = e[c + 2 - h].y) : (g = e[c].x, p = e[c].y);
	                var _ = y(u, f, e[c].x, e[c].y, d, m, g, p, i, c === l - 1 ? s : 1);
	                if (c === l - 1 && s >= 0 && s < 1) {
	                    t.bezierCurveTo(_[0], _[1], _[2], _[3], _[4], _[5]), e.splice(l - 1, h - (l - 1) - 1);
	                    var v = new Oi$1(_[4], _[5]);
	                    v.prevCtrlPoint = new Oi$1(_[2], _[3]), e.push(v), h = e.length;
	                } else t.bezierCurveTo(_[0], _[1], _[2], _[3], d, m);
	                e[c].nextCtrlPoint = _.slice(0, 2), e[c].prevCtrlPoint = a ? a.slice(2) : null, 
	                a = _;
	            }
	            !r && e[1].prevCtrlPoint && (e[0].nextCtrlPoint = e[1].prevCtrlPoint, delete e[0].prevCtrlPoint), 
	            e[h - 1].prevCtrlPoint || (e[h - 1].prevCtrlPoint = e[h - 2].nextCtrlPoint), qo._stroke(t, n);
	        }
	        function y(t, e, n, i, r, o, s, a, h, l) {
	            var c = (t + n) / 2, u = (e + i) / 2, f = (n + r) / 2, d = (i + o) / 2, m = (r + s) / 2, g = (o + a) / 2, p = Math.sqrt((n - t) * (n - t) + (i - e) * (i - e)), _ = Math.sqrt((r - n) * (r - n) + (o - i) * (o - i)), v = p / (p + _), y = _ / (_ + Math.sqrt((s - r) * (s - r) + (a - o) * (a - o))), x = c + (f - c) * v, b = u + (d - u) * v, w = f + (m - f) * y, C = d + (g - d) * y, M = x + (f - x) * h + n - x, T = b + (d - b) * h + i - b, S = w + (f - w) * h + r - w, P = C + (d - C) * h + o - C, A = [ M, T, S, P ];
	            return l < 1 ? function(t, e, n, i, r, o, s, a, h, l) {
	                var c = 1 - t, u = 1 - e, f = n * u * u + 2 * r * e * u + s * e * e, d = r * u * u + 2 * s * e * u + h * e * e, m = i * u * u + 2 * o * e * u + a * e * e, g = o * u * u + 2 * a * e * u + l * e * e;
	                return [ (n * c * c + 2 * r * t * c + s * t * t) * u + (r * c * c + 2 * s * t * c + h * t * t) * e, (i * c * c + 2 * o * t * c + a * t * t) * u + (o * c * c + 2 * a * t * c + l * t * t) * e, f * c + d * t, m * c + g * t, f * u + d * e, m * u + g * e ];
	            }(0, l, n, i, M, T, S, P, r, o) : A;
	        }
	    },
	    _arcBetween: function(t, e, n, i) {
	        var r = i, o = e.distanceTo(n), s = o / 2 / Math.sin(r / 2), a = Math.asin((n.y - e.y) / o);
	        e.x > n.x && (a = Math.PI - a);
	        var h = a - (90 * Jo - r / 2), l = Math.cos(h) * s, c = Math.sin(h) * s, u = e.x + l, f = e.y + c, d = Math.asin((n.y - f) / s);
	        u > n.x && (d = Math.PI - d);
	        var m = d + r;
	        return t.beginPath(), t.arc(u, f, s, d, m), [ u, f ];
	    },
	    _lineTo: function(t, e) {
	        t.lineTo(e.x, e.y);
	    },
	    bezierCurveAndFill: function(t, e, n, i) {
	        t.beginPath();
	        var r = e[0];
	        t.moveTo(r.x, r.y);
	        var o = [ t ];
	        o.push.apply(o, e.splice(1)), qo._bezierCurveTo.apply(qo, o), qo.fillCanvas(t, i), 
	        qo._stroke(t, n);
	    },
	    _bezierCurveTo: function(t, e, n, i) {
	        t.bezierCurveTo(e.x, e.y, n.x, n.y, i.x, i.y);
	    },
	    ellipse: function(t, e, n, i, r, o, s) {
	        var a, h, l, c, u, f, d, m, g;
	        t.beginPath(), n === i && n === r ? t.arc(e.x, e.y, n, 0, 2 * Math.PI) : t.ellipse ? i !== r ? (t.ellipse(e.x, e.y, n, i, 0, 180 * Jo, 360 * Jo, !1), 
	        t.ellipse(e.x, e.y, n, r, 0, 0, 180 * Jo, !1)) : t.ellipse(e.x, e.y, n, i, 0, 0, 360 * Jo, !1) : (d = (l = n) * (f = .5522848), 
	        m = (c = i) * f, g = (u = r) * f, t.moveTo((a = e.x) - l, h = e.y), t.bezierCurveTo(a - l, h - m, a - d, h - c, a, h - c), 
	        t.bezierCurveTo(a + d, h - c, a + l, h - m, a + l, h), t.bezierCurveTo(a + l, h + g, a + d, h + u, a, h + u), 
	        t.bezierCurveTo(a - d, h + u, a - l, h + g, a - l, h), t.closePath()), qo.fillCanvas(t, s, e.x - n, e.y - i), 
	        qo._stroke(t, o, e.x - n, e.y - i);
	    },
	    rectangle: function(t, e, n, i, r) {
	        var o = e.x, s = e.y;
	        t.beginPath(), t.rect(o, s, n.width, n.height), qo.fillCanvas(t, r, o, s), qo._stroke(t, i, o, s);
	    },
	    sector: function(t, e, n, i, r, o) {
	        var s = Jo;
	        function a(t, e, n, i, a, h) {
	            var l = s * -h, c = s * -a;
	            t.beginPath(), t.moveTo(e, n), t.arc(e, n, i, l, c), t.lineTo(e, n), qo.fillCanvas(t, o, e - i, n - i), 
	            qo._stroke(t, r, e - i, n - i);
	        }
	        a(t, e.x, e.y, n, i[0], i[1]);
	    },
	    _isPattern: function(t) {
	        return !jn(t) && !("addColorStop" in t);
	    },
	    drawCross: function(t, e, n, i, r) {
	        t.canvas._drawn = !0, t.strokeStyle = r, t.lineWidth = i, t.beginPath(), t.moveTo(e - 5, n), 
	        t.lineTo(e + 5, n), t.moveTo(e, n - 5), t.lineTo(e, n + 5), t.stroke();
	    },
	    copy: function(t, e) {
	        var n = e || bo("canvas");
	        return n.width = t.width, n.height = t.height, n.getContext("2d").drawImage(t, 0, 0), 
	        n;
	    },
	    pixelRect: function(t, e, n, i) {
	        var r = t.globalAlpha, o = !1;
	        if (t.lineWidth > 0 && n > 0) o = !0, n < 1 && (t.globalAlpha *= n); else {
	            if (!(i > 0)) return;
	            i < 1 && (t.globalAlpha *= i);
	        }
	        t.canvas._drawn = !0, o ? t.strokeRect(e[0], e[1], 1, 1) : t.fillRect(e[0], e[1], 1, 1), 
	        t.globalAlpha !== r && (t.globalAlpha = r);
	    }
	};

	function Yo(t, e, n, i) {
	    var r = e.x, o = e.y, s = n.x, a = n.y, h = i, l = function(t, e) {
	        return t <= e;
	    }, c = function(t, e) {
	        return t >= e;
	    }, u = function(t, e) {
	        return Math.min(t, e);
	    }, f = function(t, e) {
	        return Math.max(t, e);
	    }, d = {
	        thereYet: c,
	        cap: u
	    }, m = {
	        thereYet: c,
	        cap: u
	    };
	    o - a > 0 && (m.thereYet = l, m.cap = f), r - s > 0 && (d.thereYet = l, d.cap = f), 
	    t.moveTo(r, o);
	    for (var g, p, _ = r, v = o, y = 0, x = !0; !d.thereYet(_, s) || !m.thereYet(v, a); ) g = Math.atan2(a - o, s - r), 
	    p = h[y], _ = d.cap(s, _ + Math.cos(g) * p), v = m.cap(a, v + Math.sin(g) * p), 
	    x ? t.lineTo(_, v) : t.moveTo(_, v), y = (y + 1) % h.length, x = !x;
	}

	function Ko(t) {
	    return "data:image/" === t.substring(0, "data:image/".length) ? t : Ki$1(t);
	}

	function Qo(t, e) {
	    t.filter = e.filter, t.fillStyle = e.fillStyle, t.globalAlpha = e.globalAlpha, t.lineCap = e.lineCap, 
	    t.lineDashOffset = e.lineDashOffset, t.lineJoin = e.lineJoin, t.lineWidth = e.lineWidth, 
	    t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor, t.shadowOffsetX = e.shadowOffsetX, 
	    t.shadowOffsetY = e.shadowOffsetY, t.strokeStyle = e.strokeStyle;
	}

	var $o = "undefined" != typeof Promise ? Promise : $e, ts = function(t) {
	    return function(t) {
	        function e() {
	            return t.apply(this, arguments) || this;
	        }
	        Ti$1(e, t);
	        var n = e.prototype;
	        return n.on = function(t, e, n) {
	            if (!t) return this;
	            if (!jn(t)) return this._switch("on", t, e);
	            if (!e) return this;
	            this._eventMap || (this._eventMap = {});
	            var i, r, o = t.toLowerCase().split(" ");
	            n || (n = this);
	            for (var s = 0, a = o.length; s < a; s++) {
	                (r = this._eventMap[i = o[s]]) || (this._eventMap[i] = r = []);
	                var h = r.length;
	                if (h > 0) for (var l = 0; l < h; l++) if (e === r[l].handler && r[l].context === n) return console.warn(this, "find '" + t + "' handler:", e, " The old listener function will be removed"), 
	                this;
	                r.push({
	                    handler: e,
	                    context: n
	                });
	            }
	            return this;
	        }, n.addEventListener = function() {
	            return this.on.apply(this, arguments);
	        }, n.once = function(t, e, n) {
	            if (!jn(t)) {
	                var i = {};
	                for (var r in t) t.hasOwnProperty(r) && (i[r] = this._wrapOnceHandler(r, t[r], n));
	                return this._switch("on", i);
	            }
	            for (var o = t.split(" "), s = 0, a = o.length; s < a; s++) this.on(o[s], this._wrapOnceHandler(o[s], e, n));
	            return this;
	        }, n.off = function(t, e, n) {
	            if (!this._eventMap || !t) return this;
	            if (!jn(t)) return this._switch("off", t, e);
	            if (!e) return this;
	            var i, r, o, s = t.split(" ");
	            n || (n = this);
	            for (var a = 0, h = s.length; a < h; a++) {
	                if (o = "Z__" + (i = s[a].toLowerCase()), !(r = this._eventMap[i])) return this;
	                for (var l = r.length - 1; l >= 0; l--) {
	                    var c = r[l];
	                    e !== c.handler && e !== c.handler[o] || c.context !== n || (delete c.handler[o], 
	                    r.splice(l, 1));
	                }
	                r.length || delete this._eventMap[i];
	            }
	            return this;
	        }, n.removeEventListener = function() {
	            return this.off.apply(this, arguments);
	        }, n.listens = function(t, e, n) {
	            if (!this._eventMap || !jn(t)) return 0;
	            var i = this._eventMap[t.toLowerCase()];
	            if (!i || !i.length) return 0;
	            if (!e) return i.length;
	            for (var r = 0, o = i.length; r < o; r++) if (e === i[r].handler && (Dn(n) || i[r].context === n)) return 1;
	            return 0;
	        }, n.getListeningEvents = function() {
	            return this._eventMap ? Object.keys(this._eventMap) : [];
	        }, n.copyEventListeners = function(t) {
	            var e, n = t._eventMap;
	            if (!n) return this;
	            for (var i in n) for (var r = 0, o = (e = n[i]).length; r < o; r++) this.on(i, e[r].handler, e[r].context);
	            return this;
	        }, n.fire = function() {
	            return this._eventParent ? this._eventParent.fire.apply(this._eventParent, arguments) : this._fire.apply(this, arguments);
	        }, n._wrapOnceHandler = function(t, e, n) {
	            var i = this, r = "Z__" + t, o = !1, s = function a() {
	                o || (delete s[r], o = !0, e.apply(n || this, arguments), i.off(t, a, this));
	            };
	            return s[r] = e, s;
	        }, n._switch = function(t, e, n) {
	            for (var i in e) e.hasOwnProperty(i) && this[t](i, e[i], n);
	            return this;
	        }, n._clearListeners = function(t) {
	            this._eventMap && jn(t) && (this._eventMap[t.toLowerCase()] && (this._eventMap[t] = null));
	        }, n._clearAllListeners = function() {
	            this._eventMap = null;
	        }, n._setEventParent = function(t) {
	            return this._eventParent = t, this;
	        }, n._setEventTarget = function(t) {
	            return this._eventTarget = t, this;
	        }, n._fire = function(t, e) {
	            if (!this._eventMap) return this;
	            var n = this._eventMap[t.toLowerCase()];
	            if (!n) return this;
	            e || (e = {}), e.type = t, e.target = this._eventTarget || this;
	            for (var i, r, o = n.slice(0), s = 0, a = o.length; s < a; s++) o[s] && (i = o[s].context, 
	            r = kn({}, e), !1 === (i ? o[s].handler.call(i, r) : o[s].handler(r)) && e.domEvent && Ao(e.domEvent));
	            return this;
	        }, e;
	    }(t);
	}, es = ts(function() {
	    function t(t) {
	        this.target = t;
	    }
	    var e = t.prototype;
	    return e.enable = function() {
	        return this._enabled || (this._enabled = !0, this.addHooks()), this;
	    }, e.disable = function() {
	        return this._enabled ? (this._enabled = !1, this.removeHooks(), this) : this;
	    }, e.enabled = function() {
	        return !!this._enabled;
	    }, e.remove = function() {
	        this.disable(), delete this.target, delete this.dom;
	    }, t;
	}()), ns = function() {
	    function t(t) {
	        if (!this || !this.setOptions) throw new Error('Class instance is being created without "new" operator.');
	        this.setOptions(t), this.callInitHooks();
	    }
	    var e = t.prototype;
	    return e.callInitHooks = function() {
	        var t = Object.getPrototypeOf(this);
	        return this._visitInitHooks(t), this;
	    }, e.setOptions = function(t) {
	        if (this.hasOwnProperty("options") || (this.options = this.options ? Object.create(this.options) : {}), 
	        !t) return this;
	        for (var e in t) this.options[e] = t[e];
	        return this;
	    }, e.config = function(t) {
	        if (!t) {
	            var e = {};
	            for (var n in this.options) this.options.hasOwnProperty(n) && (e[n] = this.options[n]);
	            return e;
	        }
	        if (2 === arguments.length) {
	            var i = {};
	            i[t] = arguments[1], t = i;
	        }
	        for (var r in t) this.options[r] = t[r], this[r] && this[r] instanceof es && (t[r] ? this[r].enable() : this[r].disable());
	        return this.onConfig(t), this;
	    }, e.onConfig = function() {}, e._visitInitHooks = function(t) {
	        if (!this._initHooksCalled) {
	            var e = Object.getPrototypeOf(t);
	            e._visitInitHooks && e._visitInitHooks.call(this, e), this._initHooksCalled = !0;
	            var n = t._initHooks;
	            if (n && n !== e._initHooks) for (var i = 0; i < n.length; i++) n[i].call(this);
	        }
	    }, t.addInitHook = function(t) {
	        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
	        var r = "function" == typeof t ? t : function() {
	            this[t].apply(this, n);
	        }, o = this.prototype, s = Object.getPrototypeOf(o);
	        return o._initHooks && o._initHooks !== s._initHooks || (o._initHooks = []), o._initHooks.push(r), 
	        this;
	    }, t.include = function() {
	        for (var t = 0; t < arguments.length; t++) kn(this.prototype, t < 0 || arguments.length <= t ? void 0 : arguments[t]);
	        return this;
	    }, t.mergeOptions = function(t) {
	        var e = this.prototype, n = Object.getPrototypeOf(e);
	        return e.options && e.options !== n.options || (e.options = e.options ? Object.create(e.options) : {}), 
	        kn(e.options, t), this;
	    }, t;
	}(), is = {}, rs = function(t) {
	    return function(t) {
	        function e() {
	            return t.apply(this, arguments) || this;
	        }
	        return Ti$1(e, t), e.registerJSONType = function(t) {
	            return t ? (is[t] = this, this) : this;
	        }, e.getJSONClass = function(t) {
	            return t ? is[t] : null;
	        }, e.prototype.getJSONType = function() {
	            if (void 0 === this._jsonType) {
	                var t = Object.getPrototypeOf(this).constructor;
	                for (var e in is) if (is[e] === t) {
	                    this._jsonType = e;
	                    break;
	                }
	            }
	            if (!this._jsonType) throw new Error("Found an unregistered geometry class!");
	            return this._jsonType;
	        }, e;
	    }(t);
	}, os = {}, ss = function() {
	    function t() {
	        this._tree = _n(9, [ "[0]", "[1]", "[2]", "[3]" ]);
	    }
	    var e = t.prototype;
	    return e.collides = function(t) {
	        return os.minX = t[0], os.minY = t[1], os.maxX = t[2], os.maxY = t[3], this._tree.collides(os);
	    }, e.insertBox = function(t) {
	        return this._tree.insert(t), this;
	    }, e.bulkInsertBox = function(t) {
	        return this._tree.load(t), this;
	    }, e.clear = function() {
	        return this._tree.clear(), this;
	    }, t;
	}();

	function as(t) {
	    return function(t) {
	        function e() {
	            return t.apply(this, arguments) || this;
	        }
	        Ti$1(e, t);
	        var n = e.prototype;
	        return n.addHandler = function(t, e) {
	            if (!e) return this;
	            if (this._handlers || (this._handlers = []), this[t]) return this[t].enable(), this;
	            var n = this[t] = new e(this);
	            return this._handlers.push(n), this.options[t] && n.enable(), this;
	        }, n.removeHandler = function(t) {
	            if (!t) return this;
	            var e = this[t];
	            if (e) {
	                var n = this._handlers.indexOf(e);
	                n >= 0 && this._handlers.splice(n, 1), this[t].remove(), delete this[t];
	            }
	            return this;
	        }, n._clearHandlers = function() {
	            for (var t = 0, e = this._handlers.length; t < e; t++) this._handlers[t].remove();
	            this._handlers = [];
	        }, e;
	    }(t);
	}

	var hs = {
	    mousedown: "mousemove",
	    touchstart: "touchmove",
	    pointerdown: "touchmove",
	    MSPointerDown: "touchmove"
	}, ls = {
	    mousedown: "mouseup",
	    touchstart: "touchend",
	    pointerdown: "touchend",
	    MSPointerDown: "touchend"
	}, cs = function(t) {
	    function e(e, n) {
	        var i;
	        return void 0 === n && (n = {}), (i = t.call(this, null) || this).dom = e, i.options = n, 
	        i;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.enable = function() {
	        return this.dom ? (this._onMouseDown = function(t) {
	            return this.onMouseDown(t);
	        }, Ho(this.dom, "touchstart mousedown", this._onMouseDown, this), this) : this;
	    }, n.disable = function() {
	        return this.dom ? (this._offEvents(), No(this.dom, "touchstart mousedown", this._onMouseDown), 
	        delete this._onMouseDown, this) : this;
	    }, n.onMouseDown = function(t) {
	        if ((this.options.rightclick || 2 !== t.button) && !(t.touches && t.touches.length > 1 || this.options.cancelOn && !0 === this.options.cancelOn(t))) {
	            var e = this.dom;
	            e.setCapture ? e.setCapture() : window.captureEvents && window.captureEvents(window.Event.MOUSEMOVE | window.Event.MOUSEUP), 
	            e.ondragstart = function() {
	                return !1;
	            }, delete this.moved;
	            var n = t.touches ? t.touches[0] : t;
	            this.startPos = new Oi$1(n.clientX, n.clientY), No(document, hs[t.type], this.onMouseMove), 
	            No(document, ls[t.type], this.onMouseUp), Ho(document, hs[t.type], this.onMouseMove, this), 
	            Ho(document, ls[t.type], this.onMouseUp, this), this.options.ignoreMouseleave || (No(this.dom, "mouseleave", this.onMouseUp), 
	            Ho(this.dom, "mouseleave", this.onMouseUp, this)), this.fire("mousedown", {
	                domEvent: t,
	                mousePos: new Oi$1(n.clientX, n.clientY)
	            });
	        }
	    }, n.onMouseMove = function(t) {
	        if (t.touches && t.touches.length > 1) this.moved && (this.interupted = !0, this.onMouseUp(t)); else {
	            var e = t.touches ? t.touches[0] : t, n = new Oi$1(e.clientX, e.clientY).sub(this.startPos);
	            (n.x || n.y) && (this.moved ? this.fire("dragging", {
	                domEvent: t,
	                mousePos: new Oi$1(e.clientX, e.clientY)
	            }) : (this.fire("dragstart", {
	                domEvent: t,
	                mousePos: this.startPos.copy()
	            }), this.moved = !0));
	        }
	    }, n.onMouseUp = function(t) {
	        var e = t.changedTouches ? t.changedTouches[0] : t;
	        this._offEvents();
	        var n = {
	            domEvent: t
	        };
	        Ln(e.clientX) && (n.mousePos = new Oi$1(parseInt(e.clientX, 0), parseInt(e.clientY, 0))), 
	        this.moved && (n.interupted = this.interupted, this.fire("dragend", n), delete this.interupted, 
	        delete this.moved), this.fire("mouseup", n);
	    }, n._offEvents = function() {
	        var t = this.dom;
	        if (No(t, "mouseleave", this.onMouseUp), "undefined" != typeof document && "undefined" != typeof window) {
	            for (var e in hs) No(document, hs[e], this.onMouseMove), No(document, ls[e], this.onMouseUp);
	            t.releaseCapture ? t.releaseCapture() : window.captureEvents && window.captureEvents(window.Event.MOUSEMOVE | window.Event.MOUSEUP);
	        }
	    }, e;
	}(es), us = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    return Ti$1(e, t), e.toNumberArrays = function(t) {
	        return Array.isArray(t) ? Hi$1(t, (function(t) {
	            return [ t.x, t.y ];
	        })) : [ t.x, t.y ];
	    }, e.toCoordinates = function(t) {
	        if (Ln(t[0]) && Ln(t[1])) return new e(t);
	        if (t instanceof e) return t;
	        for (var n = [], i = 0, r = t.length; i < r; i++) {
	            var o = t[i];
	            Array.isArray(o) ? Ln(o[0]) ? n.push(new e(o)) : n.push(e.toCoordinates(o)) : n.push(o instanceof e ? o : new e(o));
	        }
	        return n;
	    }, e;
	}(Ei$1), fs = function() {
	    function t(t, e) {
	        this.type = t, this.properties = e;
	    }
	    return t.createProj4 = function(e) {
	        return new t("proj4", {
	            proj: e
	        });
	    }, t.fromProjectionCode = function(e) {
	        return e && t[e = e.toUpperCase().replace(":", "")] || null;
	    }, t;
	}();

	fs.WGS84 = fs.createProj4("+proj=longlat +datum=WGS84 +no_defs"), fs.EPSG4326 = fs.WGS84, 
	fs.EPSG3857 = fs.createProj4("+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs"), 
	fs.IDENTITY = fs.createProj4("+proj=identity +no_defs"), fs.CGCS2000 = fs.createProj4("+proj=longlat +datum=CGCS2000"), 
	fs.EPSG4490 = fs.CGCS2000, fs.BD09LL = fs.createProj4("+proj=longlat +datum=BD09"), 
	fs.GCJ02 = fs.createProj4("+proj=longlat +datum=GCJ02");

	var ds, ms = new Oi$1(0, 0), gs = new us(0, 0), ps = new us(0, 0), _s = new us(0, 0), vs = new us(0, 0), ys = new us(0, 0), xs = new us(0, 0), bs = new us(0, 0), ws = new us(0, 0), Cs = [], Ms = [], Ts = function() {
	    function t(t, e, n, i) {
	        this._clazz = us;
	        var r = arguments.length, o = r > 0 ? arguments[r - 1] : null;
	        o && o.unproject && (this.projection = arguments[r - 1]), this._dirty = !0, this._initialize(t, e, n, i);
	    }
	    var e = t.prototype;
	    return e._initialize = function(t, e, n, i) {
	        if (this.xmin = null, this.xmax = null, this.ymin = null, this.ymax = null, !Dn(t)) {
	            var r = this.projection;
	            Ln(t) && Ln(e) && Ln(n) && Ln(i) ? r ? this.set(t, e, n, i) : this.set(Math.min(t, n), Math.min(e, i), Math.max(t, n), Math.max(e, i)) : Array.isArray(t) ? r ? this.set(t[0], t[1], t[2], t[3]) : this.set(Math.min(t[0], t[2]), Math.min(t[1], t[3]), Math.max(t[0], t[2]), Math.max(t[1], t[3])) : Ln(t.x) && Ln(e.x) && Ln(t.y) && Ln(e.y) ? r ? this.set(t.x, t.y, e.x, e.y) : (t.x > e.x ? (this.xmin = e.x, 
	            this.xmax = t.x) : (this.xmin = t.x, this.xmax = e.x), t.y > e.y ? (this.ymin = e.y, 
	            this.ymax = t.y) : (this.ymin = t.y, this.ymax = e.y)) : Ln(t.xmin) && Ln(t.xmax) && Ln(t.ymin) && Ln(t.ymax) && this.set(t.xmin, t.ymin, t.xmax, t.ymax);
	        }
	    }, e._add = function(t) {
	        return this._dirty = !0, Dn(t.x) ? Dn(t.xmin) ? Dn(t[0]) || (this.xmin += t[0], 
	        this.ymin += t[1], this.xmax += t[0], this.ymax += t[1]) : (this.xmin += t.xmin, 
	        this.ymin += t.ymin, this.xmax += t.xmax, this.ymax += t.ymax) : (this.xmin += t.x, 
	        this.ymin += t.y, this.xmax += t.x, this.ymax += t.y), this;
	    }, e.add = function() {
	        var t = new this.constructor(this.xmin, this.ymin, this.xmax, this.ymax, this.projection);
	        return t._add.apply(t, arguments);
	    }, e._scale = function(t) {
	        return this._dirty = !0, this.xmin *= t, this.ymin *= t, this.xmax *= t, this.ymax *= t, 
	        this;
	    }, e._sub = function(t) {
	        return this._dirty = !0, Dn(t.x) ? Dn(t.xmin) ? Dn(t[0]) || (this.xmin -= t[0], 
	        this.ymin -= t[1], this.xmax -= t[0], this.ymax -= t[1]) : (this.xmin -= t.xmin, 
	        this.ymin -= t.ymin, this.xmax -= t.xmax, this.ymax -= t.ymax) : (this.xmin -= t.x, 
	        this.ymin -= t.y, this.xmax -= t.x, this.ymax -= t.y), this;
	    }, e._substract = function() {
	        return this._sub.apply(this, arguments);
	    }, e.sub = function() {
	        var t = new this.constructor(this.xmin, this.ymin, this.xmax, this.ymax, this.projection);
	        return t._sub.apply(t, arguments);
	    }, e.substract = function() {
	        return this.sub.apply(this, arguments);
	    }, e.round = function() {
	        return new this.constructor(Math.round(this.xmin), Math.round(this.ymin), Math.round(this.xmax), Math.round(this.ymax), this.projection);
	    }, e._round = function() {
	        return this._dirty = !0, this.xmin = Math.round(this.xmin), this.ymin = Math.round(this.ymin), 
	        this.xmax = Math.round(this.xmax), this.ymax = Math.round(this.ymax), this;
	    }, e.getMin = function(t) {
	        return t ? (t.set(this.xmin, this.ymin), t) : new this._clazz(this.xmin, this.ymin);
	    }, e.getMax = function(t) {
	        return t ? (t.set(this.xmax, this.ymax), t) : new this._clazz(this.xmax, this.ymax);
	    }, e.getCenter = function(t) {
	        var e = (this.xmin + this.xmax) / 2, n = (this.ymin + this.ymax) / 2;
	        return t ? (t.set(e, n), t) : new this._clazz(e, n);
	    }, e.isValid = function() {
	        return !(Dn(this.xmin) || Dn(this.ymin) || Dn(this.xmax) || Dn(this.ymax));
	    }, e.equals = function(t) {
	        return this.xmin === t.xmin && this.xmax === t.xmax && this.ymin === t.ymin && this.ymax === t.ymax;
	    }, e.intersects = function(t) {
	        this._project(this), this._project(t);
	        var e = Math.max(this.pxmin, t.pxmin), n = Math.max(this.pymin, t.pymin), i = Math.min(this.pxmax, t.pxmax), r = Math.min(this.pymax, t.pymax), o = !(e > i || n > r);
	        return o;
	    }, e.within = function(t) {
	        return this._project(this), this._project(t), this.pxmin >= t.pxmin && this.pxmax <= t.pxmax && this.pymin >= t.pymin && this.pymax <= t.pymax;
	    }, e.contains = function(t) {
	        if (!t) return !1;
	        this._project(this);
	        var e = this.projection;
	        if (e) if (void 0 !== t.x) {
	            var n = gs;
	            Array.isArray(t) ? (n.x = t[0], n.y = t[1]) : (n.x = t.x, n.y = t.y), t = e.project(n, n);
	        } else void 0 !== t.xmin && this._project(t);
	        return (t.x || t.pxmin || 0) >= this.pxmin && (t.x || t.pxmax || 0) <= this.pxmax && (t.y || t.pymin || 0) >= this.pymin && (t.y || t.pymax || 0) <= this.pymax;
	    }, e.getWidth = function() {
	        return Math.abs(this.xmax - this.xmin);
	    }, e.getHeight = function() {
	        return Math.abs(this.ymax - this.ymin);
	    }, e.getSize = function() {
	        return new Gr(this.getWidth(), this.getHeight());
	    }, e.set = function(t, e, n, i) {
	        return this.xmin = t, this.ymin = e, this.xmax = n, this.ymax = i, this._dirty = !0, 
	        this;
	    }, e.__combine = function(t) {
	        var e, n, i, r;
	        void 0 !== t.x && (ds.xmin = ds.xmax = t.x, ds.ymin = ds.ymax = t.y, t = ds), this._project(t), 
	        this._project(this), Ln(this.pxmin) ? (e = Math.min(this.pxmin, t.pxmin), n = Math.min(this.pymin, t.pymin), 
	        i = Math.max(this.pxmax, t.pxmax), r = Math.max(this.pymax, t.pymax)) : (e = t.pxmin, 
	        n = t.pymin, i = t.pxmax, r = t.pymax);
	        var o = this.projection;
	        if (o) {
	            ps.set(e, n), _s.set(i, r);
	            var s = o.unproject(ps, ps), a = o.unproject(_s, _s);
	            e = s.x, n = s.y, i = a.x, r = a.y;
	        }
	        return Ms[0] = e, Ms[1] = n, Ms[2] = i, Ms[3] = r, Ms;
	    }, e._combine = function(t) {
	        if (!t || t.isValid && !t.isValid()) return this;
	        var e = this.__combine(t);
	        return this.set(e[0], e[1], e[2], e[3]), this._dirty = !0, this;
	    }, e.combine = function(t) {
	        if (!t || t.isValid && !t.isValid()) return this;
	        var e = this.__combine(t);
	        return new this.constructor(e[0], e[1], e[2], e[3], this.projection);
	    }, e.intersection = function(t) {
	        if (!this.intersects(t)) return null;
	        vs.x = Math.max(this.pxmin, t.pxmin), vs.y = Math.max(this.pymin, t.pymin), ys.x = Math.min(this.pxmax, t.pxmax), 
	        ys.y = Math.min(this.pymax, t.pymax);
	        var e = vs, n = ys, i = this.projection;
	        return i && (e = i.unproject(e, e), n = i.unproject(n, n)), new this.constructor(e, n, i);
	    }, e.expand = function(t) {
	        var e, n;
	        return Ln(t) ? e = n = t : (e = t.width || t.x || t[0] || 0, n = t.height || t.y || t[1] || 0), 
	        new this.constructor(this.xmin - e, this.ymin - n, this.xmax + e, this.ymax + n, this.projection);
	    }, e._expand = function(t) {
	        var e, n;
	        return Ln(t) ? e = n = t : (e = t.width || t.x || t[0] || 0, n = t.height || t.y || t[1] || 0), 
	        this.xmin -= e, this.ymin -= n, this.xmax += e, this.ymax += n, this._dirty = !0, 
	        this;
	    }, e.toJSON = function() {
	        return {
	            xmin: this.xmin,
	            ymin: this.ymin,
	            xmax: this.xmax,
	            ymax: this.ymax
	        };
	    }, e.toArray = function(t) {
	        var e = this.xmin, n = this.ymin, i = this.xmax, r = this.ymax;
	        return t ? (t[0].x = e, t[0].y = r, t[1].x = i, t[1].y = r, t[2].x = i, t[2].y = n, 
	        t[3].x = e, t[3].y = n, t[4].x = e, t[4].y = r, t) : [ new this._clazz([ e, r ]), new this._clazz([ i, r ]), new this._clazz([ i, n ]), new this._clazz([ e, n ]), new this._clazz([ e, r ]) ];
	    }, e.toString = function() {
	        return this.xmin + "," + this.ymin + "," + this.xmax + "," + this.ymax;
	    }, e.copy = function() {
	        return new this.constructor(this.xmin, this.ymin, this.xmax, this.ymax, this.projection);
	    }, e.convertTo = function(t, e) {
	        if (!this.isValid()) return null;
	        var n, i = e || new this.constructor;
	        return e && i.set(null, null, null, null), this._clazz === us ? n = xs : this._clazz === Oi$1 && (n = ms), 
	        n.x = this.xmin, n.y = this.ymax, i._combine(t(n)), n.x = this.xmax, i._combine(t(n)), 
	        n.y = this.ymin, i._combine(t(n)), n.x = this.xmin, i._combine(t(n)), i;
	    }, e._project = function(t) {
	        if (t && t.isValid()) {
	            var e = this.projection;
	            if (e) {
	                if (t._dirty) {
	                    bs.set(t.xmax, t.ymin), ws.set(t.xmin, t.ymax), Cs[0] = bs, Cs[1] = ws;
	                    var n = e.projectCoords(Cs), i = n[0], r = n[1];
	                    t.pxmin = Math.min(i.x, r.x), t.pymin = Math.min(i.y, r.y), t.pxmax = Math.max(i.x, r.x), 
	                    t.pymax = Math.max(i.y, r.y);
	                }
	                delete t._dirty;
	            } else t.pxmin = t.xmin, t.pxmax = t.xmax, t.pymin = t.ymin, t.pymax = t.ymax;
	        } else t && (t.pxmin = t.pxmax = t.pymin = t.pymax = null);
	    }, t;
	}();

	ds = new Ts(0, 0, 0, 0);

	var Ss, Ps = function(t) {
	    function e(e, n, i, r) {
	        var o;
	        return (o = t.call(this, e, n, i, r) || this)._clazz = Oi$1, o;
	    }
	    return Ti$1(e, t), e;
	}(Ts), As = function() {
	    function t(t) {
	        this.matrix = t;
	    }
	    var e = t.prototype;
	    return e.transform = function(t, e, n) {
	        var i = this.matrix[0] * (t.x - this.matrix[2]) / e, r = -this.matrix[1] * (t.y - this.matrix[3]) / e;
	        return n ? (n.x = i, n.y = r, n) : new Oi$1(i, r);
	    }, e.untransform = function(t, e, n) {
	        var i = t.x * e / this.matrix[0] + this.matrix[2], r = t.y * e / -this.matrix[1] + this.matrix[3];
	        return n ? (n.x = i, n.y = r, n) : new us(i, r);
	    }, t;
	}(), Es = {
	    project: function() {},
	    unproject: function() {},
	    projectCoords: function(t, e) {
	        var n = this;
	        if (!t) return [];
	        if (!Array.isArray(t)) return this.project(t);
	        if (0 === t.length) return [];
	        if (!this.isSphere()) return Hi$1(t, this.project, this);
	        if (Array.isArray(t[0])) return t.map((function(t) {
	            return n.projectCoords(t, e);
	        }));
	        for (var i, r, o, s, a, h, l = !1 !== e, c = this.getCircum(), u = this.getSphereExtent(), f = u.sx, d = u.sy, m = t[0], g = [ this.project(m) ], p = 1, _ = t.length; p < _; p++) s = (o = t[p]).x - m.x, 
	        a = o.y - m.y, h = this.project(o), Math.abs(s) > 180 && l && (void 0 === i && (i = o.x > m.x), 
	        i && (h._add(-c.x * Bi$1(s) * f, 0), o._add(-360 * Bi$1(s), 0))), Math.abs(a) > 90 && l && (void 0 === r && (r = o.y < m.y), 
	        r && (h._add(0, -c.y * Bi$1(a) * d), o._add(0, -180 * Bi$1(a)))), m = o, g.push(h);
	        return g;
	    },
	    unprojectCoords: function(t) {
	        return t ? Array.isArray(t) ? Hi$1(t, this.unproject, this) : this.unproject(t) : [];
	    },
	    isSphere: function() {
	        return !!this.sphere;
	    },
	    isOutSphere: function(t) {
	        return !!this.isSphere() && !this.getSphereExtent().contains(t);
	    },
	    wrapCoord: function(t) {
	        if (!this.isSphere()) return t;
	        var e = this.getSphereExtent(), n = new us(t);
	        return e.contains(n) || (n.x = Ui$1(t.x, e.xmin, e.xmax), n.y = Ui$1(t.y, e.ymin, e.ymax)), 
	        n;
	    },
	    getCircum: function() {
	        if (!this.circum && this.isSphere()) {
	            var t = this.getSphereExtent();
	            this.circum = {
	                x: t.getWidth(),
	                y: t.getHeight()
	            };
	        }
	        return this.circum;
	    },
	    getSphereExtent: function() {
	        if (!this.extent && this.isSphere()) {
	            var t = this.project(new us(180, 90)), e = this.project(new us(-180, -90));
	            this.extent = new Ts(e, t, this), this.extent.sx = t.x > e.x ? 1 : -1, this.extent.sy = t.y > e.y ? 1 : -1;
	        }
	        return this.extent;
	    }
	}, Os = {
	    measureLength: function(t, e) {
	        if (!Array.isArray(t)) return this.measureLenBetween(t, e);
	        for (var n = 0, i = 0, r = t.length; i < r - 1; i++) n += this.measureLenBetween(t[i], t[i + 1]);
	        return n;
	    }
	}, Rs = kn({
	    measure: "IDENTITY",
	    measureLenBetween: function(t, e) {
	        if (!t || !e) return 0;
	        try {
	            return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
	        } catch (t) {
	            return 0;
	        }
	    },
	    measureArea: function(t) {
	        if (!Array.isArray(t)) return 0;
	        for (var e = 0, n = 0, i = t.length; n < i; n++) {
	            var r = t[n], o = null;
	            e += r.x * (o = n === i - 1 ? t[0] : t[n + 1]).y - r.y * o.x;
	        }
	        return Math.abs(e / 2);
	    },
	    locate: function(t, e, n, i) {
	        return (i = i || new us(0, 0)).set(t.x, t.y), this._locate(i, e, n);
	    },
	    _locate: function(t, e, n) {
	        return t ? (e || (e = 0), n || (n = 0), e || n ? (t.x = t.x + e, t.y = t.y + n, 
	        t) : t) : null;
	    },
	    rotate: function(t, e, n) {
	        return t = new us(t.x, t.y), this._rotate(t, e, n);
	    },
	    _rotate: (Ss = new Oi$1(0, 0), function(t, e, n) {
	        return Ss.x = t.x - e.x, Ss.y = t.y - e.y, Ss._rotate(n * Math.PI / 180), t.x = e.x + Ss.x, 
	        t.y = e.y + Ss.y, t;
	    })
	}, Os), Is = function() {
	    function t(t) {
	        this.radius = t;
	    }
	    var e = t.prototype;
	    return e.measureLenBetween = function(t, e) {
	        if (!t || !e) return 0;
	        var n = Vn(t.y), i = Vn(e.y), r = n - i, o = Vn(t.x) - Vn(e.x);
	        return n = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(r / 2), 2) + Math.cos(n) * Math.cos(i) * Math.pow(Math.sin(o / 2), 2))), 
	        n *= this.radius, Math.round(1e5 * n) / 1e5;
	    }, e.measureArea = function(t) {
	        var e, n = Vn(this.radius), i = 0, r = t, o = r.length;
	        if (o < 3) return 0;
	        for (e = 0; e < o - 1; e++) {
	            var s = r[e], a = r[e + 1];
	            i += s.x * n * Math.cos(Vn(s.y)) * a.y * n - a.x * n * Math.cos(Vn(a.y)) * s.y * n;
	        }
	        return o = r[e], r = r[0], i += o.x * n * Math.cos(Vn(o.y)) * r.y * n - r.x * n * Math.cos(Vn(r.y)) * o.y * n, 
	        .5 * Math.abs(i);
	    }, e.locate = function(t, e, n, i) {
	        return (i = i || new us(0, 0)).set(t.x, t.y), this._locate(i, e, n);
	    }, e._locate = function(t, e, n) {
	        if (!t) return null;
	        if (e || (e = 0), n || (n = 0), !e && !n) return t;
	        var i, r, o = Vn(t.y);
	        if (0 !== n) {
	            var s = Math.abs(n);
	            r = Ui$1(180 * (o += 2 * Math.sin(s / (2 * this.radius)) * (n > 0 ? 1 : -1)) / Math.PI, -90, 90);
	        } else r = t.y;
	        if (0 !== e) {
	            var a = Math.abs(e), h = Vn(t.x);
	            i = Ui$1(180 * (h += 2 * Math.sqrt(Math.pow(Math.sin(a / (2 * this.radius)), 2) / Math.pow(Math.cos(o), 2)) * (e > 0 ? 1 : -1)) / Math.PI, -180, 180);
	        } else i = t.x;
	        return t.x = i, t.y = r, t;
	    }, e.rotate = function(t, e, n) {
	        return t = new us(t), this._rotate(t, e, n);
	    }, e._rotate = function(t, e, n) {
	        var i = function(t, e, n) {
	            void 0 === n && (n = {});
	            var i;
	            i = n.final ? ks(e, t) : ks(t, e);
	            return i > 180 ? -(360 - i) : i;
	        }(e, t) - n, r = this.measureLenBetween(e, t);
	        return t.x = e.x, t.y = e.y, function(t, e, n, i) {
	            var r = e / i, o = t.x * Math.PI / 180, s = Vn(t.y), a = Vn(n), h = r * Math.cos(a), l = s + h;
	            Math.abs(l) > Math.PI / 2 && (l = l > 0 ? Math.PI - l : -Math.PI - l);
	            var c = Math.log(Math.tan(l / 2 + Math.PI / 4) / Math.tan(s / 2 + Math.PI / 4)), u = Math.abs(c) > 1e-11 ? h / c : Math.cos(s), f = r * Math.sin(a) / u;
	            return t.x = (180 * (o + f) / Math.PI + 540) % 360 - 180, t.y = 180 * l / Math.PI, 
	            t;
	        }(t, r, i, this.radius);
	    }, t;
	}();

	function ks(t, e) {
	    var n = Vn(t.y), i = Vn(e.y), r = Vn(e.x - t.x);
	    r > Math.PI && (r -= 2 * Math.PI), r < -Math.PI && (r += 2 * Math.PI);
	    var o = Math.log(Math.tan(i / 2 + Math.PI / 4) / Math.tan(n / 2 + Math.PI / 4));
	    return (Un(Math.atan2(r, o)) + 360) % 360;
	}

	var Ds = kn({
	    measure: "EPSG:4326",
	    sphere: new Is(6378137),
	    measureLenBetween: function() {
	        return this.sphere.measureLenBetween.apply(this.sphere, arguments);
	    },
	    measureArea: function() {
	        return this.sphere.measureArea.apply(this.sphere, arguments);
	    },
	    _locate: function() {
	        return this.sphere._locate.apply(this.sphere, arguments);
	    },
	    locate: function() {
	        return this.sphere.locate.apply(this.sphere, arguments);
	    },
	    _rotate: function() {
	        return this.sphere._rotate.apply(this.sphere, arguments);
	    },
	    rotate: function() {
	        return this.sphere.rotate.apply(this.sphere, arguments);
	    }
	}, Os), Ls = kn({
	    measure: "BAIDU",
	    sphere: new Is(6370996.81),
	    measureLenBetween: function() {
	        return this.sphere.measureLenBetween.apply(this.sphere, arguments);
	    },
	    measureArea: function() {
	        return this.sphere.measureArea.apply(this.sphere, arguments);
	    },
	    _locate: function() {
	        return this.sphere._locate.apply(this.sphere, arguments);
	    },
	    locate: function() {
	        return this.sphere.locate.apply(this.sphere, arguments);
	    },
	    _rotate: function() {
	        return this.sphere._rotate.apply(this.sphere, arguments);
	    },
	    rotate: function() {
	        return this.sphere.rotate.apply(this.sphere, arguments);
	    }
	}, Os), zs = Ds, Fs = {};

	function js(t) {
	    Fs[t.measure] = t;
	}

	js(Rs), js(Ds), js(Ls);

	var Hs = {
	    getInstance: function(t) {
	        if (!t) return zs;
	        for (var e in Fs) if (Bn(Fs, e)) {
	            var n = Fs[e].measure;
	            if (!n) continue;
	            if (t.toLowerCase() === n.toLowerCase()) return Fs[e];
	        }
	        return null;
	    }
	}, Ns = kn({}, Es, {
	    code: "EPSG:3857",
	    rad: Math.PI / 180,
	    metersPerDegree: 6378137 * Math.PI / 180,
	    maxLatitude: 85.0511287798,
	    project: function(t, e) {
	        var n = this.rad, i = this.metersPerDegree, r = this.maxLatitude, o = t.x, s = Math.max(Math.min(r, t.y), -r), a = o * i, h = (0 === s ? 0 : Math.log(Math.tan((90 + s) * n / 2)) / n) * i;
	        return e ? (e.x = a, e.y = h, e) : new us(a, h);
	    },
	    unproject: function(t, e) {
	        var n, i = this.rad, r = this.metersPerDegree, o = t.x / r, s = t.y;
	        0 === s ? n = 0 : (n = s / r, n = (2 * Math.atan(Math.exp(n * i)) - Math.PI / 2) / i), 
	        Math.abs(Math.abs(o) - 180) < 1e-7 && (o = 180 * Bi$1(o)), Math.abs(Math.abs(n) - this.maxLatitude) < 1e-7 && (n = Bi$1(n) * this.maxLatitude);
	        var a = Ui$1(o, -180, 180), h = Ui$1(n, -this.maxLatitude, this.maxLatitude);
	        return e ? (e.x = a, e.y = h, e) : new us(a, h);
	    }
	}, Ds), Bs = kn({}, Es, {
	    code: "EPSG:4326",
	    project: function(t, e) {
	        return e ? (e.x = t.x, e.y = t.y, e) : new us(t);
	    },
	    unproject: function(t, e) {
	        return e ? (e.x = t.x, e.y = t.y, e) : new us(t);
	    }
	}, Ds), Gs = kn({}, Bs, {
	    code: "EPSG:4490"
	}), Vs = kn({}, Es, {
	    code: "BAIDU",
	    project: function(t, e) {
	        return this.convertLL2MC(t, e);
	    },
	    unproject: function(t, e) {
	        return this.convertMC2LL(t, e);
	    }
	}, Ls, {
	    EARTHRADIUS: 6370996.81,
	    MCBAND: [ 12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0 ],
	    LLBAND: [ 75, 60, 45, 30, 15, 0 ],
	    MC2LL: [ [ 1.410526172116255e-8, 898305509648872e-20, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -.03801003308653, 17337981.2 ], [ -7.435856389565537e-9, 8983055097726239e-21, -.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 10260144.86 ], [ -3.030883460898826e-8, 898305509983578e-20, .30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, .32710905363475, 6856817.37 ], [ -1.981981304930552e-8, 8983055099779535e-21, .03278182852591, 40.31678527705744, .65659298677277, -4.44255534477492, .85341911805263, .12923347998204, -.04625736007561, 4482777.06 ], [ 3.09191371068437e-9, 8983055096812155e-21, 6995724062e-14, 23.10934304144901, -.00023663490511, -.6321817810242, -.00663494467273, .03430082397953, -.00466043876332, 2555164.4 ], [ 2.890871144776878e-9, 8983055095805407e-21, -3.068298e-8, 7.47137025468032, -353937994e-14, -.02145144861037, -1234426596e-14, .00010322952773, -323890364e-14, 826088.5 ] ],
	    LL2MC: [ [ -.0015702102444, 111320.7020616939, 0x60e374c3105a3, -0x24bb4115e2e164, 0x5cc55543bb0ae8, -0x7ce070193f3784, 0x5e7ca61ddf8150, -0x261a578d8b24d0, 0x665d60f3742ca, 82.5 ], [ .0008277824516172526, 111320.7020463578, 647795574.6671607, -4082003173.641316, 10774905663.51142, -15171875531.51559, 12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5 ], [ .00337398766765, 111320.7020202162, 4481351.045890365, -23393751.19931662, 79682215.47186455, -115964993.2797253, 97236711.15602145, -43661946.33752821, 8477230.501135234, 52.5 ], [ .00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5 ], [ -.0003441963504368392, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5 ], [ -.0003218135878613132, 111320.7020701615, .00369383431289, 823725.6402795718, .46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, .37238884252424, 7.45 ] ],
	    convertMC2LL: function(t, e) {
	        for (var n, i = 0, r = this.MCBAND.length; i < r; i++) if (Math.abs(t.y) >= this.MCBAND[i]) {
	            n = this.MC2LL[i];
	            break;
	        }
	        return this.convertor(t, n, e);
	    },
	    convertLL2MC: function(t, e) {
	        var n, i, r;
	        t.x = this.getLoop(t.x, -180, 180), t.y = this.getRange(t.y, -74, 74);
	        var o = new us(t.x, t.y);
	        for (i = 0, r = this.LLBAND.length; i < r; i++) if (o.y >= this.LLBAND[i]) {
	            n = this.LL2MC[i];
	            break;
	        }
	        if (!n) for (i = this.LLBAND.length - 1; i >= 0; i--) if (o.y <= -this.LLBAND[i]) {
	            n = this.LL2MC[i];
	            break;
	        }
	        return this.convertor(t, n, e);
	    },
	    convertor: function(t, e, n) {
	        if (!t || !e) return null;
	        var i = e[0] + e[1] * Math.abs(t.x), r = Math.abs(t.y) / e[9], o = e[2] + e[3] * r + e[4] * r * r + e[5] * r * r * r + e[6] * r * r * r * r + e[7] * r * r * r * r * r + e[8] * r * r * r * r * r * r;
	        return i *= t.x < 0 ? -1 : 1, o *= t.y < 0 ? -1 : 1, n ? (n.x = i, n.y = o, n) : new us(i, o);
	    },
	    toRadians: function(t) {
	        return Math.PI * t / 180;
	    },
	    toDegrees: function(t) {
	        return 180 * t / Math.PI;
	    },
	    getRange: function(t, e, n) {
	        return null != e && (t = Math.max(t, e)), null != n && (t = Math.min(t, n)), t;
	    },
	    getLoop: function(t, e, n) {
	        if (t === 1 / 0) return n;
	        if (t === -1 / 0) return e;
	        for (;t > n; ) t -= n - e;
	        for (;t < e; ) t += n - e;
	        return t;
	    }
	}), Us = kn({}, Es, {
	    code: "IDENTITY",
	    project: function(t, e) {
	        return e ? (e.x = t.x, e.y = t.y, e) : t.copy();
	    },
	    unproject: function(t, e) {
	        return e ? (e.x = t.x, e.y = t.y, e) : t.copy();
	    }
	}, Rs), Ws = Ns, Zs = Object.freeze({
	    EPSG3857: Ns,
	    DEFAULT: Ws,
	    EPSG4326: Bs,
	    EPSG4490: Gs,
	    BAIDU: Vs,
	    IDENTITY: Us,
	    Common: Es
	}), Xs = function(t) {
	    return function(t) {
	        function e() {
	            return t.apply(this, arguments) || this;
	        }
	        return Ti$1(e, t), e.registerRenderer = function(t, e) {
	            var n = this.prototype, i = Object.getPrototypeOf(n);
	            return n._rendererClasses && n._rendererClasses !== i._rendererClasses || (n._rendererClasses = n._rendererClasses ? Object.create(n._rendererClasses) : {}), 
	            n._rendererClasses[t.toLowerCase()] = e, this;
	        }, e.getRendererClass = function(t) {
	            var e = this.prototype;
	            return e._rendererClasses ? e._rendererClasses[t.toLowerCase()] : null;
	        }, e;
	    }(t);
	}, Js = {};

	var qs;

	function Ys() {
	    if ("undefined" == typeof window) return null;
	    if (!qs) {
	        var t = function() {
	            var t = "\n    var adapters = {};\n    onmessage = function (msg) {\n        msg = msg.data;\n        if (msg.messageType === 'batch') {\n            const messages = msg.messages;\n            if (messages) {\n                for (let i = 0; i < messages.length; i++) {\n                    dispatch(messages[i]);\n                }\n            }\n        } else {\n            dispatch(msg);\n        }\n    };\n\n    function dispatch(msg) {\n        var workerKey = msg.workerKey;\n        var adapter = adapters[workerKey];\n        if (!adapter) {\n            post(msg.callback, 'Unregistered worker adapters for ' + workerKey);\n            return;\n        }\n        try {\n            adapter.onmessage(msg, wrap(msg.callback));\n        } catch (err) {\n            post(msg.callback, workerKey + ':' + err.message);\n            console.error(err);\n            throw err;\n        }\n    }\n\n    function post(callback, err, data, buffers) {\n        var msg = {\n            callback : callback\n        };\n        if (err) {\n            msg.error = err;\n        } else {\n            msg.data = data;\n        }\n        if (buffers && buffers.length > 0) {\n            postMessage(msg, buffers);\n        } else {\n            postMessage(msg);\n        }\n    }\n    function wrap(callback) {\n        return function (err, data, buffers) {\n            post(callback, err, data, buffers);\n        };\n    }\n    var workerExports;\n";
	            for (var e in Js) {
	                var n = Js[e];
	                Hn(n) && 0 === n.length && (n = n()), t += "\n    workerExports = {};\n    (" + n + ")(workerExports, self);\n    adapters['" + e + "'] = workerExports", 
	                t += "\n    workerExports.initialize && workerExports.initialize(self);\n        ";
	            }
	            return t += "\n    workerExports = null;\n";
	        }();
	        qs = window.URL.createObjectURL(new Blob([ t ], {
	            type: "text/javascript"
	        })), Js = null;
	    }
	    return qs;
	}

	var Ks, Qs = "undefined" != typeof window ? window.navigator.hardwareConcurrency || 4 : 0, $s = Math.max(Math.floor(Qs / 2), 1), ta = function() {
	    function t(t) {
	        void 0 === t && (t = 50), this._limit = t, this._messages = [], this.buffers = [];
	    }
	    var e = t.prototype;
	    return e.addMessage = function(t, e) {
	        if (this._messages.push(t), Array.isArray(e)) for (var n = 0; n < e.length; n++) this.buffers.indexOf(e[n]) < 0 && this.buffers.push(e[n]);
	    }, e.isFull = function() {
	        return this._messages.length >= this._limit;
	    }, e.getMessage = function() {
	        return {
	            messageType: "batch",
	            messages: this._messages
	        };
	    }, t;
	}(), ea = function() {
	    function t() {
	        this.active = {}, this.workerCount = "undefined" != typeof window ? window.MAPTALKS_WORKER_COUNT || $s : 0, 
	        this._messages = [], this._messageBuffers = [];
	    }
	    var e = t.prototype;
	    return e.acquire = function(t) {
	        if (!this.workers) {
	            this.workers = [];
	            for (var e = Ys(), n = 0; n < this.workerCount; n++) {
	                var i = new Worker(e);
	                i.id = n, this.workers.push(i);
	            }
	            URL.revokeObjectURL(e);
	        }
	        return this.active[t] = !0, this.workers.slice();
	    }, e.release = function(t) {
	        delete this.active[t], 0 === Object.keys(this.active).length && (this.workers.forEach((function(t) {
	            t.terminate();
	        })), this.workers = null);
	    }, e.addMessage = function(t, e, n) {
	        var i = this._messages[t];
	        i && i.length || (i = this._messages[t] = [ new ta ]);
	        var r = i[i.length - 1];
	        r.isFull() && (r = new ta, this._messages[t].push(r)), r.addMessage(e, n);
	    }, e.commit = function() {
	        if (this._messages.length) for (var t = 0; t < this._messages.length; t++) if (this._messages[t] && this._messages[t].length) {
	            var e = this._messages[t].shift();
	            this.workers[t].postMessage(e.getMessage(), e.buffers);
	        }
	    }, t;
	}();

	function na() {
	    return Ks || (Ks = new ea), Ks;
	}

	Pi$1 && Pi$1((function t() {
	    na().commit(), Pi$1(t);
	}));

	var ia = 0, ra = [], oa = function() {
	    function t(t) {
	        var e = this;
	        this.workerKey = t, this.workerPool = na(), this.currentActor = 0, this.actorId = Di$1(), 
	        this.workers = this.workerPool.acquire(this.actorId), this.callbacks = {}, this.callbackID = 0, 
	        this.receiveFn = this.receive.bind(this), this.workers.forEach((function(t) {
	            t.addEventListener("message", e.receiveFn, !1);
	        }));
	    }
	    var e = t.prototype;
	    return e.isActive = function() {
	        return !!this.workers;
	    }, e.broadcast = function(t, e, n) {
	        var i = this;
	        return function(t, e, n) {
	            t.length || n(null, []);
	            var i = t.length, r = new Array(t.length), o = null;
	            t.forEach((function(t, s) {
	                e(t, (function(t, e) {
	                    t && (o = t), r[s] = e, 0 == --i && n(o, r);
	                }));
	            }));
	        }(this.workers, (function(n, r) {
	            i.send(t, e, r, n.id);
	        }), n = n || function() {}), this;
	    }, e.send = function(t, e, n, i) {
	        var r = n ? this.actorId + ":" + this.callbackID++ : null;
	        return n && (this.callbacks[r] = n), this.post({
	            data: t,
	            callback: String(r)
	        }, e, i), this;
	    }, e.receive = function(t) {
	        var e = this, n = t.data, i = n.callback, r = this.callbacks[i];
	        delete this.callbacks[i], "<request>" === n.type ? this.actorId === n.actorId && this[n.command](n.params, (function(t, i, r) {
	            var o = {
	                type: "<response>",
	                callback: n.callback
	            };
	            t ? o.error = t.message : o.data = i, e.post(o, r || ra, n.workerId);
	        })) : r && n.error ? r(n.error) : r && r(null, n.data);
	    }, e.remove = function() {
	        var t = this;
	        this.workers.forEach((function(e) {
	            e.removeEventListener("message", t.receiveFn, !1);
	        })), this.workerPool.release(this.actorId), delete this.receiveFn, delete this.workers, 
	        delete this.callbacks, delete this.workerPool;
	    }, e.post = function(t, e, n) {
	        return ("number" != typeof n || isNaN(n)) && (n = this.currentActor = (this.currentActor + 1) % this.workerPool.workerCount), 
	        t.workerId = n, t.workerKey = this.workerKey, t.actorId = this.actorId, this.workerPool.addMessage(n, t, e || ra), 
	        n;
	    }, e.getDedicatedWorker = function() {
	        return ia = (ia + 1) % this.workerPool.workerCount;
	    }, t;
	}();

	var sa = [], aa = function(t) {
	    function e() {
	        return t.call(this, "core-fetch-image") || this;
	    }
	    return Ti$1(e, t), e.prototype.fetchImage = function(t, e) {
	        this.send({
	            url: t
	        }, sa, e);
	    }, e;
	}(oa), ha = function(t) {
	    function e(e) {
	        var n;
	        return (n = t.call(this) || this).layer = e, n._painted = !1, n._drawTime = 0, !Mi$1.decodeImageInWorker || "gl" !== e.options.renderer && Mi$1.safari || (n._resWorkerConn = new aa), 
	        n.setToRedraw(), n;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.render = function(t) {
	        this.prepareRender(), this.getMap() && this.layer.isVisible() && (this.resources || (this.resources = new la), 
	        this.checkAndDraw(this._tryToDraw, t));
	    }, n.checkAndDraw = function(t) {
	        var e = this;
	        this._toRedraw = !1;
	        for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) i[r - 1] = arguments[r];
	        if (this.checkResources) {
	            var o = this.checkResources();
	            o.length > 0 ? (this._loadingResource = !0, this.loadResources(o).then((function() {
	                e._loadingResource = !1, e.layer && (e.layer.fire("resourceload"), e.setToRedraw());
	            }))) : t.call.apply(t, [ this ].concat(i));
	        } else t.call.apply(t, [ this ].concat(i));
	    }, n.testIfNeedRedraw = function() {
	        var t = this.getMap();
	        return !this._loadingResource && (!!this._toRedraw || !(t.isInteracting() && !this.drawOnInteracting) && !!this.needToRedraw());
	    }, n.needToRedraw = function() {
	        var t = this.getMap();
	        return !(!t.isInteracting() && !t.getRenderer().isViewChanged()) && !(!t.getPitch() && t.isMoving() && !t.isZooming() && !t.isRotating() && !this.layer.options.forceRenderOnMoving);
	    }, n.onSkipDrawOnInteracting = function() {}, n.isLoadingResource = function() {
	        return this._loadingResource;
	    }, n.isRenderComplete = function() {
	        return !!this._renderComplete;
	    }, n.mustRenderOnInteracting = function() {
	        return !this._painted;
	    }, n.setToRedraw = function() {
	        return this._toRedraw = !0, this;
	    }, n.setCanvasUpdated = function() {
	        return this._canvasUpdated = !0, this;
	    }, n.isCanvasUpdated = function() {
	        return !!this._canvasUpdated;
	    }, n.remove = function() {
	        this.onRemove(), delete this._loadingResource, delete this.southWest, delete this.canvas, 
	        delete this.context, delete this.canvasExtent2D, delete this._extent2D, this.resources && this.resources.remove(), 
	        delete this.resources, delete this.layer;
	    }, n.onRemove = function() {}, n.onAdd = function() {}, n.getMap = function() {
	        return this.layer ? this.layer.getMap() : null;
	    }, n.getCanvasImage = function() {
	        var t = this.getMap();
	        if (this._canvasUpdated = !1, this._renderZoom !== t.getZoom() || !this.canvas || !this._extent2D) return null;
	        if (this.isBlank()) return null;
	        if (this.layer.isEmpty && this.layer.isEmpty()) return null;
	        var e = t._pointToContainerPoint(this.southWest)._add(0, -t.height);
	        return {
	            image: this.canvas,
	            layer: this.layer,
	            point: e
	        };
	    }, n.clear = function() {
	        this.clearCanvas();
	    }, n.isBlank = function() {
	        return !this._painted;
	    }, n.show = function() {
	        this.setToRedraw();
	    }, n.hide = function() {
	        this.clear(), this.setToRedraw();
	    }, n.setZIndex = function() {
	        this.setToRedraw();
	    }, n.hitDetect = function(t) {
	        if (!this.context || this.layer.isEmpty && this.layer.isEmpty() || this.isBlank() || this._errorThrown || this.layer.isVisible && !this.layer.isVisible()) return !1;
	        var e = this.getMap(), n = e.getDevicePixelRatio(), i = e.getSize();
	        if (t.x < 0 || t.x > i.width * n || t.y < 0 || t.y > i.height * n) return !1;
	        var r = this.getImageData && this.getImageData();
	        if (r) {
	            var o = Math.round(n * t.x), s = Math.round(n * t.y);
	            return r.data[s * r.width * 4 + 4 * o + 3] > 0;
	        }
	        try {
	            if (this.context.getImageData(n * t.x, n * t.y, 1, 1).data[3] > 0) return !0;
	        } catch (t) {
	            return this._errorThrown || (console && console.warn("hit detect failed with tainted canvas, some geometries have external resources in another domain:\n", t), 
	            this._errorThrown = !0), !1;
	        }
	        return !1;
	    }, n.loadResources = function(t) {
	        this.resources || (this.resources = new la);
	        var e = this.resources, n = [];
	        if (Zi$1(t)) for (var i = {}, r = t.length - 1; r >= 0; r--) {
	            var o = t[r];
	            o && o.length && !i[o.join("-")] && (i[o.join("-")] = 1, e.isResourceLoaded(o, !0) || n.push(new $o(this._promiseResource(o))));
	        }
	        return $o.all(n);
	    }, n.prepareRender = function() {
	        delete this._renderComplete;
	        var t = this.getMap();
	        this._renderZoom = t.getZoom(), this.canvasExtent2D = this._extent2D = t._get2DExtent(), 
	        this.southWest = t._containerPointToPoint(new Oi$1(0, t.height));
	    }, n.createCanvas = function() {
	        if (!this.canvas) {
	            var t = this.getMap(), e = t.getSize(), n = t.getDevicePixelRatio(), i = Math.round(n * e.width), r = Math.round(n * e.height);
	            if (this.layer._canvas) {
	                var o = this.layer._canvas;
	                o.width = i, o.height = r, o.style && (o.style.width = e.width + "px", o.style.height = e.height + "px"), 
	                this.canvas = this.layer._canvas;
	            } else this.canvas = qo.createCanvas(i, r, t.CanvasClass);
	            this.onCanvasCreate();
	        }
	    }, n.onCanvasCreate = function() {}, n.createContext = function() {
	        if (!(this.gl && this.gl.canvas === this.canvas || this.context) && (this.context = this.canvas.getContext("2d"), 
	        this.context)) {
	            this.layer.options.globalCompositeOperation && (this.context.globalCompositeOperation = this.layer.options.globalCompositeOperation);
	            var t = this.getMap().getDevicePixelRatio();
	            1 !== t && this.context.scale(t, t);
	        }
	    }, n.resetCanvasTransform = function() {
	        if (this.context) {
	            var t = this.getMap().getDevicePixelRatio();
	            this.context.setTransform(t, 0, 0, t, 0, 0);
	        }
	    }, n.resizeCanvas = function(t) {
	        var e = this.canvas;
	        if (e) {
	            var n = t || this.getMap().getSize(), i = this.getMap().getDevicePixelRatio(), r = ur(n, i), o = r.width, s = r.height, a = r.cssWidth, h = r.cssHeight;
	            !this.layer._canvas || e.style.width === a && e.style.height === h || (e.style.width = a, 
	            e.style.height = h), e.width === o && e.height === s || (e.height = s, e.width = o, 
	            1 !== i && this.context && this.context.scale(i, i));
	        }
	    }, n.clearCanvas = function() {
	        if (this.context && this.getMap()) {
	            var t = 1 / this.getMap().getDevicePixelRatio(), e = this.canvas.height * t;
	            qo.clearRect(this.context, 0, 0, Math.max(this.canvas.width * t, this.canvas.width), Math.max(e, this.canvas.height));
	        }
	    }, n.prepareCanvas = function() {
	        this.canvas ? (this.resetCanvasTransform(), this.clearCanvas(), this.resizeCanvas()) : (this.createCanvas(), 
	        this.createContext(), this.layer.onCanvasCreate(), this.layer.fire("canvascreate", {
	            context: this.context,
	            gl: this.gl
	        })), delete this._maskExtent;
	        var t = this.layer.getMask();
	        if (!t) return this.layer.fire("renderstart", {
	            context: this.context,
	            gl: this.gl
	        }), null;
	        var e = this._maskExtent = t._getMaskPainter().get2DExtent();
	        return e.intersects(this._extent2D), this.layer.fire("renderstart", {
	            context: this.context,
	            gl: this.gl
	        }), e;
	    }, n.clipCanvas = function(t) {
	        var e = this.layer.getMask();
	        if (!e) return !1;
	        var n = this.southWest, i = this.getMap();
	        this.southWest = i._containerPointToPoint(new Oi$1(0, i.height)), t.save();
	        var r = i.getDevicePixelRatio();
	        if (1 !== r && (t.save(), t.scale(r, r)), e.getGeometries) {
	            t.isMultiClip = !0;
	            var o = e.getGeometries() || [];
	            t.beginPath(), o.forEach((function(e) {
	                e._getMaskPainter().paint(null, t);
	            })), t.stroke(), delete t.isMultiClip;
	        } else {
	            e._getMaskPainter().paint(null, t);
	        }
	        return 1 !== r && t.restore(), t.clip(), this.southWest = n, !0;
	    }, n.getViewExtent = function() {
	        return {
	            extent: this._extent2D,
	            maskExtent: this._maskExtent,
	            zoom: this._renderZoom,
	            southWest: this.southWest
	        };
	    }, n.completeRender = function() {
	        this.getMap() && (this._renderComplete = !0, this.layer.fire("renderend", {
	            context: this.context,
	            gl: this.gl
	        }), this.setCanvasUpdated());
	    }, n.getEvents = function() {
	        return {
	            _zoomstart: this.onZoomStart,
	            _zooming: this.onZooming,
	            _zoomend: this.onZoomEnd,
	            _resize: this.onResize,
	            _movestart: this.onMoveStart,
	            _moving: this.onMoving,
	            _moveend: this.onMoveEnd,
	            _dragrotatestart: this.onDragRotateStart,
	            _dragrotating: this.onDragRotating,
	            _dragrotateend: this.onDragRotateEnd,
	            _spatialreferencechange: this.onSpatialReferenceChange
	        };
	    }, n.onZoomStart = function() {}, n.onZoomEnd = function() {
	        this.setToRedraw();
	    }, n.onZooming = function() {}, n.onMoveStart = function() {}, n.onMoving = function() {}, 
	    n.onMoveEnd = function() {
	        this.setToRedraw();
	    }, n.onResize = function() {
	        delete this._extent2D, this.resizeCanvas(), this.setToRedraw();
	    }, n.onDragRotateStart = function() {}, n.onDragRotating = function() {}, n.onDragRotateEnd = function() {
	        this.setToRedraw();
	    }, n.onSpatialReferenceChange = function() {}, n.getDrawTime = function() {
	        return this._drawTime;
	    }, n._tryToDraw = function(t) {
	        this._toRedraw = !1, !this.canvas && this.layer.isEmpty && this.layer.isEmpty() ? this._renderComplete = !0 : this._drawAndRecord(t);
	    }, n._drawAndRecord = function(t) {
	        if (this.getMap()) {
	            var e = this._painted;
	            this._painted = !0;
	            var n = In();
	            this.draw(t), n = In() - n, this._drawTime = e ? n : n / 2, e && this.layer && this.layer.options.logDrawTime && console.log(this.layer.getId(), "frameTimeStamp:", t, "drawTime:", this._drawTime);
	        }
	    }, n._promiseResource = function(t) {
	        var e = this, n = this.resources, i = this.layer.options.crossOrigin, r = this.layer.options.renderer || "";
	        return function(o) {
	            if (n.isResourceLoaded(t, !0)) o(t); else if (!Ri$1(t[0]) && e._resWorkerConn) {
	                var s = lr(t[0]);
	                e._resWorkerConn.fetchImage(s, (function(n, i) {
	                    if (n) return n && "undefined" != typeof console && console.warn(n), void o(t);
	                    hr(i, (function(n) {
	                        e._cacheResource(t, n), o(t);
	                    }));
	                }));
	            } else {
	                var a = new Image;
	                Dn(i) ? "canvas" !== r && (a.crossOrigin = "") : a.crossOrigin = i, Ri$1(t[0]) && !Wn && (t[1] && (t[1] *= 2), 
	                t[2] && (t[2] *= 2)), a.onload = function() {
	                    e._cacheResource(t, a), o(t);
	                }, a.onabort = function(e) {
	                    console && console.warn("image loading aborted: " + t[0]), e && console && console.warn(e), 
	                    o(t);
	                }, a.onerror = function(e) {
	                    e && "undefined" != typeof console && console.warn(e), n.markErrorResource(t), o(t);
	                }, Ii$1(a, t);
	            }
	        };
	    }, n._cacheResource = function(t, e) {
	        if (this.layer && this.resources) {
	            var n = t[1], i = t[2];
	            if (this.layer.options.cacheSvgOnCanvas && 1 === Ri$1(t[0]) && (Mi$1.edge || Mi$1.ie)) {
	                Dn(n) && (n = e.width || this.layer.options.defaultIconSize[0]), Dn(i) && (i = e.height || this.layer.options.defaultIconSize[1]);
	                var r = qo.createCanvas(n, i);
	                qo.image(r.getContext("2d"), e, 0, 0, n, i), e = r;
	            }
	            this.resources.addResource(t, e);
	        }
	    }, e;
	}(ns), la = function() {
	    function t() {
	        this.resources = {}, this._errors = {};
	    }
	    var e = t.prototype;
	    return e.addResource = function(t, e) {
	        var n = this;
	        if (this.resources[t[0]] = {
	            image: e,
	            width: +t[1],
	            height: +t[2],
	            refCnt: 0
	        }, e && !e.close && Mi$1.imageBitMap && !Mi$1.safari) {
	            if (e.src && Ri$1(e.src)) return;
	            createImageBitmap(e).then((function(e) {
	                n.resources[t[0]] && (n.resources[t[0]].image = e);
	            }));
	        }
	    }, e.isResourceLoaded = function(t, e) {
	        if (!t) return !1;
	        var n = this._getImgUrl(t);
	        if (this._errors[n]) return !0;
	        var i = this.resources[n];
	        return !!i && !(e && Ri$1(t[0]) && (+t[1] > i.width || +t[2] > i.height));
	    }, e.login = function(t) {
	        var e = this.resources[t];
	        e && e.refCnt++;
	    }, e.logout = function(t) {
	        var e = this.resources[t];
	        e && e.refCnt-- <= 0 && delete this.resources[t];
	    }, e.getImage = function(t) {
	        var e = this._getImgUrl(t);
	        return !this.isResourceLoaded(t) || this._errors[e] ? null : this.resources[e].image;
	    }, e.markErrorResource = function(t) {
	        this._errors[this._getImgUrl(t)] = 1;
	    }, e.merge = function(t) {
	        if (!t) return this;
	        for (var e in t.resources) {
	            var n = t.resources[e];
	            this.addResource([ e, n.width, n.height ], n.image);
	        }
	        return this;
	    }, e.forEach = function(t) {
	        if (!this.resources) return this;
	        for (var e in this.resources) Bn(this.resources, e) && t(e, this.resources[e]);
	        return this;
	    }, e._getImgUrl = function(t) {
	        return Array.isArray(t) ? t[0] : t;
	    }, e.remove = function() {
	        for (var t in this.resources) {
	            var e = this.resources[t];
	            e && e.image && e.image.close && e.image.close();
	        }
	        this.resources = {};
	    }, t;
	}(), ca = 10, ua = 10, fa = 1;

	var da = new Oi$1(0, 0);

	function ma(t, e, n, i, r, o, s) {
	    var a, h, l = da.set(e, n), c = t.set(l.x, l.y, l.x + o, l.y + s);
	    return c._add(r), i && (h = i, wa.set((a = c).xmin, a.ymin, a.xmax, a.ymax), wa.convertTo((function(t) {
	        return t._rotate(h);
	    }), a)), c;
	}

	var ga = [];

	function pa(t, e, n) {
	    var i = xa(e, (n = n || ba(ga, e))[0], n[1]);
	    return ma(t, e.markerDx || 0, e.markerDy || 0, Ca(e), i, n[0], n[1]);
	}

	function _a(t) {
	    return "rectangle" === t ? "right" : "middle";
	}

	function va(t) {
	    return "bar" === t || "pie" === t || "pin" === t ? "top" : "rectangle" === t ? "bottom" : "middle";
	}

	var ya = new Gr(0, 0);

	function xa(t, e, n) {
	    var i = 2 * (t.shadowBlur || 0) + .5;
	    ya.width = e, ya.height = n;
	    var r = t.markerType, o = to(ya, t.markerHorizontalAlignment || _a(r), t.markerVerticalAlignment || va(r));
	    return o.x !== -e / 2 && (o.x -= Bi$1(o.x + e / 2) * i), o.y !== -n / 2 && (o.y -= Bi$1(o.y + n / 2) * i), 
	    o;
	}

	function ba(t, e) {
	    var n = Ni$1(e.markerWidth, ca), i = Ni$1(e.markerHeight, ua), r = Ni$1(e.markerLineWidth, fa), o = 2 * ((e.shadowBlur || 0) + Math.max(Math.abs(e.shadowOffsetX || 0) + Math.abs(e.shadowOffsetY || 0))), s = Math.round(n + r + o + 1), a = Math.round(i + r + o + 1);
	    return t[0] = s, t[1] = a, t;
	}

	var wa = new Ps;

	function Ca(t, e) {
	    void 0 === e && (e = "markerRotation");
	    var n = t[e];
	    return Ln(n) ? -n * Math.PI / 180 : 0;
	}

	function Ma(t, e, n) {
	    var i = n ? n.getImage(e.markerFile) : null, r = e.markerWidth || (i ? i.width : 0), o = e.markerHeight || (i ? i.height : 0);
	    ya.width = r, ya.height = o;
	    var s = to(ya, e.markerHorizontalAlignment || "middle", e.markerVerticalAlignment || "top");
	    return ma(t, e.markerDx || 0, e.markerDy || 0, Ca(e), s, r, o);
	}

	function Ta(t, e, n) {
	    var i = n.size, r = to(i, e.textHorizontalAlignment, e.textVerticalAlignment);
	    if (e.textHaloRadius) {
	        var o = e.textHaloRadius;
	        i = i.add(2 * o, 2 * o);
	    }
	    return ma(t, e.textDx || 0, e.textDy || 0, Ca(e, "textRotation"), r, i.width, i.height);
	}

	var Sa = new Ps;

	function Pa(t, e, n, i) {
	    var r = t || new Ps;
	    if (Array.isArray(e)) {
	        for (var o = e, s = 0; s < o.length; s++) Pa(r, o[s], n, i[s]);
	        return r;
	    }
	    return Aa(e) && r._combine(Ta(Sa, e, i)), Ea(e) && r._combine(Ma(Sa, e, n)), Oa(e) && r._combine(pa(Sa, e)), 
	    Ra(e) && r._combine(Ma(Sa, e)), r;
	}

	function Aa(t) {
	    return !!t && !Dn(t.textName);
	}

	function Ea(t) {
	    return !!t && !Dn(t.markerFile);
	}

	function Oa(t) {
	    return !!t && !(!Dn(t.markerFile) || Dn(t.markerType) || "path" === t.markerType);
	}

	function Ra(t) {
	    return !!t && !(!Dn(t.markerFile) || "path" !== t.markerType);
	}

	var Ia, ka = [ "markerWidth", "markerHeight", "markerHorizontalAlignment", "markerVerticalAlignment", "markerDx", "markerDy", "textName", "textSize", "textDx", "textDy", "textVerticalAlignment", "textHorizontalAlignment", "textRotation" ], Da = [ "textName", "markerType", "markerFile", "textHaloRadius", "shadowBlur", "shadowOffsetX", "shadowOffsetY" ];

	function La(t, e, n, i) {
	    for (var r, o = [], s = 0, a = 0, h = t.length; a < h - 1; a++) (r = za(t[a], t[a + 1], e, a, n, i)) && (o[s] = o[s] || [], 
	    o[s].push({
	        point: r[0],
	        index: a
	    }), r[1] === t[a + 1] && a !== h - 2 || (o[s].push({
	        point: r[1],
	        index: a + 1
	    }), s++));
	    return o;
	}

	function za(t, e, n, i, r, o) {
	    var s, a, h, l = i ? Ia : Ha(t, n), c = Ha(e, n);
	    for (Ia = c; ;) {
	        if (!(l | c)) return [ t, e ];
	        if (l & c) return !1;
	        if (o) return [ t, e ];
	        h = Ha(a = ja(t, e, s = l || c, n, r), n), s === l ? (t = a, l = h) : (e = a, c = h);
	    }
	}

	function Fa(t, e, n) {
	    var i, r, o, s, a, h, l, c, u, f = [ 1, 4, 2, 8 ];
	    for (r = 0, l = t.length; r < l; r++) t[r]._code = Ha(t[r], e);
	    for (s = 0; s < 4; s++) {
	        for (c = f[s], i = [], r = 0, o = (l = t.length) - 1; r < l; o = r++) h = t[o], 
	        (a = t[r])._code & c ? h._code & c || ((u = ja(h, a, c, e, n))._code = Ha(u, e), 
	        i.push(u)) : (h._code & c && ((u = ja(h, a, c, e, n))._code = Ha(u, e), i.push(u)), 
	        i.push(a));
	        t = i;
	    }
	    return t;
	}

	function ja(t, e, n, i, r) {
	    var o, s, a = e.x - t.x, h = e.y - t.y, l = i.getMin(), c = i.getMax();
	    8 & n ? (o = t.x + a * (c.y - t.y) / h, s = c.y) : 4 & n ? (o = t.x + a * (l.y - t.y) / h, 
	    s = l.y) : 2 & n ? (o = c.x, s = t.y + h * (c.x - t.x) / a) : 1 & n && (o = l.x, 
	    s = t.y + h * (l.x - t.x) / a);
	    var u = new Oi$1(o, s);
	    return r && u._round(), u;
	}

	function Ha(t, e) {
	    var n = 0;
	    return t.x < e.getMin().x ? n |= 1 : t.x > e.getMax().x && (n |= 2), t.y < e.getMin().y ? n |= 4 : t.y > e.getMax().y && (n |= 8), 
	    n;
	}

	function Na(t, e, n, i) {
	    t = new Oi$1(t);
	    var r, o, s, a = Math.abs(n.x - e.x), h = Math.abs(n.y - e.y), l = Math.sqrt(Math.abs(a * a - h * h));
	    return a >= h ? (r = new Oi$1(e.x - l, e.y), o = new Oi$1(e.x + l, e.y), s = 2 * a) : (r = new Oi$1(e.x, e.y - l), 
	    o = new Oi$1(e.x, e.y + l), s = 2 * h), t.distanceTo(r) + t.distanceTo(o) <= s + 2 * i;
	}

	var Ba = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n._prepareContext = function(t) {
	        if (_r(this.symbol.opacity) ? this._opacityFn || (this._opacityFn = yr(this.symbol.opacity)) : delete this._opacityFn, 
	        Ln(this.symbol.opacity)) t.globalAlpha !== this.symbol.opacity && (t.globalAlpha = this.symbol.opacity); else if (this._opacityFn) {
	            var e = this.getMap();
	            t.globalAlpha = this._opacityFn(e.getZoom());
	        } else 1 !== t.globalAlpha && (t.globalAlpha = 1);
	    }, n.prepareCanvas = function(t, e, n) {
	        t.setLineDash && Zi$1(e.lineDasharray) && t.setLineDash(e.lineDasharray);
	        var i = this.getPainter().isHitTesting();
	        qo.prepareCanvas(t, e, n, i);
	    }, n.remove = function() {}, n.setZIndex = function() {}, n.show = function() {}, 
	    n.hide = function() {}, n._defineStyle = function(t) {
	        return zr(t, this.geometry);
	    }, e;
	}(function() {
	    function t() {}
	    var e = t.prototype;
	    return e.getMap = function() {
	        return this.geometry.getMap();
	    }, e.getPainter = function() {
	        return this.painter;
	    }, e.isDynamicSize = function() {
	        return !1;
	    }, t.testColor = function(t) {
	        return !(!t || !jn(t)) && Rn.indexOf(t) >= 0;
	    }, t;
	}());

	function Ga(t, e, n, i) {
	    var r, o = Va(n), s = n, a = s.markerType.toLowerCase(), h = Ua(a, s.markerWidth, s.markerHeight), l = o.lineOpacity, c = o.polygonOpacity;
	    ro(o.polygonFill) && (ro(o.polygonFill) && (r || (r = function(t, e, n) {
	        var i = new Ps;
	        return i._combine(t), i.xmin += -e / 2, i.ymin += -n / 2, i.xmax += e / 2, i.ymax += n / 2, 
	        i;
	    }(e, s.markerWidth, s.markerHeight)), o.polygonGradientExtent = r));
	    qo.prepareCanvas(t, o, i);
	    var u = s.markerWidth, f = s.markerHeight, d = s.markerLineWidth / 2;
	    if ("ellipse" === a) qo.ellipse(t, e, u / 2, f / 2, f / 2, l, c); else if ("cross" === a || "x" === a) {
	        for (var m = h.length - 1; m >= 0; m--) h[m]._add(e);
	        qo.path(t, h.slice(0, 2), l), qo.path(t, h.slice(2, 4), l);
	    } else if ("diamond" === a || "bar" === a || "square" === a || "rectangle" === a || "triangle" === a) {
	        "bar" === a ? e = e.add(0, -d) : "rectangle" === a && (e = e.add(d, d));
	        for (var g = h.length - 1; g >= 0; g--) h[g]._add(e);
	        qo.polygon(t, h, l, c);
	    } else if ("pin" === a) {
	        e = e.add(0, -d);
	        for (var p = h.length - 1; p >= 0; p--) h[p]._add(e);
	        var _ = t.lineCap;
	        t.lineCap = "round", qo.bezierCurveAndFill(t, h, l, c), t.lineCap = _;
	    } else {
	        if ("pie" !== a) throw new Error("unsupported markerType: " + a);
	        e = e.add(0, -d);
	        var v = 180 * Math.atan(u / 2 / f) / Math.PI, y = t.lineCap;
	        t.lineCap = "round", qo.sector(t, e, f, [ 90 - v, 90 + v ], l, c), t.lineCap = y;
	    }
	    return t.canvas;
	}

	function Va(t) {
	    var e = {
	        lineColor: t.markerLineColor,
	        linePatternFile: t.markerLinePatternFile,
	        lineWidth: t.markerLineWidth,
	        lineOpacity: t.markerLineOpacity,
	        lineDasharray: t.markerLineDasharray,
	        lineCap: "butt",
	        lineJoin: "round",
	        polygonFill: t.markerFill,
	        polygonPatternFile: t.markerFillPatternFile,
	        polygonOpacity: t.markerFillOpacity
	    };
	    return 0 === e.lineWidth && (e.lineOpacity = 0), e;
	}

	function Ua(t, e, n) {
	    var i, r, o, s, a = n / 2, h = e / 2;
	    if ("triangle" === t) return [ i = new Oi$1(0, 0 - a), r = new Oi$1(0 - h, 0 + a), o = new Oi$1(0 + h, 0 + a) ];
	    if ("cross" === t) return [ i = new Oi$1(0 - h, 0), r = new Oi$1(0 + h, 0), o = new Oi$1(0, 0 - a), s = new Oi$1(0, 0 + a) ];
	    if ("diamond" === t) return [ i = new Oi$1(0 - h, 0), r = new Oi$1(0, 0 - a), o = new Oi$1(0 + h, 0), s = new Oi$1(0, 0 + a) ];
	    if ("square" === t) return [ i = new Oi$1(0 - h, 0 + a), r = new Oi$1(0 + h, 0 + a), o = new Oi$1(0 + h, 0 - a), s = new Oi$1(0 - h, 0 - a) ];
	    if ("rectangle" === t) return r = (i = new Oi$1(0, 0)).add(e, 0), o = i.add(e, n), 
	    s = i.add(0, n), [ i, r, o, s ];
	    if ("x" === t) return [ i = new Oi$1(0 - h, 0 + a), r = new Oi$1(0 + h, 0 - a), o = new Oi$1(0 + h, 0 + a), s = new Oi$1(0 - h, 0 - a) ];
	    if ("bar" === t) return [ i = new Oi$1(0 - h, 0 - n), r = new Oi$1(0 + h, 0 - n), o = new Oi$1(0 + h, 0), s = new Oi$1(0 - h, 0) ];
	    if ("pin" === t || "pie" === t) {
	        var l = n * Math.atan(h / a);
	        return [ i = new Oi$1(0, 0), r = new Oi$1(0 - l, 0 - n), o = new Oi$1(0 + l, 0 - n), s = new Oi$1(0, 0) ];
	    }
	    return [];
	}

	var Wa, Za = new Oi$1(0, 0), Xa = new Oi$1(0, 0), Ja = new Oi$1(0, 0), qa = new Oi$1(0, 0), Ya = function(t) {
	    function e(e, n, i) {
	        var r;
	        return (r = t.call(this) || this).symbol = e, r.geometry = n, r.painter = i, r;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.get2DExtent = function() {
	        for (var t = this.getMap(), e = t.getGLRes(), n = new Ps, i = this._getRenderPoints()[0], r = i.length - 1; r >= 0; r--) i[r] && n._combine(t._pointAtResToPoint(i[r], e));
	        return n;
	    }, n.isDynamicSize = function() {
	        var t = this.symbol;
	        return _r(t.markerWidth) || _r(t.markerHeight) || _r(t.textSize);
	    }, n._rotateExtent = function(t, e) {
	        return t.convertTo((function(t) {
	            return t._rotate(e);
	        }));
	    }, n._getRenderPoints = function() {
	        var t = this.getPainter().isSpriting() ? "center" : this.getPlacement();
	        return this.getPainter().getRenderPoints(t);
	    }, n._getRenderContainerPoints = function(t) {
	        var e = this.getPainter();
	        if (e.isSpriting()) return this._getRenderPoints()[0];
	        var n, i = this.geometry, r = this.getDxDy();
	        if (i._cPoint && !t) {
	            var o = t ? Ja : qa;
	            o.set(i._cPoint.x, i._cPoint.y), o._sub(e.containerOffset);
	            var s = r.x, a = r.y;
	            (s || a) && o._add(s || 0, a || 0), n = [ o ];
	        } else {
	            var h = this._getRenderPoints()[0];
	            n = this.painter._pointContainerPoints(h, r.x, r.y, t, !0, this.getPlacement());
	        }
	        if (!n || !Array.isArray(n[0])) return n;
	        for (var l = [], c = 0, u = n.length; c < u; c++) for (var f = 0, d = n[c].length; f < d; f++) l.push(n[c][f]);
	        return l;
	    }, n.getPlacement = function() {
	        return this.symbol.markerPlacement;
	    }, n.getRotation = function() {
	        return Ca(this.style);
	    }, n.getDxDy = function() {
	        var t = this.style;
	        return new Oi$1(t.markerDx, t.markerDy);
	    }, n._getRotationAt = function(t) {
	        var e = this.getRotation();
	        e || (e = 0);
	        var n = this._getRenderPoints()[1];
	        if (!n || !n[t]) return e;
	        var i = this.getMap(), r = n[t][0], o = n[t][1];
	        if (i.isTransforming()) {
	            var s = i.getGLRes();
	            return r = i._pointAtResToContainerPoint(n[t][0], s, 0, Za), o = i._pointAtResToContainerPoint(n[t][1], s, 0, Xa), 
	            e + tr(r.x, r.y, o.x, o.y);
	        }
	        return e + -tr(r.x, r.y, o.x, o.y);
	    }, n._rotate = function(t, e, n) {
	        if (n) {
	            var i = this.getDxDy(), r = e.sub(i);
	            return t.save(), t.translate(r.x, r.y), t.rotate(n), i;
	        }
	        return null;
	    }, e;
	}(Ba), Ka = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getPlacement = function() {
	        return "point";
	    }, n.getDxDy = function() {
	        return new Oi$1(0, 0);
	    }, n.symbolize = function(t) {
	        var e = this.geometry, n = e.getLayer();
	        if (e.options.debug || !n || n.options.debug) {
	            var i = this.getMap();
	            if (i && !i.isZooming()) {
	                var r = n.options.debugOutline;
	                t.strokeStyle = r, t.fillStyle = r;
	                var o = e.getContainerExtent().toArray();
	                qo.polygon(t, [ o ], 1, 0);
	                for (var s = this._getRenderContainerPoints(), a = this.geometry.getId(), h = Ua("cross", 10, 10), l = 0; l < s.length; l++) {
	                    var c = s[l];
	                    Dn(a) || qo.fillText(t, a, c.add(8, -4), r);
	                    for (var u = [], f = 0; f < h.length; f++) u.push(h[f].add(c));
	                    qo.path(t, u.slice(0, 2), 1), qo.path(t, u.slice(2, 4), 1);
	                }
	            }
	        }
	    }, e;
	}(Ya), Qa = new Gr(1, 1), $a = function(t) {
	    function e(e, n, i) {
	        var r;
	        return (r = t.call(this, e, n, i) || this).style = r._defineStyle(r.translate()), 
	        r;
	    }
	    Ti$1(e, t), e.test = function(t) {
	        return Ea(t);
	    };
	    var n = e.prototype;
	    return n.symbolize = function(t, e) {
	        var n = this.style;
	        if (this.painter.isHitTesting() || 0 !== n.markerWidth && 0 !== n.markerHeight && 0 !== n.markerOpacity) {
	            var i = this._getRenderContainerPoints();
	            if (Zi$1(i)) {
	                var r = this._getImage(e);
	                if (r) {
	                    this._prepareContext(t);
	                    var o, s = n.markerWidth, a = n.markerHeight;
	                    if (!Ln(s) || !Ln(a)) {
	                        a = r.height, n.markerWidth = s = r.width, n.markerHeight = a;
	                        var h = n.markerFile;
	                        e.isResourceLoaded(h) || e.addResource(h, r);
	                        var l = this.getPainter();
	                        l.isSpriting() || l.removeCache();
	                    }
	                    "path" !== this.symbol.markerType && Ln(n.markerOpacity) && n.markerOpacity < 1 && (o = t.globalAlpha, 
	                    t.globalAlpha *= n.markerOpacity), Qa.width = s, Qa.height = a;
	                    for (var c = to(Qa, n.markerHorizontalAlignment, n.markerVerticalAlignment), u = 0, f = i.length; u < f; u++) {
	                        var d = i[u], m = this.getRotation() ? this._rotate(t, d, this._getRotationAt(u)) : null;
	                        m && (d = m), qo.image(t, r, d.x + c.x, d.y + c.y, s, a), m && t.restore();
	                    }
	                    void 0 !== o && (t.globalAlpha = o);
	                } else "undefined" != typeof console && console.warn("no img found for " + (this.style.markerFile || this._url[0]));
	            }
	        }
	    }, n._getImage = function(t) {
	        return function(t, e) {
	            return t && t.getImage(e) || null;
	        }(t, this.style.markerFile);
	    }, n.getFixedExtent = function(t) {
	        return this._fixedExtent = this._fixedExtent || new Ps, Ma(this._fixedExtent, this.style, t);
	    }, n.translate = function() {
	        var t = this.symbol;
	        return {
	            markerFile: t.markerFile,
	            markerOpacity: Ni$1(t.markerOpacity, 1),
	            markerWidth: Ni$1(t.markerWidth, null),
	            markerHeight: Ni$1(t.markerHeight, null),
	            markerRotation: Ni$1(t.markerRotation, 0),
	            markerDx: Ni$1(t.markerDx, 0),
	            markerDy: Ni$1(t.markerDy, 0),
	            markerHorizontalAlignment: Ni$1(t.markerHorizontalAlignment, "middle"),
	            markerVerticalAlignment: Ni$1(t.markerVerticalAlignment, "top")
	        };
	    }, e;
	}(Ya), th = new us(0, 0), eh = new us(0, 0), nh = function(t) {
	    function e(e, n, i) {
	        var r;
	        return (r = t.call(this) || this).symbol = e, r.geometry = n, r.painter = i, "Point" === n.type ? Si$1(r) : (r.style = r._defineStyle(r.translate()), 
	        r);
	    }
	    Ti$1(e, t), e.test = function(t, e) {
	        if (!t) return !1;
	        if (e && "Point" === e.type) return !1;
	        for (var n in t) {
	            var i = n.slice(0, 4);
	            if ("line" === i || "poly" === i) return !0;
	        }
	        return !1;
	    };
	    var n = e.prototype;
	    return n.symbolize = function(t, e) {
	        var n = this.style;
	        if (0 !== n.polygonOpacity || 0 !== n.lineOpacity || this.painter.isHitTesting()) {
	            var i = this._getPaintParams();
	            if (i) {
	                this._prepareContext(t);
	                var r = ro(n.lineColor), o = "Polygon" === this.geometry.getJSONType() || "LineString" === this.geometry.type;
	                !r || !n.lineColor.places && o || (n.lineGradientExtent = this.geometry.getContainerExtent()._expand(n.lineWidth)), 
	                ro(n.polygonFill) && (n.polygonGradientExtent = this.geometry.getContainerExtent());
	                var s = i[0];
	                if ("Polygon" === this.geometry.getJSONType() && s.length > 0 && Array.isArray(s[0][0]) || "LineString" === this.geometry.type && s.length > 0 && Array.isArray(s[0])) for (var a = 0; a < s.length; a++) {
	                    this.prepareCanvas(t, n, e), r && o && !n.lineColor.places && this._createGradient(t, s[a], n.lineColor);
	                    var h = [ t, s[a] ];
	                    i.length > 1 && h.push.apply(h, i.slice(1)), h.push(n.lineOpacity, n.polygonOpacity, n.lineDasharray), 
	                    this.geometry._paintOn.apply(this.geometry, h);
	                } else {
	                    this.prepareCanvas(t, n, e), r && o && !n.lineColor.places && this._createGradient(t, s, n.lineColor);
	                    var l = [ t ];
	                    l.push.apply(l, i), l.push(n.lineOpacity, n.polygonOpacity, n.lineDasharray), this.geometry._paintOn.apply(this.geometry, l);
	                }
	                t.setLineDash && Array.isArray(n.lineDasharray) && t.setLineDash([]);
	            }
	        }
	    }, n.get2DExtent = function() {
	        var t = this.getMap(), e = this.geometry._getPrjExtent();
	        if (!e) return null;
	        this._extMin && this._extMax || (this._extMin = new us(0, 0), this._extMax = new us(0, 0)), 
	        this._extMin.x = e.xmin, this._extMin.y = e.ymin, this._extMax.x = e.xmax, this._extMax.y = e.ymax;
	        var n = t._prjToPoint(this._extMin, void 0, th), i = t._prjToPoint(this._extMax, void 0, eh);
	        return this._pxExtent ? this._pxExtent.set(Math.min(n.x, i.x), Math.min(n.y, i.y), Math.max(n.x, i.x), Math.max(n.y, i.y)) : this._pxExtent = new Ps(n, i), 
	        this._pxExtent;
	    }, n.getFixedExtent = function() {
	        var t = this.style.lineWidth / 2;
	        return new Ps(-t, -t, t, t);
	    }, n._getPaintParams = function() {
	        return this.getPainter().getPaintParams(this.style.lineDx, this.style.lineDy);
	    }, n.translate = function() {
	        var t = this.symbol, e = {
	            lineColor: Ni$1(t.lineColor, "#000"),
	            lineWidth: Ni$1(t.lineWidth, 2),
	            lineOpacity: Ni$1(t.lineOpacity, 1),
	            lineDasharray: Ni$1(t.lineDasharray, []),
	            lineCap: Ni$1(t.lineCap, "butt"),
	            lineJoin: Ni$1(t.lineJoin, "miter"),
	            linePatternFile: Ni$1(t.linePatternFile, null),
	            lineDx: Ni$1(t.lineDx, 0),
	            lineDy: Ni$1(t.lineDy, 0),
	            polygonFill: Ni$1(t.polygonFill, null),
	            polygonOpacity: Ni$1(t.polygonOpacity, 1),
	            polygonPatternFile: Ni$1(t.polygonPatternFile, null),
	            polygonPatternDx: Ni$1(t.polygonPatternDx, 0),
	            polygonPatternDy: Ni$1(t.polygonPatternDy, 0),
	            linePatternDx: Ni$1(t.linePatternDx, 0),
	            linePatternDy: Ni$1(t.linePatternDy, 0)
	        };
	        return 0 === e.lineWidth && (e.lineOpacity = 0), "LineString" !== this.geometry.type || e.polygonFill || (e.polygonFill = e.lineColor), 
	        e;
	    }, n._createGradient = function(t, e, n) {
	        if (Array.isArray(e) && e.length) {
	            var i = e.length, r = t.createLinearGradient(e[0].x, e[0].y, e[i - 1].x, e[i - 1].y);
	            n.colorStops.forEach((function(t) {
	                r.addColorStop.apply(r, t);
	            })), t.strokeStyle = r;
	        }
	    }, e;
	}(Ba), ih = function(t) {
	    function e(e, n, i) {
	        var r, o = (r = t.call(this, e, n, i) || this).translate();
	        return r._dynamic = vr(o), r.style = r._defineStyle(o), 0 === r.style.textWrapWidth ? Si$1(r) : (r.strokeAndFill = r._defineStyle(r.translateLineAndFill(r.style)), 
	        r);
	    }
	    Ti$1(e, t), e.test = function(t) {
	        return Aa(t);
	    };
	    var n = e.prototype;
	    return n.symbolize = function(t, e) {
	        if (this.painter.isHitTesting() || 0 !== this.style.textSize && (this.style.textOpacity || this.style.textHaloRadius && this.style.textHaloOpacity) && 0 !== this.style.textWrapWidth) {
	            var n = this._getRenderContainerPoints();
	            if (Zi$1(n)) {
	                var i = this.style, r = this.strokeAndFill, o = Qr(this.style.textName, this.geometry.getProperties());
	                this._dynamic && delete this._textDesc;
	                var s = this._textDesc = this._textDesc || $r(o, this.style);
	                this._prepareContext(t), this.prepareCanvas(t, r, e), qo.prepareCanvasFont(t, i);
	                for (var a = 0, h = n.length; a < h; a++) {
	                    var l = n[a], c = this.getRotation() ? this._rotate(t, l, this._getRotationAt(a)) : null;
	                    c && (l = c), qo.text(t, o, l, i, s), c && t.restore();
	                }
	            }
	        }
	    }, n.getPlacement = function() {
	        return this.symbol.textPlacement;
	    }, n.getRotation = function() {
	        var t = this.style.textRotation;
	        return Ln(t) ? -t * Math.PI / 180 : null;
	    }, n.getDxDy = function() {
	        var t = this.style;
	        return new Oi$1(t.textDx, t.textDy);
	    }, n.getFixedExtent = function() {
	        var t = this.geometry.getTextDesc();
	        return Array.isArray(t) && (t = t[this._index]), this._fixedExtent = this._fixedExtent || new Ps, 
	        t ? Ta(this._fixedExtent, this.style, t) : this._fixedExtent;
	    }, n.translate = function() {
	        var t = this.symbol, e = {
	            textName: t.textName,
	            textFaceName: Ni$1(t.textFaceName, "monospace"),
	            textWeight: Ni$1(t.textWeight, "normal"),
	            textStyle: Ni$1(t.textStyle, "normal"),
	            textSize: Ni$1(t.textSize, 14),
	            textFont: Ni$1(t.textFont, null),
	            textFill: Ni$1(t.textFill, "#000"),
	            textOpacity: Ni$1(t.textOpacity, 1),
	            textHaloFill: Ni$1(t.textHaloFill, "#ffffff"),
	            textHaloRadius: Ni$1(t.textHaloRadius, 0),
	            textHaloOpacity: Ni$1(t.textHaloOpacity, 1),
	            textWrapWidth: Ni$1(t.textWrapWidth, null),
	            textWrapCharacter: Ni$1(t.textWrapCharacter, "\n"),
	            textLineSpacing: Ni$1(t.textLineSpacing, 0),
	            textDx: Ni$1(t.textDx, 0),
	            textDy: Ni$1(t.textDy, 0),
	            textHorizontalAlignment: Ni$1(t.textHorizontalAlignment, "middle"),
	            textVerticalAlignment: Ni$1(t.textVerticalAlignment, "middle"),
	            textAlign: Ni$1(t.textAlign, "center"),
	            textRotation: Ni$1(t.textRotation, 0),
	            textMaxWidth: Ni$1(t.textMaxWidth, 0),
	            textMaxHeight: Ni$1(t.textMaxHeight, 0)
	        };
	        return e.textMaxWidth > 0 && (!e.textWrapWidth || e.textWrapWidth > e.textMaxWidth) && (e.textWrapWidth || (e.textMaxHeight = 1), 
	        e.textWrapWidth = e.textMaxWidth), e;
	    }, n.translateLineAndFill = function(t) {
	        return {
	            lineColor: t.textHaloRadius ? t.textHaloFill : t.textFill,
	            lineWidth: t.textHaloRadius,
	            lineOpacity: t.textOpacity,
	            lineDasharray: null,
	            lineCap: "butt",
	            lineJoin: "round",
	            polygonFill: t.textFill,
	            polygonOpacity: t.textOpacity
	        };
	    }, e;
	}(Ya), rh = [], oh = function(t) {
	    function e(e, n, i) {
	        var r, o = (r = t.call(this, e, n, i) || this).translate();
	        return r._dynamic = vr(o), r.style = r._defineStyle(o), r.strokeAndFill = r._defineStyle(Va(r.style)), 
	        r.padding = 0, r;
	    }
	    Ti$1(e, t), e.test = function(t) {
	        return Oa(t);
	    };
	    var n = e.prototype;
	    return n.symbolize = function(t, e) {
	        var n = this.style;
	        if (this.painter.isHitTesting() || 0 !== n.markerWidth && 0 !== n.markerHeight && (0 !== n.polygonOpacity || 0 !== n.lineOpacity)) {
	            var i = this._getRenderContainerPoints();
	            Zi$1(i) && (this._prepareContext(t), this.getPainter().isSpriting() || this.geometry.getLayer().getMask() === this.geometry || this._dynamic || !1 === this.geometry.getLayer().options.cacheVectorOnCanvas ? this._drawMarkers(t, i, e) : this._drawMarkersWithCache(t, i, e));
	        }
	    }, n._drawMarkers = function(t, e, n) {
	        for (var i = e.length - 1; i >= 0; i--) {
	            var r = e[i], o = this.getRotation() ? this._rotate(t, r, this._getRotationAt(i)) : null;
	            o && (r = o), this._drawVectorMarker(t, r, n), o && t.restore();
	        }
	    }, n._drawMarkersWithCache = function(t, e, n) {
	        var i = this._stampSymbol(), r = n.getImage(i);
	        r || (r = this._createMarkerImage(t, n), n.addResource([ i, r.width, r.height ], r));
	        for (var o = xa(this.style, r.width, r.height), s = e.length - 1; s >= 0; s--) {
	            var a = e[s], h = this.getRotation() ? this._rotate(t, a, this._getRotationAt(s)) : null;
	            h && (a = h), qo.image(t, r, a.x + o.x, a.y + o.y), h && t.restore();
	        }
	    }, n._createMarkerImage = function(t, e) {
	        var n = t.canvas.constructor, i = ba(rh, this.style), r = qo.createCanvas(i[0], i[1], n), o = this._getCacheImageAnchor(i[0], i[1]), s = r.getContext("2d");
	        return this._drawVectorMarker(s, o, e), r;
	    }, n._stampSymbol = function() {
	        return this._stamp || (this._stamp = io([ this.style.markerType, ro(this.style.markerFill) ? oo(this.style.markerFill) : this.style.markerFill, this.style.markerFillOpacity, this.style.markerFillPatternFile, ro(this.style.markerLineColor) ? oo(this.style.markerLineColor) : this.style.markerLineColor, this.style.markerLineWidth, this.style.markerLineOpacity, this.style.markerLineDasharray ? this.style.markerLineDasharray.join(",") : "", this.style.markerLinePatternFile, this.style.markerWidth, this.style.markerHeight, this.style.markerHorizontalAlignment, this.style.markerVerticalAlignment ].join("_"))), 
	        this._stamp;
	    }, n._getCacheImageAnchor = function(t, e) {
	        var n = 2 * (this.symbol.shadowBlur || 0) + this.padding, i = this.style.markerType;
	        return "bar" === i || "pie" === i || "pin" === i ? new Oi$1(t / 2, e - n) : "rectangle" === i ? new Oi$1(n, n) : new Oi$1(t / 2, e / 2);
	    }, n._getGraidentExtent = function(t) {
	        var e = new Ps, n = this.getDxDy(), i = this.getFixedExtent();
	        if (Array.isArray(t)) for (var r = t.length - 1; r >= 0; r--) e._combine(t[r]); else e._combine(t);
	        return e.xmin += i.xmin - n.x, e.ymin += i.ymin - n.y, e.xmax += i.xmax - n.x, e.ymax += i.ymax - n.y, 
	        e;
	    }, n._drawVectorMarker = function(t, e, n) {
	        Ga(t, e, this.style, n);
	    }, n.getFixedExtent = function() {
	        var t = this.isDynamicSize(), e = this.style.markerWidth, n = this.style.markerHeight;
	        return this._fixedExtent = this._fixedExtent || new Ps, pa(this._fixedExtent, this.style, t ? [ 128, 128 * n / e ] : null);
	    }, n.translate = function() {
	        var t = this.symbol, e = {
	            markerType: Ni$1(t.markerType, "ellipse"),
	            markerFill: Ni$1(t.markerFill, "#00f"),
	            markerFillOpacity: Ni$1(t.markerFillOpacity, 1),
	            markerFillPatternFile: Ni$1(t.markerFillPatternFile, null),
	            markerLineColor: Ni$1(t.markerLineColor, "#000"),
	            markerLineWidth: Ni$1(t.markerLineWidth, fa),
	            markerLineOpacity: Ni$1(t.markerLineOpacity, 1),
	            markerLineDasharray: Ni$1(t.markerLineDasharray, []),
	            markerLinePatternFile: Ni$1(t.markerLinePatternFile, null),
	            markerDx: Ni$1(t.markerDx, 0),
	            markerDy: Ni$1(t.markerDy, 0),
	            markerWidth: Ni$1(t.markerWidth, ca),
	            markerHeight: Ni$1(t.markerHeight, ua),
	            markerRotation: Ni$1(t.markerRotation, 0),
	            shadowBlur: Ni$1(t.shadowBlur, 0),
	            shadowOffsetX: Ni$1(t.shadowOffsetX, 0),
	            shadowOffsetY: Ni$1(t.shadowOffsetY, 0)
	        }, n = e.markerType, i = _a(n), r = va(n);
	        return e.markerHorizontalAlignment = Ni$1(t.markerHorizontalAlignment, i), e.markerVerticalAlignment = Ni$1(t.markerVerticalAlignment, r), 
	        Ln(t.markerOpacity) && (Ln(t.markerFillOpacity) && (e.markerFillOpacity *= t.markerOpacity), 
	        Ln(t.markerLineOpacity) && (e.markerLineOpacity *= t.markerOpacity)), e;
	    }, e;
	}(Ya), sh = function(t) {
	    function e(e, n, i) {
	        var r;
	        Dn(e.markerWidth) && (e.markerWidth = 80), Dn(e.markerHeight) && (e.markerHeight = 80), 
	        e = kn(e, (r = t.call(this, e, n, i) || this).translate());
	        var o = r.style = r._defineStyle(e);
	        return r._url = Mi$1.gecko ? [ jr(o, o.markerWidth, o.markerHeight), o.markerWidth, o.markerHeight ] : [ jr(o), o.markerWidth, o.markerHeight ], 
	        r;
	    }
	    Ti$1(e, t), e.test = function(t) {
	        return Ra(t);
	    };
	    var n = e.prototype;
	    return n._prepareContext = function() {}, n._getImage = function(t) {
	        var e = this;
	        if (t && t.isResourceLoaded(this._url)) return t.getImage(this._url);
	        var n = this.painter, i = new Image;
	        return i.onload = function() {
	            var t = n.getLayer() && n.getLayer().getRenderer();
	            t && t.setToRedraw();
	        }, i.onerror = function(n) {
	            n && "undefined" != typeof console && console.warn(n), t.markErrorResource(e._url);
	        }, i.src = this._url[0], t && t.addResource(this._url, i), i;
	    }, e;
	}($a), ah = {
	    lineWidth: 1,
	    polygonFill: "#fff",
	    polygonOpacity: .5
	}, hh = [ function(t) {
	    function e(e, n, i) {
	        var r;
	        return (r = t.call(this, e, n, i) || this).style = n.getLayer().options.drawAltitude, 
	        r.style && Fn(r.style) || (r.style = {
	            lineWidth: 2
	        }), r.style.lineWidth || (r.style.lineWidth = 0), r.dxdy = r._defineStyle({
	            dx: e.textDx || e.markerDx,
	            dy: e.textDy || e.markerDy
	        }), r;
	    }
	    Ti$1(e, t), e.test = function(t, e) {
	        if (!e.getLayer()) return !1;
	        var n = e.getJSONType();
	        return "Marker" === n || "LineString" === n;
	    };
	    var n = e.prototype;
	    return n.symbolize = function(t) {
	        var e = this.geometry.getLayer();
	        if (e.options.drawAltitude) {
	            var n = this.geometry.getProperties();
	            if (n && n[e.options.altitudeProperty]) {
	                var i = this._getStyle();
	                if (this._prepareContext(t), "LineString" === this.geometry.type) {
	                    var r = this._getPaintParams(i.lineDx, i.lineDy, !1, !0);
	                    if (!r) return;
	                    var o = this.getPainter().getPaintParams(i.lineDx, i.lineDy, !0, !0, "_groundpt")[0];
	                    this._drawLineAltitude(t, r[0], o);
	                } else {
	                    var s = this._getRenderContainerPoints(), a = this._getRenderContainerPoints(!0);
	                    if (!s || 0 === s.length) return;
	                    this._drawMarkerAltitude(t, s[0], a[0]);
	                }
	            }
	        }
	    }, n.getDxDy = function() {
	        var t = this.dxdy;
	        return new Oi$1(t.dx || 0, t.dy || 0);
	    }, n.get2DExtent = function() {
	        return "LineString" === this.geometry.type ? nh.prototype.get2DExtent.apply(this) : t.prototype.get2DExtent.call(this);
	    }, n.getPlacement = function() {
	        return "point";
	    }, n._getPaintParams = function(t, e) {
	        return this.getPainter().getPaintParams(t || 0, e || 0, null, !0, "_altpt");
	    }, n._drawMarkerAltitude = function(t, e, n) {
	        var i = this._getStyle();
	        this.prepareCanvas(t, i), qo.path(t, [ e, n ], i.lineOpacity, null, i.lineDasharray);
	    }, n._drawLineAltitude = function(t, e, n) {
	        var i = this._getStyle();
	        if (e.length > 0 && Array.isArray(e[0])) for (var r = 0; r < e.length; r++) this._drawLine(t, e[r], n[r]); else this._drawLine(t, e, n);
	        t.setLineDash && Array.isArray(i.lineDasharray) && t.setLineDash([]);
	    }, n._drawLine = function(t, e, n) {
	        var i = this._getStyle();
	        this.prepareCanvas(t, i);
	        for (var r = 0, o = e.length - 1; r < o; r++) qo.polygon(t, [ e[r], e[r + 1], n[r + 1], n[r] ], i.lineOpacity, i.polygonOpacity, i.lineDasharray);
	    }, n._getStyle = function() {
	        var t = this.geometry.getLayer().options.drawAltitude;
	        return Fn(t) || (t = ah), t.lineWidth || (t.lineWidth = 0, t.lineOpacity = 0), t;
	    }, e;
	}(Ya), nh, $a, sh, oh, ih ], lh = new Oi$1(0, 0), ch = new Ps, uh = new Ps, fh = new Ps, dh = new Ps, mh = new Ps, gh = {}, ph = {
	    minx: 1 / 0,
	    miny: 1 / 0,
	    maxx: -1 / 0,
	    maxy: -1 / 0
	}, _h = function(t) {
	    function e(e) {
	        var n;
	        return (n = t.call(this) || this).geometry = e, n.symbolizers = n._createSymbolizers(), 
	        n._altAtGL = n._getGeometryAltitude(), n;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getMap = function() {
	        return this.geometry.getMap();
	    }, n.getLayer = function() {
	        return this.geometry.getLayer();
	    }, n._createSymbolizers = function() {
	        var t = this.getSymbol(), e = [], n = hh, i = t;
	        Array.isArray(t) || (i = [ t ]);
	        for (var r = i.length - 1; r >= 0; r--) for (var o = i[r], s = n.length - 1; s >= 0; s--) if (n[s].test(o, this.geometry)) {
	            var a = new n[s](o, this.geometry, this);
	            a._index = r, e.push(a), a instanceof Ya && (this._hasPoint = !0);
	        }
	        if (!e.length && console) {
	            var h = this.geometry.getId();
	            console.warn("invalid symbol for geometry(" + (this.geometry ? this.geometry.getType() + (h ? ":" + h : "") : "") + ") to draw : " + JSON.stringify(t));
	        }
	        return this._debugSymbolizer = new Ka(t, this.geometry, this), e;
	    }, n.hasPoint = function() {
	        return !!this._hasPoint;
	    }, n.getRenderPoints = function(t) {
	        return this._verifyProjection(), this._renderPoints || (this._renderPoints = {}), 
	        t || (t = "center"), this._renderPoints[t] || (this._renderPoints[t] = this.geometry._getRenderPoints(t)), 
	        this._renderPoints[t];
	    }, n.getPaintParams = function(t, e, n, i, r) {
	        void 0 === r && (r = "_pt");
	        var o, s, a, h, l, c = this.getLayer()._getRenderer().mapStateCache, u = this.getMap();
	        c && !this._hitPoint ? (o = c.resolution, s = c.pitch, a = c.bearing, h = c.glScale, 
	        l = c.containerExtent) : (o = u.getResolution(), s = u.getPitch(), a = u.getBearing(), 
	        h = u.getGLScale(), l = u.getContainerExtent());
	        var f = this.geometry, d = o, m = 0 !== s, g = 0 !== a, p = this._cachedParams, _ = f._paintAsPath && f._paintAsPath();
	        if (_ && this._unsimpledParams && d <= this._unsimpledParams._res) p = this._unsimpledParams; else if (!p || p._res !== o || this._pitched !== m && f._redrawWhenPitch() || this._rotated !== g && f._redrawWhenRotate()) {
	            if (!(p = f._getPaintParams())) return null;
	            p._res = d, !f._simplified && _ && (this._unsimpledParams || (this._unsimpledParams = p), 
	            d > this._unsimpledParams._res && (this._unsimpledParams._res = d)), this._cachedParams = p;
	        }
	        if (!p) return null;
	        this._pitched = m, this._rotated = g;
	        var v = h, y = [], x = this._pointContainerPoints(p[0], t, e, n, i || this._hitPoint && !l.contains(this._hitPoint), null, r);
	        if (!x) return null;
	        y.push(x);
	        for (var b = 1, w = p.length; b < w; b++) Ln(p[b]) || p[b] instanceof Gr ? Ln(p[b]) ? y.push(p[b] / v) : y.push(p[b].multi(1 / v)) : y.push(p[b]);
	        return y;
	    }, n._pointContainerPoints = function(t, e, n, i, r, o, s) {
	        if (void 0 === s && (s = "_pt"), this._aboveCamera()) return null;
	        var a, h, l, c = this.getLayer()._getRenderer(), u = c.mapStateCache, f = this.getMap(), d = this.geometry, m = this.containerOffset;
	        u ? (a = u.glRes, h = u.containerExtent) : (a = f.getGLRes(), h = f.getContainerExtent());
	        var g = this.getLayer().options.roundPoint, p = 1 / 0, _ = 1 / 0, v = -1 / 0, y = -1 / 0, x = !r, b = c.layer.options.clipBBoxBufferSize || 3, w = this.symbolizers;
	        function C(t, i) {
	            void 0 === t && (t = []), void 0 === i && (i = []);
	            for (var r = sr(t, s), o = 0, l = (r = f._pointsAtResToContainerPoints(t, a, i, r)).length; o < l; o++) {
	                var c = r[o];
	                c._sub(m), (e || n) && c._add(e || 0, n || 0), g && (c.x = Math.ceil(c.x), c.y = Math.ceil(c.y)), 
	                p = Math.min(c.x, p), _ = Math.min(c.y, _), v = Math.max(c.x, v), y = Math.max(c.y, y);
	            }
	            if (x && go(w)) {
	                if (mh.ymin = h.ymin, mh.ymin < b && (mh.ymin = h.ymin - b), mh.xmin = h.xmin - b, 
	                mh.xmax = h.xmax + b, mh.ymax = h.ymax + b, d.getShell && d.getHoles) return Fa(r, mh);
	                var u = La(r, mh, !1);
	                if (u.length) {
	                    var C = [];
	                    return u.forEach((function(t) {
	                        for (var e = 0, n = t.length; e < n; e++) C.push(t[e].point);
	                    })), C;
	                }
	            }
	            return r;
	        }
	        var M = this.getAltitude();
	        if (Array.isArray(t)) {
	            var T;
	            !r && this.geometry.options.enableClip ? (T = this._clip(t, M)).inView && (x = !1) : T = {
	                points: t,
	                altitude: M
	            };
	            var S = T.points;
	            M = T.altitude, i && (M = 0);
	            var P = M;
	            l = [];
	            for (var A = [], E = Ln(M), O = 0, R = S.length; O < R; O++) {
	                var I = S[O];
	                if (Array.isArray(I)) {
	                    if (E) {
	                        var k = C(I, M);
	                        l.push(k);
	                        continue;
	                    }
	                    for (var D = [], L = 0, z = I.length; L < z; L++) Array.isArray(M) && (P = M[O] ? M[O][L] : 0), 
	                    D.push(P);
	                    var F = C(I, D);
	                    l.push(F);
	                } else Array.isArray(M) && (P = "vertex-last" === o ? M[M.length - 1 - O] : "line" === o ? (M[O] + M[O + 1]) / 2 : M[O]), 
	                A.push(P);
	            }
	            A.length && (l = C(S, A));
	        } else t instanceof Oi$1 && (i && (M = 0), l = f._pointAtResToContainerPoint(t, a, M)._sub(m), 
	        (e || n) && l._add(e, n));
	        return ph.minx = p, ph.miny = _, ph.maxx = v, ph.maxy = y, this._containerBbox = ph, 
	        l;
	    }, n._clip = function(t, e) {
	        if (Ln(e) && 0 !== e) return {
	            points: t,
	            altitude: e
	        };
	        if (Array.isArray(e)) {
	            for (var n = !1, i = 0, r = e.length; i < r; i++) if (0 !== e[i]) {
	                n = !0;
	                break;
	            }
	            if (n) return {
	                points: t,
	                altitude: e
	            };
	        }
	        var o = this.getMap(), s = this.geometry, a = this.getSymbol().lineWidth;
	        Ln(a) || (a = 4);
	        var h, l, c, u = this.getLayer()._getRenderer().mapStateCache;
	        u ? (h = u._2DExtent, l = u.glExtent, c = u.pitch) : (h = o._get2DExtent(), l = o._get2DExtentAtRes(o.getGLRes()), 
	        c = o.getPitch());
	        var f = h._expand(a);
	        if (c > 0 && e) {
	            var d = o.cameraLookAt, m = o.cameraPosition;
	            lh.set(m.x, m.y), f = f._combine(lh._add(Bi$1(d[0] - m[0]), Bi$1(d[1] - m[1])));
	        }
	        var g = t;
	        if (this.get2DExtent(null, dh).within(f)) return {
	            points: g,
	            altitude: e,
	            inView: !0
	        };
	        var p = l._expand(a * o._glScale);
	        fh.xmin = p.xmin, fh.xmax = p.xmax, fh.ymin = p.ymin, fh.ymax = p.ymax;
	        var _ = s.options.smoothness;
	        if (s.getShell && this.geometry.getHoles && !_) {
	            var v = p.ymin, y = p.ymax, x = Math.abs(p.xmax - p.xmin), b = Math.abs(y - v), w = Math.sqrt(x * x + b * b), C = (w - x) / 2, M = (w - b) / 2;
	            if (fh.xmin = p.xmin - C, fh.xmax = p.xmax + C, fh.ymin = p.ymin - M, fh.ymax = p.ymax + M, 
	            Array.isArray(t[0])) {
	                g = [];
	                for (var T = 0; T < t.length; T++) {
	                    var S = Fa(t[T], fh);
	                    S.length && g.push(S);
	                }
	            } else g = Fa(t, fh);
	        } else if ("LineString" === s.getJSONType() && !_) {
	            if (Array.isArray(t[0])) {
	                g = [];
	                for (var P = 0; P < t.length; P++) Fi$1(g, La(t[P], fh, !1, !!_));
	            } else g = La(t, fh, !1, !!_);
	            return this._interpolateSegAlt(g, t, e);
	        }
	        return {
	            points: g,
	            altitude: e
	        };
	    }, n._interpolateSegAlt = function(t, e, n) {
	        if (!Array.isArray(n)) {
	            var i = function(t) {
	                return t.point;
	            };
	            return {
	                points: t.map((function(t) {
	                    return Array.isArray(t) ? t.map(i) : t.point;
	                })),
	                altitude: n
	            };
	        }
	        var r = function t(e, n, i) {
	            if (!Array.isArray(i)) return e;
	            for (var r = [], o = 0, s = e.length; o < s; o++) if (Array.isArray(e[o])) r.push(t(e[o], n, i)); else {
	                var a = e[o];
	                if (a.point.equals(n[a.index])) a.altitude = i[a.index], r.push(a); else {
	                    var h = void 0, l = void 0;
	                    0 === a.index ? (h = a.index, l = a.index + 1) : (h = a.index - 1, l = a.index);
	                    var c = a.point.distanceTo(n[l]), u = c / (c + n[h].distanceTo(a.point)), f = Vi$1(i[h], i[l], 1 - u);
	                    a.altitude = f, r.push(a);
	                }
	            }
	            return r;
	        }(t, e, n);
	        return n = [], {
	            points: r.map((function(t) {
	                if (Array.isArray(t)) {
	                    var e = [], i = t.map((function(t) {
	                        return e.push(t.altitude), t.point;
	                    }));
	                    return n.push(e), i;
	                }
	                return n.push(t.altitude), t.point;
	            })),
	            altitude: n
	        };
	    }, n.getSymbol = function() {
	        return this.geometry._getInternalSymbol();
	    }, n.paint = function(t, e, n) {
	        if (this.symbolizers) {
	            var i = this.getLayer(), r = i._getRenderer();
	            if (r && (r.context || e)) {
	                var o = r.mapStateCache || {};
	                if (this.geometry._isCheck || !t || t.intersects(this.get2DExtent(r.resources, ch))) {
	                    var s = this.getMap(), a = this.getMinAltitude(), h = s.getFrustumAltitude();
	                    if (!(a && h && h < a)) {
	                        this.containerOffset = n || o.offset || s._pointToContainerPoint(r.southWest)._add(0, -s.height), 
	                        this._beforePaint();
	                        for (var l = e || r.context, c = [ l, r.resources ], u = this.symbolizers.length - 1; u >= 0; u--) (l.shadowBlur || this.symbolizers[u].symbol.shadowBlur) && this._prepareShadow(l, this.symbolizers[u].symbol), 
	                        this.symbolizers[u].symbolize.apply(this.symbolizers[u], c);
	                        this._afterPaint(), this._painted = !0, (this.geometry.options.debug || i.options.debug) && this._debugSymbolizer.symbolize.apply(this._debugSymbolizer, c);
	                    }
	                }
	            }
	        }
	    }, n.getSprite = function(t, e) {
	        if ("Point" !== this.geometry.type) return null;
	        if (this._spriting = !0, !this._sprite && this.symbolizers.length > 0) {
	            var n = new Ps;
	            this.symbolizers.forEach((function(e) {
	                var i = e.getFixedExtent(t);
	                n._combine(i);
	            }));
	            var i, r = n.getMin().multi(-1), o = e || (this.getMap() ? this.getMap().CanvasClass : null), s = qo.createCanvas(n.getWidth(), n.getHeight(), o);
	            this._renderPoints && (i = this._renderPoints);
	            for (var a = s.getContext("2d"), h = [ a, t ], l = this.symbolizers.length - 1; l >= 0; l--) {
	                var c = this.symbolizers[l].getDxDy();
	                this._renderPoints = {
	                    center: [ [ r.add(c) ] ]
	                }, this._prepareShadow(a, this.symbolizers[l].symbol), this.symbolizers[l].symbolize.apply(this.symbolizers[l], h);
	            }
	            i && (this._renderPoints = i), this._sprite = {
	                canvas: s,
	                offset: n.getCenter()
	            };
	        }
	        return this._spriting = !1, this._sprite;
	    }, n.isSpriting = function() {
	        return !!this._spriting;
	    }, n.hitTest = function(t, e) {
	        if ((!e || e < .5) && (e = .5), this._hitPoint = t.sub(e, e), !Wa) {
	            var n = this.getMap() ? this.getMap().CanvasClass : null;
	            Wa = qo.createCanvas(1, 1, n);
	        }
	        qo.setHitTesting(!0), Wa.width = Wa.height = 2 * e;
	        var i = Wa.getContext("2d");
	        try {
	            this.paint(null, i, this._hitPoint);
	        } catch (t) {
	            throw t;
	        } finally {
	            qo.setHitTesting(!1);
	        }
	        delete this._hitPoint;
	        for (var r = i.getImageData(0, 0, Wa.width, Wa.height).data, o = 3, s = r.length; o < s; o += 4) if (r[o] > 0) return !0;
	        return !1;
	    }, n.isHitTesting = function() {
	        return !!this._hitPoint;
	    }, n._prepareShadow = function(t, e) {
	        e.shadowBlur ? (t.shadowBlur = this.isHitTesting() ? 0 : e.shadowBlur, t.shadowColor = e.shadowColor || "#000", 
	        t.shadowOffsetX = e.shadowOffsetX || 0, t.shadowOffsetY = e.shadowOffsetY || 0) : t.shadowBlur && (t.shadowBlur = null, 
	        t.shadowColor = null, t.shadowOffsetX = null, t.shadowOffsetY = null);
	    }, n._eachSymbolizer = function(t, e) {
	        if (this.symbolizers) {
	            e || (e = this);
	            for (var n = this.symbolizers.length - 1; n >= 0; n--) t.apply(e, [ this.symbolizers[n] ]);
	        }
	    }, n.get2DExtent = function(t, e) {
	        this._verifyProjection();
	        var n = this.getMap();
	        t = t || this.getLayer()._getRenderer().resources;
	        var i = n.getZoom(), r = this._isDynamicSize();
	        if (this._extent2D && this._extent2D._zoom === i && this._fixedExtent || (this._extent2D && this._extent2D._zoom !== i && delete this._extent2D, 
	        this.symbolizers && (this._extent2D || (this._extent2D = this._computeExtent2D(new Ps), 
	        this._extent2D._zoom = i), this._fixedExtent || (this._fixedExtent = this._computeFixedExtent(t, new Ps)))), 
	        !this._extent2D) return r && delete this._fixedExtent, null;
	        var o = this._fixedExtent, s = o.xmin, a = o.ymin, h = o.xmax, l = o.ymax;
	        return r && delete this._fixedExtent, uh.set(s, -l, h, -a), e ? (e.set(this._extent2D.xmin, this._extent2D.ymin, this._extent2D.xmax, this._extent2D.ymax), 
	        e._add(uh), e) : this._extent2D.add(uh);
	    }, n._computeExtent2D = function(t) {
	        for (var e = this.symbolizers.length - 1; e >= 0; e--) {
	            t._combine(this.symbolizers[e].get2DExtent());
	        }
	        return t;
	    }, n._computeFixedExtent = function(t, e) {
	        for (var n = this.symbolizers.length - 1; n >= 0; n--) {
	            var i = this.symbolizers[n];
	            i.getFixedExtent && e._combine(i.getFixedExtent(t));
	        }
	        return e;
	    }, n._isDynamicSize = function() {
	        for (var t = this.symbolizers.length - 1; t >= 0; t--) {
	            if (this.symbolizers[t].isDynamicSize()) return !0;
	        }
	        return !1;
	    }, n._aboveCamera = function() {
	        var t = this.getMinAltitude(), e = this.getMap().getFrustumAltitude();
	        return t && e && e < t;
	    }, n.getFixedExtent = function() {
	        var t = this.getMap().getZoom();
	        return this._isDynamicSize() ? this._computeFixedExtent(null, new Ps) : (this._extent2D && this._extent2D._zoom === t || this.get2DExtent(null, uh), 
	        this._fixedExtent);
	    }, n.setZIndex = function(t) {
	        this._eachSymbolizer((function(e) {
	            e.setZIndex(t);
	        }));
	    }, n.show = function() {
	        this._painted ? (this.removeCache(), this._eachSymbolizer((function(t) {
	            t.show();
	        }))) : this.getLayer().isCanvasRender() || this.paint();
	    }, n.hide = function() {
	        this._eachSymbolizer((function(t) {
	            t.hide();
	        }));
	    }, n.repaint = function() {
	        this._altAtGL = this._getGeometryAltitude(), this.removeCache();
	        var t = this.getLayer();
	        if (t) {
	            var e = t.getRenderer();
	            e && e.setToRedraw() && e.setToRedraw();
	        }
	    }, n.refreshSymbol = function() {
	        this.removeCache(), this._removeSymbolizers(), this.symbolizers = this._createSymbolizers();
	    }, n.remove = function() {
	        this.removeCache(), this._removeSymbolizers();
	    }, n._removeSymbolizers = function() {
	        this._eachSymbolizer((function(t) {
	            delete t.painter, t.remove();
	        })), delete this.symbolizers;
	    }, n.removeCache = function() {
	        delete this._renderPoints, delete this._paintParams, delete this._sprite, delete this._extent2D, 
	        delete this._fixedExtent, delete this._cachedParams, delete this._unsimpledParams;
	    }, n.getAltitude = function() {
	        return this.geometry.getAltitude() !== this._propAlt && (this._altAtGL = this._getGeometryAltitude()), 
	        this._altAtGL ? this._altAtGL : 0;
	    }, n.getMinAltitude = function() {
	        return this.minAltitude ? this.minAltitude : 0;
	    }, n.getMaxAltitude = function() {
	        return this.maxAltitude ? this.maxAltitude : 0;
	    }, n._getGeometryAltitude = function() {
	        var t = this;
	        if (!this.getMap()) return 0;
	        var e = this.geometry.getAltitude();
	        if (this._propAlt = e, !e) return this.minAltitude = this.maxAltitude = 0, 0;
	        var n = this.geometry.getCenter();
	        return n ? Array.isArray(e) ? (this.minAltitude = Number.MAX_VALUE, this.maxAltitude = Number.MIN_VALUE, 
	        e.map((function(e) {
	            var i = t._meterToPoint(n, e);
	            return i < t.minAltitude && (t.minAltitude = i), i > t.maxAltitude && (t.maxAltitude = i), 
	            i;
	        }))) : (this.minAltitude = this.maxAltitude = this._meterToPoint(n, e), this.minAltitude) : 0;
	    }, n._meterToPoint = function(t, e) {
	        var n = this.getMap(), i = n.getGLRes();
	        return n.altitudeToPoint(e, i) * Bi$1(e);
	    }, n._verifyProjection = function() {
	        var t = this.geometry._getProjection() || gh;
	        this._projCode && this._projCode !== t.code && this.removeCache(), this._projCode = t.code;
	    }, n._beforePaint = function() {}, n._afterPaint = function() {}, e;
	}(ns);

	var vh = new Ps, yh = function(t) {
	    function e(e, n) {
	        var i;
	        return (i = t.call(this) || this).geometry = e, i.isMask = n, i;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n._eachPainter = function(t) {
	        for (var e, n = this.geometry.getGeometries(), i = 0, r = n.length; i < r && (!(e = this.isMask ? n[i]._getMaskPainter() : n[i]._getPainter()) || !e || !1 !== t.call(this, e)); i++) ;
	    }, n.paint = function(t) {
	        this.geometry && this._eachPainter((function(e) {
	            e.paint(t);
	        }));
	    }, n.get2DExtent = function(t, e) {
	        e && e.set(null, null, null, null);
	        var n = e || new Ps;
	        return this._eachPainter((function(e) {
	            n = n._combine(e.get2DExtent(t, vh));
	        })), n;
	    }, n.remove = function() {
	        var t = arguments;
	        this._eachPainter((function(e) {
	            e.remove.apply(e, t);
	        }));
	    }, n.setZIndex = function() {
	        var t = arguments;
	        this._eachPainter((function(e) {
	            e.setZIndex.apply(e, t);
	        }));
	    }, n.show = function() {
	        var t = arguments;
	        this._eachPainter((function(e) {
	            e.show.apply(e, t);
	        }));
	    }, n.hide = function() {
	        var t = arguments;
	        this._eachPainter((function(e) {
	            e.hide.apply(e, t);
	        }));
	    }, n.repaint = function() {
	        var t = arguments;
	        this._eachPainter((function(e) {
	            e.repaint.apply(e, t);
	        }));
	    }, n.refreshSymbol = function() {
	        var t = arguments;
	        this._eachPainter((function(e) {
	            e.refreshSymbol.apply(e, t);
	        }));
	    }, n.hasPoint = function() {
	        var t = !1;
	        return this._eachPainter((function(e) {
	            return !e.hasPoint() || (t = !0, !1);
	        })), t;
	    }, n.getMinAltitude = function() {
	        var t = !0, e = 0;
	        return this._eachPainter((function(n) {
	            var i = n.getMinAltitude();
	            (t || i < e) && (t = !1, e = i);
	        })), e;
	    }, n.getMaxAltitude = function() {
	        var t = 0;
	        return this._eachPainter((function(e) {
	            var n = e.getMaxAltitude();
	            n > t && (t = n);
	        })), t;
	    }, e;
	}(ns), xh = {
	    "EPSG:3857": {
	        projection: "EPSG:3857",
	        resolutions: function() {
	            for (var t = [], e = 12756274 * Math.PI, n = 0; n < 23; n++) t[n] = e / (256 * Math.pow(2, n));
	            return t;
	        }(),
	        fullExtent: {
	            top: 6378137 * Math.PI,
	            left: -6378137 * Math.PI,
	            bottom: -6378137 * Math.PI,
	            right: 6378137 * Math.PI
	        }
	    },
	    "EPSG:4326": {
	        projection: "EPSG:4326",
	        fullExtent: {
	            top: 90,
	            left: -180,
	            bottom: -90,
	            right: 180
	        },
	        resolutions: function() {
	            for (var t = [], e = 0; e < 23; e++) t[e] = 180 / (128 * Math.pow(2, e));
	            return t;
	        }()
	    },
	    BAIDU: {
	        projection: "baidu",
	        resolutions: function() {
	            for (var t = Math.pow(2, 18), e = [], n = 0; n < 23; n++) e[n] = t, t *= .5;
	            return e;
	        }(),
	        fullExtent: {
	            top: 33554432,
	            left: -33554432,
	            bottom: -33554432,
	            right: 33554432
	        }
	    },
	    IDENTITY: {
	        projection: "identity",
	        resolutions: function() {
	            for (var t = Math.pow(2, 8), e = [], n = 0; n < 23; n++) e[n] = t, t *= .5;
	            return e;
	        }(),
	        fullExtent: {
	            top: 2e5,
	            left: -2e5,
	            bottom: -2e5,
	            right: 2e5
	        }
	    },
	    "PRESET-VT-3857": {
	        projection: "EPSG:3857",
	        resolutions: function() {
	            for (var t = [], e = 6378137 * Math.PI, n = 0; n < 23; n++) t[n] = e / (256 * Math.pow(2, n));
	            return t;
	        }(),
	        fullExtent: {
	            top: 6378137 * Math.PI,
	            left: -6378137 * Math.PI,
	            bottom: -6378137 * Math.PI,
	            right: 6378137 * Math.PI
	        }
	    }
	};

	xh["EPSG:4490"] = xh["EPSG:4326"];

	var bh = function() {
	    function t(t) {
	        void 0 === t && (t = {}), this.options = t, this._initSpatialRef();
	    }
	    t.getPreset = function(t) {
	        return xh[t.toUpperCase()];
	    }, t.getAllPresets = function() {
	        return Object.keys(xh);
	    }, t.getProjectionInstance = function(t) {
	        if (!t) return null;
	        if (Fn(t)) return t.locate || (t = kn({}, t), kn(t, Hs.getInstance("identity" === t.measure ? "IDENTITY" : "EPSG:4326"))), 
	        t;
	        for (var e in t = (t + "").toLowerCase(), Zs) if (Bn(Zs, e)) {
	            var n = Zs[e].code;
	            if (n && n.toLowerCase() === t) return Zs[e];
	        }
	        return null;
	    }, t.equals = function(t, e) {
	        if (jn(t) || jn(e)) return t === e;
	        if (!t && !e) return !0;
	        if (!t || !e) return !1;
	        if (t.projection !== e.projection) return !1;
	        var n = t.fullExtent, i = e.fullExtent;
	        if (n && !i || !n && i) return !1;
	        if (n && i && (n.top !== i.top || n.bottom !== i.bottom || n.left !== i.left || n.right !== i.right)) return !1;
	        var r = t.resolutions, o = e.resolutions;
	        if (r && o) {
	            if (r.length !== o.length) return !1;
	            for (var s = 0; s < r.length; s++) if (r[s] !== o[s]) return !1;
	        } else if (r || o) return !1;
	        return !0;
	    };
	    var e = t.prototype;
	    return e._initSpatialRef = function() {
	        var e = this.options.projection;
	        if (!(e = e ? t.getProjectionInstance(e) : Ws)) throw new Error("must provide a valid projection in map's spatial reference.");
	        (e = kn({}, Es, e)).measureLength || kn(e, Hs.DEFAULT), this._projection = e;
	        var n, i = this.options.resolutions;
	        if (!i && (e.code && (n = xh[e.code.toUpperCase()]) && (i = n.resolutions, this.isEPSG = "IDENTITY" !== e.code), 
	        !i)) throw new Error("must provide valid resolutions in map's spatial reference.");
	        if (this._resolutions = i, this._pyramid = !0, this._pyramid) for (var r = 0; r < i.length; r++) if (i[r] && i[r - 1] && i[r - 1] / i[r] != 2) {
	            this._pyramid = !1;
	            break;
	        }
	        var o = this.options.fullExtent;
	        if (!o && (e.code && (n = xh[e.code.toUpperCase()]) && (o = n.fullExtent), !o)) throw new Error("must provide a valid fullExtent in map's spatial reference.");
	        if (Dn(o.left) ? (this._fullExtent = new Ts(o), o.left = o.xmin, o.right = o.xmax, 
	        o.top = o.ymax, o.bottom = o.ymin) : this._fullExtent = new Ts(new us(o.left, o.top), new us(o.right, o.bottom)), 
	        Dn(o.top) || Dn(o.bottom) || Dn(o.left) || Dn(o.right)) throw new Error("must provide valid top/bottom/left/right in fullExtent.");
	        kn(this._fullExtent, o), this._projection.fullExtent = o, this._transformation = new As([ o.right >= o.left ? 1 : -1, o.top >= o.bottom ? -1 : 1, 0, 0 ]);
	    }, e.getResolutions = function() {
	        return this._resolutions || [];
	    }, e.getResolution = function(t) {
	        var e = 0 | t;
	        e < 0 ? e = 0 : e > this._resolutions.length - 1 && (e = this._resolutions.length - 1);
	        var n = this._resolutions[e];
	        return e !== t && t > 0 && e < this._resolutions.length - 1 ? n + (this._resolutions[e + 1] - n) * (t - e) : n;
	    }, e.getProjection = function() {
	        return this._projection;
	    }, e.getFullExtent = function() {
	        return this._fullExtent;
	    }, e.getTransformation = function() {
	        return this._transformation;
	    }, e.getMinZoom = function() {
	        for (var t = 0; t < this._resolutions.length; t++) if (!Dn(this._resolutions[t])) return t;
	        return 0;
	    }, e.getMaxZoom = function() {
	        for (var t = this._resolutions.length - 1; t >= 0; t--) if (!Dn(this._resolutions[t])) return t;
	        return this._resolutions.length - 1;
	    }, e.getZoomDirection = function() {
	        return Bi$1(this._resolutions[this.getMinZoom()] - this._resolutions[this.getMaxZoom()]);
	    }, e.toJSON = function() {
	        return this.json || (this.json = {
	            resolutions: this._resolutions,
	            fullExtent: {
	                top: this._fullExtent.top,
	                left: this._fullExtent.left,
	                bottom: this._fullExtent.bottom,
	                right: this._fullExtent.right
	            },
	            projection: this._projection.code
	        }), this.json;
	    }, e.isPyramid = function() {
	        return this._pyramid;
	    }, t;
	}(), wh = new Oi$1(0, 0), Ch = new Ps, Mh = function(t) {
	    function e(e) {
	        var n, i = kn({}, e), r = i.symbol, o = i.properties, s = i.id;
	        return delete i.symbol, delete i.id, delete i.properties, n = t.call(this, i) || this, 
	        r ? n.setSymbol(r) : n._genSizeSymbol(), o && n.setProperties(o), Dn(s) || n.setId(s), 
	        n;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getFirstCoordinate = function() {
	        if ("GeometryCollection" === this.type) {
	            var t = this.getGeometries();
	            return t.length ? t[0].getFirstCoordinate() : null;
	        }
	        var e = this.getCoordinates();
	        if (!Array.isArray(e)) return e;
	        do {
	            e = e[0];
	        } while (Array.isArray(e) && e.length > 0);
	        return e;
	    }, n.getLastCoordinate = function() {
	        if ("GeometryCollection" === this.type) {
	            var t = this.getGeometries();
	            return t.length ? t[t.length - 1].getLastCoordinate() : null;
	        }
	        var e = this.getCoordinates();
	        if (!Array.isArray(e)) return e;
	        do {
	            e = e[e.length - 1];
	        } while (Array.isArray(e) && e.length > 0);
	        return e;
	    }, n.addTo = function(t, e) {
	        return t.addGeometry(this, e), this;
	    }, n.getLayer = function() {
	        return this._layer ? this._layer : null;
	    }, n.getMap = function() {
	        return this._layer ? this._layer.getMap() : null;
	    }, n.getId = function() {
	        return this._id;
	    }, n.setId = function(t) {
	        var e = this.getId();
	        return this._id = t, this._fireEvent("idchange", {
	            old: e,
	            new: t
	        }), this;
	    }, n.getProperties = function() {
	        return this.properties ? this.properties : this._getParent() ? this._getParent().getProperties() : null;
	    }, n.setProperties = function(t) {
	        var e = this.properties;
	        return this.properties = Fn(t) ? kn({}, t) : t, this._repaint(), this._fireEvent("propertieschange", {
	            old: e,
	            new: t
	        }), this;
	    }, n.getType = function() {
	        return this.type;
	    }, n.getSymbol = function() {
	        var t = this._symbol;
	        return t ? Array.isArray(t) ? ho(t) : kn({}, t) : null;
	    }, n.setSymbol = function(t) {
	        return this._symbolUpdated = t, this._symbol = this._prepareSymbol(t), this.onSymbolChanged(), 
	        delete this._compiledSymbol, delete this._symbolHash, this;
	    }, n.getSymbolHash = function() {
	        return this._symbolHash || (this._symbolHash = so(this._symbolUpdated)), this._symbolHash;
	    }, n.updateSymbol = function(t) {
	        if (!t) return this;
	        var e = this._getSymbol();
	        if (Array.isArray(e)) {
	            if (!Array.isArray(t)) throw new Error("Parameter of updateSymbol is not an array.");
	            for (var n = 0; n < t.length; n++) Aa(t[n]) && delete this._textDesc, e[n] && t[n] && (e[n] = ho(e[n], t[n]));
	        } else {
	            if (Array.isArray(t)) throw new Error("Geometry's symbol is not an array to update.");
	            Aa(e) && delete this._textDesc, e = ho(e || this._getInternalSymbol(), t);
	        }
	        return this._eventSymbolProperties = t, delete this._compiledSymbol, this.setSymbol(e);
	    }, n.getTextContent = function() {
	        var t = this._getInternalSymbol();
	        if (Array.isArray(t)) {
	            for (var e = [], n = !1, i = 0; i < t.length; i++) e[i] = Qr(t[i] && t[i].textName, this.getProperties()), 
	            Dn(e[i]) || (n = !0);
	            return n ? e : null;
	        }
	        return Qr(t && t.textName, this.getProperties());
	    }, n.getTextDesc = function() {
	        if (!this._textDesc) {
	            var t = this.getTextContent(), e = this._sizeSymbol, n = Array.isArray(t);
	            this._textDesc = Array.isArray(e) ? e.map((function(e, i) {
	                return $r(n ? t[i] : "", e);
	            })) : $r(t, e);
	        }
	        return this._textDesc;
	    }, n.getCenter = function() {
	        return this._computeCenter(this._getMeasurer());
	    }, n.getExtent = function() {
	        var t = this._getPrjExtent(), e = this._getProjection();
	        if (t && e) {
	            var n = e.unproject(new us(t.xmin, t.ymin)), i = e.unproject(new us(t.xmax, t.ymax));
	            return new Ts(n, i, e);
	        }
	        return this._computeExtent(this._getMeasurer());
	    }, n.getContainerExtent = function(t) {
	        var e = this.get2DExtent();
	        if (!e || !e.isValid()) return null;
	        var n = this.getMap(), i = n.getGLRes(), r = this.getMinAltitude(), o = n.altitudeToPoint(r, i) * Bi$1(r), s = e.convertTo((function(t) {
	            return n._pointAtResToContainerPoint(t, i, o, wh);
	        }), t), a = this.getMaxAltitude();
	        if (a !== r) {
	            a = n.altitudeToPoint(a, i) * Bi$1(a);
	            var h = e.convertTo((function(t) {
	                return n._pointAtResToContainerPoint(t, i, a, wh);
	            }), Ch);
	            s._combine(h);
	        }
	        var l = this.getLayer();
	        if (l && "LineString" === this.type && a && l.options.drawAltitude) {
	            var c = e.convertTo((function(t) {
	                return n._pointAtResToContainerPoint(t, i, 0, wh);
	            }), Ch);
	            s._combine(c);
	        }
	        return s && s._add(this._getFixedExtent()), this.options.smoothness && s._expand(.15 * s.getWidth()), 
	        s;
	    }, n._getFixedExtent = function() {
	        this._fixedExtent || (this._fixedExtent = new Ps);
	        var t = this._sizeSymbol, e = (t && t.lineWidth || 1) / 2;
	        return this._fixedExtent.set(-e, -e, e, e), this._fixedExtent._add([ t && t.lineDx || 0, 0 ]), 
	        this._fixedExtent._add([ 0, t && t.lineDy || 0 ]), this._fixedExtent;
	    }, n.get2DExtent = function() {
	        var t = this.getMap();
	        if (!t) return null;
	        if (this._extent2d) return this._extent2d;
	        var e = this._getPrjExtent();
	        if (!e || !e.isValid()) return null;
	        var n = e.getMin(), i = e.getMax(), r = t.getGLRes();
	        return t._prjToPointAtRes(n, r, n), t._prjToPointAtRes(i, r, i), this._extent2d = new Ps(n, i), 
	        this._extent2d.z = t.getZoom(), this._extent2d;
	    }, n.getSize = function() {
	        var t = this.getContainerExtent();
	        return t ? t.getSize() : null;
	    }, n.containsPoint = function(t, e) {
	        if (!this.getMap()) throw new Error('The geometry is required to be added on a map to perform "containsPoint".');
	        return t instanceof us && (t = this.getMap().coordToContainerPoint(t)), this._containsPoint(t, e);
	    }, n._containsPoint = function(t, e) {
	        var n = this._getPainter();
	        return !!n && (e = e || 0, this._hitTestTolerance && (e += this._hitTestTolerance()), 
	        n.hitTest(t, e));
	    }, n.show = function() {
	        if (this.options.visible = !0, this.getMap()) {
	            var t = this._getPainter();
	            t && t.show(), this._fireEvent("show");
	        }
	        return this;
	    }, n.hide = function() {
	        if (this.options.visible = !1, this.getMap()) {
	            this.onHide();
	            var t = this._getPainter();
	            t && t.hide(), this._fireEvent("hide");
	        }
	        return this;
	    }, n.isVisible = function() {
	        if (!this.options.visible) return !1;
	        var t = this._getInternalSymbol();
	        if (!t) return !0;
	        if (Array.isArray(t)) {
	            if (!t.length) return !0;
	            for (var e = 0, n = t.length; e < n; e++) if (Dn(t[e].opacity) || t[e].opacity > 0) return !0;
	            return !1;
	        }
	        return Dn(t.opacity) || Fn(t.opacity) || Ln(t.opacity) && t.opacity > 0;
	    }, n.getZIndex = function() {
	        return this.options.zIndex || 0;
	    }, n.setZIndex = function(t) {
	        var e = this.options.zIndex;
	        return this.options.zIndex = t, this._fireEvent("zindexchange", {
	            old: e,
	            new: t
	        }), this;
	    }, n.setZIndexSilently = function(t) {
	        return this.options.zIndex = t, this;
	    }, n.bringToFront = function() {
	        var t = this.getLayer();
	        if (!t || !t.getGeoMaxZIndex) return this;
	        var e = t.getGeoMaxZIndex();
	        return this.setZIndex(e + 1), this;
	    }, n.bringToBack = function() {
	        var t = this.getLayer();
	        if (!t || !t.getGeoMinZIndex) return this;
	        var e = t.getGeoMinZIndex();
	        return this.setZIndex(e - 1), this;
	    }, n.translate = function(t, e) {
	        if (Dn(t)) return this;
	        var n = new us(t, e);
	        if (0 === n.x && 0 === n.y) return this;
	        var i = this.getCoordinates();
	        if (this._silence = !0, i) if (Array.isArray(i)) {
	            var r = Hi$1(i, (function(t) {
	                return t.add(n);
	            }));
	            this.setCoordinates(r);
	        } else this.setCoordinates(i.add(n));
	        return this._silence = !1, this._fireEvent("positionchange"), this;
	    }, n.flash = function(t, e, n, i) {
	        return or.call(this, t, e, n, i);
	    }, n.copy = function() {
	        var t = this.toJSON(), n = e.fromJSON(t);
	        return n.options.visible = !0, n;
	    }, n.remove = function() {
	        return this.getLayer() ? (this._fireEvent("removestart"), this._unbind(), this._fireEvent("removeend"), 
	        this._fireEvent("remove"), this) : this;
	    }, n.toGeoJSONGeometry = function() {
	        return this._exportGeoJSONGeometry();
	    }, n.toGeoJSON = function(t) {
	        t || (t = {});
	        var e = {
	            type: "Feature",
	            geometry: null
	        };
	        if (Dn(t.geometry) || t.geometry) {
	            var n = this._exportGeoJSONGeometry();
	            e.geometry = n;
	        }
	        var i, r = this.getId();
	        return Dn(r) || (e.id = r), (Dn(t.properties) || t.properties) && (i = this._exportProperties()), 
	        e.properties = i, e;
	    }, n.toJSON = function(t) {
	        t || (t = {});
	        var e = this._toJSON(t);
	        return kn(e, this._exportGraphicOptions(t)), e;
	    }, n.getLength = function() {
	        return this._computeGeodesicLength(this._getMeasurer());
	    }, n.getArea = function() {
	        return this._computeGeodesicArea(this._getMeasurer());
	    }, n.rotate = function(t, e) {
	        if ("GeometryCollection" === this.type) return this.getGeometries().forEach((function(n) {
	            return n.rotate(t, e);
	        })), this;
	        e = e ? new us(e) : this.getCenter();
	        var n = this._getMeasurer(), i = this.getCoordinates();
	        if (!Array.isArray(i)) {
	            if (e.x !== i.x || e.y !== i.y) {
	                var r = n._rotate(i, e, t);
	                this.setCoordinates(r);
	            }
	            return this;
	        }
	        return Hi$1(i, (function(i) {
	            return n._rotate(i, e, t);
	        })), this.setCoordinates(i), this;
	    }, n._getConnectPoints = function() {
	        return [ this.getCenter() ];
	    }, n._initOptions = function(t) {
	        var e = kn({}, t), n = e.symbol, i = e.properties, r = e.id;
	        delete e.symbol, delete e.id, delete e.properties, this.setOptions(e), n && this.setSymbol(n), 
	        i && this.setProperties(i), Dn(r) || this.setId(r);
	    }, n._bindLayer = function(t) {
	        if (this.getLayer()) throw new Error("Geometry cannot be added to two or more layers at the same time.");
	        this._layer = t, this._clearCache(), this._bindInfoWindow(), this._bindMenu();
	    }, n._prepareSymbol = function(t) {
	        if (Array.isArray(t)) {
	            for (var e = [], n = 0; n < t.length; n++) e.push(Nr(this._checkAndCopySymbol(t[n])));
	            return e;
	        }
	        return t ? Nr(t = this._checkAndCopySymbol(t)) : null;
	    }, n._checkAndCopySymbol = function(t) {
	        var e = {};
	        for (var n in t) e[n] = On[n] && jn(t[n]) ? +t[n] : t[n];
	        return e;
	    }, n._getSymbol = function() {
	        return this._symbol;
	    }, n._setExternSymbol = function(t) {
	        return this._eventSymbolProperties = t, this._symbol || delete this._textDesc, this._externSymbol = this._prepareSymbol(t), 
	        this.onSymbolChanged(), this;
	    }, n._getInternalSymbol = function() {
	        return this._symbol ? this._symbol : this._externSymbol ? this._externSymbol : this.options.symbol ? this.options.symbol : null;
	    }, n._getPrjExtent = function() {
	        var t = this._getProjection();
	        return this._verifyProjection(), !this._extent && t && (this._extent = this._computePrjExtent(t)), 
	        this._extent;
	    }, n._unbind = function() {
	        var t = this.getLayer();
	        t && (this._animPlayer && this._animPlayer.finish(), this._unbindMenu(), this._unbindInfoWindow(), 
	        this.isEditing() && this.endEdit(), this._removePainter(), this.onRemove && this.onRemove(), 
	        t.onRemoveGeometry && t.onRemoveGeometry(this), delete this._layer, delete this._internalId, 
	        delete this._extent);
	    }, n._getInternalId = function() {
	        return this._internalId;
	    }, n._setInternalId = function(t) {
	        this._internalId = t;
	    }, n._getMeasurer = function() {
	        return this._getProjection() ? this._getProjection() : bh.getProjectionInstance(this.options.defaultProjection);
	    }, n._getProjection = function() {
	        var t = this.getMap();
	        return t ? t.getProjection() : null;
	    }, n._verifyProjection = function() {
	        var t = this._getProjection();
	        this._projCode && t && this._projCode !== t.code && this._clearProjection(), this._projCode = t ? t.code : this._projCode;
	    }, n._getExternalResources = function() {
	        return Hr(this._getInternalSymbol());
	    }, n._getPainter = function() {
	        var t = this.getLayer();
	        if (!this._painter && t) if (-1 !== Sn.indexOf(this.type)) {
	            if (t.constructor.getCollectionPainterClass) {
	                var e = t.constructor.getCollectionPainterClass();
	                e && (this._painter = new e(this));
	            }
	        } else if (t.constructor.getPainterClass) {
	            var n = t.constructor.getPainterClass();
	            n && (this._painter = new n(this));
	        }
	        return this._painter;
	    }, n._getMaskPainter = function() {
	        return this._maskPainter || (this._maskPainter = this.getGeometries && this.getGeometries() ? new yh(this, !0) : new _h(this)), 
	        this._maskPainter;
	    }, n._removePainter = function() {
	        this._painter && this._painter.remove(), delete this._painter;
	    }, n._paint = function(t) {
	        if (this._painter) {
	            if (this._dirtyCoords) {
	                delete this._dirtyCoords;
	                var e = this._getProjection();
	                e && (this._pcenter = e.project(this._coordinates), this._clearCache());
	            }
	            this._painter.paint(t);
	        }
	    }, n._clearCache = function() {
	        delete this._extent, delete this._extent2d;
	    }, n._clearProjection = function() {
	        delete this._extent, delete this._extent2d;
	    }, n._repaint = function() {
	        this._painter && this._painter.repaint();
	    }, n.onHide = function() {
	        this.closeMenu(), this.closeInfoWindow();
	    }, n.onShapeChanged = function() {
	        this._clearCache(), this._repaint(), this._fireEvent("shapechange");
	    }, n.onPositionChanged = function() {
	        this._clearCache(), this._repaint(), this._fireEvent("positionchange");
	    }, n.onSymbolChanged = function() {
	        this._painter && this._painter.refreshSymbol();
	        var t = {};
	        this._eventSymbolProperties ? (t.properties = kn({}, this._eventSymbolProperties), 
	        delete this._eventSymbolProperties) : delete this._textDesc, this._genSizeSymbol(), 
	        this._fireEvent("symbolchange", t);
	    }, n._genSizeSymbol = function() {
	        var t = this._getInternalSymbol();
	        if (t) if (Array.isArray(t)) {
	            this._sizeSymbol = [];
	            for (var e = !1, n = 0; n < t.length; n++) {
	                var i = this._sizeSymbol[n] = this._getSizeSymbol(t[n]);
	                !e && i && i._dynamic && (e = !0);
	            }
	            this._sizeSymbol._dynamic = e;
	        } else this._sizeSymbol = this._getSizeSymbol(t); else delete this._sizeSymbol;
	    }, n._getSizeSymbol = function(t) {
	        var e = zr({
	            lineWidth: t.lineWidth,
	            lineDx: t.lineDx,
	            lineDy: t.lineDy
	        }, this);
	        return (_r(t.lineWidth) || _r(t.lineDx) || _r(t.lineDy)) && (e._dynamic = !0), e;
	    }, n._getCompiledSymbol = function() {
	        return this._compiledSymbol || (this._compiledSymbol = zr(this._getInternalSymbol(), this)), 
	        this._compiledSymbol;
	    }, n.onConfig = function(t) {
	        var e;
	        t.properties && (e = t.properties, delete t.properties);
	        var n = !1;
	        for (var i in t) if (t.hasOwnProperty(i)) {
	            var r = i.slice(0, 5);
	            if ("arrow" === r || "smoot" === r) {
	                n = !0;
	                break;
	            }
	        }
	        e ? (this.setProperties(e), this._repaint()) : n && this._repaint();
	    }, n._setParent = function(t) {
	        t && (this._parent = t);
	    }, n._getParent = function() {
	        return this._parent;
	    }, n._fireEvent = function(t, e) {
	        this._silence || (this.getLayer() && this.getLayer()._onGeometryEvent && (e || (e = {}), 
	        e.type = t, e.target = this, this.getLayer()._onGeometryEvent(e)), this.fire(t, e));
	    }, n._toJSON = function(t) {
	        return {
	            feature: this.toGeoJSON(t)
	        };
	    }, n._exportGraphicOptions = function(t) {
	        var e = {};
	        return (Dn(t.options) || t.options) && (e.options = this.config()), (Dn(t.symbol) || t.symbol) && (e.symbol = this.getSymbol()), 
	        (Dn(t.infoWindow) || t.infoWindow) && this._infoWinOptions && (e.infoWindow = this._infoWinOptions), 
	        e;
	    }, n._exportGeoJSONGeometry = function() {
	        var t = this.getCoordinates(), e = us.toNumberArrays(t);
	        return {
	            type: this.getType(),
	            coordinates: e
	        };
	    }, n._exportProperties = function() {
	        var t = null, e = this.getProperties();
	        return Dn(e) || (t = Fn(e) ? kn({}, e) : e), t;
	    }, n._hitTestTolerance = function() {
	        var t = this.getLayer();
	        return t && t.options.geometryEventTolerance || 0;
	    }, n.getAltitude = function() {
	        var t = this.getLayer();
	        if (!t) return 0;
	        var e = t.options, n = this.getProperties(), i = e.enableAltitude && n ? n[e.altitudeProperty] : 0, r = t.getAltitude ? t.getAltitude() : 0;
	        return Array.isArray(i) ? i.map((function(t) {
	            return t + r;
	        })) : i + r;
	    }, n._genMinMaxAlt = function() {
	        var t = this, e = this.getAltitude();
	        Array.isArray(e) ? (this._minAlt = Number.MAX_VALUE, this._maxAlt = Number.MIN_VALUE, 
	        e.forEach((function(e) {
	            var n = e;
	            n < t._minAlt && (t._minAlt = n), n > t._maxAlt && (t._maxAlt = n);
	        }))) : this._minAlt = this._maxAlt = e;
	    }, n.getMinAltitude = function() {
	        return void 0 === this._minAlt && this._genMinMaxAlt(), this._minAlt ? this._minAlt : 0;
	    }, n.getMaxAltitude = function() {
	        return void 0 === this._maxAlt && this._genMinMaxAlt(), this._maxAlt ? this._maxAlt : 0;
	    }, e;
	}(rs(ts(as(ns))));

	Mh.mergeOptions({
	    id: null,
	    visible: !0,
	    interactive: !0,
	    editable: !0,
	    cursor: null,
	    antiMeridian: !1,
	    defaultProjection: "EPSG:4326"
	});

	var Th = {
	    attribution: null,
	    minZoom: null,
	    maxZoom: null,
	    visible: !0,
	    opacity: 1,
	    globalCompositeOperation: null,
	    renderer: "canvas",
	    debugOutline: "#0f0",
	    cssFilter: null,
	    forceRenderOnMoving: !1,
	    forceRenderOnZooming: !1,
	    forceRenderOnRotating: !1,
	    collision: !1,
	    collisionScope: "layer",
	    hitDetect: !Mi$1.mobile
	}, Sh = function(t) {
	    function e(e, n) {
	        var i, r;
	        return n && (r = n.canvas, delete n.canvas), (i = t.call(this, n) || this)._canvas = r, 
	        i.setId(e), n && (i.setZIndex(n.zIndex), n.mask && i.setMask(Mh.fromJSON(n.mask))), 
	        i;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.load = function() {
	        if (!this.getMap()) return this;
	        if (this.onLoad()) {
	            this._initRenderer();
	            var t = this.getZIndex();
	            Dn(t) || (this._renderer.setZIndex(t), this.isCanvasRender() || this._renderer.render()), 
	            this.onLoadEnd();
	        }
	        return this;
	    }, n.getId = function() {
	        return this._id;
	    }, n.setId = function(t) {
	        var e = this._id;
	        return Dn(t) || (t += ""), this._id = t, this.fire("idchange", {
	            old: e,
	            new: t
	        }), this;
	    }, n.addTo = function(t) {
	        return t.addLayer(this), this;
	    }, n.setZIndex = function(t) {
	        return this._zIndex = t, Dn(t) ? delete this.options.zIndex : this.options.zIndex = t, 
	        this.map && this.map._sortLayersByZIndex(), this._renderer && this._renderer.setZIndex(t), 
	        this;
	    }, n.getZIndex = function() {
	        return this._zIndex || 0;
	    }, n.getMinZoom = function() {
	        var t = this.getMap(), e = this.options.minZoom;
	        return t ? Math.max(t.getMinZoom(), e || 0) : e;
	    }, n.getMaxZoom = function() {
	        var t = this.getMap(), e = this.options.maxZoom;
	        return t ? Math.min(t.getMaxZoom(), Dn(e) ? 1 / 0 : e) : e;
	    }, n.getOpacity = function() {
	        return this.options.opacity;
	    }, n.setOpacity = function(t) {
	        return this.config("opacity", t), this;
	    }, n.isCanvasRender = function() {
	        var t = this._getRenderer();
	        return t && t instanceof ha;
	    }, n.getMap = function() {
	        return this.map ? this.map : null;
	    }, n.getProjection = function() {
	        var t = this.getMap();
	        return t ? t.getProjection() : null;
	    }, n.bringToFront = function() {
	        var t = this._getLayerList();
	        if (!t.length) return this;
	        var e = t[t.length - 1];
	        if (1 === t.length || e === this) return this;
	        var n = e.getZIndex();
	        return this.setZIndex(n + 1), this;
	    }, n.bringToBack = function() {
	        var t = this._getLayerList();
	        if (!t.length) return this;
	        var e = t[0];
	        if (1 === t.length || e === this) return this;
	        var n = e.getZIndex();
	        return this.setZIndex(n - 1), this;
	    }, n.show = function() {
	        var t = this;
	        if (!this.options.visible) {
	            this.options.visible = !0;
	            var e = this.getRenderer();
	            e && e.show();
	            var n = this.getMap();
	            e && n ? n.once("renderend", (function() {
	                t.fire("show");
	            })) : this.fire("show");
	        }
	        return this;
	    }, n.hide = function() {
	        var t = this;
	        if (this.options.visible) {
	            this.options.visible = !1;
	            var e = this.getRenderer();
	            e && e.hide();
	            var n = this.getMap();
	            e && n ? n.once("renderend", (function() {
	                t.fire("hide");
	            })) : this.fire("hide");
	        }
	        return this;
	    }, n.isVisible = function() {
	        if (Ln(this.options.opacity) && this.options.opacity <= 0) return !1;
	        var t = this.getMap();
	        if (t) {
	            var e = t.getZoom();
	            if (!Dn(this.options.maxZoom) && this.options.maxZoom < e || !Dn(this.options.minZoom) && this.options.minZoom > e) return !1;
	        }
	        return Dn(this.options.visible) && (this.options.visible = !0), this.options.visible;
	    }, n.remove = function() {
	        return this.map && this.map.removeLayer(this), this;
	    }, n.getMask = function() {
	        return this._mask;
	    }, n.setMask = function(t) {
	        if (!("Point" === t.type && t._isVectorMarker() || "Polygon" === t.type || "MultiPolygon" === t.type)) throw new Error("Mask for a layer must be a marker with vector marker symbol or a Polygon(MultiPolygon).");
	        if (t._bindLayer(this), "Point" === t.type ? t.updateSymbol({
	            markerLineColor: "rgba(0, 0, 0, 0)",
	            markerFillOpacity: 0
	        }) : t.setSymbol({
	            lineColor: "rgba(0, 0, 0, 0)",
	            polygonOpacity: 0
	        }), this._mask = t, this.options.mask = t.toJSON(), !this.getMap() || this.getMap().isZooming()) return this;
	        var e = this._getRenderer();
	        return e && e.setToRedraw && this._getRenderer().setToRedraw(), this;
	    }, n.removeMask = function() {
	        if (delete this._mask, delete this.options.mask, !this.getMap() || this.getMap().isZooming()) return this;
	        var t = this._getRenderer();
	        return t && t.setToRedraw && this._getRenderer().setToRedraw(), this;
	    }, n.onLoad = function() {
	        return !0;
	    }, n.onLoadEnd = function() {}, n.isLoaded = function() {
	        return !!this._loaded;
	    }, n.getCollisionIndex = function() {
	        if ("layer" === this.options.collisionScope) return this._collisionIndex || (this._collisionIndex = new ss), 
	        this._collisionIndex;
	        var t = this.getMap();
	        return t ? t.getCollisionIndex() : null;
	    }, n.clearCollisionIndex = function() {
	        return "layer" === this.options.collisionScope && this._collisionIndex && this._collisionIndex.clear(), 
	        this;
	    }, n.getRenderer = function() {
	        return this._getRenderer();
	    }, n.onConfig = function(t) {
	        if (Ln(t.opacity) || t.cssFilter) {
	            var e = this.getRenderer();
	            e && e.setToRedraw();
	        }
	    }, n.onAdd = function() {}, n.onRendererCreate = function() {}, n.onCanvasCreate = function() {}, 
	    n.onRemove = function() {}, n._bindMap = function(t, e) {
	        t && (this.map = t, Dn(e) || this.setZIndex(e), this._switchEvents("on", this), 
	        this.onAdd(), this.fire("add"));
	    }, n._initRenderer = function() {
	        var t = this.options.renderer;
	        if (this.constructor.getRendererClass) {
	            var e = this.constructor.getRendererClass(t);
	            if (!e) throw new Error("Invalid renderer for Layer(" + this.getId() + "):" + t);
	            this._renderer = new e(this), this._renderer.layer = this, this._renderer.setZIndex(this.getZIndex()), 
	            this._switchEvents("on", this._renderer), this._renderer.onAdd && this._renderer.onAdd(), 
	            this.onRendererCreate(), this.fire("renderercreate", {
	                renderer: this._renderer
	            });
	        }
	    }, n._doRemove = function() {
	        this._loaded = !1, this._switchEvents("off", this), this.onRemove(), this._renderer && (this._switchEvents("off", this._renderer), 
	        this._renderer.remove(), delete this._renderer), delete this.map, delete this._collisionIndex;
	    }, n._switchEvents = function(t, e) {
	        e && e.getEvents && this.getMap() && this.getMap()[t](e.getEvents(), e);
	    }, n._getRenderer = function() {
	        return this._renderer;
	    }, n._getLayerList = function() {
	        return this.map ? this.map._layers : [];
	    }, n._getMask2DExtent = function() {
	        if (!this._mask || !this.getMap()) return null;
	        var t = this._mask._getMaskPainter();
	        return t ? t.get2DExtent() : null;
	    }, e;
	}(rs(ts(Xs(ns))));

	Sh.mergeOptions(Th);

	var Ph = Sh.prototype.fire;

	Sh.prototype.fire = function(t, e) {
	    return "layerload" === t && (this._loaded = !0), this.map && (e || (e = {}), e.type = t, 
	    e.target = this, this.map._onLayerEvent(e)), Ph.apply(this, arguments);
	};

	var Ah, Eh, Oh, Rh, Ih, kh, Dh, Lh = new us(0, 0), zh = {
	    maxVisualPitch: 70,
	    maxPitch: 80,
	    centerCross: !1,
	    zoomInCenter: !1,
	    zoomOrigin: null,
	    zoomAnimation: !Wn,
	    zoomAnimationDuration: 330,
	    panAnimation: !Wn,
	    panAnimationDuration: 600,
	    rotateAnimation: !Wn,
	    zoomable: !0,
	    enableInfoWindow: !0,
	    hitDetect: !Mi$1.mobile,
	    hitDetectLimit: 5,
	    fpsOnInteracting: 25,
	    layerCanvasLimitOnInteracting: -1,
	    maxZoom: null,
	    minZoom: null,
	    maxExtent: null,
	    fixCenterOnResize: !0,
	    checkSize: !0,
	    checkSizeInterval: 1e3,
	    renderer: "canvas",
	    cascadePitches: [ 10, 60 ],
	    renderable: !0,
	    clickTimeThreshold: 280,
	    stopRenderOnOffscreen: !0
	}, Fh = function(t) {
	    function e(n, i) {
	        var r;
	        if (!i) throw new Error("Invalid options when creating map.");
	        if (!i.center) throw new Error("Invalid center when creating map.");
	        var o = kn({}, i), s = o.zoom;
	        delete o.zoom;
	        var a = new us(o.center);
	        delete o.center;
	        var h = o.baseLayer;
	        delete o.baseLayer;
	        var l = o.layers;
	        return delete o.layers, (r = t.call(this, o) || this).VERSION = e.VERSION, Object.defineProperty(Si$1(Si$1(r)), "id", {
	            value: Di$1(),
	            writable: !1
	        }), r._loaded = !1, r._initContainer(n), r._panels = {}, r._baseLayer = null, r._layers = [], 
	        r._zoomLevel = s, r._center = a, r.setSpatialReference(o.spatialReference || o.view), 
	        r._mapViewPoint = new Oi$1(0, 0), r._initRenderer(), r._updateMapSize(r._getContainerDomSize()), 
	        h && r.setBaseLayer(h), l && r.addLayer(l), r.setMaxExtent(o.maxExtent), r._Load(), 
	        r;
	    }
	    Ti$1(e, t), e.addOnLoadHook = function(t) {
	        var e = Array.prototype.slice.call(arguments, 1), n = "function" == typeof t ? t : function() {
	            this[t].apply(this, e);
	        };
	        return this.prototype._onLoadHooks = this.prototype._onLoadHooks || [], this.prototype._onLoadHooks.push(n), 
	        this;
	    };
	    var n = e.prototype;
	    return n.isLoaded = function() {
	        return !!this._loaded;
	    }, n.getContainer = function() {
	        return this._containerDOM;
	    }, n.getSpatialReference = function() {
	        return this._spatialReference;
	    }, n.setSpatialReference = function(t) {
	        var e = this.options.spatialReference;
	        return this._loaded && bh.equals(e, t) || this._updateSpatialReference(t, e), this;
	    }, n._updateSpatialReference = function(t, e) {
	        if (jn(t) && (t = bh.getPreset(t)), t = kn({}, t), this._center = this.getCenter(), 
	        this.options.spatialReference = t, this._spatialReference = new bh(t), this.options.spatialReference && Hn(this.options.spatialReference.projection)) {
	            var n = this._spatialReference.getProjection();
	            this.options.spatialReference.projection = n.code;
	        }
	        return this._resetMapStatus(), this._fireEvent("spatialreferencechange", {
	            old: e,
	            new: kn({}, this.options.spatialReference)
	        }), this;
	    }, n.onConfig = function(t) {
	        var e = t.spatialReference || t.view;
	        return Dn(e) || this._updateSpatialReference(e, null), this;
	    }, n.getProjection = function() {
	        return this._spatialReference ? this._spatialReference.getProjection() : null;
	    }, n.getFullExtent = function() {
	        return this._spatialReference ? this._spatialReference.getFullExtent() : null;
	    }, n.setCursor = function(t) {
	        return delete this._cursor, this._trySetCursor(t), this._cursor = t, this;
	    }, n.resetCursor = function() {
	        return this.setCursor(null);
	    }, n.getCenter = function() {
	        return this._loaded && this._prjCenter ? this.getProjection().unproject(this._prjCenter) : this._center;
	    }, n.setCenter = function(t) {
	        if (!t) return this;
	        t = new us(t);
	        var e = this.getProjection().project(t);
	        return this._verifyExtent(e) ? this._loaded ? (this.onMoveStart(), this._setPrjCenter(e), 
	        this.onMoveEnd(this._parseEventFromCoord(this.getCenter())), this) : (this._center = t, 
	        this) : this;
	    }, n.getSize = function() {
	        return Dn(this.width) || Dn(this.height) ? this._getContainerDomSize() : new Gr(this.width, this.height);
	    }, n.getContainerExtent = function() {
	        var t = this.height, e = this.getPitch(), n = this.options.maxVisualPitch;
	        return n && e > n && (t = this._getVisualHeight(n)), new Ps(0, this.height - t, this.width, this.height);
	    }, n._getVisualHeight = function(t) {
	        t = t || .01;
	        var e = (90 - this.getPitch()) * Math.PI / 180, n = this.getFov() * Math.PI / 180;
	        t *= Math.PI / 180;
	        var i = this.cameraCenterDistance / this.getGLScale(), r = Math.tan(n / 2), o = i * r / (1 / Math.tan(t) - r) / Math.sin(t), s = i * (Math.sin(e) * o / (i + Math.cos(e) * o));
	        return this.height / 2 + s;
	    }, n.getExtent = function() {
	        return this._pointToExtent(this._get2DExtent());
	    }, n.getProjExtent = function() {
	        var t = this._get2DExtent();
	        return new Ts(this._pointToPrj(t.getMin()), this._pointToPrj(t.getMax()));
	    }, n.getPrjExtent = function() {
	        return this.getProjExtent();
	    }, n.getMaxExtent = function() {
	        return this.options.maxExtent ? new Ts(this.options.maxExtent, this.getProjection()) : null;
	    }, n.setMaxExtent = function(t) {
	        if (t) {
	            var e = new Ts(t, this.getProjection());
	            this.options.maxExtent = e;
	            var n = this.getProjection();
	            this._prjMaxExtent = e.convertTo((function(t) {
	                return n.project(t);
	            })), this._verifyExtent(this._getPrjCenter()) || (this._loaded ? this._panTo(this._prjMaxExtent.getCenter()) : this._center = n.unproject(this._prjMaxExtent.getCenter()));
	        } else delete this.options.maxExtent, delete this._prjMaxExtent;
	        return this;
	    }, n.getZoom = function() {
	        return this._zoomLevel;
	    }, n.getZoomForScale = function(t, e, n) {
	        var i = this.getZoom();
	        if (Dn(e) && (e = i), 1 === t && e === i) return i;
	        var r = this._getResolution(e), o = this.getZoomFromRes(r / t);
	        if (n) return o;
	        return this.getSpatialReference().getZoomDirection() < 0 ? Math.ceil(o - 1e-6) : Math.floor(o + 1e-6);
	    }, n.getZoomFromRes = function(t) {
	        var e = this._getResolutions(), n = this._getResolution(this.getMinZoom()), i = this._getResolution(this.getMaxZoom());
	        if (n <= i) {
	            if (t <= n) return this.getMinZoom();
	            if (t >= i) return this.getMaxZoom();
	        } else {
	            if (t >= n) return this.getMinZoom();
	            if (t <= i) return this.getMaxZoom();
	        }
	        for (var r = e.length, o = 0; o < r - 1; o++) if (e[o]) {
	            var s = e[o + 1] - e[o], a = t - e[o];
	            if (Bi$1(s) === Bi$1(a) && Math.abs(s) >= Math.abs(a)) return o + a / s;
	        }
	        return r - 1;
	    }, n.setZoom = function(t, e) {
	        return void 0 === e && (e = {
	            animation: !0
	        }), isNaN(t) || Dn(t) || (t = +t, this._loaded && this.options.zoomAnimation && e.animation ? this._zoomAnimation(t) : this._zoom(t)), 
	        this;
	    }, n.getMaxZoom = function() {
	        return Dn(this.options.maxZoom) ? this.getMaxNativeZoom() : this.options.maxZoom;
	    }, n.setMaxZoom = function(t) {
	        var e = this.getMaxNativeZoom();
	        return t > e && (t = e), null !== t && t < this._zoomLevel && (this.setZoom(t), 
	        t = +t), this.options.maxZoom = t, this;
	    }, n.getMinZoom = function() {
	        return Dn(this.options.minZoom) ? this._spatialReference.getMinZoom() : this.options.minZoom;
	    }, n.setMinZoom = function(t) {
	        if (null !== t) {
	            t = +t;
	            var e = this._spatialReference.getMinZoom();
	            t < e && (t = e), t > this._zoomLevel && this.setZoom(t);
	        }
	        return this.options.minZoom = t, this;
	    }, n.getMaxNativeZoom = function() {
	        var t = this.getSpatialReference();
	        return t ? t.getMaxZoom() : null;
	    }, n.getGLRes = function() {
	        if (this._glRes) return this._glRes;
	        var t = this.getSpatialReference().getFullExtent();
	        return this._glRes = (t.right - t.left) / Math.pow(2, 19), this._glRes;
	    }, n.getGLScale = function(t) {
	        return Dn(t) && (t = this.getZoom()), this._getResolution(t) / this.getGLRes();
	    }, n.zoomIn = function() {
	        return this.setZoom(this.getZoom() + 1);
	    }, n.zoomOut = function() {
	        return this.setZoom(this.getZoom() - 1);
	    }, n.isZooming = function() {
	        return !!this._zooming;
	    }, n.isInteracting = function() {
	        return this.isZooming() || this.isMoving() || this.isRotating();
	    }, n.setCenterAndZoom = function(t, e) {
	        return Dn(e) || this._zoomLevel === e ? this.setCenter(t) : (this.setCenter(t), 
	        this.setZoom(e, {
	            animation: !1
	        })), this;
	    }, n.getFitZoom = function(t, e) {
	        var n = this;
	        if (!(t && t instanceof Ts)) return this._zoomLevel;
	        if (t.xmin === t.xmax && t.ymin === t.ymax) return this.getMaxZoom();
	        var i = this.getSize(), r = t.convertTo((function(t) {
	            return n.coordToPoint(t);
	        })), o = r.getWidth(), s = r.getHeight(), a = i.width / o, h = i.height / s, l = this.getSpatialReference().getZoomDirection() < 0 ? Math.max(a, h) : Math.min(a, h);
	        return this.getZoomForScale(l, null, e);
	    }, n.getView = function() {
	        return {
	            center: this.getCenter().toArray(),
	            zoom: this.getZoom(),
	            pitch: this.getPitch(),
	            bearing: this.getBearing()
	        };
	    }, n.setView = function(t) {
	        return t ? (t.center && this.setCenter(t.center), null === t.zoom || isNaN(+t.zoom) || this.setZoom(+t.zoom, {
	            animation: !1
	        }), null === t.pitch || isNaN(+t.pitch) || this.setPitch(+t.pitch), null === t.pitch || isNaN(+t.bearing) || this.setBearing(+t.bearing), 
	        this) : this;
	    }, n.getResolution = function(t) {
	        return this._getResolution(t);
	    }, n.getScale = function(t) {
	        var e = Dn(t) ? this.getZoom() : t, n = this._getResolution(this.getMaxNativeZoom());
	        return this._getResolution(e) / n;
	    }, n.fitExtent = function(t, e, n, i) {
	        if (void 0 === n && (n = {}), !t) return this;
	        t = new Ts(t, this.getProjection());
	        var r = this.getFitZoom(t) + (e || 0), o = t.getCenter();
	        return void 0 === n.animation || n.animation ? this._animateTo({
	            center: o,
	            zoom: r
	        }, {
	            duration: n.duration || this.options.zoomAnimationDuration,
	            easing: n.easing || "out"
	        }, i) : this.setCenterAndZoom(o, r);
	    }, n.getBaseLayer = function() {
	        return this._baseLayer;
	    }, n.setBaseLayer = function(t) {
	        var e = !1;
	        if (this._baseLayer && (e = !0, this._fireEvent("baselayerchangestart"), this._baseLayer.remove()), 
	        !t) return delete this._baseLayer, this._fireEvent("baselayerchangeend"), this._fireEvent("setbaselayer"), 
	        this;
	        return this._baseLayer = t, t._bindMap(this, -1), this._baseLayer.on("layerload", (function() {
	            this._fireEvent("baselayerload"), e && (e = !1, this._fireEvent("baselayerchangeend"));
	        }), this), this._loaded && this._baseLayer.load(), this._fireEvent("setbaselayer"), 
	        this;
	    }, n.removeBaseLayer = function() {
	        return this._baseLayer && (this._baseLayer.remove(), delete this._baseLayer, this._fireEvent("baselayerremove")), 
	        this;
	    }, n.getLayers = function(t) {
	        return this._getLayers((function(e) {
	            return !(e === this._baseLayer || e.getId().indexOf("_maptalks__internal_layer_") >= 0) && (!t || t(e));
	        }));
	    }, n.getLayer = function(t) {
	        if (!t) return null;
	        var e = this._layerCache ? this._layerCache[t] : null;
	        if (e) return e;
	        var n = this.getBaseLayer();
	        return n && n.getId() === t ? n : null;
	    }, n.addLayer = function(t) {
	        if (!t) return this;
	        if (!Array.isArray(t)) return t = Array.prototype.slice.call(arguments, 0), this.addLayer(t);
	        this._layerCache || (this._layerCache = {});
	        for (var e = this._layers, n = 0, i = t.length; n < i; n++) {
	            var r = t[n], o = r.getId();
	            if (Dn(o)) throw new Error("Invalid id for the layer: " + o);
	            if (r.getMap() !== this) {
	                if (this._layerCache[o]) throw new Error("Duplicate layer id in the map: " + o);
	                this._layerCache[o] = r, r._bindMap(this), e.push(r), this._loaded && r.load();
	            }
	        }
	        return this._sortLayersByZIndex(), this._fireEvent("addlayer", {
	            layers: t
	        }), this;
	    }, n.removeLayer = function(t) {
	        if (!t) return this;
	        if (!Array.isArray(t)) return this.removeLayer([ t ]);
	        for (var e = [], n = 0, i = t.length; n < i; n++) {
	            var r = t[n];
	            if (r instanceof Sh || (r = this.getLayer(r)), r) {
	                var o = r.getMap();
	                if (o && o === this) {
	                    e.push(r), this._removeLayer(r, this._layers), this._loaded && r._doRemove();
	                    var s = r.getId();
	                    this._layerCache && delete this._layerCache[s];
	                }
	            }
	        }
	        if (e.length > 0) {
	            var a = this.getRenderer();
	            a && a.setLayerCanvasUpdated(), this.once("frameend", (function() {
	                e.forEach((function(t) {
	                    t.fire("remove");
	                }));
	            }));
	        }
	        return this._fireEvent("removelayer", {
	            layers: t
	        }), this;
	    }, n.sortLayers = function(t) {
	        if (!t || !Array.isArray(t)) return this;
	        for (var e = [], n = Number.MAX_VALUE, i = 0, r = t.length; i < r; i++) {
	            var o = t[i];
	            if (jn(t[i]) && (o = this.getLayer(o)), !(o instanceof Sh && o.getMap() && o.getMap() === this)) throw new Error("It must be a layer added to this map to order.");
	            o.getZIndex() < n && (n = o.getZIndex()), e.push(o);
	        }
	        for (var s = 0, a = e.length; s < a; s++) e[s].setZIndex(n + s);
	        return this;
	    }, n.toDataURL = function(t) {
	        t || (t = {});
	        var e = t.mimeType;
	        e || (e = "image/png");
	        var n = t.save, i = this._getRenderer();
	        if (i && i.toDataURL) {
	            var r = t.fileName;
	            r || (r = "export");
	            var o = i.toDataURL(e, t.quality || .92);
	            if (n && o) {
	                var s;
	                if ("undefined" != typeof Blob && "undefined" != typeof atob) {
	                    var a = $i$1(o.replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, ""), e);
	                    s = URL.createObjectURL(a);
	                } else s = o;
	                var h = document.createElement("a");
	                h.download = r, h.href = s, document.body.appendChild(h), h.click(), document.body.removeChild(h);
	            }
	            return o;
	        }
	        return null;
	    }, n.coordToPoint = function(t, e, n) {
	        return this.coordinateToPoint(t, e, n);
	    }, n.coordToPointAtRes = function(t, e, n) {
	        return this.coordinateToPointAtRes(t, e, n);
	    }, n.pointToCoord = function(t, e, n) {
	        return this.pointToCoordinate(t, e, n);
	    }, n.pointAtResToCoord = function(t, e, n) {
	        return this.pointAtResToCoordinate(t, e, n);
	    }, n.coordToViewPoint = function(t, e, n) {
	        return this.coordinateToViewPoint(t, e, n);
	    }, n.viewPointToCoord = function(t, e) {
	        return this.viewPointToCoordinate(t, e);
	    }, n.coordToContainerPoint = function(t, e, n) {
	        return this.coordinateToContainerPoint(t, e, n);
	    }, n.containerPointToCoord = function(t, e) {
	        return this.containerPointToCoordinate(t, e);
	    }, n.containerPointToViewPoint = function(t, e) {
	        return e ? e.set(t.x, t.y) : e = t.copy(), e._sub(this.getViewPoint());
	    }, n.viewPointToContainerPoint = function(t, e) {
	        return e ? e.set(t.x, t.y) : e = t.copy(), e._add(this.getViewPoint());
	    }, n.checkSize = function(t) {
	        var e = In() - this._initTime < 1500 && 0 === this.width || 0 === this.height, n = this._getContainerDomSize(), i = this.height, r = this.width;
	        if (!t && n.width === r && n.height === i) return this;
	        Oo(this._containerDOM);
	        var o = this.getCenter();
	        if (this.options.fixCenterOnResize) this._updateMapSize(n); else {
	            var s = this._getVisualHeight(this.getPitch()), a = new Oi$1(0, this.height - s), h = this._containerPointToPrj(a);
	            this._updateMapSize(n);
	            var l = this._getVisualHeight(this.getPitch()), c = new Oi$1(0, this.height - l);
	            this._setPrjCoordAtContainerPoint(h, c), this._mapViewCoord = this._getPrjCenter();
	        }
	        return (e || (0 === n.width || 0 === n.height || 0 === r || 0 === i)) && (this._eventSilence = !0, 
	        this.setCenter(o), delete this._eventSilence), this._fireEvent("resize"), this;
	    }, n.locate = function(t, e, n) {
	        return this.getProjection()._locate(new us(t), e, n);
	    }, n.getMainPanel = function() {
	        return this._getRenderer().getMainPanel();
	    }, n.getPanels = function() {
	        return this._panels;
	    }, n.remove = function() {
	        var t = this;
	        if (this.isRemoved()) return this;
	        this._fireEvent("removestart"), this._removeDomEvents(), this._clearHandlers(), 
	        this.removeBaseLayer();
	        for (var e = this.getLayers(), n = 0; n < e.length; n++) e[n].remove();
	        return this._getRenderer() && this._getRenderer().remove(), this._containerDOM.childNodes && this._containerDOM.childNodes.length > 0 && Array.prototype.slice.call(this._containerDOM.childNodes, 0).filter((function(t) {
	            return "maptalks-wrapper" === t.className;
	        })).forEach((function(e) {
	            return t._containerDOM.removeChild(e);
	        })), delete this._panels, delete this._containerDOM, delete this.renderer, this._fireEvent("removeend"), 
	        this._clearAllListeners(), Mi$1.removeDPRListening && Mi$1.removeDPRListening(this), 
	        this;
	    }, n.isRemoved = function() {
	        return !this._containerDOM;
	    }, n.isMoving = function() {
	        return !!this._moving;
	    }, n.onMoveStart = function(t) {
	        this._mapAnimPlayer && this._stopAnim(this._mapAnimPlayer);
	        var e = this._getPrjCenter();
	        this._originCenter && !this._verifyExtent(e) || (this._originCenter = e), this._moving = !0, 
	        this._trySetCursor("move"), this._fireEvent("movestart", this._parseEvent(t ? t.domEvent : null, "movestart"));
	    }, n.onMoving = function(t) {
	        this._fireEvent("moving", this._parseEvent(t ? t.domEvent : null, "moving"));
	    }, n.onMoveEnd = function(t) {
	        (this._moving = !1, this._trySetCursor("default"), this._fireEvent("moveend", t && t.domEvent ? this._parseEvent(t.domEvent, "moveend") : t), 
	        !this._verifyExtent(this._getPrjCenter()) && this._originCenter) && this._panTo(this._originCenter);
	    }, n.onDragRotateStart = function(t) {
	        this._dragRotating = !0, this._fireEvent("dragrotatestart", this._parseEvent(t ? t.domEvent : null, "dragrotatestart"));
	    }, n.onDragRotating = function(t) {
	        this._fireEvent("dragrotating", this._parseEvent(t ? t.domEvent : null, "dragrotating"));
	    }, n.onDragRotateEnd = function(t) {
	        this._dragRotating = !1, this._fireEvent("dragrotateend", this._parseEvent(t ? t.domEvent : null, "dragrotateend"));
	    }, n.isDragRotating = function() {
	        return !!this._dragRotating;
	    }, n.isOffscreen = function(t, e) {
	        void 0 === e && (e = 0);
	        var n = this.width + e, i = this.height + e, r = t.xmin, o = t.ymin, s = t.xmax, a = t.ymax;
	        return Array.isArray(t) && (r = t[0], o = t[1], s = t[2], a = t[3]), s < e || r >= n || a < e || o > i;
	    }, n.getRenderer = function() {
	        return this._getRenderer();
	    }, n.getDevicePixelRatio = function() {
	        return this.options.devicePixelRatio || Mi$1.devicePixelRatio || 1;
	    }, n.setDevicePixelRatio = function(t) {
	        return Ln(t) && t > 0 && t !== this.options.devicePixelRatio && (this.options.devicePixelRatio = t, 
	        this.checkSize(!0)), this;
	    }, n._initContainer = function(t) {
	        if (jn(t)) {
	            if (this._containerDOM = document.getElementById(t), !this._containerDOM) throw new Error("Invalid container when creating map: '" + t + "'");
	        } else this._containerDOM = t, Wn && (this.CanvasClass = this._containerDOM.constructor);
	        if (this._containerDOM.childNodes && this._containerDOM.childNodes.length > 0 && "maptalks-wrapper" === this._containerDOM.childNodes[0].className) throw new Error("Container is already loaded with another map instance, use map.remove() to clear it.");
	    }, n._trySetCursor = function(t) {
	        return this._cursor || this._priorityCursor || (t || (t = "default"), this._setCursorToPanel(t)), 
	        this;
	    }, n._setPriorityCursor = function(t) {
	        if (t) this._priorityCursor = t, this._setCursorToPanel(t); else {
	            var e = !1;
	            this._priorityCursor && (e = !0), delete this._priorityCursor, e && this.setCursor(this._cursor);
	        }
	        return this;
	    }, n._setCursorToPanel = function(t) {
	        var e = this.getMainPanel();
	        e && e.style && e.style.cursor !== t && (e.style.cursor = t);
	    }, n._removeLayer = function(t, e) {
	        if (t && e) {
	            var n = e.indexOf(t);
	            n > -1 && e.splice(n, 1);
	        }
	    }, n._sortLayersByZIndex = function() {
	        if (this._layers) {
	            for (var t = 0, e = this._layers.length; t < e; t++) this._layers[t]._order = t, 
	            this._layers[t].sortLayersByZIndex && this._layers[t].sortLayersByZIndex();
	            this._layers.sort((function(t, e) {
	                var n = t.getZIndex() - e.getZIndex();
	                return 0 === n ? t._order - e._order : n;
	            }));
	        }
	    }, n._fireEvent = function(t, e) {
	        this._eventSilence || (this.fire("_" + t, e), this.fire(t, e));
	    }, n._Load = function() {
	        this._resetMapStatus(), this.options.pitch && (this.setPitch(this.options.pitch), 
	        delete this.options.pitch), this.options.bearing && (this.setBearing(this.options.bearing), 
	        delete this.options.bearing), delete this._glRes, this._loadAllLayers(), this._getRenderer().onLoad(), 
	        this._loaded = !0, this._callOnLoadHooks(), this._initTime = In();
	    }, n._initRenderer = function() {
	        var t = e.getRendererClass(this.options.renderer);
	        this._renderer = new t(this), this._renderer.load();
	    }, n._getRenderer = function() {
	        return this._renderer;
	    }, n._loadAllLayers = function() {
	        this._baseLayer && this._baseLayer.load(), this._eachLayer((function(t) {
	            t && t.load();
	        }), this.getLayers());
	    }, n._getLayers = function(t) {
	        for (var e = this._baseLayer ? [ this._baseLayer ].concat(this._layers) : this._layers, n = [], i = 0; i < e.length; i++) t && !t.call(this, e[i]) || n.push(e[i]);
	        return n;
	    }, n._eachLayer = function(t) {
	        if (!(arguments.length < 2)) {
	            var e = Array.prototype.slice.call(arguments, 1);
	            e && !Array.isArray(e) && (e = [ e ]);
	            for (var n = [], i = 0, r = e.length; i < r; i++) n = n.concat(e[i]);
	            for (var o = 0, s = n.length; o < s; o++) t.call(t, n[o]);
	        }
	    }, n._onLayerEvent = function(t) {
	        t && "idchange" === t.type && (delete this._layerCache[t.old], this._layerCache[t.new] = t.target);
	    }, n._resetMapStatus = function() {
	        var t = this.getMaxZoom(), e = this.getMinZoom(), n = this._spatialReference.getMaxZoom(), i = this._spatialReference.getMinZoom();
	        (Dn(t) || -1 === t || t > n) && this.setMaxZoom(n), (Dn(e) || -1 === e || e < i) && this.setMinZoom(i), 
	        (t = this.getMaxZoom()) < (e = this.getMinZoom()) && this.setMaxZoom(e), (Dn(this._zoomLevel) || this._zoomLevel > t) && (this._zoomLevel = t), 
	        this._zoomLevel < e && (this._zoomLevel = e), delete this._prjCenter;
	        var r = this.getProjection();
	        this._prjCenter = r.project(this._center), this._calcMatrices();
	        var o = this._getRenderer();
	        o && o.resetContainer();
	    }, n._getContainerDomSize = function() {
	        if (!this._containerDOM) return null;
	        var t, e, n = this._containerDOM;
	        if (this._containerDomContentRect) return new Gr(t = this._containerDomContentRect.width, e = this._containerDomContentRect.height);
	        if (Dn(n.width) || Dn(n.height)) {
	            if (Dn(n.clientWidth) || Dn(n.clientHeight)) throw new Error("can not get size of container");
	            t = parseInt(n.clientWidth, 0), e = parseInt(n.clientHeight, 0);
	        } else {
	            t = n.width, e = n.height;
	            var i = this.getDevicePixelRatio();
	            1 !== i && n.layer && (t /= i, e /= i);
	        }
	        return new Gr(t, e);
	    }, n._updateMapSize = function(t) {
	        return this.width = t.width, this.height = t.height, this._getRenderer().updateMapSize(t), 
	        this._calcMatrices(), this;
	    }, n._getPrjCenter = function() {
	        return this._prjCenter;
	    }, n._setPrjCenter = function(t) {
	        this._prjCenter = t, this.isInteracting() && !this.isMoving() && (this._mapViewCoord = t), 
	        this._calcMatrices();
	    }, n._setPrjCoordAtContainerPoint = function(t, e) {
	        if (e.x === this.width / 2 && e.y === this.height / 2) return this;
	        var n = this._containerPointToPoint(e)._sub(this._prjToPoint(this._getPrjCenter())), i = this._pointToPrj(this._prjToPoint(t).sub(n));
	        return this._setPrjCenter(i), this;
	    }, n._verifyExtent = function(t) {
	        if (!t) return !1;
	        var e = this._prjMaxExtent;
	        return !e || e.contains(t);
	    }, n._offsetCenterByPixel = function(t) {
	        var e = new Oi$1(this.width / 2 - t.x, this.height / 2 - t.y), n = this._containerPointToPrj(e);
	        return this._setPrjCenter(n), n;
	    }, n.offsetPlatform = function(t) {
	        return t ? (this._getRenderer().offsetPlatform(t), this._mapViewCoord = this._getPrjCenter(), 
	        this._mapViewPoint = this._mapViewPoint.add(t), this) : this._mapViewPoint;
	    }, n.getViewPoint = function() {
	        var t = this._getViewPointFrameOffset(), e = this.offsetPlatform();
	        return t && (e = e.add(t)), e;
	    }, n._resetMapViewPoint = function() {
	        this._mapViewPoint = new Oi$1(0, 0), this._mapViewCoord = this._getPrjCenter();
	    }, n._getResolution = function(t) {
	        return void 0 !== t && t !== this._zoomLevel || void 0 === this._mapRes ? (Dn(t) && (t = this._zoomLevel), 
	        this._spatialReference.getResolution(t)) : this._mapRes;
	    }, n._getResolutions = function() {
	        return this._spatialReference.getResolutions();
	    }, n._prjToPoint = function(t, e, n) {
	        e = Dn(e) ? this.getZoom() : e;
	        var i = this._getResolution(e);
	        return this._prjToPointAtRes(t, i, n);
	    }, n._prjToPointAtRes = function(t, e, n) {
	        return this._spatialReference.getTransformation().transform(t, e, n);
	    }, n._prjsToPointsAtRes = function(t, e, n) {
	        void 0 === n && (n = []);
	        for (var i = this._spatialReference.getTransformation(), r = [], o = 0, s = t.length; o < s; o++) {
	            var a = i.transform(t[o], e, n[o]);
	            r.push(a);
	        }
	        return r;
	    }, n._pointToPrj = function(t, e, n) {
	        e = Dn(e) ? this.getZoom() : e;
	        var i = this._getResolution(e);
	        return this._pointToPrjAtRes(t, i, n);
	    }, n._pointToPrjAtRes = function(t, e, n) {
	        return this._spatialReference.getTransformation().untransform(t, e, n);
	    }, n._pointToPoint = function(t, e, n) {
	        return Dn(e) ? (n ? (n.x = t.x, n.y = t.y) : n = t.copy(), n) : this._pointAtResToPoint(t, this._getResolution(e), n);
	    }, n._pointAtResToPoint = function(t, e, n) {
	        return n ? (n.x = t.x, n.y = t.y) : n = t.copy(), n._multi(e / this._getResolution());
	    }, n._pointToPointAtRes = function(t, e, n) {
	        return n ? (n.x = t.x, n.y = t.y) : n = t.copy(), n._multi(this._getResolution() / e);
	    }, n._containerPointToPrj = function(t, e) {
	        return this._pointToPrj(this._containerPointToPoint(t, void 0, e), void 0, e);
	    }, n._callOnLoadHooks = function() {
	        var t = e.prototype;
	        if (t._onLoadHooks) for (var n = 0, i = t._onLoadHooks.length; n < i; n++) t._onLoadHooks[n].call(this);
	    }, n._fixPrjOnWorldWide = function(t) {
	        var e = this.getProjection();
	        if (e && e.fullExtent && t) {
	            var n = e.fullExtent || {}, i = n.left, r = n.bottom, o = n.top, s = n.right;
	            Ln(i) && (t.x = Math.max(i, t.x)), Ln(s) && (t.x = Math.min(s, t.x)), Ln(r) && (t.y = Math.max(r, t.y)), 
	            Ln(o) && (t.y = Math.min(o, t.y));
	        }
	        return this;
	    }, e;
	}(as(ts(Xs(ns))));

	Fh.include({
	    coordinateToPoint: function(t, e, n) {
	        var i = this._getResolution(e);
	        return this.coordinateToPointAtRes(t, i, n);
	    },
	    coordinateToPointAtRes: (Dh = new us(0, 0), function(t, e, n) {
	        var i = this.getProjection().project(t, Dh);
	        return this._prjToPointAtRes(i, e, n);
	    }),
	    pointToCoordinate: function() {
	        var t = new us(0, 0);
	        return function(e, n, i) {
	            var r = this._pointToPrj(e, n, t);
	            return this.getProjection().unproject(r, i);
	        };
	    }(),
	    pointAtResToCoordinate: function() {
	        var t = new us(0, 0);
	        return function(e, n, i) {
	            var r = this._pointToPrjAtRes(e, n, t);
	            return this.getProjection().unproject(r, i);
	        };
	    }(),
	    coordinateToViewPoint: function() {
	        var t = new us(0, 0);
	        return function(e, n, i) {
	            return this._prjToViewPoint(this.getProjection().project(e, t), n, i);
	        };
	    }(),
	    viewPointToCoordinate: function() {
	        var t = new us(0, 0);
	        return function(e, n) {
	            return this.getProjection().unproject(this._viewPointToPrj(e, t), n);
	        };
	    }(),
	    coordinateToContainerPoint: function(t, e, n) {
	        var i = this._getResolution(e);
	        return this.coordinateToContainerPointAtRes(t, i, n);
	    },
	    coordinateToContainerPointAtRes: function() {
	        var t = new us(0, 0);
	        return function(e, n, i) {
	            var r = this.getProjection().project(e, t);
	            return this._prjToContainerPointAtRes(r, n, i);
	        };
	    }(),
	    coordinatesToContainerPoints: function(t, e) {
	        var n = this._getResolution(e);
	        return this.coordinatesToContainerPointsAtRes(t, n);
	    },
	    coordinatesToContainerPointsAtRes: function(t, e) {
	        for (var n = [], i = this._spatialReference.getTransformation(), r = e / this._getResolution(), o = this.getProjection(), s = new us(0, 0), a = this.isTransforming(), h = this._prjToPoint(this._getPrjCenter(), void 0, Lh), l = 0, c = t.length; l < c; l++) {
	            var u = o.project(t[l], s), f = i.transform(u, e);
	            f = f._multi(r), this._toContainerPoint(f, a, r, 0, h), n.push(f);
	        }
	        return n;
	    },
	    containerPointToCoordinate: function() {
	        var t = new us(0, 0);
	        return function(e, n) {
	            var i = this._containerPointToPrj(e, t);
	            return this.getProjection().unproject(i, n);
	        };
	    }(),
	    containerToExtent: (Ih = new Oi$1(0, 0), kh = new Oi$1(0, 0), function(t) {
	        var e = new Ps(this._containerPointToPoint(t.getMin(Ih), void 0, Ih), this._containerPointToPoint(t.getMax(kh), void 0, kh));
	        return this._pointToExtent(e);
	    }),
	    distanceToPixel: function() {
	        var t = new Oi$1(0, 0), e = new Oi$1(0, 0);
	        return function(n, i, r) {
	            var o = this.getProjection();
	            if (!o) return null;
	            var s = this.getScale() / this.getScale(r), a = this.getCenter(), h = o.locate(a, n, i), l = this.coordToContainerPoint(a, void 0, t), c = this.coordToContainerPoint(h, void 0, e);
	            return c._sub(l)._multi(s)._abs(), new Gr(c.x, c.y);
	        };
	    }(),
	    distanceToPoint: function(t, e, n, i) {
	        var r = this._getResolution(n);
	        return this.distanceToPointAtRes(t, e, r, i);
	    },
	    distanceToPointAtRes: function() {
	        var t = new Oi$1(0, 0), e = new us(0, 0);
	        return function(n, i, r, o, s) {
	            var a = this.getProjection();
	            if (!a) return null;
	            var h = o || this.getCenter(), l = a.locate(h, n, i, e), c = this.coordToPointAtRes(h, r, t), u = this.coordToPointAtRes(l, r, s);
	            return u._sub(c)._abs(), u;
	        };
	    }(),
	    altitudeToPoint: (Oh = new us(0, 40), Rh = new Oi$1(0, 0), function(t, e, n) {
	        void 0 === t && (t = 0);
	        var i = this.distanceToPointAtRes(t, t, e, n || Oh, Rh);
	        t < 0 && i.x > 0 && (i.x = -i.x);
	        var r = this.options.heightFactor;
	        return r && 1 !== r && (i.x *= r, i.y *= r), i.x;
	    }),
	    pointAtResToAltitude: function() {
	        var t = new us(0, 40);
	        return function(e, n, i) {
	            return void 0 === e && (e = 0), this.pointAtResToDistance(e, 0, n, i || t);
	        };
	    }(),
	    pixelToDistance: (Ah = new us(0, 0), Eh = new us(0, 0), function(t, e) {
	        var n = this.getProjection();
	        if (!n) return null;
	        var i = this.getFullExtent(), r = Ah.set(this.width / 2 + t, this.height / 2 + (i.top > i.bottom ? -1 : 1) * e), o = this.containerPointToCoord(r, Eh);
	        return n.measureLength(this.getCenter(), o);
	    }),
	    pointToDistance: function(t, e, n) {
	        var i = this.getResolution(n);
	        return this.pointAtResToDistance(t, e, i);
	    },
	    pointAtResToDistance: function() {
	        var t = new Oi$1(0, 0), e = new us(0, 0), n = new us(0, 0), i = new us(0, 0);
	        return function(r, o, s, a) {
	            var h = this.getProjection();
	            if (!h) return null;
	            var l = a ? h.project(a, e) : this._getPrjCenter(), c = this._prjToPointAtRes(l, s, t);
	            c._add(r, o);
	            var u = this.pointAtResToCoord(c, s, n), f = a || h.unproject(l, i);
	            return h.measureLength(f, u);
	        };
	    }(),
	    locateByPoint: function() {
	        var t = new Oi$1(0, 0);
	        return function(e, n, i) {
	            var r = this.coordToContainerPoint(e, void 0, t);
	            return this.containerPointToCoord(r._add(n, i));
	        };
	    }(),
	    _get2DExtent: function(t, e) {
	        var n;
	        if (void 0 !== t && t !== this._zoomLevel || !this._mapExtent2D || (n = this._mapExtent2D), 
	        n) return e ? (e.set(n.xmin, n.ymin, n.xmax, n.ymax), e) : n.copy();
	        var i = this._getResolution(t);
	        return this._get2DExtentAtRes(i, e);
	    },
	    _get2DExtentAtRes: function() {
	        var t = new Oi$1(0, 0);
	        return function(e, n) {
	            var i = this;
	            return e === this._mapGlRes && this._mapGlExtent2D ? this._mapGlExtent2D : this.getContainerExtent().convertTo((function(n) {
	                return i._containerPointToPointAtRes(n, e, t);
	            }), n);
	        };
	    }(),
	    _pointToExtent: function() {
	        var t = new us(0, 0), e = new us(0, 0);
	        return function(n) {
	            var i = n.getMin(), r = n.getMax(), o = this.getFullExtent(), s = !o || o.left <= o.right ? [ i.x, r.x ] : [ r.x, i.x ], a = s[1], h = !o || o.top > o.bottom ? [ r.y, i.y ] : [ i.y, r.y ], l = h[0], c = i.set(s[0], h[1]), u = r.set(a, l);
	            return new Ts(this.pointToCoord(c, void 0, t), this.pointToCoord(u, void 0, e), this.getProjection());
	        };
	    }(),
	    _getViewPointFrameOffset: function() {
	        var t = new Oi$1(0, 0);
	        return function() {
	            if (this.isZooming()) return null;
	            var e = this._getPrjCenter();
	            return this._mapViewCoord && !this._mapViewCoord.equals(e) ? this._prjToContainerPoint(this._mapViewCoord)._sub(this._prjToContainerPoint(e, void 0, t)) : null;
	        };
	    }(),
	    _viewPointToPrj: function() {
	        var t = new Oi$1(0, 0);
	        return function(e, n) {
	            return this._containerPointToPrj(this.viewPointToContainerPoint(e, t), n);
	        };
	    }(),
	    _prjToContainerPoint: function(t, e, n, i) {
	        var r = this._getResolution(e);
	        return this._prjToContainerPointAtRes(t, r, n, i);
	    },
	    _prjToContainerPointAtRes: function() {
	        var t = new Oi$1(0, 0);
	        return function(e, n, i, r) {
	            return this._pointAtResToContainerPoint(this._prjToPointAtRes(e, n, t), n, r || 0, i);
	        };
	    }(),
	    _prjToViewPoint: function() {
	        var t = new Oi$1(0, 0);
	        return function(e, n, i) {
	            var r = this._prjToContainerPoint(e, void 0, t, i);
	            return this.containerPointToViewPoint(r, n);
	        };
	    }(),
	    _viewPointToPoint: function() {
	        var t = new Oi$1(0, 0);
	        return function(e, n, i) {
	            return this._containerPointToPoint(this.viewPointToContainerPoint(e, t), n, i);
	        };
	    }(),
	    _pointToViewPoint: function() {
	        var t = new us(0, 0);
	        return function(e, n, i) {
	            return this._prjToViewPoint(this._pointToPrj(e, n, t), i);
	        };
	    }()
	}), Fh.mergeOptions(zh);

	var jh = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.addHooks = function() {
	        this.target && this.target.on("_dblclick", this._onDoubleClick, this);
	    }, n.removeHooks = function() {
	        this.target && this.target.off("_dblclick", this._onDoubleClick, this);
	    }, n._onDoubleClick = function(t) {
	        var e = this.target;
	        if (e.options.doubleClickZoom) {
	            var n = e.getZoom(), i = t.domEvent.shiftKey ? Math.ceil(n) - 1 : Math.floor(n) + 1;
	            e._zoomAnimation(i, t.containerPoint);
	        }
	    }, e;
	}(es);

	Fh.mergeOptions({
	    doubleClickZoom: !0
	}), Fh.addOnLoadHook("addHandler", "doubleClickZoom", jh);

	var Hh = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.addHooks = function() {
	        var t = this.target;
	        t && (this._dragHandler = new cs(t._panels.mapWrapper || t._containerDOM, {
	            cancelOn: this._cancelOn.bind(this),
	            rightclick: !0
	        }), this._dragHandler.on("mousedown", this._onMouseDown, this).on("dragstart", this._onDragStart, this).on("dragging", this._onDragging, this).on("dragend", this._onDragEnd, this).enable());
	    }, n.removeHooks = function() {
	        this._dragHandler.off("mousedown", this._onMouseDown, this).off("dragstart", this._onDragStart, this).off("dragging", this._onDragging, this).off("dragend", this._onDragEnd, this), 
	        this._dragHandler.remove(), delete this._dragHandler;
	    }, n._cancelOn = function(t) {
	        return !(!this.target.isZooming() && !this._ignore(t));
	    }, n._ignore = function(t) {
	        return !!t && (t.domEvent && (t = t.domEvent), this.target._ignoreEvent(t));
	    }, n._onMouseDown = function(t) {
	        delete this.startDragTime, delete this._mode, 2 === t.domEvent.button || t.domEvent.ctrlKey ? (this.target.options.dragRotate || this.target.options.dragPitch) && (this._mode = "rotatePitch") : this.target.options.dragPan && (this._mode = "move"), 
	        this.target._stopAnim(this.target._mapAnimPlayer), Po(t.domEvent);
	    }, n._onDragStart = function(t) {
	        this.startDragTime = In(), "move" === this._mode ? this._moveStart(t) : "rotatePitch" === this._mode && this._rotateStart(t);
	    }, n._onDragging = function(t) {
	        this.target._isEventOutMap(t.domEvent) || ("move" === this._mode ? this._moving(t) : "rotatePitch" === this._mode && this._rotating(t));
	    }, n._onDragEnd = function(t) {
	        "move" === this._mode ? this._moveEnd(t) : "rotatePitch" === this._mode && this._rotateEnd(t), 
	        delete this.startDragTime, delete this.startBearing;
	    }, n._start = function(t) {
	        this.preX = t.mousePos.x, this.preY = t.mousePos.y, this.startX = this.preX, this.startY = this.preY, 
	        this._startPrjCenter = this.target._getPrjCenter().copy();
	    }, n._moveStart = function(t) {
	        this._start(t);
	        var e = this.target;
	        e.onMoveStart(t);
	        var n = Ro(e._getActualEvent(t.domEvent), e.getContainer());
	        this.startPrjCoord = e._containerPointToPrj(n);
	    }, n._moving = function(t) {
	        if (this.startDragTime) {
	            var e = this.target, n = Ro(e._getActualEvent(t.domEvent), e.getContainer());
	            e._setPrjCoordAtContainerPoint(this.startPrjCoord, n), e.onMoving(t);
	        }
	    }, n._moveEnd = function(t) {
	        if (this.startDragTime) {
	            var e = "touchend" === t.domEvent.type, n = this.target, i = In() - this.startDragTime, r = t.mousePos.x - this.startX, o = t.mousePos.y - this.startY, s = n._getPrjCenter(), a = s.sub(this._startPrjCenter);
	            if (this._clear(), n.options.panAnimation && !t.interupted && n._verifyExtent(n._getPrjCenter()) && i < 280 && Math.abs(o) + Math.abs(r) > 5) {
	                i *= 5;
	                var h = s.add(a._multi(e ? 5 : 2.8));
	                n._panTo(h, {
	                    duration: e ? 3 * i : 2 * i,
	                    easing: "outExpo"
	                });
	            } else n.onMoveEnd(t);
	        }
	    }, n._rotateStart = function(t) {
	        this._start(t), delete this._rotateMode, this.startBearing = this.target.getBearing(), 
	        this.target.onDragRotateStart(t), this._db = 0;
	    }, n._rotating = function(t) {
	        var e = this.target, n = t.mousePos.x, i = t.mousePos.y, r = e.getPitch(), o = e.getBearing(), s = Math.abs(n - this.preX), a = Math.abs(i - this.preY);
	        if (this._rotateMode || (this._rotateMode = e.options.dragRotatePitch ? "rotate_pitch" : s > a ? "rotate" : s < a ? "pitch" : "rotate"), 
	        !("pitch" === this._rotateMode && 0 === r && a < 10)) {
	            if (this._rotateMode.indexOf("rotate") >= 0 && e.options.dragRotate) {
	                var h = 0;
	                h = e.options.dragPitch || s > a ? -.6 * (this.preX - n) : n > e.width / 2 ? .6 * (this.preY - i) : -.6 * (this.preY - i);
	                var l = e.getBearing() + h;
	                this._db = this._db || 0, this._db += h, e._setBearing(l);
	            }
	            this._rotateMode.indexOf("pitch") >= 0 && e.options.dragPitch && e._setPitch(e.getPitch() + .4 * (this.preY - i)), 
	            this.preX = n, this.preY = i, e.getBearing() === o && e.getPitch() === r || e.onDragRotating(t);
	        }
	    }, n._rotateEnd = function(t) {
	        var e = this.target, n = e.getBearing();
	        this._clear();
	        var i = In() - this.startDragTime;
	        if (e.onDragRotateEnd(t), e.options.rotateAnimation && Math.abs(n - this.startBearing) > 20 && ("rotate" === this._rotateMode || "rotate_pitch" === this._rotateMode) && !t.interupted && i < 400) {
	            var r = e.getBearing();
	            e._animateTo({
	                bearing: r + this._db / 1.5
	            }, {
	                easing: "outQuint",
	                duration: 1600
	            });
	        }
	    }, n._clear = function() {
	        delete this.startPrjCoord, delete this.preX, delete this.preY, delete this.startX, 
	        delete this.startY;
	    }, e;
	}(es);

	Fh.mergeOptions({
	    draggable: !0,
	    dragPan: !0,
	    dragRotatePitch: !0,
	    dragRotate: !0,
	    dragPitch: !0
	}), Fh.addOnLoadHook("addHandler", "draggable", Hh);

	var Nh = "mousedown mouseup mousemove click dblclick contextmenu touchstart touchmove touchend", Bh = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.addHooks = function() {
	        var t = this.target;
	        Ho(t._panels.allLayers || t._containerDOM, Nh, this._identifyGeometryEvents, this);
	    }, n.removeHooks = function() {
	        var t = this.target;
	        No(t._panels.allLayers || t._containerDOM, Nh, this._identifyGeometryEvents);
	    }, n._identifyGeometryEvents = function(t, e) {
	        var n = this.target;
	        if (!n.isInteracting() && !n._ignoreEvent(t)) {
	            var i = null, r = e || t.type, o = "mousedown" === r || "touchstart" === r && t.touches && 1 === t.touches.length;
	            if (o) this._mouseDownTime = In(); else if (("click" === r || "touchend" === r) && this._mouseDownTime) {
	                var s = this._mouseDownTime;
	                if (delete this._mouseDownTime, In() - s > 300) {
	                    if ("click" === r) return;
	                } else "touchend" === r && (i = "click");
	            }
	            var a = t.touches && t.touches.length > 0 ? t.touches[0] : t.changedTouches && t.changedTouches.length > 0 ? t.changedTouches[0] : t;
	            if (a) {
	                var h = Ro(a, n._containerDOM);
	                "touchstart" === r && Po(t);
	                for (var l = null, c = this.target.getRenderer().getTopElements(), u = o && 2 !== t.button, f = 0; f < c.length; f++) if (c[f].hitTest(h)) {
	                    var d = c[f].options.cursor;
	                    if (d && (l = d), u || c[f].events && c[f].events.indexOf(r) >= 0) {
	                        var m = {
	                            target: n,
	                            type: r,
	                            domEvent: t,
	                            containerPoint: h
	                        };
	                        if (u) return n._setPriorityCursor(l), void c[f].mousedown(m);
	                        c[f].onEvent(m);
	                    }
	                }
	                var g = n._getLayers((function(t) {
	                    return !(!t.identify || !t.options.geometryEvents);
	                }));
	                if (n._setPriorityCursor(l), g.length) {
	                    var p = {
	                        includeInternals: !0,
	                        filter: function(e) {
	                            if (!(e instanceof Mh)) return !1;
	                            var n = e._getEventTypeToFire(t);
	                            if ("mousemove" === r) {
	                                if (!l && e.options.cursor && (l = e.options.cursor), !e.listens("mousemove") && !e.listens("mouseover") && !e.listens("mouseenter")) return !1;
	                            } else if (!e.listens(n) && !e.listens(i)) return !1;
	                            return !0;
	                        },
	                        count: 1,
	                        containerPoint: h,
	                        onlyVisible: n.options.onlyVisibleGeometryEvents,
	                        layers: g
	                    }, _ = function(e) {
	                        var o = !0;
	                        if ("mousemove" === r) {
	                            var s = {};
	                            if (e.length > 0) for (var a = e.length - 1; a >= 0; a--) {
	                                var h = e[a];
	                                if (h instanceof Mh) {
	                                    var c = h._getInternalId();
	                                    s[c] = h, h._onEvent(t), this._prevOverGeos && this._prevOverGeos.geomap[c] || h._onEvent(t, "mouseenter"), 
	                                    o = h._onEvent(t, "mouseover");
	                                }
	                            }
	                            n._setPriorityCursor(l);
	                            var u = this._prevOverGeos && this._prevOverGeos.geos;
	                            if (this._prevOverGeos = {
	                                geos: e,
	                                geomap: s
	                            }, u && u.length > 0) for (var f = u.length - 1; f >= 0; f--) {
	                                var d = u[f];
	                                if (d instanceof Mh) {
	                                    var m = u[f]._getInternalId();
	                                    s[m] || (o = d._onEvent(t, "mouseout"));
	                                }
	                            }
	                        } else {
	                            if (!e || !e.length) return;
	                            for (var g = e.length - 1; g >= 0; g--) if (e[g] instanceof Mh) {
	                                o = e[g]._onEvent(t), i && e[g]._onEvent(t, i);
	                                break;
	                            }
	                        }
	                        !1 === o && Ao(t);
	                    }.bind(this);
	                    "mousemove" === r || "touchmove" === r ? this._queryIdentifyTimeout = n.getRenderer().callInNextFrame((function() {
	                        n.isInteracting() || n.identifyAtPoint(p, _);
	                    })) : n.identifyAtPoint(p, _);
	                }
	            }
	        }
	    }, e;
	}(es);

	Fh.mergeOptions({
	    geometryEvents: !0,
	    onlyVisibleGeometryEvents: !0
	}), Fh.addOnLoadHook("addHandler", "geometryEvents", Bh);

	var Gh = function(t) {
	    function e(e) {
	        var n;
	        return (n = t.call(this, e) || this)._thisScrollZoom = n._scrollZoom.bind(Si$1(Si$1(n))), 
	        n._wheelZoomRate = 1 / 450, n._defaultZoomRate = .01, n._delta = 0, n;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.addHooks = function() {
	        Mo(this.target._containerDOM, "wheel", this._onWheelScroll, this);
	    }, n.removeHooks = function() {
	        To(this.target._containerDOM, "wheel", this._onWheelScroll);
	    }, n._onWheelScroll = function(t) {
	        Po(t), Ao(t);
	        var e = this.target;
	        if (e._ignoreEvent(t) || !e.options.zoomable) return !1;
	        var n = e._checkZoomOrigin(Ro(t, e._containerDOM));
	        return e.options.seamlessZoom ? (this._zooming || (this._trackPadSuspect = 0, this._ensureTrackpad = !1), 
	        this._seamless(t, n)) : this._interval(t, n);
	    }, n._seamless = function(t, e) {
	        var n = t.deltaMode === window.WheelEvent.DOM_DELTA_LINE ? 60 * t.deltaY : t.deltaY;
	        if (n % 4.000244140625 != 0 && (this._ensureTrackpad || (Math.abs(n) < 60 ? this._trackPadSuspect++ : this._trackPadSuspect = 0, 
	        this._trackPadSuspect >= 2 && (this._ensureTrackpad = !0)), this._ensureTrackpad && (n *= 14)), 
	        t.shiftKey && n && (n /= 4), this._lastWheelEvent = t, this._delta -= n, !this._zooming && this._delta) {
	            var i = this.target;
	            this._zoomOrigin = e, i.onZoomStart(null, e);
	        }
	        this._start();
	    }, n._start = function() {
	        this._delta && (this._zooming = !0, this._active || (this.target.getRenderer().callInNextFrame(this._thisScrollZoom), 
	        this._active = !0));
	    }, n._scrollZoom = function() {
	        var t = this;
	        if (this._active = !1, this._delta) {
	            var e = Math.abs(this._delta) > 4.000244140625 ? this._wheelZoomRate : this._defaultZoomRate, n = 2 / (1 + Math.exp(-Math.abs(this._delta * e)));
	            this._delta < 0 && 0 !== n && (n = 1 / n);
	            var i = this.target, r = i.getZoom(), o = i.getZoomForScale(n, r, !0);
	            this._delta = 0, i.onZooming(o, this._zoomOrigin), this._timeout && clearTimeout(this._timeout), 
	            this._timeout = setTimeout((function() {
	                t._zooming = !1, delete t._timeout, i.onZoomEnd(i.getZoom(), t._zoomOrigin);
	            }), 210);
	        }
	    }, n._interval = function(t, e) {
	        var n = this, i = this.target;
	        if (this._zooming) return this._requesting++, !1;
	        this._requesting = 0;
	        var r = (t.deltaY ? -1 * t.deltaY : t.wheelDelta ? t.wheelDelta : t.detail) > 0 ? 1 : -1;
	        t.detail && (r *= -1);
	        var o = i.getZoom(), s = o + r;
	        if ((s = i._checkZoom(r > 0 ? Math.ceil(s) : Math.floor(s))) === o) return !1;
	        this._zooming = !0, this._delta || (i.onZoomStart(null, e), this._origin = e, this._delta = r, 
	        this._startZoom = i.getZoom());
	        return i._animateTo({
	            zoom: s - 1 * this._delta / 2,
	            around: this._origin
	        }, {
	            continueOnViewChanged: !0,
	            easing: "linear",
	            duration: 90,
	            wheelZoom: !0
	        }, (function(e) {
	            "finished" === e.state.playState ? n._requesting < 1 || Math.abs(s - n._startZoom) > 2 || s === i.getMaxZoom() || s === i.getMinZoom() ? (i._animateTo({
	                zoom: s,
	                around: n._origin
	            }, {
	                continueOnViewChanged: !0,
	                duration: 100
	            }, (function(t) {
	                "running" !== t.state.playState && (delete n._zooming, delete n._requesting);
	            })), delete n._startZoom, delete n._origin, delete n._delta, n._requesting = 0) : Dn(n._requesting) || (delete n._zooming, 
	            n._onWheelScroll(t)) : "running" !== e.state.playState && (delete n._zooming, delete n._requesting);
	        })), !1;
	    }, e;
	}(es);

	Fh.mergeOptions({
	    scrollWheelZoom: !0,
	    seamlessZoom: !0
	}), Fh.addOnLoadHook("addHandler", "scrollWheelZoom", Gh);

	var Vh = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.addHooks = function() {
	        Mo(this.target.getContainer(), "touchstart", this._onTouchStart, this);
	    }, n.removeHooks = function() {
	        To(this.target.getContainer(), "touchstart", this._onTouchStart);
	    }, n._onTouchStart = function(t) {
	        var e = this.target;
	        if (t.touches && !(t.touches.length < 2)) {
	            var n = e.getContainer(), i = Ro(t.touches[0], n), r = Ro(t.touches[1], n);
	            this.preY = i.y, this._startP1 = i, this._startP2 = r, this._startDist = i.distanceTo(r), 
	            this._startVector = i.sub(r), this._startZoom = e.getZoom(), this._startBearing = e.getBearing(), 
	            No(document, "touchmove", this._onTouchMove), No(document, "touchend", this._onTouchEnd), 
	            Mo(document, "touchmove", this._onTouchMove, this), Mo(document, "touchend", this._onTouchEnd, this), 
	            Po(t), e._fireEvent("touchactstart");
	        }
	    }, n._onTouchMove = function(t) {
	        var e = this.target;
	        if (t.touches && !(t.touches.length < 2)) {
	            var n = e.getContainer(), i = Ro(t.touches[0], n), r = Ro(t.touches[1], n), o = i.sub(this._startP1), s = r.sub(this._startP2), a = i.sub(r), h = i.distanceTo(r) / this._startDist, l = 180 * a.angleWith(this._startVector) / Math.PI, c = .4 * ((this.preY || i.y) - i.y);
	            this.preY = i.y;
	            var u = {
	                domEvent: t,
	                mousePos: [ i, r ]
	            };
	            if (this.mode || (e.options.touchRotate && Math.abs(l) > 8 ? this.mode = e.options.touchZoomRotate ? "rotate_zoom" : "rotate" : e.options.touchPitch && o.y * s.y > 0 && Math.abs(o.y) > 10 && Math.abs(s.y) > 10 ? this.mode = "pitch" : e.options.zoomable && e.options.touchZoom && Math.abs(1 - h) > .15 && (this.mode = e.options.touchZoomRotate && e.options.touchRotate ? "rotate_zoom" : "zoom"), 
	            this._startTouching(u)), "zoom" === this.mode || "rotate_zoom" === this.mode) {
	                this._scale = h;
	                var f = e._getResolution(this._startZoom) / h, d = e.getZoomFromRes(f);
	                e.onZooming(d, this._Origin);
	            }
	            "rotate" === this.mode || "rotate_zoom" === this.mode ? (e._setBearing(this._startBearing + l), 
	            e.onDragRotating(u)) : "pitch" === this.mode && (e._setPitch(e.getPitch() + c), 
	            e.onDragRotating(u)), e._fireEvent("touchactinging");
	        }
	    }, n._startTouching = function(t) {
	        var e = this.target;
	        if ("zoom" === this.mode || "rotate_zoom" === this.mode) {
	            var n = e.getSize();
	            this._Origin = new Oi$1(n.width / 2, n.height / 2), e.onZoomStart(null, this._Origin);
	        }
	        "rotate" !== this.mode && "pitch" !== this.mode && "rotate_zoom" !== this.mode || e.onDragRotateStart(t);
	    }, n._onTouchEnd = function(t) {
	        delete this.preY;
	        var e = this.target;
	        if (No(document, "touchmove", this._onTouchMove), No(document, "touchend", this._onTouchEnd), 
	        "zoom" === this.mode || "rotate_zoom" === this.mode) {
	            var n = this._scale, i = e._getResolution(this._startZoom) / n, r = e.getZoomFromRes(i);
	            e.onZoomEnd(r, this._Origin);
	        }
	        "pitch" !== this.mode && "rotate" !== this.mode && "rotate_zoom" !== this.mode || e.onDragRotateEnd({
	            domEvent: t
	        }), delete this.mode, e._fireEvent("touchactend");
	    }, e;
	}(es);

	Fh.mergeOptions({
	    touchGesture: !0,
	    touchZoom: !0,
	    touchPitch: !0,
	    touchRotate: !0,
	    touchZoomRotate: !1
	}), Fh.addOnLoadHook("addHandler", "touchGesture", Vh);

	var Uh = "__anim_player", Wh = {
	    outExpo: function(t) {
	        return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
	    },
	    outQuint: function(t) {
	        return 1 - Math.pow(1 - t, 5);
	    },
	    in: function(t) {
	        return Math.pow(t, 2);
	    },
	    out: function(t) {
	        return 1 - Wh.in(1 - t);
	    },
	    inAndOut: function(t) {
	        return 3 * t * t - 2 * t * t * t;
	    },
	    linear: function(t) {
	        return t;
	    },
	    upAndDown: function(t) {
	        return t < .5 ? Wh.inAndOut(2 * t) : 1 - Wh.inAndOut(2 * (t - .5));
	    }
	}, Zh = function(t, e) {
	    this.state = t, this.styles = e;
	}, Xh = function(t, e, n, i) {
	    this._animation = t, this.options = e, this._onFrame = n, this.playState = "idle", 
	    this.ready = !0, this.finished = !1, this.target = i;
	}, Jh = {
	    speed: {
	        slow: 2e3,
	        normal: 1e3,
	        fast: 500
	    },
	    _resolveStyles: function(t) {
	        if (!t) return null;
	        function e(t) {
	            if (!Array.isArray(t)) return Jh._resolveStyles(t);
	            for (var e = [], n = [], i = [], r = 0; r < t.length; r++) {
	                var o = Jh._resolveStyles(t[r]);
	                o && (e.push(o[0]), n.push(o[1]), i.push(o[2]));
	            }
	            return e.length ? [ e, n, i ] : null;
	        }
	        function n(t) {
	            var e, n = t;
	            Array.isArray(t) || (n = Ln(t) ? [ 0, t ] : t instanceof Oi$1 || t instanceof us ? [ new (e = t.constructor)(0, 0), t ] : [ t, t ]);
	            var i = n[0], r = n[1];
	            return Ln(i) && Ln(r) ? i === r ? null : [ i, r - i, r ] : Array.isArray(i) && Ln(i[0]) || i instanceof us || i instanceof Oi$1 ? (Array.isArray(i) ? (i = new us(i), 
	            r = new us(r)) : (i = new (e = i.constructor)(i), r = new e(r)), i.equals(r) ? null : [ i, r.sub(i), r ]) : [ i, r, r ];
	        }
	        var i, r = {}, o = {}, s = {};
	        for (var a in t) if (t.hasOwnProperty(a)) {
	            var h = t[a];
	            if (!h) continue;
	            if (Array.isArray(h) && (Dn(h[0]) || Dn(h[1]))) continue;
	            var l = void 0;
	            i = h, (l = !Array.isArray(i) && i.constructor === Object || Array.isArray(i) && i[0].constructor === Object ? e(h) : n(h)) && (o[a] = l[0], 
	            r[a] = l[1], s[a] = l[2]);
	        }
	        return [ o, r, s ];
	    },
	    framing: function(t, e) {
	        e || (e = {});
	        var n, i, r, o = e.easing ? Wh[e.easing] : Wh.linear;
	        o || (o = Wh.linear), (t = Jh._resolveStyles(t)) && (i = t[0], n = t[1], r = t[2]);
	        return function(t, e) {
	            var s, a;
	            if (t < 0) s = {
	                playState: "idle",
	                delta: 0
	            }, a = i; else if (t < e) {
	                var h = o(t / e);
	                s = {
	                    playState: "running",
	                    delta: h
	                }, a = function t(e, n, i) {
	                    if (!n || !i) return null;
	                    var o = {};
	                    for (var s in i) if (i.hasOwnProperty(s)) {
	                        if (n[s] === r[s]) {
	                            o[s] = n[s];
	                            continue;
	                        }
	                        var a = n[s], h = i[s];
	                        if (Ln(h)) o[s] = a + e * h; else if (Array.isArray(h)) {
	                            for (var l = [], c = 0; c < h.length; c++) l.push(t(e, a[c], h[c]));
	                            o[s] = l;
	                        } else {
	                            o[s] = h.constructor === Object ? t(e, a, h) : a instanceof Oi$1 || a instanceof us ? a.add(h.multi(e)) : h;
	                        }
	                    }
	                    return o;
	                }(h, i, n);
	            } else s = {
	                playState: "finished",
	                delta: 1
	            }, a = r;
	            return s.startStyles = i, s.destStyles = r, s.progress = t, s.remainingMs = e - t, 
	            new Zh(s, a);
	        };
	    },
	    _requestAnimFrame: function(t) {
	        this._frameQueue || (this._frameQueue = []), this._frameQueue.push(t), this._a();
	    },
	    _a: function() {
	        this._animationFrameId || (this._animationFrameId = Pi$1(Jh._frameFn));
	    },
	    _run: function() {
	        if (this._frameQueue.length) {
	            var t = this._frameQueue;
	            this._frameQueue = [];
	            for (var e = 0, n = t.length; e < n; e++) t[e]();
	            this._frameQueue.length ? this._animationFrameId = Pi$1(Jh._frameFn) : delete this._animationFrameId;
	        }
	    },
	    animate: function(t, e, n, i) {
	        e || (e = {});
	        var r = Jh.framing(t, e);
	        return new Xh(r, e, n, i);
	    }
	};

	Jh._frameFn = Jh._run.bind(Jh), kn(Xh.prototype, {
	    _prepare: function() {
	        var t = this.options, e = t.speed || t.duration;
	        jn(e) && ((e = Jh.speed[e]) || (e = +e)), e || (e = Jh.speed.normal), this.duration = e, 
	        this._framer = t.framer || Jh._requestAnimFrame.bind(Jh);
	    },
	    play: function() {
	        if ("idle" !== this.playState && "paused" !== this.playState || this.target && this.target[Uh]) return this;
	        this.target && (this.target[Uh] = 1), "idle" === this.playState && (this.currentTime = 0, 
	        this._prepare());
	        var t = In();
	        if (!this.startTime) {
	            var e = this.options;
	            this.startTime = e.startTime ? e.startTime : t;
	        }
	        return this._playStartTime = Math.max(t, this.startTime), "paused" === this.playState && (this._playStartTime -= this.currentTime), 
	        this.playState = "running", this._run(), this;
	    },
	    pause: function() {
	        return "paused" === this.playState || (this.playState = "paused", this._run()), 
	        this;
	    },
	    cancel: function() {
	        return "idle" === this.playState || (this.playState = "idle", this.finished = !1, 
	        this._run()), this;
	    },
	    finish: function() {
	        return "finished" === this.playState || (this.playState = "finished", this.finished = !0, 
	        this._run()), this;
	    },
	    reverse: function() {},
	    _run: function() {
	        var t = this, e = this._onFrame, n = In(), i = n - this._playStartTime;
	        if (this.options.repeat && i >= this.duration && (this._playStartTime = n, i = 0), 
	        "running" === this.playState) {
	            var r = this._animation(i, this.duration);
	            this.playState = r.state.playState, "running" !== this.playState && this.target && delete this.target[Uh], 
	            "idle" === this.playState ? this.startTime > n && setTimeout(this._run.bind(this), this.startTime - n) : "running" === this.playState ? this._framer((function() {
	                "running" === t.playState && (t.currentTime = i, e && e(r), t._run());
	            })) : "finished" === this.playState && (this.finished = !0, e && e(r));
	        } else if (this.target && delete this.target[Uh], e) {
	            "finished" === this.playState ? i = this.duration : "idle" === this.playState && (i = 0);
	            var o = this._animation(i, this.duration);
	            o.state.playState = this.playState, e(o);
	        }
	    }
	});

	var qh = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.animateShow = function(t, e) {
	        var n = this;
	        void 0 === t && (t = {}), this._showPlayer && this._showPlayer.finish(), Hn(t) && (e = t = {});
	        var i = this.getCoordinates();
	        if (0 === i.length) return this;
	        this._animIdx = 0, this._animLenSoFar = 0, this.show();
	        var r = !!this.getShell ? this.getShell().concat(this.getShell()[0]) : i, o = this._getProjection(), s = o.projectCoords(r, this.options.antiMeridian);
	        this._prjAniShowCenter = this._getPrjExtent().getCenter(), this._aniShowCenter = o.unproject(this._prjAniShowCenter);
	        var a = t.duration || 1e3, h = t.easing || "out";
	        this.setCoordinates([]);
	        var l = 0;
	        s.length && (s[0]._distance = 0);
	        for (var c = 1; c < s.length; c++) {
	            var u = s[c].distanceTo(s[c - 1]);
	            s[c]._distance = u, l += u;
	        }
	        this._tempCoord = new us(0, 0), this._tempPrjCoord = new Oi$1(0, 0);
	        var f = this._showPlayer = Jh.animate({
	            t: a
	        }, {
	            duration: a,
	            easing: h
	        }, (function(t) {
	            if (n.getMap()) {
	                var o = n._drawAnimShowFrame(t.styles.t, a, l, r, s);
	                "finished" === t.state.playState && (delete n._showPlayer, delete n._aniShowCenter, 
	                delete n._prjAniShowCenter, delete n._animIdx, delete n._animLenSoFar, delete n._animTailRatio, 
	                delete n._tempCoord, delete n._tempPrjCoord, n.setCoordinates(i)), e && e(t, o);
	            } else if ("finished" !== f.playState && (f.finish(), e)) {
	                var h = n.getCoordinates();
	                e(t, h[h.length - 1]);
	            }
	        }), this);
	        return f.play(), f;
	    }, n._drawAnimShowFrame = function(t, e, n, i, r) {
	        if (0 === t) return i[0];
	        var o, s, a = t / e * n, h = 0;
	        for (o = this._animIdx + 1, s = r.length; o < s && !(this._animLenSoFar + (h = r[o]._distance) > a); o++) this._animLenSoFar += h;
	        if (this._animIdx = o - 1, this._animIdx >= s - 1) return this.setCoordinates(i), 
	        i[i.length - 1];
	        var l = this._animIdx, c = r[l], u = r[l + 1], f = (a - this._animLenSoFar) / h;
	        this._animTailRatio = f;
	        var d = c.y + (u.y - c.y) * f;
	        this._tempPrjCoord.x = c.x + (u.x - c.x) * f, this._tempPrjCoord.y = d;
	        var m = this._tempPrjCoord, g = i[l], p = i[l + 1], _ = g.y + (p.y - g.y) * f;
	        this._tempCoord.x = g.x + (p.x - g.x) * f, this._tempCoord.y = _;
	        var v = this._tempCoord, y = !!this.getShell;
	        if (!y && this.options.smoothness > 0) {
	            for (var x = [], b = [], w = 0; w <= this._animIdx; w++) x.push(i[w]), b.push(r[w]);
	            x.push(v, v), b.push(m, m), this.setCoordinates(x), this._setPrjCoordinates(b);
	        } else {
	            var C = i.slice(0, this._animIdx + 1);
	            C.push(v);
	            var M = r.slice(0, this._animIdx + 1);
	            M.push(m), y ? (this.setCoordinates([ this._aniShowCenter ].concat(C)), this._setPrjCoordinates([ this._prjAniShowCenter ].concat(M))) : (this.setCoordinates(C), 
	            this._setPrjCoordinates(M));
	        }
	        return v;
	    }, n._getCenterInExtent = function(t, e, n) {
	        var i = this.getExtent();
	        if (!t.intersects(i)) return null;
	        var r = n(e, t);
	        if (0 === r.length) return null;
	        var o = 0, s = 0, a = 0;
	        r.forEach((function(t) {
	            Array.isArray(t) ? t.forEach((function(t) {
	                t.point && (t = t.point), o += t.x, s += t.y, a++;
	            })) : (t.point && (t = t.point), o += t.x, s += t.y, a++);
	        }));
	        var h = new us(o, s)._multi(1 / a);
	        return h.count = a, h;
	    }, n._getPath2DPoints = function(t, e, n) {
	        if (!Zi$1(t)) return [];
	        var i = this.getMap(), r = !e && this._shouldSimplify(), o = this.options.simplifyTolerance * i._getResolution(), s = Array.isArray(t[0]);
	        if (delete this._simplified, r && !s) {
	            var a = t.length;
	            t = yn(t, o, !1), this._simplified = t.length < a;
	        }
	        if (n || (n = i._getResolution()), Array.isArray(t)) {
	            var h = [];
	            if (!Array.isArray(t[0])) return h = sr(t, "_glPt"), i._prjsToPointsAtRes(t, n, h);
	            for (var l = [], c = 0, u = t.length; c < u; c++) {
	                var f = t[c];
	                h = sr(f, "_glPt");
	                var d = i._prjsToPointsAtRes(f, n, h);
	                l.push(d);
	            }
	            return l;
	        }
	        return i._prjToPointAtRes(t, n);
	    }, n._shouldSimplify = function() {
	        var t = this.getLayer(), e = this.getProperties(), n = e && t.options.enableAltitude && !Dn(e[t.options.altitudeProperty]) && 0 !== e[t.options.altitudeProperty];
	        return t && t.options.enableSimplify && !n && this.options.enableSimplify && !this._showPlayer;
	    }, n._setPrjCoordinates = function(t) {
	        this._prjCoords = t, this.onShapeChanged();
	    }, n._getPrjCoordinates = function() {
	        return this._verifyProjection(), !this._prjCoords && this._getProjection() && (this._prjCoords = this._projectCoords(this._coordinates)), 
	        this._prjCoords;
	    }, n._updateCache = function() {
	        this._clearCache(), this._getProjection() && this._prjCoords && (this._coordinates = this._unprojectCoords(this._getPrjCoordinates()));
	    }, n._clearProjection = function() {
	        this._prjCoords = null, t.prototype._clearProjection.call(this);
	    }, n._projectCoords = function(t) {
	        var e = this._getProjection();
	        return e ? e.projectCoords(t, this.options.antiMeridian) : [];
	    }, n._unprojectCoords = function(t) {
	        var e = this._getProjection();
	        return e ? e.unprojectCoords(t) : [];
	    }, n._computeCenter = function() {
	        var t = this._coordinates;
	        if (!Zi$1(t)) return null;
	        for (var e = 0, n = 0, i = 0, r = t.length, o = 0; o < r; o++) t[o] && Ln(t[o].x) && Ln(t[o].y) && (e += t[o].x, 
	        n += t[o].y, i++);
	        return new us(e / i, n / i);
	    }, n._computeExtent = function() {
	        var t = this._coordinates;
	        if (!Zi$1(t)) return null;
	        var e = [ t ];
	        return this.hasHoles && this.hasHoles() && e.push.apply(e, this.getHoles()), this._coords2Extent(e, this._getProjection());
	    }, n._computePrjExtent = function() {
	        var t = [ this._getPrjCoordinates() ];
	        return this.hasHoles && this.hasHoles() && t.push.apply(t, this._getPrjHoles()), 
	        this._coords2Extent(t);
	    }, n._get2DLength = function() {
	        for (var t = this._getPath2DPoints(this._getPrjCoordinates(), !0), e = 0, n = 1, i = t.length; n < i; n++) e += t[n].distanceTo(t[n - 1]);
	        return e;
	    }, n._hitTestTolerance = function() {
	        var e, n = this._getInternalSymbol();
	        if (Array.isArray(n)) {
	            e = 0;
	            for (var i = 0; i < n.length; i++) Ln(n[i].lineWidth) && n[i].lineWidth > e && (e = n[i].lineWidth);
	        } else e = n.lineWidth;
	        return t.prototype._hitTestTolerance.call(this) + (Ln(e) ? e / 2 : 1.5);
	    }, n._coords2Extent = function(t, e) {
	        if (!t || 0 === t.length || Array.isArray(t[0]) && 0 === t[0].length) return null;
	        for (var n = new Ts(e), i = 0, r = t.length; i < r; i++) for (var o = 0, s = t[i].length; o < s; o++) n._combine(t[i][o]);
	        return n;
	    }, e;
	}(Mh);

	qh.mergeOptions({
	    smoothness: 0,
	    enableClip: !0,
	    enableSimplify: !0,
	    simplifyTolerance: 2,
	    symbol: {
	        lineColor: "#000",
	        lineWidth: 2,
	        lineOpacity: 1,
	        polygonFill: "#fff",
	        polygonOpacity: 1,
	        opacity: 1
	    }
	});

	var Yh = function(t) {
	    function e(e, n) {
	        var i;
	        return (i = t.call(this, n) || this).type = "Polygon", e && i.setCoordinates(e), 
	        i;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getOutline = function() {
	        return this._getPainter() ? new e(this.getExtent().toArray(), {
	            symbol: {
	                lineWidth: 1,
	                lineColor: "6b707b"
	            }
	        }) : null;
	    }, n.setCoordinates = function(t) {
	        if (!t) return this._coordinates = null, this._holes = null, this._projectRings(), 
	        this;
	        var e = us.toCoordinates(t), n = e.length;
	        if (Array.isArray(e[0])) {
	            if (this._coordinates = this._trimRing(e[0]), n > 1) {
	                for (var i = [], r = 1; r < n; r++) e[r] && i.push(this._trimRing(e[r]));
	                this._holes = i;
	            }
	        } else this._coordinates = this._trimRing(e);
	        return this._projectRings(), this;
	    }, n.getCoordinates = function() {
	        if (!this._coordinates) return [];
	        for (var t = this.getHoles(), e = [ this._copyAndCloseRing(this._coordinates) ], n = 0, i = t.length; n < i; n++) e.push(this._copyAndCloseRing(t[n]));
	        return e;
	    }, n.getCenterInExtent = function(t) {
	        return this._getCenterInExtent(t, this.getShell(), Fa);
	    }, n.getShell = function() {
	        return this._coordinates || [];
	    }, n.getHoles = function() {
	        return this._holes || [];
	    }, n.hasHoles = function() {
	        return this.getHoles().length > 0;
	    }, n._projectRings = function() {
	        this.getMap() ? (this._prjCoords = this._projectCoords(this._coordinates), this._prjHoles = this._projectCoords(this._holes), 
	        this.onShapeChanged()) : this.onShapeChanged();
	    }, n._setPrjCoordinates = function(t) {
	        this._prjCoords = t, this.onShapeChanged();
	    }, n._cleanRing = function(t) {
	        for (var e = t.length - 1; e >= 0; e--) t[e] || t.splice(e, 1);
	    }, n._checkRing = function(t) {
	        if (this._cleanRing(t), !t || !Zi$1(t)) return !1;
	        var e = t[t.length - 1], n = !0;
	        return t[0].x === e.x && t[0].y === e.y || (n = !1), n;
	    }, n._trimRing = function(t) {
	        var e = this._checkRing(t);
	        return Zi$1(t) && e && t.splice(t.length - 1, 1), t;
	    }, n._copyAndCloseRing = function(t) {
	        t = t.slice(0);
	        var e = this._checkRing(t);
	        return Zi$1(t) && !e ? (t.push(t[0].copy()), t) : t;
	    }, n._getPrjShell = function() {
	        return "Polygon" === this.getJSONType() ? this._getPrjCoordinates() : (this._verifyProjection(), 
	        this._getProjection() && !this._prjShell && (this._prjShell = this._projectCoords(this.getShell())), 
	        this._prjShell);
	    }, n._getPrjHoles = function() {
	        var t = this._getProjection();
	        return this._verifyProjection(), t && !this._prjHoles && (this._prjHoles = this._projectCoords(this.getHoles())), 
	        this._prjHoles;
	    }, n._computeGeodesicLength = function(t) {
	        var e = this.getCoordinates();
	        if (!Zi$1(e)) return 0;
	        for (var n = 0, i = 0, r = e.length; i < r; i++) n += t.measureLength(e[i]);
	        return n;
	    }, n._computeGeodesicArea = function(t) {
	        var e = this.getCoordinates();
	        if (!Zi$1(e)) return 0;
	        for (var n = t.measureArea(e[0]), i = 1, r = e.length; i < r; i++) n -= t.measureArea(e[i]);
	        return n;
	    }, n._updateCache = function() {
	        t.prototype._updateCache.call(this), this._prjHoles && (this._holes = this._unprojectCoords(this._getPrjHoles()));
	    }, n._clearCache = function() {
	        return delete this._prjShell, t.prototype._clearCache.call(this);
	    }, n._clearProjection = function() {
	        this._prjHoles && (this._prjHoles = null), this._prjShell && (this._prjShell = null), 
	        t.prototype._clearProjection.call(this);
	    }, e;
	}(qh);

	function Kh(t) {
	    return function(t) {
	        function e() {
	            return t.apply(this, arguments) || this;
	        }
	        Ti$1(e, t);
	        var n = e.prototype;
	        return n.getCoordinates = function() {
	            return this._coordinates;
	        }, n.setCoordinates = function(t) {
	            var e = t instanceof us ? t : new us(t);
	            if (e.equals(this._coordinates)) return this;
	            if (this._coordinates = e, !this.getMap()) return this._dirtyCoords = !0, this.onPositionChanged(), 
	            this;
	            var n = this._getProjection();
	            return this._setPrjCoordinates(n.project(this._coordinates)), this;
	        }, n._getCenter2DPoint = function(t) {
	            var e = this.getMap();
	            if (!e) return null;
	            var n = this._getPrjCoordinates();
	            return n ? (t || (t = e._getResolution()), e._prjToPointAtRes(n, t)) : null;
	        }, n._getPrjCoordinates = function() {
	            var t = this._getProjection();
	            return this._verifyProjection(), !this._pcenter && t && this._coordinates && (this._pcenter = t.project(this._coordinates)), 
	            this._pcenter;
	        }, n._setPrjCoordinates = function(t) {
	            this._pcenter = t, this.onPositionChanged();
	        }, n._updateCache = function() {
	            this._clearCache();
	            var t = this._getProjection();
	            this._pcenter && t && (this._coordinates = t.unproject(this._pcenter));
	        }, n._clearProjection = function() {
	            this._pcenter = null, t.prototype._clearProjection.call(this);
	        }, n._computeCenter = function() {
	            return this._coordinates ? this._coordinates.copy() : null;
	        }, e;
	    }(t);
	}

	Yh.registerJSONType("Polygon");

	var Qh = new Ps, $h = function(t) {
	    function e(e, n) {
	        var i;
	        return (i = t.call(this, n) || this).type = "Point", e && i.setCoordinates(e), i;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getOutline = function() {
	        var t = this.getCoordinates(), n = this.getContainerExtent(), i = this.getMap().coordToContainerPoint(t);
	        return new e(t, {
	            symbol: {
	                markerType: "square",
	                markerWidth: n.getWidth(),
	                markerHeight: n.getHeight(),
	                markerLineWidth: 1,
	                markerLineColor: "6b707b",
	                markerFill: "rgba(0, 0, 0, 0)",
	                markerDx: n.xmin - (i.x - n.getWidth() / 2),
	                markerDy: n.ymin - (i.y - n.getHeight() / 2)
	            }
	        });
	    }, n.setSymbol = function() {
	        var e;
	        delete this._fixedExtent;
	        for (var n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
	        return (e = t.prototype.setSymbol).call.apply(e, [ this ].concat(i));
	    }, n._getSizeSymbol = function(t) {
	        for (var e, n = {}, i = !1, r = !1, o = 0; o < ka.length; o++) {
	            var s = t[ka[o]];
	            Dn(s) || (!i && _r(s) && (i = !0, r = !0), n[ka[o]] = s);
	        }
	        for (var a = 0; a < Da.length; a++) {
	            var h = t[Da[a]];
	            Dn(h) || (!i && _r(h) && (i = !0), n[Da[a]] = h);
	        }
	        return i ? (e = zr(n, this), r && (e._dynamic = !0)) : e = n, e;
	    }, n._setExternSymbol = function(e) {
	        return this._symbol || delete this._fixedExtent, t.prototype._setExternSymbol.call(this, e);
	    }, n._isDynamicSize = function() {
	        return this._sizeSymbol && this._sizeSymbol._dynamic;
	    }, n._getFixedExtent = function() {
	        if (this._fixedExtent && !this._isDynamicSize()) return this._fixedExtent;
	        this._fixedExtent = this._fixedExtent || new Ps, this._fixedExtent.set(null, null, null, null);
	        var t = this._sizeSymbol;
	        if (!t) return this._fixedExtent;
	        var e = this.getLayer() && this.getLayer().getRenderer(), n = e && e.resources, i = this.getTextDesc();
	        if (Array.isArray(t)) {
	            Qh.set(1 / 0, 1 / 0, -1 / 0, -1 / 0);
	            for (var r = 0; r < t.length; r++) t[r] && this._fixedExtent._combine(Pa(Qh, t[r], n, i && i[r]));
	        } else this._fixedExtent = Pa(this._fixedExtent, t, n, i);
	        return this._fixedExtent;
	    }, n._isVectorMarker = function() {
	        var t = this._getInternalSymbol();
	        return !Array.isArray(t) && Oa(t);
	    }, n._canEdit = function() {
	        var t = this._getInternalSymbol();
	        return !Array.isArray(t) && (Oa(t) || Ra(t) || Ea(t));
	    }, n._containsPoint = function(e, n) {
	        var i = this.getContainerExtent();
	        return n && (i = i.expand(n)), !!i.contains(e) && (!this.options.hitTestForEvent || t.prototype._containsPoint.call(this, e, n));
	    }, n._computeExtent = function() {
	        return tl.call(this, "getCenter");
	    }, n._computePrjExtent = function() {
	        return tl.call(this, "_getPrjCoordinates");
	    }, n._computeGeodesicLength = function() {
	        return 0;
	    }, n._computeGeodesicArea = function() {
	        return 0;
	    }, n._getSprite = function(t, e) {
	        return this._getPainter() ? this._getPainter().getSprite(t, e) : new _h(this).getSprite(t, e);
	    }, e;
	}(Kh(Mh));

	function tl(t) {
	    var e = this[t]();
	    return e ? new Ts(e, e, this._getProjection()) : null;
	}

	$h.mergeOptions({
	    symbol: {
	        markerType: "path",
	        markerPath: [ {
	            path: "M8 23l0 0 0 0 0 0 0 0 0 0c-4,-5 -8,-10 -8,-14 0,-5 4,-9 8,-9l0 0 0 0c4,0 8,4 8,9 0,4 -4,9 -8,14z M3,9 a5,5 0,1,0,0,-0.9Z",
	            fill: "#DE3333"
	        } ],
	        markerPathWidth: 16,
	        markerPathHeight: 23,
	        markerWidth: 24,
	        markerHeight: 34
	    },
	    hitTestForEvent: !1
	}), $h.registerJSONType("Marker");

	var el = function(t) {
	    function e(e, n) {
	        var i;
	        return (i = t.call(this, n) || this).type = "LineString", e && i.setCoordinates(e), 
	        i;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getOutline = function() {
	        return Yh.prototype.getOutline.call(this);
	    }, n.setCoordinates = function(t) {
	        return t ? (this._coordinates = us.toCoordinates(t), this.getMap() ? this._setPrjCoordinates(this._projectCoords(this._coordinates)) : this.onShapeChanged(), 
	        this) : (this._coordinates = null, this._setPrjCoordinates(null), this);
	    }, n.getCoordinates = function() {
	        return this._coordinates || [];
	    }, n.getCenterInExtent = function(t) {
	        return this._getCenterInExtent(t, this.getCoordinates(), La);
	    }, n._computeGeodesicLength = function(t) {
	        return t.measureLength(this.getCoordinates());
	    }, n._computeGeodesicArea = function() {
	        return 0;
	    }, e;
	}(qh);

	el.mergeOptions({
	    arrowStyle: null,
	    arrowPlacement: "vertex-last"
	}), el.registerJSONType("LineString");

	var nl = new Ps, il = function(t) {
	    function e(e, n) {
	        var i;
	        return (i = t.call(this, n) || this).type = "GeometryCollection", i.setGeometries(e), 
	        i;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getContainerExtent = function(t) {
	        var e = t || new Ps;
	        return this.forEach((function(t) {
	            e._combine(t.getContainerExtent(nl));
	        })), e;
	    }, n.setGeometries = function(t) {
	        for (var e = this._checkGeometries(t || []), n = this._getSymbol(), i = this.config(), r = e.length - 1; r >= 0; r--) e[r]._initOptions(i), 
	        e[r]._setParent(this), e[r]._setEventParent(this), n && e[r].setSymbol(n);
	        return this._geometries = e, this.getLayer() && (this._bindGeometriesToLayer(), 
	        this.onShapeChanged()), this;
	    }, n.getGeometries = function() {
	        return this._geometries || [];
	    }, n.forEach = function(t, e) {
	        for (var n = this.getGeometries(), i = 0, r = n.length; i < r; i++) n[i] && (e ? t.call(e, n[i], i) : t(n[i], i));
	        return this;
	    }, n.filter = function(t, n) {
	        if (!t) return new e;
	        var i = [], r = Hn(t), o = r ? t : Cr(t);
	        return this.forEach((function(t) {
	            var e = r ? t : Ir(t);
	            (n ? o.call(n, e) : o(e)) && i.push(t);
	        }), this), new e(i);
	    }, n.translate = function(t) {
	        if (!t) return this;
	        if (this.isEmpty()) return this;
	        var e = arguments;
	        return this.forEach((function(t) {
	            t && t.translate && t.translate.apply(t, e);
	        })), this;
	    }, n.isEmpty = function() {
	        return !Zi$1(this.getGeometries());
	    }, n.remove = function() {
	        return this.forEach((function(t) {
	            t._unbind();
	        })), Mh.prototype.remove.apply(this, arguments);
	    }, n.show = function() {
	        return this.options.visible = !0, this.forEach((function(t) {
	            t.show();
	        })), this;
	    }, n.hide = function() {
	        return this.options.visible = !1, this.forEach((function(t) {
	            t.hide();
	        })), this;
	    }, n.onConfig = function(t) {
	        this.forEach((function(e) {
	            e.config(t);
	        }));
	    }, n.getSymbol = function() {
	        var e = t.prototype.getSymbol.call(this);
	        if (!e) {
	            var n = [], i = !1;
	            this.forEach((function(t) {
	                t.getSymbol() && !i && (i = !0), n.push(t.getSymbol());
	            })), i && (e = {
	                children: n
	            });
	        }
	        return e;
	    }, n.setSymbol = function(t) {
	        if (t && t.children) this._symbol = null, this.forEach((function(e, n) {
	            e.setSymbol(t.children[n]);
	        })); else {
	            var e = this._prepareSymbol(t);
	            this._symbol = e, this.forEach((function(t) {
	                t.setSymbol(e);
	            }));
	        }
	        return this.onSymbolChanged(), this;
	    }, n._setExternSymbol = function(t) {
	        return t = this._prepareSymbol(t), this._externSymbol = t, this.forEach((function(e) {
	            e._setExternSymbol(t);
	        })), this.onSymbolChanged(), this;
	    }, n._bindLayer = function() {
	        t.prototype._bindLayer.apply(this, arguments), this._bindGeometriesToLayer();
	    }, n._bindGeometriesToLayer = function() {
	        var t = this.getLayer();
	        this.forEach((function(e) {
	            e._bindLayer(t);
	        }));
	    }, n._checkGeometries = function(t) {
	        if (t && !Array.isArray(t)) {
	            if (t instanceof Mh) return [ t ];
	            throw new Error("The geometry added to collection is invalid.");
	        }
	        for (var e = 0, n = t.length; e < n; e++) if (!this._checkGeo(t[e])) throw new Error("The geometry added to collection is invalid. Index: " + e);
	        return t;
	    }, n._checkGeo = function(t) {
	        return t instanceof Mh;
	    }, n._updateCache = function() {
	        this._clearCache(), this.isEmpty() || this.forEach((function(t) {
	            t && t._updateCache && t._updateCache();
	        }));
	    }, n._removePainter = function() {
	        this._painter && this._painter.remove(), delete this._painter, this.forEach((function(t) {
	            t._removePainter();
	        }));
	    }, n._computeCenter = function(t) {
	        if (!t || this.isEmpty()) return null;
	        for (var e = 0, n = 0, i = 0, r = this.getGeometries(), o = 0, s = r.length; o < s; o++) if (r[o]) {
	            var a = r[o]._computeCenter(t);
	            a && (e += a.x, n += a.y, i++);
	        }
	        return 0 === i ? null : new us(e / i, n / i);
	    }, n._containsPoint = function(t, e) {
	        if (this.isEmpty()) return !1;
	        delete this._pickGeometryIndex;
	        for (var n = this.getGeometries(), i = 0, r = n.length; i < r; i++) if (n[i]._containsPoint(t, e)) return this._pickGeometryIndex = i, 
	        !0;
	        return !1;
	    }, n._computeExtent = function(t) {
	        return rl.call(this, t, "_computeExtent");
	    }, n._computePrjExtent = function(t) {
	        return rl.call(this, t, "_computePrjExtent");
	    }, n._computeGeodesicLength = function(t) {
	        if (!t || this.isEmpty()) return 0;
	        for (var e = this.getGeometries(), n = 0, i = 0, r = e.length; i < r; i++) e[i] && (n += e[i]._computeGeodesicLength(t));
	        return n;
	    }, n._computeGeodesicArea = function(t) {
	        if (!t || this.isEmpty()) return 0;
	        for (var e = this.getGeometries(), n = 0, i = 0, r = e.length; i < r; i++) e[i] && (n += e[i]._computeGeodesicArea(t));
	        return n;
	    }, n._exportGeoJSONGeometry = function() {
	        var t = [];
	        if (!this.isEmpty()) for (var e = this.getGeometries(), n = 0, i = e.length; n < i; n++) e[n] && t.push(e[n]._exportGeoJSONGeometry());
	        return {
	            type: "GeometryCollection",
	            geometries: t
	        };
	    }, n._toJSON = function(t) {
	        var e, n = {
	            type: "Feature",
	            geometry: {
	                type: "GeometryCollection",
	                geometries: this.getGeometries().filter((function(t) {
	                    return t && t._toJSON;
	                })).map((function(t) {
	                    var e = t._toJSON();
	                    return e.subType ? e : t._exportGeoJSONGeometry();
	                }))
	            }
	        }, i = this.getId();
	        return Dn(i) || (n.id = i), (Dn(t.properties) || t.properties) && (e = this._exportProperties()), 
	        n.properties = e, t.feature = n, t;
	    }, n._clearProjection = function() {
	        if (!this.isEmpty()) for (var t = this.getGeometries(), e = 0, n = t.length; e < n; e++) t[e] && t[e]._clearProjection();
	    }, n._getConnectPoints = function() {
	        var t = this.getExtent();
	        return [ new us(t.xmin, t.ymax), new us(t.xmax, t.ymin), new us(t.xmin, t.ymin), new us(t.xmax, t.ymax) ];
	    }, n._getExternalResources = function() {
	        if (this.isEmpty()) return [];
	        for (var t, e, n = this.getGeometries(), i = [], r = {}, o = 0, s = n.length; o < s; o++) if (n[o]) for (var a = 0, h = (t = Hr(n[o]._getInternalSymbol())).length; a < h; a++) r[e = t[a].join()] || (i.push(t[a]), 
	        r[e] = 1);
	        return i;
	    }, n.startEdit = function(t) {
	        var e = this;
	        if (this.isEmpty()) return this;
	        t || (t = {}), t.symbol && (this._originalSymbol = this.getSymbol(), this.setSymbol(t.symbol)), 
	        this._draggbleBeforeEdit = this.options.draggable, this.config("draggable", !1);
	        for (var n = this.getGeometries(), i = 0, r = n.length; i < r; i++) n[i].startEdit(t);
	        return this._editing = !0, this.hide(), setTimeout((function() {
	            e.fire("editstart");
	        }), 1), this;
	    }, n.endEdit = function() {
	        if (this.isEmpty()) return this;
	        for (var t = this.getGeometries(), e = 0, n = t.length; e < n; e++) t[e].endEdit();
	        return this._originalSymbol && (this.setSymbol(this._originalSymbol), delete this._originalSymbol), 
	        this._editing = !1, this.show(), this.config("draggable", this._draggbleBeforeEdit), 
	        this.fire("editend"), this;
	    }, n.isEditing = function() {
	        return !!this._editing;
	    }, e;
	}(Mh);

	function rl(t, e) {
	    if (this.isEmpty()) return null;
	    for (var n = new Ts, i = this.getGeometries(), r = 0, o = i.length; r < o; r++) if (i[r]) {
	        var s = i[r][e](t);
	        s && n._combine(s);
	    }
	    return n;
	}

	il.registerJSONType("GeometryCollection");

	var ol = function(t) {
	    function e(e, n, i, r) {
	        var o;
	        return (o = t.call(this, null, r) || this).GeometryType = e, o.type = n, o._initData(i), 
	        o;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getCoordinates = function() {
	        for (var t = [], e = this.getGeometries(), n = 0, i = e.length; n < i; n++) {
	            var r = e[n];
	            t.push(r.getShell && "Polygon" !== r.getJSONType() ? [ r.getShell() ] : r.getCoordinates());
	        }
	        return t;
	    }, n.setCoordinates = function(t) {
	        for (var e = [], n = 0, i = (t = t || []).length; n < i; n++) {
	            var r = new this.GeometryType(t[n], this.config());
	            e.push(r);
	        }
	        return this.setGeometries(e), this;
	    }, n._initData = function(t) {
	        (t = t || []).length && (t[0] instanceof this.GeometryType ? this.setGeometries(t) : this.setCoordinates(t));
	    }, n._checkGeo = function(t) {
	        return t instanceof this.GeometryType;
	    }, n._exportGeoJSONGeometry = function() {
	        var t = this.getCoordinates(), e = us.toNumberArrays(t);
	        return {
	            type: this.getType(),
	            coordinates: e
	        };
	    }, n._toJSON = function(t) {
	        return {
	            feature: this.toGeoJSON(t)
	        };
	    }, e;
	}(il), sl = function(t) {
	    function e(e, n) {
	        return t.call(this, $h, "MultiPoint", e, n) || this;
	    }
	    return Ti$1(e, t), e.prototype.findClosest = function(t) {
	        if (!t) return null;
	        var e = this.getCoordinates(), n = null, i = 1 / 0;
	        return e.forEach((function(e) {
	            var r, o, s, a, h = (s = (o = t).x - (r = e).x, a = o.y - r.y, Math.sqrt(s * s + a * a));
	            h < i && (n = e, i = h);
	        })), n;
	    }, e;
	}(ol);

	sl.registerJSONType("MultiPoint");

	var al = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    return Ti$1(e, t), e.prototype.getCenterInExtent = function(t) {
	        var e = this.getGeometries(), n = 0, i = 0, r = 0;
	        return e.forEach((function(e) {
	            var o = e.getCenterInExtent(t);
	            o && (n += o.x * o.count, i += o.y * o.count, r += o.count);
	        })), 0 === r ? null : new us(n, i)._multi(1 / r);
	    }, e;
	}(ol), hl = function(t) {
	    function e(e, n) {
	        return t.call(this, el, "MultiLineString", e, n) || this;
	    }
	    return Ti$1(e, t), e;
	}(al);

	hl.registerJSONType("MultiLineString");

	var ll = function(t) {
	    function e(e, n) {
	        return t.call(this, Yh, "MultiPolygon", e, n) || this;
	    }
	    return Ti$1(e, t), e;
	}(al);

	ll.registerJSONType("MultiPolygon");

	var cl = {
	    Marker: $h,
	    LineString: el,
	    Polygon: Yh,
	    MultiPoint: sl,
	    MultiLineString: hl,
	    MultiPolygon: ll
	}, ul = {
	    toGeometry: function(t, e) {
	        if (jn(t) && (t = zi$1(t)), Array.isArray(t)) {
	            for (var n = [], i = 0, r = t.length; i < r; i++) {
	                var o = ul._convert(t[i], e);
	                Array.isArray(o) ? Fi$1(n, o) : n.push(o);
	            }
	            return n;
	        }
	        return ul._convert(t, e);
	    },
	    _convert: function(t, e) {
	        if (!t || Dn(t.type)) return null;
	        var n = t.type;
	        if ("Feature" === n) {
	            var i = ul._convert(t.geometry);
	            return i ? (i.setId(t.id), i.setProperties(t.properties), e && e(i), i) : null;
	        }
	        if ("FeatureCollection" === n) {
	            var r = t.features;
	            return r ? ul.toGeometry(r, e) : null;
	        }
	        if ([ "Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon" ].indexOf(n) >= 0) {
	            var o = new cl["Point" === n ? "Marker" : n](t.coordinates);
	            return e && e(o), o;
	        }
	        if ("GeometryCollection" === n) {
	            var s = t.geometries;
	            if (!Zi$1(s)) {
	                var a = new il;
	                return e && e(a), a;
	            }
	            for (var h = [], l = s.length, c = 0; c < l; c++) h.push(s[c].subType ? Mh.getJSONClass(s[c].subType).fromJSON(s[c]) : ul._convert(s[c]));
	            var u = new il(h);
	            return e && e(u), u;
	        }
	        return null;
	    }
	}, fl = function(t) {
	    function e(e, n, i) {
	        var r;
	        return r = t.call(this, null, i) || this, e && r.setCoordinates(e), r._radius = n, 
	        r;
	    }
	    Ti$1(e, t), e.fromJSON = function(t) {
	        var n = t.feature, i = new e(t.coordinates, t.radius, t.options);
	        return i.setProperties(n.properties), i;
	    };
	    var n = e.prototype;
	    return n.getRadius = function() {
	        return this._radius;
	    }, n.setRadius = function(t) {
	        return this._radius = t, this.onShapeChanged(), this;
	    }, n.getShell = function() {
	        for (var t, e, n, i = this._getMeasurer(), r = this.getCoordinates(), o = this.options.numberOfShellPoints, s = this.getRadius(), a = [], h = 0, l = o - 1; h < l; h++) {
	            t = 360 * h / l * Math.PI / 180, e = s * Math.cos(t), n = s * Math.sin(t);
	            var c = i.locate(r, e, n);
	            a.push(c);
	        }
	        return a.push(a[0]), a;
	    }, n.getHoles = function() {
	        return [];
	    }, n.animateShow = function() {
	        return this.show();
	    }, n._containsPoint = function(e, n) {
	        var i = this.getMap();
	        if (i.getPitch()) return t.prototype._containsPoint.call(this, e, n);
	        var r = i._pointToContainerPoint(this._getCenter2DPoint()), o = this.getSize(), s = Dn(n) ? this._hitTestTolerance() : n, a = r.add(o.width / 2, o.height / 2);
	        return Na(e, r, a, s);
	    }, n._computePrjExtent = function(t) {
	        var e = this._getMinMax(t);
	        if (!e) return null;
	        var n = this._getPrjCoordinates(), i = e.map((function(e) {
	            return t.project(e);
	        })), r = i[1].x - n.x, o = i[3].y - n.y;
	        return new Ts(n.add(i[0].x - n.x, i[2].y - n.y), n.add(r, o));
	    }, n._computeExtent = function(t) {
	        var e = this._getMinMax(t);
	        return e ? new Ts(e[0].x, e[2].y, e[1].x, e[3].y, this._getProjection()) : null;
	    }, n._getMinMax = function(t) {
	        if (!t || !this._coordinates || Dn(this._radius)) return null;
	        var e = this._radius;
	        return [ t.locate(this._coordinates, -e, 0), t.locate(this._coordinates, e, 0), t.locate(this._coordinates, 0, e), t.locate(this._coordinates, 0, -e) ];
	    }, n._computeGeodesicLength = function() {
	        return Dn(this._radius) ? 0 : 2 * Math.PI * this._radius;
	    }, n._computeGeodesicArea = function() {
	        return Dn(this._radius) ? 0 : Math.PI * Math.pow(this._radius, 2);
	    }, n._exportGeoJSONGeometry = function() {
	        return {
	            type: "Polygon",
	            coordinates: us.toNumberArrays([ this.getShell() ])
	        };
	    }, n._toJSON = function(t) {
	        var e = this.getCenter(), n = kn({}, t);
	        n.geometry = !1;
	        var i = this.toGeoJSON(n);
	        return i.geometry = {
	            type: "Polygon"
	        }, {
	            feature: i,
	            subType: "Circle",
	            coordinates: [ e.x, e.y ],
	            radius: this.getRadius()
	        };
	    }, e;
	}(Kh(Yh));

	fl.mergeOptions({
	    numberOfShellPoints: 60
	}), fl.registerJSONType("Circle");

	var dl = function(t) {
	    function e(e, n, i, r) {
	        var o;
	        return o = t.call(this, null, r) || this, e && o.setCoordinates(e), o.width = n, 
	        o.height = i, o;
	    }
	    Ti$1(e, t), e.fromJSON = function(t) {
	        var n = t.feature, i = new e(t.coordinates, t.width, t.height, t.options);
	        return i.setProperties(n.properties), i;
	    };
	    var n = e.prototype;
	    return n.getWidth = function() {
	        return this.width;
	    }, n.setWidth = function(t) {
	        return this.width = t, this.onShapeChanged(), this;
	    }, n.getHeight = function() {
	        return this.height;
	    }, n.setHeight = function(t) {
	        return this.height = t, this.onShapeChanged(), this;
	    }, n.getShell = function() {
	        for (var t, e, n, i, r = this._getMeasurer(), o = this.getCoordinates(), s = this.options.numberOfShellPoints, a = this.getWidth(), h = this.getHeight(), l = [], c = Math.pow(a / 2, 2) * Math.pow(h / 2, 2), u = Math.pow(a / 2, 2), f = Math.pow(h / 2, 2), d = 0; d < s; d++) {
	            e = (t = 360 * d / s) * Math.PI / 180, n = Math.sqrt(c / (u * Math.pow(Math.tan(e), 2) + f)), 
	            i = Math.sqrt(c / (f * Math.pow(1 / Math.tan(e), 2) + u)), t > 90 && t < 270 && (n *= -1), 
	            t > 180 && t < 360 && (i *= -1);
	            var m = r.locate(o, n, i);
	            l.push(m);
	        }
	        return l;
	    }, n.getHoles = function() {
	        return [];
	    }, n.animateShow = function() {
	        return this.show();
	    }, n._containsPoint = function(e, n) {
	        var i = this.getMap();
	        if (i.isTransforming()) return t.prototype._containsPoint.call(this, e, n);
	        var r = i.getProjection(), o = Dn(n) ? this._hitTestTolerance() : n, s = r.projectCoords([ this._coordinates, i.locate(this._coordinates, this.getWidth() / 2, this.getHeight() / 2) ], this.options.antiMeridian);
	        return Na(e, i._prjToContainerPoint(s[0]), i._prjToContainerPoint(s[1]), o);
	    }, n._computePrjExtent = function() {
	        return fl.prototype._computePrjExtent.apply(this, arguments);
	    }, n._computeExtent = function() {
	        return fl.prototype._computeExtent.apply(this, arguments);
	    }, n._getMinMax = function(t) {
	        if (!t || !this._coordinates || Dn(this.width) || Dn(this.height)) return null;
	        var e = this.getWidth(), n = this.getHeight();
	        return [ t.locate(this._coordinates, -e / 2, 0), t.locate(this._coordinates, e / 2, 0), t.locate(this._coordinates, 0, -n / 2), t.locate(this._coordinates, 0, n / 2) ];
	    }, n._computeGeodesicLength = function() {
	        return Dn(this.width) || Dn(this.height) ? 0 : 2 * Math.PI * (this.width > this.height ? this.width : this.height) / 2 - 4 * Math.abs(this.width - this.height);
	    }, n._computeGeodesicArea = function() {
	        return Dn(this.width) || Dn(this.height) ? 0 : Math.PI * this.width * this.height / 4;
	    }, n._exportGeoJSONGeometry = function() {
	        return {
	            type: "Polygon",
	            coordinates: us.toNumberArrays([ this.getShell() ])
	        };
	    }, n._toJSON = function(t) {
	        var e = kn({}, t), n = this.getCenter();
	        e.geometry = !1;
	        var i = this.toGeoJSON(e);
	        return i.geometry = {
	            type: "Polygon"
	        }, {
	            feature: i,
	            subType: "Ellipse",
	            coordinates: [ n.x, n.y ],
	            width: this.getWidth(),
	            height: this.getHeight()
	        };
	    }, e;
	}(Kh(Yh));

	dl.mergeOptions({
	    numberOfShellPoints: 80
	}), dl.registerJSONType("Ellipse");

	var ml = function(t) {
	    function e(e, n, i, r) {
	        var o;
	        return o = t.call(this, null, r) || this, e && o.setCoordinates(e), o._width = n, 
	        o._height = i, o;
	    }
	    Ti$1(e, t), e.fromJSON = function(t) {
	        var n = t.feature, i = new e(t.coordinates, t.width, t.height, t.options);
	        return i.setProperties(n.properties), i;
	    };
	    var n = e.prototype;
	    return n.getCoordinates = function() {
	        return this._coordinates;
	    }, n.setCoordinates = function(t) {
	        if (this._coordinates = t instanceof us ? t : new us(t), !this._coordinates || !this.getMap()) return this.onPositionChanged(), 
	        this;
	        var e = this._getProjection();
	        return this._setPrjCoordinates(e.project(this._coordinates)), this;
	    }, n.getWidth = function() {
	        return this._width;
	    }, n.setWidth = function(t) {
	        return this._width = t, this.onShapeChanged(), this;
	    }, n.getHeight = function() {
	        return this._height;
	    }, n.setHeight = function(t) {
	        return this._height = t, this.onShapeChanged(), this;
	    }, n.getShell = function() {
	        var t = this._getMeasurer(), e = this._coordinates, n = this.getMap(), i = 1, r = -1;
	        if (n) {
	            var o = n.getFullExtent();
	            o.left > o.right && (i = -1), o.bottom > o.top && (r = 1);
	        }
	        var s = [];
	        return s.push(e), s.push(t.locate(e, i * this._width, 0)), s.push(t.locate(e, i * this._width, r * this._height)), 
	        s.push(t.locate(e, 0, r * this._height)), s.push(e), s;
	    }, n.getHoles = function() {
	        return [];
	    }, n.animateShow = function() {
	        return this.show();
	    }, n._getPrjCoordinates = function() {
	        var t = this._getProjection();
	        return this._verifyProjection(), !this._pnw && t && this._coordinates && (this._pnw = t.project(this._coordinates)), 
	        this._pnw;
	    }, n._setPrjCoordinates = function(t) {
	        this._pnw = t, this.onPositionChanged();
	    }, n._getPrjShell = function() {
	        var e = t.prototype._getPrjShell.call(this), n = this._getProjection();
	        if (!n.isSphere()) return e;
	        for (var i = n.getSphereExtent(), r = i.sx, o = i.sy, s = this._getProjection().getCircum(), a = e[0], h = 1, l = e.length; h < l; h++) {
	            var c = e[h], u = 0, f = 0;
	            r * (a.x - c.x) > 0 && (u = s.x * r), o * (a.y - c.y) < 0 && (f = s.y * o), e[h]._add(u, f);
	        }
	        return e;
	    }, n._updateCache = function() {
	        this._clearCache();
	        var t = this._getProjection();
	        this._pnw && t && (this._coordinates = t.unproject(this._pnw));
	    }, n._clearProjection = function() {
	        this._pnw = null, t.prototype._clearProjection.call(this);
	    }, n._computeCenter = function(t) {
	        return t.locate(this._coordinates, this._width / 2, -this._height / 2);
	    }, n._containsPoint = function(e, n) {
	        var i = this.getMap();
	        if (i.isTransforming()) return t.prototype._containsPoint.call(this, e, n);
	        var r = Dn(n) ? this._hitTestTolerance() : n, o = i._getResolution() * r, s = this._getPrjExtent().expand(o), a = i._containerPointToPrj(e);
	        return s.contains(a);
	    }, n._computePrjExtent = function(t) {
	        var e = this._getSouthEast(t);
	        if (!e) return null;
	        var n = t.projectCoords([ new us(this._coordinates.x, e.y), new us(e.x, this._coordinates.y) ], this.options.antiMeridian);
	        return new Ts(n[0], n[1]);
	    }, n._computeExtent = function(t) {
	        var e = this._getSouthEast(t);
	        return e ? new Ts(this._coordinates, e, this._getProjection()) : null;
	    }, n._getSouthEast = function(t) {
	        if (!t || !this._coordinates || Dn(this._width) || Dn(this._height)) return null;
	        var e = this.getWidth(), n = -this.getHeight();
	        if (t.fullExtent) {
	            var i = t.fullExtent;
	            e *= i.right > i.left ? 1 : -1, n *= i.top > i.bottom ? 1 : -1;
	        }
	        var r = t.locate(this._coordinates, e, 0), o = t.locate(this._coordinates, 0, n);
	        return r.y = o.y, r;
	    }, n._computeGeodesicLength = function() {
	        return Dn(this._width) || Dn(this._height) ? 0 : 2 * (this._width + this._height);
	    }, n._computeGeodesicArea = function() {
	        return Dn(this._width) || Dn(this._height) ? 0 : this._width * this._height;
	    }, n._exportGeoJSONGeometry = function() {
	        return {
	            type: "Polygon",
	            coordinates: us.toNumberArrays([ this.getShell() ])
	        };
	    }, n._toJSON = function(t) {
	        var e = kn({}, t), n = this.getCoordinates();
	        e.geometry = !1;
	        var i = this.toGeoJSON(e);
	        return i.geometry = {
	            type: "Polygon"
	        }, {
	            feature: i,
	            subType: "Rectangle",
	            coordinates: [ n.x, n.y ],
	            width: this.getWidth(),
	            height: this.getHeight()
	        };
	    }, e;
	}(Yh);

	ml.registerJSONType("Rectangle");

	var gl = function(t) {
	    function e(e, n, i, r, o) {
	        var s;
	        return (s = t.call(this, e, n, o) || this).startAngle = i, s.endAngle = r, s;
	    }
	    Ti$1(e, t), e.fromJSON = function(t) {
	        var n = t.feature, i = new e(t.coordinates, t.radius, t.startAngle, t.endAngle, t.options);
	        return i.setProperties(n.properties), i;
	    };
	    var n = e.prototype;
	    return n.getStartAngle = function() {
	        return this.startAngle;
	    }, n.setStartAngle = function(t) {
	        return this.startAngle = t, this.onShapeChanged(), this;
	    }, n.getEndAngle = function() {
	        return this.endAngle;
	    }, n.setEndAngle = function(t) {
	        return this.endAngle = t, this.onShapeChanged(), this;
	    }, n.getShell = function() {
	        for (var t, e, n, i = this._getMeasurer(), r = this.getCoordinates(), o = this.options.numberOfShellPoints - 2, s = this.getRadius(), a = [ r.copy() ], h = this.getStartAngle(), l = this.getEndAngle() - h, c = 0; c < o; c++) {
	            t = (l * c / (o - 1) + h) * Math.PI / 180, e = s * Math.cos(t), n = s * Math.sin(t);
	            var u = i.locate(r, e, n);
	            a.push(u);
	        }
	        return a.push(r.copy()), a;
	    }, n._containsPoint = function(e, n) {
	        var i = this.getMap();
	        if (i.isTransforming()) return t.prototype._containsPoint.call(this, e, n);
	        var r = i._pointToContainerPoint(this._getCenter2DPoint()), o = Dn(n) ? this._hitTestTolerance() : n, s = this.getSize(), a = r, h = e, l = Math.atan2(a.y - h.y, h.x - a.x), c = l < 0 ? 360 * (l + 2 * Math.PI) / (2 * Math.PI) : 360 * l / (2 * Math.PI), u = this.startAngle % 360, f = this.endAngle % 360, d = !1;
	        return d = u > f ? !(c > f && c < u) : c >= u && c <= f, h.distanceTo(a) <= s.width / 2 + o && d;
	    }, n._computeGeodesicLength = function() {
	        return Dn(this._radius) ? 0 : 2 * Math.PI * this._radius * Math.abs(this.startAngle - this.endAngle) / 360 + 2 * this._radius;
	    }, n._computeGeodesicArea = function() {
	        return Dn(this._radius) ? 0 : Math.PI * Math.pow(this._radius, 2) * Math.abs(this.startAngle - this.endAngle) / 360;
	    }, n._toJSON = function(t) {
	        var e = kn({}, t), n = this.getCenter();
	        e.geometry = !1;
	        var i = this.toGeoJSON(e);
	        return i.geometry = {
	            type: "Polygon"
	        }, {
	            feature: i,
	            subType: "Sector",
	            coordinates: [ n.x, n.y ],
	            radius: this.getRadius(),
	            startAngle: this.getStartAngle(),
	            endAngle: this.getEndAngle()
	        };
	    }, e;
	}(fl);

	gl.mergeOptions({
	    numberOfShellPoints: 60
	}), gl.registerJSONType("Sector");

	var pl = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n._arc = function(t, e, n) {
	        for (var i = this.options.arcDegree * Math.PI / 180, r = 1, o = e.length; r < o; r++) {
	            var s = qo._arcBetween(t, e[r - 1], e[r], i), a = [ e[r - 1].x + e[r].x - s[0], e[r - 1].y + e[r].y - s[1] ];
	            e[r - 1].nextCtrlPoint = a, e[r].prevCtrlPoint = a, qo._stroke(t, n);
	        }
	    }, n._quadraticCurve = function(t, e) {
	        if (e.length <= 2) qo._path(t, e); else {
	            var n, i;
	            for (n = 2, i = e.length; n < i; n += 2) t.quadraticCurveTo(e[n - 1].x, e[n - 1].y, e[n].x, e[n].y);
	            if ((n -= 1) < i) for (;n < i; n++) t.lineTo(e[n].x, e[n].y);
	        }
	    }, n._bezierCurve = function(t, e) {
	        if (e.length <= 3) qo._path(t, e); else {
	            var n, i;
	            for (n = 1, i = e.length; n + 2 < i; n += 3) t.bezierCurveTo(e[n].x, e[n].y, e[n + 1].x, e[n + 1].y, e[n + 2].x, e[n + 2].y);
	            if (n < i) for (;n < i; n++) t.lineTo(e[n].x, e[n].y);
	        }
	    }, n._getCurveArrowPoints = function(t, e, n, i, r, o) {
	        var s, a = e.length;
	        for (s = o; s < a; s += o) {
	            var h = this._getArrowShape(e[s - 1], e[s], n, i, r);
	            h && t.push(h);
	        }
	        if ((s -= o) < a - 1) for (s += 1; s < a; s++) {
	            var l = this._getArrowShape(e[s - 1], e[s], n, i, r);
	            l && t.push(l);
	        }
	    }, e;
	}(el);

	pl.mergeOptions({
	    enableSimplify: !1,
	    enableClip: !1
	});

	var _l = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n._toJSON = function(t) {
	        return {
	            feature: this.toGeoJSON(t),
	            subType: "ArcCurve"
	        };
	    }, n._paintOn = function(t, e, n) {
	        t.beginPath(), this._arc(t, e, n), qo._stroke(t, n), this._paintArrow(t, e, n);
	    }, e.fromJSON = function(t) {
	        var n = t.feature, i = new e(n.geometry.coordinates, t.options);
	        return i.setProperties(n.properties), i;
	    }, e;
	}(pl);

	_l.registerJSONType("ArcCurve"), _l.mergeOptions({
	    arcDegree: 90
	});

	var vl = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t), e.fromJSON = function(t) {
	        var n = t.feature, i = new e(n.geometry.coordinates, t.options);
	        return i.setProperties(n.properties), i;
	    };
	    var n = e.prototype;
	    return n._toJSON = function(t) {
	        return {
	            feature: this.toGeoJSON(t),
	            subType: "CubicBezierCurve"
	        };
	    }, n._paintOn = function(t, e, n) {
	        t.beginPath(), t.moveTo(e[0].x, e[0].y), this._bezierCurve(t, e), qo._stroke(t, n), 
	        this._paintArrow(t, e, n);
	    }, n._getArrowPoints = function(t, e, n, i, r) {
	        return this._getCurveArrowPoints(t, e, n, i, r, 3);
	    }, e;
	}(pl);

	vl.registerJSONType("CubicBezierCurve");

	var yl = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t), e.fromJSON = function(t) {
	        var n = t.feature, i = new e(n.geometry.coordinates, t.options);
	        return i.setProperties(n.properties), i;
	    };
	    var n = e.prototype;
	    return n._toJSON = function(t) {
	        return {
	            feature: this.toGeoJSON(t),
	            subType: "QuadBezierCurve"
	        };
	    }, n._paintOn = function(t, e, n) {
	        t.beginPath(), t.moveTo(e[0].x, e[0].y), this._quadraticCurve(t, e, n), qo._stroke(t, n), 
	        this._paintArrow(t, e, n);
	    }, n._getArrowPoints = function(t, e, n, i, r) {
	        return this._getCurveArrowPoints(t, e, n, i, r, 2);
	    }, e;
	}(pl);

	yl.registerJSONType("QuadBezierCurve");

	var xl = {
	    textFaceName: "monospace",
	    textSize: 12,
	    textLineSpacing: 8,
	    textWrapCharacter: "\n",
	    textHorizontalAlignment: "middle",
	    textVerticalAlignment: "middle"
	}, bl = {
	    markerType: "square",
	    markerLineColor: "#000",
	    markerLineWidth: 2,
	    markerLineOpacity: 1,
	    markerFill: "#fff",
	    markerOpacity: 1
	}, wl = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getContent = function() {
	        return this._content;
	    }, n.setContent = function(t) {
	        var e = this._content;
	        return this._content = Wr(t), this._refresh(), this._fireEvent("contentchange", {
	            old: e,
	            new: t
	        }), this;
	    }, n.onAdd = function() {
	        this._refresh();
	    }, n.toJSON = function() {
	        var e = t.prototype.toJSON.call(this);
	        return delete e.symbol, e;
	    }, n.setSymbol = function(e) {
	        if (this._refreshing || !e) return t.prototype.setSymbol.call(this, e);
	        var n = this._parseSymbol(e);
	        if (this.setTextStyle) {
	            var i = this.getTextStyle() || {};
	            i.symbol = n[0], this.setTextStyle(i);
	        } else this.setTextSymbol && this.setTextSymbol(n[0]);
	        if (this.setBoxStyle) {
	            var r = this.getBoxStyle() || {};
	            r.symbol = n[1], this.setBoxStyle(r);
	        } else this.setBoxSymbol && this.setBoxSymbol(n[1]);
	        return this;
	    }, n._parseSymbol = function(t) {
	        var e = {}, n = {};
	        for (var i in t) Bn(t, i) && (0 === i.indexOf("text") ? e[i] = t[i] : n[i] = t[i]);
	        return [ e, n ];
	    }, n._getTextSize = function(t) {
	        return no(this._content, t).size;
	    }, n._getInternalSymbol = function() {
	        return this._symbol;
	    }, n._getDefaultTextSymbol = function() {
	        return kn({}, xl);
	    }, n._getDefaultBoxSymbol = function() {
	        return kn({}, bl);
	    }, n._getDefaultPadding = function() {
	        return [ 12, 8 ];
	    }, e;
	}($h), Cl = function(t) {
	    function e(e, n, i, r, o) {
	        var s;
	        return void 0 === o && (o = {}), (s = t.call(this, n, o) || this)._content = Wr(e), 
	        s._width = Dn(i) ? 100 : i, s._height = Dn(r) ? 40 : r, o.boxSymbol && s.setBoxSymbol(o.boxSymbol), 
	        o.textStyle && s.setTextStyle(o.textStyle), s._refresh(), s;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getWidth = function() {
	        return this._width;
	    }, n.setWidth = function(t) {
	        return this._width = t, this._refresh(), this;
	    }, n.getHeight = function() {
	        return this._height;
	    }, n.setHeight = function(t) {
	        return this._height = t, this._refresh(), this;
	    }, n.getBoxSymbol = function() {
	        return kn({}, this.options.boxSymbol);
	    }, n.setBoxSymbol = function(t) {
	        return this.options.boxSymbol = t ? kn({}, t) : t, this.getSymbol() && this._refresh(), 
	        this;
	    }, n.getTextStyle = function() {
	        return this.options.textStyle ? kn({}, this.options.textStyle) : null;
	    }, n.setTextStyle = function(t) {
	        return this.options.textStyle = t ? kn({}, t) : t, this.getSymbol() && this._refresh(), 
	        this;
	    }, e.fromJSON = function(t) {
	        var n = t.feature, i = new e(t.content, n.geometry.coordinates, t.width, t.height, t.options);
	        return i.setProperties(n.properties), i.setId(n.id), t.symbol && i.setSymbol(t.symbol), 
	        i;
	    }, n._toJSON = function(t) {
	        return {
	            feature: this.toGeoJSON(t),
	            width: this.getWidth(),
	            height: this.getHeight(),
	            subType: "TextBox",
	            content: this._content
	        };
	    }, n._refresh = function() {
	        var t = this.getTextStyle() || {}, e = t.padding || [ 12, 8 ], n = this._width - 2 * e[0], i = this._height - 2 * e[1], r = kn({}, t.symbol || this._getDefaultTextSymbol(), this.options.boxSymbol || this._getDefaultBoxSymbol(), {
	            textName: this._content,
	            markerWidth: this._width,
	            markerHeight: this._height,
	            textHorizontalAlignment: "middle",
	            textVerticalAlignment: "middle",
	            textMaxWidth: n,
	            textMaxHeight: i
	        });
	        t.wrap && !r.textWrapWidth && (r.textWrapWidth = n);
	        var o = t.horizontalAlignment;
	        r.textDx = r.markerDx || 0;
	        var s = r.markerWidth / 2 - e[0];
	        "left" === o ? (r.textHorizontalAlignment = "right", r.textDx = r.textDx - s) : "right" === o && (r.textHorizontalAlignment = "left", 
	        r.textDx = r.textDx + s);
	        var a = t.verticalAlignment;
	        r.textDy = r.markerDy || 0;
	        var h = r.markerHeight / 2 - e[1];
	        "top" === a ? (r.textVerticalAlignment = "bottom", r.textDy -= h) : "bottom" === a && (r.textVerticalAlignment = "top", 
	        r.textDy += h), this._refreshing = !0, this.updateSymbol(r), delete this._refreshing;
	    }, e;
	}(wl);

	Cl.mergeOptions({
	    textStyle: {
	        wrap: !0,
	        padding: [ 12, 8 ],
	        verticalAlignment: "middle",
	        horizontalAlignment: "middle"
	    },
	    boxSymbol: null
	}), Cl.registerJSONType("TextBox");

	var Ml = function(t) {
	    function e(e, n, i) {
	        var r;
	        return void 0 === i && (i = {}), r = t.call(this, n, i) || this, i.textSymbol && r.setTextSymbol(i.textSymbol), 
	        i.boxStyle && r.setBoxStyle(i.boxStyle), r._content = Wr(e), r._refresh(), r;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getBoxStyle = function() {
	        return this.options.boxStyle ? kn({}, this.options.boxStyle) : null;
	    }, n.setBoxStyle = function(t) {
	        return this.options.boxStyle = t ? kn({}, t) : t, this._refresh(), this;
	    }, n.getTextSymbol = function() {
	        return kn({}, this._getDefaultTextSymbol(), this.options.textSymbol);
	    }, n.setTextSymbol = function(t) {
	        return this.options.textSymbol = t ? kn({}, t) : t, this._refresh(), this;
	    }, e.fromJSON = function(t) {
	        var n = t.feature, i = new e(t.content, n.geometry.coordinates, t.options);
	        return i.setProperties(n.properties), i.setId(n.id), t.symbol && i.setSymbol(t.symbol), 
	        i;
	    }, n._canEdit = function() {
	        return !1;
	    }, n._toJSON = function(t) {
	        return {
	            feature: this.toGeoJSON(t),
	            subType: "Label",
	            content: this._content
	        };
	    }, n._refresh = function() {
	        var t = kn({}, this.getTextSymbol(), {
	            textName: this._content
	        }), e = this.getBoxStyle();
	        if (e) {
	            kn(t, e.symbol);
	            var n = this._getBoxSize(t), i = n[1], r = e.padding || this._getDefaultPadding(), o = n[0];
	            t.markerWidth = o.width, t.markerHeight = o.height;
	            var s = t.textDx || 0, a = t.textDy || 0, h = to(i, t.textHorizontalAlignment, t.textVerticalAlignment)._add(s, a), l = e.horizontalAlignment || "middle";
	            t.markerDx = h.x, "left" === l ? t.markerDx += t.markerWidth / 2 - r[0] : "right" === l ? t.markerDx -= t.markerWidth / 2 - i.width - r[0] : t.markerDx += i.width / 2;
	            var c = e.verticalAlignment || "middle";
	            t.markerDy = h.y, "top" === c ? t.markerDy += t.markerHeight / 2 - r[1] : "bottom" === c ? t.markerDy -= t.markerHeight / 2 - i.height - r[1] : t.markerDy += i.height / 2;
	        }
	        this._refreshing = !0, this.updateSymbol(t), delete this._refreshing;
	    }, n._getBoxSize = function(t) {
	        t.markerType || (t.markerType = "square");
	        var e, n, i = this.getBoxStyle(), r = this._getTextSize(t), o = i.padding || this._getDefaultPadding();
	        return e = r.width + 2 * o[0], n = r.height + 2 * o[1], i.minWidth && (!e || e < i.minWidth) && (e = i.minWidth), 
	        i.minHeight && (!n || n < i.minHeight) && (n = i.minHeight), [ new Gr(e, n), r ];
	    }, e;
	}(wl);

	Ml.mergeOptions({
	    boxStyle: null,
	    textSymbol: null
	}), Ml.registerJSONType("Label");

	var Tl = function(t) {
	    return function(t) {
	        function e() {
	            return t.apply(this, arguments) || this;
	        }
	        Ti$1(e, t), e._hasConnectors = function(t) {
	            return !Dn(t.__connectors) && t.__connectors.length > 0;
	        }, e._getConnectors = function(t) {
	            return t.__connectors;
	        };
	        var n = e.prototype;
	        return n.getConnectSource = function() {
	            return this._connSource;
	        }, n.setConnectSource = function(t) {
	            var e = this._connTarget;
	            return this.onRemove(), this._connSource = t, this._connTarget = e, this.onAdd(), 
	            this;
	        }, n.getConnectTarget = function() {
	            return this._connTarget;
	        }, n.setConnectTarget = function(t) {
	            var e = this._connSource;
	            return this.onRemove(), this._connSource = e, this._connTarget = t, this._updateCoordinates(), 
	            this._registerEvents(), this;
	        }, n._updateCoordinates = function() {
	            var t = this.getMap();
	            if (!t && this._connSource && (t = this._connSource.getMap()), !t && this._connTarget && (t = this._connTarget.getMap()), 
	            t && this._connSource && this._connTarget) {
	                for (var e, n, i = this._connSource._getConnectPoints(), r = this._connTarget._getConnectPoints(), o = 0, s = this.getCoordinates(), a = 0, h = i.length; a < h; a++) for (var l = i[a], c = 0, u = r.length; c < u; c++) {
	                    var f = r[c], d = t.computeLength(l, f);
	                    0 === a && 0 === c ? (e = l, n = f, o = d) : d < o && (e = l, n = f);
	                }
	                Zi$1(s) && s[0].equals(e) && s[1].equals(n) || this.setCoordinates([ e, n ]);
	            }
	        }, n.onAdd = function() {
	            this._registerEvents(), this._updateCoordinates();
	        }, n.onRemove = function() {
	            if (this._connSource && (this._connSource.__connectors && ji$1(this, this._connSource.__connectors), 
	            this._connSource.off("dragging positionchange", this._updateCoordinates, this).off("remove", this.onRemove, this), 
	            this._connSource.off("dragstart mousedown mouseover", this._showConnect, this), 
	            this._connSource.off("dragend mouseup mouseout", this.hide, this), this._connSource.off("show", this._showConnect, this).off("hide", this.hide, this), 
	            delete this._connSource), this._connTarget && (ji$1(this, this._connTarget.__connectors), 
	            this._connTarget.off("dragging positionchange", this._updateCoordinates, this).off("remove", this.onRemove, this), 
	            this._connTarget.off("show", this._showConnect, this).off("hide", this.hide, this), 
	            delete this._connTarget), !(this._connSource instanceof Mh && this._connTarget instanceof Mh)) {
	                var t = this.getMap();
	                t && t.off("movestart moving moveend zoomstart zooming zoomend rotate pitch fovchange spatialreferencechange", this._updateCoordinates, this);
	            }
	        }, n._showConnect = function() {
	            this._connSource && this._connTarget && this._connSource.isVisible() && this._connTarget.isVisible() && (this._updateCoordinates(), 
	            this.show());
	        }, n._registerEvents = function() {
	            if (this._connSource && this._connTarget) {
	                this._connSource.__connectors || (this._connSource.__connectors = []), this._connTarget.__connectors || (this._connTarget.__connectors = []), 
	                this._connSource.__connectors.push(this), this._connTarget.__connectors.push(this), 
	                this._connSource.on("dragging positionchange", this._updateCoordinates, this).on("remove", this.remove, this), 
	                this._connTarget.on("dragging positionchange", this._updateCoordinates, this).on("remove", this.remove, this), 
	                this._connSource.on("show", this._showConnect, this).on("hide", this.hide, this), 
	                this._connTarget.on("show", this._showConnect, this).on("hide", this.hide, this);
	                var t = this.options.showOn;
	                if (this.hide(), "moving" === t ? (this._connSource.on("dragstart", this._showConnect, this).on("dragend", this.hide, this), 
	                this._connTarget.on("dragstart", this._showConnect, this).on("dragend", this.hide, this)) : "click" === t ? (this._connSource.on("mousedown", this._showConnect, this).on("mouseup", this.hide, this), 
	                this._connTarget.on("mousedown", this._showConnect, this).on("mouseup", this.hide, this)) : "mouseover" === t ? (this._connSource.on("mouseover", this._showConnect, this).on("mouseout", this.hide, this), 
	                this._connTarget.on("mouseover", this._showConnect, this).on("mouseout", this.hide, this)) : this._showConnect(), 
	                !(this._connSource instanceof Mh && this._connTarget instanceof Mh)) {
	                    var e = this.getMap();
	                    e && e.on("movestart moving moveend zoomstart zooming zoomend rotate pitch fovchange spatialreferencechange", this._updateCoordinates, this);
	                }
	            }
	        }, e;
	    }(t);
	}, Sl = {
	    showOn: "always"
	}, Pl = function(t) {
	    function e(e, n, i) {
	        var r;
	        return r = t.call(this, null, i) || this, 1 === arguments.length && (i = e, e = null, 
	        n = null), r._connSource = e, r._connTarget = n, r;
	    }
	    return Ti$1(e, t), e;
	}(Tl(el));

	Pl.mergeOptions(Sl), Pl.registerJSONType("ConnectorLine");

	var Al = function(t) {
	    function e(e, n, i) {
	        var r;
	        return r = t.call(this, null, i) || this, 1 === arguments.length && (i = e, e = null, 
	        n = null), r._connSource = e, r._connTarget = n, r;
	    }
	    return Ti$1(e, t), e;
	}(Tl(_l));

	Al.mergeOptions(Sl), Al.registerJSONType("ArcConnectorLine");

	var El = function(t) {
	    function e(e, n, i) {
	        var r;
	        n && !(n instanceof Mh) && !Array.isArray(n) && Pn.indexOf(n.type) < 0 && (i = n, 
	        n = null), (r = t.call(this, e, i) || this)._maxZIndex = 0, r._minZIndex = 0, r._initCache(), 
	        n && r.addGeometry(n);
	        var o = r.options.style;
	        return o && r.setStyle(o), r;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getGeometryById = function(t) {
	        return Dn(t) || "" === t ? null : this._geoMap[t] ? this._geoMap[t] : null;
	    }, n.getGeometries = function(t, e) {
	        if (!t) return this._geoList.slice(0);
	        for (var n, i = [], r = 0, o = this._geoList.length; r < o; r++) n = this._geoList[r], 
	        (e ? t.call(e, n) : t(n)) && i.push(n);
	        return i;
	    }, n.getFirstGeometry = function() {
	        return this._geoList.length ? this._geoList[0] : null;
	    }, n.getLastGeometry = function() {
	        var t = this._geoList.length;
	        return 0 === t ? null : this._geoList[t - 1];
	    }, n.getCount = function() {
	        return this._geoList.length;
	    }, n.getExtent = function() {
	        if (0 === this.getCount()) return null;
	        var t = new Ts(this.getProjection());
	        return this.forEach((function(e) {
	            t._combine(e.getExtent());
	        })), t;
	    }, n.forEach = function(t, e) {
	        for (var n = this._geoList.slice(0), i = 0, r = n.length; i < r; i++) e ? t.call(e, n[i], i) : t(n[i], i);
	        return this;
	    }, n.filter = function(t, e) {
	        var n = [], i = Hn(t), r = i ? t : Cr(t);
	        return this.forEach((function(t) {
	            var o = i ? t : Ir(t);
	            (e ? r.call(e, o) : r(o)) && n.push(t);
	        }), this), n;
	    }, n.isEmpty = function() {
	        return !this._geoList.length;
	    }, n.addGeometry = function(t, e) {
	        if (!t) return this;
	        if ("FeatureCollection" === t.type) return this.addGeometry(ul.toGeometry(t), e);
	        if (!Array.isArray(t)) {
	            var n = arguments.length, i = arguments[n - 1];
	            return t = Array.prototype.slice.call(arguments, 0, n - 1), e = i, i && Fn(i) && ("type" in i || i instanceof Mh) && (t.push(i), 
	            e = !1), this.addGeometry(t, e);
	        }
	        if (0 === t.length) return this;
	        var r;
	        this._initCache(), e && (r = new Ts), this._toSort = this._maxZIndex > 0;
	        for (var o = [], s = 0, a = t.length; s < a; s++) {
	            var h = t[s];
	            if (!h) throw new Error("Invalid geometry to add to layer(" + this.getId() + ") at index:" + s);
	            if (!(h instanceof Mh) && (h = Mh.fromJSON(h), Array.isArray(h))) for (var l = 0, c = h.length; l < c; l++) this._add(h[l], r, s), 
	            o.push(h[l]);
	            Array.isArray(h) || (this._add(h, r, s), o.push(h));
	        }
	        var u = this.getMap();
	        if (u && (this._getRenderer().onGeometryAdd(o), r && !Dn(r.xmin))) {
	            var f = r.getCenter(), d = u.getFitZoom(r);
	            if (Fn(e)) {
	                var m = Hn(e.step) ? e.step : function() {};
	                u.animateTo({
	                    center: f,
	                    zoom: d
	                }, kn({
	                    duration: u.options.zoomAnimationDuration,
	                    easing: "out"
	                }, e), m);
	            } else !0 === e && u.setCenterAndZoom(f, d);
	        }
	        return this.fire("addgeo", {
	            geometries: t
	        }), this;
	    }, n.getGeoMinZIndex = function() {
	        return this._minZIndex;
	    }, n.getGeoMaxZIndex = function() {
	        return this._maxZIndex;
	    }, n._add = function(t, e, n) {
	        this._toSort || (this._toSort = 0 !== t.getZIndex()), this._updateZIndex(t.getZIndex());
	        var i = t.getId();
	        if (!Dn(i)) {
	            if (!Dn(this._geoMap[i])) throw new Error("Duplicate geometry id in layer(" + this.getId() + "):" + i + ", at index:" + n);
	            this._geoMap[i] = t;
	        }
	        var r = Di$1();
	        t._setInternalId(r), this._geoList.push(t), this.onAddGeometry(t), t._bindLayer(this), 
	        t.onAdd && t.onAdd(), e && e._combine(t.getExtent()), t._fireEvent("add", {
	            layer: this
	        }), this._cookedStyles && this._styleGeometry(t);
	    }, n.removeGeometry = function(t) {
	        if (!Array.isArray(t)) return this.removeGeometry([ t ]);
	        for (var e = t.length - 1; e >= 0; e--) t[e] instanceof Mh || (t[e] = this.getGeometryById(t[e])), 
	        t[e] && this === t[e].getLayer() && t[e].remove();
	        return this.fire("removegeo", {
	            geometries: t
	        }), this;
	    }, n.clear = function() {
	        this._clearing = !0, this.forEach((function(t) {
	            t.remove();
	        })), this._geoMap = {};
	        var t = this._geoList;
	        this._geoList = [];
	        var e = this._getRenderer();
	        return e && (e.onGeometryRemove(t), e.clearImageData && e.clearImageData()), this._clearing = !1, 
	        this.fire("clear"), this;
	    }, n.onRemoveGeometry = function(t) {
	        if (t && !this._clearing && (this === t.getLayer() && !Dn(t._getInternalId()))) {
	            var e = t.getId();
	            Dn(e) || delete this._geoMap[e];
	            var n = this._findInList(t);
	            n >= 0 && this._geoList.splice(n, 1), this._getRenderer() && this._getRenderer().onGeometryRemove([ t ]);
	        }
	    }, n.getStyle = function() {
	        return this.options.style ? this.options.style : null;
	    }, n.setStyle = function(t) {
	        return this.options.style = t, t = lo(t), this._cookedStyles = function t(e) {
	            if (!Array.isArray(e)) return t([ e ]);
	            for (var n = [], i = 0; i < e.length; i++) {
	                var r = void 0;
	                r = !0 === e[i].filter ? function() {
	                    return !0;
	                } : Cr(e[i].filter), n.push(kr({}, e[i], {
	                    filter: r
	                }));
	            }
	            return n;
	        }(t), this.forEach((function(t) {
	            this._styleGeometry(t);
	        }), this), this.fire("setstyle", {
	            style: t
	        }), this;
	    }, n._styleGeometry = function(t) {
	        if (!this._cookedStyles) return !1;
	        for (var e = Ir(t), n = 0, i = this._cookedStyles.length; n < i; n++) if (!0 === this._cookedStyles[n].filter(e)) return t._setExternSymbol(this._cookedStyles[n].symbol), 
	        !0;
	        return !1;
	    }, n.removeStyle = function() {
	        return this.options.style ? (delete this.options.style, delete this._cookedStyles, 
	        this.forEach((function(t) {
	            t._setExternSymbol(null);
	        }), this), this.fire("removestyle"), this) : this;
	    }, n.onAddGeometry = function(t) {
	        this.getStyle() && this._styleGeometry(t);
	    }, n.hide = function() {
	        for (var t = 0, e = this._geoList.length; t < e; t++) this._geoList[t].onHide();
	        return Sh.prototype.hide.call(this);
	    }, n._initCache = function() {
	        this._geoList || (this._geoList = [], this._geoMap = {});
	    }, n._updateZIndex = function() {
	        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
	        this._maxZIndex = Math.max(this._maxZIndex, Math.max.apply(Math, e)), this._minZIndex = Math.min(this._minZIndex, Math.min.apply(Math, e));
	    }, n._sortGeometries = function() {
	        var t = this;
	        this._toSort && (this._maxZIndex = 0, this._minZIndex = 0, this._geoList.sort((function(e, n) {
	            return t._updateZIndex(e.getZIndex(), n.getZIndex()), t._compare(e, n);
	        })), this._toSort = !1);
	    }, n._compare = function(t, e) {
	        return t.getZIndex() === e.getZIndex() ? t._getInternalId() - e._getInternalId() : t.getZIndex() - e.getZIndex();
	    }, n._findInList = function(t) {
	        var e = this._geoList.length;
	        if (0 === e) return -1;
	        this._sortGeometries();
	        for (var n, i = 0, r = e - 1; i <= r; ) {
	            if (n = Math.floor((i + r) / 2), this._geoList[n] === t) return n;
	            this._compare(this._geoList[n], t) > 0 ? r = n - 1 : i = n + 1;
	        }
	        return -1;
	    }, n._onGeometryEvent = function(t) {
	        if (t && t.target) {
	            var e = t.type;
	            "idchange" === e ? this._onGeometryIdChange(t) : "zindexchange" === e ? this._onGeometryZIndexChange(t) : "positionchange" === e ? this._onGeometryPositionChange(t) : "shapechange" === e ? this._onGeometryShapeChange(t) : "symbolchange" === e ? this._onGeometrySymbolChange(t) : "show" === e ? this._onGeometryShow(t) : "hide" === e ? this._onGeometryHide(t) : "propertieschange" === e && this._onGeometryPropertiesChange(t);
	        }
	    }, n._onGeometryIdChange = function(t) {
	        if (t.new !== t.old || !this._geoMap[t.old] || this._geoMap[t.old] !== t.target) {
	            if (!Dn(t.new)) {
	                if (this._geoMap[t.new]) throw new Error("Duplicate geometry id in layer(" + this.getId() + "):" + t.new);
	                this._geoMap[t.new] = t.target;
	            }
	            Dn(t.old) || t.new === t.old || delete this._geoMap[t.old];
	        }
	    }, n._onGeometryZIndexChange = function(t) {
	        t.old !== t.new && (this._updateZIndex(t.new), this._toSort = !0, this._getRenderer() && this._getRenderer().onGeometryZIndexChange(t));
	    }, n._onGeometryPositionChange = function(t) {
	        this._getRenderer() && this._getRenderer().onGeometryPositionChange(t);
	    }, n._onGeometryShapeChange = function(t) {
	        this._getRenderer() && this._getRenderer().onGeometryShapeChange(t);
	    }, n._onGeometrySymbolChange = function(t) {
	        this._getRenderer() && this._getRenderer().onGeometrySymbolChange(t);
	    }, n._onGeometryShow = function(t) {
	        this._getRenderer() && this._getRenderer().onGeometryShow(t);
	    }, n._onGeometryHide = function(t) {
	        this._getRenderer() && this._getRenderer().onGeometryHide(t);
	    }, n._onGeometryPropertiesChange = function(t) {
	        this._getRenderer() && this._getRenderer().onGeometryPropertiesChange(t);
	    }, e;
	}(Sh);

	El.mergeOptions({
	    drawImmediate: !1
	});

	var Ol = new Ps, Rl = {
	    debug: !1,
	    enableSimplify: !0,
	    geometryEvents: !0,
	    defaultIconSize: [ 20, 20 ],
	    cacheVectorOnCanvas: !0,
	    cacheSvgOnCanvas: Mi$1.gecko,
	    enableAltitude: !1,
	    altitudeProperty: "altitude",
	    drawAltitude: !1,
	    sortByDistanceToCamera: !1,
	    roundPoint: !1,
	    altitude: 0,
	    clipBBoxBufferSize: 3,
	    geometryEventTolerance: 1
	}, Il = function(t) {
	    function e(e, n, i) {
	        return t.call(this, e, n, i) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.onConfig = function(e) {
	        if (t.prototype.onConfig.call(this, e), e.enableAltitude || e.drawAltitude || e.altitudeProperty) {
	            var n = this.getRenderer();
	            n && n.setToRedraw && n.setToRedraw();
	        }
	    }, n.identify = function(t, e) {
	        void 0 === e && (e = {});
	        var n = this.getRenderer();
	        t instanceof us || (t = new us(t));
	        var i = this.getMap().coordToContainerPoint(t);
	        return e.onlyVisible && n && n.identifyAtPoint ? n.identifyAtPoint(i, e) : this._hitGeos(this._geoList, i, e);
	    }, n.identifyAtPoint = function(t, e) {
	        void 0 === e && (e = {});
	        var n = this.getRenderer();
	        return t instanceof Oi$1 || (t = new Oi$1(t)), e.onlyVisible && n && n.identifyAtPoint ? n.identifyAtPoint(t, e) : this._hitGeos(this._geoList, t, e);
	    }, n._hitGeos = function(t, e, n) {
	        void 0 === n && (n = {});
	        var i = n.filter, r = [], o = n.tolerance, s = this.getMap(), a = this.getRenderer(), h = a && a.getImageData && a.getImageData();
	        if (h) {
	            for (var l = 0, c = t.length - 1; c >= 0; c--) {
	                var u = t[c]._hitTestTolerance() + (o || 0);
	                u > l && (l = u);
	            }
	            var f = s.getDevicePixelRatio();
	            h.r = f;
	            for (var d = !1, m = e.x - l, g = e.y - l, p = -l; p <= l; p++) {
	                for (var _ = -l; _ <= l; _++) {
	                    var v = Math.round((m + p) * f), y = Math.round((g + _) * f);
	                    if (h.data[y * h.width * 4 + 4 * v + 3] > 0) {
	                        d = !0;
	                        break;
	                    }
	                }
	                if (d) break;
	            }
	            if (!d) return r;
	        }
	        for (var x = t.length - 1; x >= 0; x--) {
	            var b = t[x];
	            if (b && b.isVisible() && b._getPainter() && b.options.interactive) {
	                if (!(b instanceof el && (b._getArrowStyle() || b instanceof pl))) {
	                    var w = b.getContainerExtent(Ol);
	                    if (o && (w = w._expand(o)), !w || !w.contains(e)) continue;
	                }
	                if (b._containsPoint(e, o) && (!i || i(b)) && (r.push(b), n.count && r.length >= n.count)) break;
	            }
	        }
	        return r;
	    }, n.getAltitude = function() {
	        return this.options.altitude || 0;
	    }, n.toJSON = function(t) {
	        t || (t = {});
	        var e = {
	            type: this.getJSONType(),
	            id: this.getId(),
	            options: this.config()
	        };
	        if (Dn(t.geometries) || t.geometries) {
	            var n;
	            if (t.clipExtent) {
	                var i = this.getMap(), r = i ? i.getProjection() : null;
	                n = new Ts(t.clipExtent, r);
	            }
	            for (var o = [], s = this.getGeometries(), a = 0, h = s.length; a < h; a++) {
	                var l = s[a], c = l.getExtent();
	                if (c && (!n || n.intersects(c))) {
	                    var u = l.toJSON(t.geometries);
	                    o.push(u);
	                }
	            }
	            e.geometries = o;
	        }
	        return e;
	    }, e.fromJSON = function(t) {
	        if (!t || "VectorLayer" !== t.type) return null;
	        for (var n = new e(t.id, t.options), i = t.geometries, r = [], o = 0; o < i.length; o++) {
	            var s = Mh.fromJSON(i[o]);
	            s && r.push(s);
	        }
	        return n.addGeometry(r), n;
	    }, e.getPainterClass = function() {
	        return _h;
	    }, e.getCollectionPainterClass = function() {
	        return yh;
	    }, e;
	}(El);

	Il.mergeOptions(Rl), Il.registerJSONType("VectorLayer");

	var kl = "_map_tool", Dl = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.addTo = function(t) {
	        return t ? (this._map = t, t[kl] && t[kl].disable(), this.onAdd && this.onAdd(), 
	        this.enable(), t[kl] = this, this._fireEvent("add"), this) : this;
	    }, n.getMap = function() {
	        return this._map;
	    }, n.enable = function() {
	        return !this._map || this._enabled || (this._enabled = !0, this._switchEvents("off"), 
	        this._registerEvents(), this.onEnable && this.onEnable(), this._fireEvent("enable")), 
	        this;
	    }, n.disable = function() {
	        return this._enabled && this._map ? (this._enabled = !1, this._switchEvents("off"), 
	        this.onDisable && this.onDisable(), this._fireEvent("disable"), this) : this;
	    }, n.isEnabled = function() {
	        return !!this._enabled;
	    }, n.remove = function() {
	        return this._map ? (this.disable(), this._map && (delete this._map[kl], delete this._map), 
	        this._fireEvent("remove"), this) : this;
	    }, n._registerEvents = function() {
	        this._switchEvents("on");
	    }, n._switchEvents = function(t) {
	        var e = this.getEvents();
	        e && this._map[t](e, this);
	    }, n._fireEvent = function(t, e) {
	        e || (e = {}), this.fire(t, e);
	    }, e;
	}(ts(ns)), Ll = {}, zl = function(t) {
	    function e(e) {
	        var n;
	        return (n = t.call(this, e) || this)._checkMode(), n._events = {
	            click: n._clickHandler,
	            "mousemove touchmove": n._mouseMoveHandler,
	            dblclick: n._doubleClickHandler,
	            "mousedown touchstart": n._mouseDownHandler,
	            "mouseup touchend": n._mouseUpHandler,
	            mousemove: n._mouseMoveHandler,
	            mousedown: n._mouseDownHandler,
	            mouseup: n._mouseUpHandler
	        }, n;
	    }
	    Ti$1(e, t), e.registerMode = function(t, e) {
	        Ll[t.toLowerCase()] = e;
	    }, e.getRegisterMode = function(t) {
	        return Ll[t.toLowerCase()];
	    };
	    var n = e.prototype;
	    return n.getMode = function() {
	        return this.options.mode ? this.options.mode.toLowerCase() : null;
	    }, n.setMode = function(t) {
	        return this._geometry && (this._geometry.remove(), delete this._geometry), this._clearStage(), 
	        this._switchEvents("off"), this.options.mode = t, this._checkMode(), this.isEnabled() && (this._switchEvents("on"), 
	        this._restoreMapCfg(), this._saveMapCfg()), this;
	    }, n.getSymbol = function() {
	        var t = this.options.symbol;
	        return ho(t || this.options.symbol);
	    }, n.setSymbol = function(t) {
	        return t ? (this.options.symbol = t, this._geometry && this._geometry.setSymbol(t), 
	        this) : this;
	    }, n.getCurrentGeometry = function() {
	        return this._geometry;
	    }, n.onAdd = function() {
	        this._checkMode();
	    }, n.onEnable = function() {
	        this._saveMapCfg(), this._drawToolLayer = this._getDrawLayer(), this._clearStage(), 
	        this._loadResources();
	        var t = this.getMap();
	        return this.options.autoPanAtEdge && (this._mapAutoPanAtEdge = t.options.autoPanAtEdge, 
	        this._mapAutoPanAtEdge || t.config({
	            autoPanAtEdge: !0
	        })), this._geometryEvents = t.options.geometryEvents, this.options.blockGeometryEvents && t.config("geometryEvents", !1), 
	        this;
	    }, n.onDisable = function() {
	        var t = this.getMap();
	        return this._restoreMapCfg(), this.endDraw(), this._map && (t.removeLayer(this._getDrawLayer()), 
	        this.options.autoPanAtEdge && (this._mapAutoPanAtEdge || t.config({
	            autoPanAtEdge: !1
	        }))), this.options.blockGeometryEvents && t.config("geometryEvents", this._geometryEvents), 
	        this;
	    }, n.undo = function() {
	        var t = this._getRegisterMode();
	        if (!this._shouldRecordHistory(t.action) || !this._historyPointer) return this;
	        var e = this._clickCoords.slice(0, --this._historyPointer);
	        return t.update(this.getMap().getProjection(), e, this._geometry), this;
	    }, n.redo = function() {
	        var t = this._getRegisterMode();
	        if (!this._shouldRecordHistory(t.action) || Dn(this._historyPointer) || this._historyPointer === this._clickCoords.length) return this;
	        var e = this._clickCoords.slice(0, ++this._historyPointer);
	        return t.update(this.getMap().getProjection(), e, this._geometry), this;
	    }, n._shouldRecordHistory = function(t) {
	        return Array.isArray(t) && "click" === t[0] && "mousemove" === t[1] && "dblclick" === t[2];
	    }, n._checkMode = function() {
	        this._getRegisterMode();
	    }, n._saveMapCfg = function() {
	        var t = this.getMap();
	        this._mapDoubleClickZoom = t.options.doubleClickZoom, t.config({
	            doubleClickZoom: this.options.doubleClickZoom
	        });
	        for (var e = this._getRegisterMode().action, n = !1, i = 0; i < e.length; i++) if (e[i].indexOf("mousedown") >= 0 || e[i].indexOf("touchstart") >= 0) {
	            n = !0;
	            break;
	        }
	        if (n) {
	            var r = this.getMap();
	            this._mapDraggable = r.options.draggable, r.config({
	                draggable: !1
	            });
	        }
	    }, n._restoreMapCfg = function() {
	        var t = this.getMap();
	        t.config({
	            doubleClickZoom: this._mapDoubleClickZoom
	        }), Dn(this._mapDraggable) || t.config("draggable", this._mapDraggable), delete this._mapDraggable, 
	        delete this._mapDoubleClickZoom;
	    }, n._loadResources = function() {
	        var t = Hr(this.getSymbol());
	        t.length > 0 && this._drawToolLayer._getRenderer().loadResources(t);
	    }, n._getProjection = function() {
	        return this._map.getProjection();
	    }, n._getRegisterMode = function() {
	        var t = this.getMode(), n = e.getRegisterMode(t);
	        if (!n) throw new Error(t + " is not a valid mode of DrawTool.");
	        return n;
	    }, n.getEvents = function() {
	        var t = this._getRegisterMode().action, e = {};
	        if (Array.isArray(t)) {
	            for (var n = 0; n < t.length; n++) e[t[n]] = this._events[t[n]];
	            return e;
	        }
	        return null;
	    }, n._mouseDownHandler = function(t) {
	        this._createGeometry(t);
	    }, n._mouseUpHandler = function(t) {
	        this.endDraw(t);
	    }, n._clickHandler = function(t) {
	        var e = this._getRegisterMode();
	        if (this._clickCoords && this._clickCoords.length) {
	            var n = this._clickCoords.length, i = this.getMap()._pointToPrj(t.point2d);
	            if (this._clickCoords[n - 1].equals(i)) return;
	        }
	        if (this._geometry) {
	            var r = this.getMap()._pointToPrj(t.point2d), o = this._geometry.snapTo;
	            if (o && Hn(o)) {
	                var s = this._geometry.snapTo(t.containerPoint) || t.containerPoint;
	                r = this.getMap()._containerPointToPrj(s);
	            }
	            if (Dn(this._historyPointer) || (this._clickCoords = this._clickCoords.slice(0, this._historyPointer)), 
	            this._clickCoords.push(r), this._historyPointer = this._clickCoords.length, t.drawTool = this, 
	            e.update(this.getMap().getProjection(), this._clickCoords, this._geometry, t), "point" === this.getMode()) return void this.endDraw(t);
	            this._fireEvent(this._clickCoords.length <= 1 ? "drawstart" : "drawvertex", t), 
	            e.clickLimit && e.clickLimit === this._historyPointer && this.endDraw(t);
	        } else this._createGeometry(t);
	    }, n._createGeometry = function(t) {
	        var e = this.getMode(), n = this._getRegisterMode(), i = this.getMap()._pointToPrj(t.point2d), r = this.getSymbol();
	        this._geometry || (this._clickCoords = [ i ], t.drawTool = this, this._geometry = n.create(this.getMap().getProjection(), this._clickCoords, t), 
	        r && "point" !== e ? this._geometry.setSymbol(r) : this.options.hasOwnProperty("symbol") && this._geometry.setSymbol(this.options.symbol), 
	        this._addGeometryToStage(this._geometry), this._fireEvent("drawstart", t)), "point" === e && "mousemove" !== t.type && this.endDraw(t);
	    }, n._mouseMoveHandler = function(t) {
	        var e = this.getMap();
	        if (e && !e.isInteracting()) if ("point" !== this.getMode() || this._geometry) {
	            if (this._geometry) {
	                var n = this._getMouseContainerPoint(t);
	                if (this._isValidContainerPoint(n)) {
	                    var i = this.getMap()._pointToPrj(t.point2d);
	                    this._geometry.snapTo && (n = this._geometry.snapTo(n) || n, i = e._containerPointToPrj(n));
	                    var r = e.getProjection();
	                    t.drawTool = this;
	                    var o = this._getRegisterMode();
	                    if (this._shouldRecordHistory(o.action)) {
	                        var s = this._clickCoords.slice(0, this._historyPointer);
	                        if (s && s.length > 0 && i.equals(s[s.length - 1])) return;
	                        o.update(r, s.concat([ i ]), this._geometry, t);
	                    } else o.update(r, i, this._geometry, t);
	                    this._fireEvent("mousemove", t);
	                }
	            }
	        } else this._createGeometry(t);
	    }, n._doubleClickHandler = function(t) {
	        if (this._geometry) {
	            var e = this._getMouseContainerPoint(t);
	            if (this._isValidContainerPoint(e)) {
	                var n = this._getRegisterMode(), i = this._clickCoords;
	                if (!(i.length < 2)) {
	                    var r = this.getMode();
	                    if (!(r && r.indexOf("polygon") > -1 && i.length < 3)) {
	                        for (var o = this.getMap().getProjection(), s = [ i[0] ], a = 1, h = i.length; a < h; a++) i[a].x === i[a - 1].x && i[a].y === i[a - 1].y || s.push(i[a]);
	                        s.length < 2 || this._geometry && this._geometry instanceof Yh && s.length < 3 || (t.drawTool = this, 
	                        n.update(o, s, this._geometry, t), this.endDraw(t));
	                    }
	                }
	            }
	        }
	    }, n._addGeometryToStage = function(t) {
	        this._getDrawLayer().addGeometry(t);
	    }, n.endDraw = function(t) {
	        if (!this._geometry || this._ending) return this;
	        this._ending = !0;
	        var e = this._geometry;
	        return this._clearStage(), t = t || {}, this._geometry = e, this._fireEvent("drawend", t), 
	        delete this._geometry, this.options.once && this.disable(), delete this._ending, 
	        delete this._historyPointer, this._vertexes && (this._vertexes = []), this;
	    }, n._clearStage = function() {
	        this._getDrawLayer().clear(), delete this._geometry, delete this._clickCoords;
	    }, n._getMouseContainerPoint = function(t) {
	        var e = this._getRegisterMode().action;
	        return (e[0].indexOf("mousedown") >= 0 || e[0].indexOf("touchstart") >= 0) && Ao(t.domEvent), 
	        t.containerPoint;
	    }, n._isValidContainerPoint = function(t) {
	        var e = this._map.getSize();
	        return !(t.x < 0 || t.y < 0) && !(t.x > e.width || t.y > e.height);
	    }, n._getDrawLayer = function() {
	        var t = "_maptalks__internal_layer_drawtool", e = this._map.getLayer(t);
	        return e || (e = new Il(t, {
	            enableSimplify: !1,
	            enableAltitude: this.options.enableAltitude
	        }), this._map.addLayer(e)), e;
	    }, n._fireEvent = function(t, e) {
	        e || (e = {}), e = kn({}, e), this._geometry && (e.geometry = this._getRegisterMode().generate(this._geometry, {
	            drawTool: this
	        }), e.tempGeometry = this._geometry), Dl.prototype._fireEvent.call(this, t, e);
	    }, e;
	}(Dl);

	zl.mergeOptions({
	    symbol: {
	        lineColor: "#000",
	        lineWidth: 2,
	        lineOpacity: 1,
	        polygonFill: "#fff",
	        polygonOpacity: .3
	    },
	    doubleClickZoom: !1,
	    mode: null,
	    once: !1,
	    autoPanAtEdge: !1,
	    ignoreMouseleave: !0,
	    blockGeometryEvents: !1
	});

	var Fl = function(t) {
	    function e(e) {
	        var n;
	        return (n = t.call(this, e) || this).drawTool = new zl({
	            mode: "boxZoom",
	            ignoreMouseleave: !1
	        }), n;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.addHooks = function() {
	        this.target.on("_mousedown", this._onMouseDown, this);
	    }, n.removeHooks = function() {
	        this.target.off("_mousedown", this._onMouseDown, this), this.drawTool.isEnabled() && this.drawTool.remove();
	    }, n._onMouseDown = function(t) {
	        this.target.options.boxZoom && t.domEvent.shiftKey && this.drawTool.setSymbol(this.target.options.boxZoomSymbol).on("drawend", this._boxZoom, this).addTo(this.target);
	    }, n._boxZoom = function(t) {
	        var e = this.target;
	        this.drawTool.remove();
	        var n = t.geometry, i = n.getCenter(), r = n.getSymbol(), o = new Ts(i, e.locateByPoint(i, r.markerWidth, r.markerHeight), e.getProjection()), s = e.getFitZoom(o);
	        e._animateTo({
	            center: o.getCenter(),
	            zoom: s
	        });
	    }, e;
	}(es);

	Fh.mergeOptions({
	    boxZoom: !0,
	    boxZoomSymbol: {
	        markerType: "rectangle",
	        markerLineWidth: 3,
	        markerLineColor: "#1bbc9b",
	        markerLineDasharray: [ 10, 5 ],
	        markerFillOpacity: .1,
	        markerFill: "#1bbc9b",
	        markerWidth: 1,
	        markerHeight: 1
	    }
	}), Fh.addOnLoadHook("addHandler", "boxZoom", Fl);

	var jl = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.addHooks = function() {
	        this.target && this.target.on("_mousemove", this._onMouseMove, this);
	    }, n.removeHooks = function() {
	        this.target && this.target.off("_mousemove", this._onMouseMove, this);
	    }, n._onMouseMove = function(t) {
	        var e = this.target;
	        if (e.options.autoPanAtEdge) {
	            var n = t.containerPoint, i = e.getContainerExtent();
	            if (i) {
	                var r, o = n.x, s = n.y, a = i.xmax, h = i.ymax;
	                o < 30 && (r = [ Math.abs(o - 30), 0 ]), s < 30 && (r = [ 0, Math.abs(s - 30) ]), 
	                o + 30 > a && (r = [ -Math.abs(o + 30 - a), 0 ]), s + 30 > h && (r = [ 0, -Math.abs(s + 30 - h) ]), 
	                r && e.panBy(r, {
	                    duration: 1
	                });
	            }
	        }
	    }, e;
	}(es);

	function Hl(t, e, n) {
	    return t * (1 - n) + e * n;
	}

	Fh.mergeOptions({
	    autoPanAtEdge: !1
	}), Fh.addOnLoadHook("addHandler", "autoPanAtEdge", jl), Fh.include({
	    animateTo: function(t, e, n) {
	        var i = this;
	        void 0 === e && (e = {}), Hn(e) && (n = e, e = {});
	        var r = this.getProjection(), o = this.getView(), s = {}, a = !0;
	        for (var h in t) if (Bn(t, h) && !Dn(t[h]) && ("prjCenter" === h || !Dn(o[h]))) if (a = !1, 
	        "center" === h) {
	            var l = new us(o[h]), c = new us(t[h]);
	            l.equals(c) || (s.center = [ l, c ]);
	        } else if ("prjCenter" === h) {
	            var u = new us(this._getPrjCenter()), f = new us(t[h]);
	            u.equals(f) || (s.prjCenter = [ u, f ]);
	        } else o[h] !== t[h] && "around" !== h && (s[h] = [ o[h], t[h] ]);
	        if (a) return null;
	        this._animPlayer && (this._isInternalAnimation ? "running" === this._animPlayer.playState && (this._animPlayer.pause(), 
	        this._prevAnimPlayer = this._animPlayer) : (delete this._prevAnimPlayer, this._stopAnim(this._animPlayer)));
	        var d = t.around || new Oi$1(this.width / 2, this.height / 2), m = this._getRenderer(), g = this._animPlayer = Jh.animate(s, {
	            easing: e.easing || "out",
	            duration: e.duration || this.options.zoomAnimationDuration,
	            framer: function(t) {
	                m.callInNextFrame(t);
	            },
	            repeat: e.repeat
	        }, (function(t) {
	            if (i.isRemoved()) g.finish(); else {
	                if ("running" === g.playState) {
	                    if (t.styles.center) i._setPrjCenter(r.project(t.styles.center)), i.onMoving(i._parseEventFromCoord(i.getCenter())); else if (t.styles.prjCenter) {
	                        i._setPrjCenter(t.styles.prjCenter), i.onMoving(i._parseEventFromCoord(i.getCenter()));
	                    }
	                    Dn(t.styles.zoom) || i.onZooming(t.styles.zoom, d), Dn(t.styles.pitch) || i._setPitch(t.styles.pitch), 
	                    Dn(t.styles.bearing) || i._setBearing(t.styles.bearing), i._fireEvent("animating");
	                } else "paused" === g.playState && g !== i._mapAnimPlayer || (g._interupted || (s.center ? i._setPrjCenter(r.project(s.center[1])) : s.prjCenter && i._setPrjCenter(s.prjCenter[1]), 
	                Dn(s.pitch) || i._setPitch(s.pitch[1]), Dn(s.bearing) || i._setBearing(s.bearing[1])), 
	                i._endAnim(g, s, d, e));
	                n && n(t);
	            }
	        }), this);
	        return this._startAnim(s, d), g;
	    },
	    _animateTo: function(t, e, n) {
	        return void 0 === e && (e = {}), this._mapAnimPlayer && this._stopAnim(this._mapAnimPlayer), 
	        this._isInternalAnimation = !0, this._mapAnimPlayer = this.animateTo(t, e, n), delete this._isInternalAnimation, 
	        this._mapAnimPlayer;
	    },
	    flyTo: function(t, e, n) {
	        var i = this;
	        void 0 === e && (e = {}), this._animPlayer && (this._isInternalAnimation ? "running" === this._animPlayer.playState && (this._animPlayer.pause(), 
	        this._prevAnimPlayer = this._animPlayer) : (delete this._prevAnimPlayer, this._stopAnim(this._animPlayer))), 
	        Hn(e) && (n = e, e = {}), e = kn({
	            curve: 1.42
	        }, e);
	        var r = this;
	        function o(t, e) {
	            return r.getResolution(e) / r.getResolution(t);
	        }
	        var s = t.around || new Oi$1(this.width / 2, this.height / 2), a = this.getMinZoom(), h = this.getMaxZoom(), l = this.getProjection(), c = this.getView(), u = c.zoom, f = c.bearing, d = c.pitch, m = "zoom" in t ? Wi$1(+t.zoom, a, h) : u, g = "bearing" in t ? +t.bearing : f, p = "pitch" in t ? +t.pitch : d, _ = l.project(t.center && new us(t.center) || this.getCenter()), v = o(m, u), y = l.project(this.getCenter()), x = _.sub(y), b = e.curve, w = Math.max(this.width, this.height), C = w / v, M = x.mag();
	        if ("minZoom" in e) {
	            var T = Wi$1(Math.min(e.minZoom, u, m), a, h), S = w / o(T, u);
	            b = Math.sqrt(S / M * 2);
	        }
	        var P = b * b;
	        function A(t) {
	            var e = (C * C - w * w + (t ? -1 : 1) * P * P * M * M) / (2 * (t ? C : w) * P * M);
	            return Math.log(Math.sqrt(e * e + 1) - e);
	        }
	        function E(t) {
	            return (Math.exp(t) - Math.exp(-t)) / 2;
	        }
	        function O(t) {
	            return (Math.exp(t) + Math.exp(-t)) / 2;
	        }
	        var R = A(0), I = function(t) {
	            return O(R) / O(R + b * t);
	        }, k = function(t) {
	            return w * ((O(R) * (E(e = R + b * t) / O(e)) - E(R)) / P) / M;
	            var e;
	        }, D = (A(1) - R) / b;
	        if (Math.abs(M) < 1e-6 || !isFinite(D)) {
	            if (Math.abs(w - C) < 1e-6) return this.animateTo(t, e, n);
	            var L = C < w ? -1 : 1;
	            D = Math.abs(Math.log(C / w)) / b, k = function() {
	                return 0;
	            }, I = function(t) {
	                return Math.exp(L * b * t);
	            };
	        }
	        var z = this._getRenderer(), F = this._animPlayer = Jh.animate({
	            k: [ 0, 1 ]
	        }, {
	            easing: e.easing || "out",
	            duration: e.duration || 8,
	            framer: function(t) {
	                z.callInNextFrame(t);
	            }
	        }, (function(r) {
	            if (i.isRemoved()) F.finish(); else {
	                var o = r.styles.k, a = o * D, h = 1 / I(a), l = {};
	                if (t.center) {
	                    var c = 1 === o ? _ : y.add(x.multi(k(a)));
	                    l.prjCenter = [ _, c ];
	                }
	                if (u !== m) {
	                    var v = 1 === o ? m : i.getZoomForScale(h, u, !0);
	                    l.zoom = [ u, v ];
	                }
	                if (d !== p) {
	                    var b = Hl(d, p, o);
	                    l.pitch = [ p, b ];
	                }
	                if (f !== g) {
	                    var w = Hl(f, g, o);
	                    l.bearing = [ g, w ];
	                }
	                if ("running" === F.playState) {
	                    if (l.prjCenter) i._setPrjCenter(l.prjCenter[1]), i.onMoving(i._parseEventFromCoord(i.getCenter()));
	                    l.zoom && i.onZooming(l.zoom[1], s), l.pitch && i._setPitch(l.pitch[1]), l.bearing && i._setBearing(l.bearing[1]), 
	                    i._fireEvent("animating");
	                } else "paused" === F.playState && F !== i._mapAnimPlayer || (F._interupted || (l.prjCenter && i._setPrjCenter(l.prjCenter[1]), 
	                l.pitch && i._setPitch(l.pitch[1]), l.bearing && i._setBearing(l.bearing[1])), i._endAnim(F, l, s, e));
	                n && n(r);
	            }
	        }));
	        return this._startAnim({
	            center: t.center,
	            zoom: t.zoom !== u,
	            pitch: p !== d,
	            bearing: g !== f
	        }, s), this;
	    },
	    isAnimating: function() {
	        return !!this._animPlayer;
	    },
	    isRotating: function() {
	        return this.isDragRotating() || !!this._animRotating;
	    },
	    _endAnim: function(t, e, n, i) {
	        delete this._animRotating;
	        var r, o = t._interupted ? "animateinterrupted" : "animateend";
	        if (t === this._animPlayer && delete this._animPlayer, t === this._mapAnimPlayer && delete this._mapAnimPlayer, 
	        e.center) r = t._interupted ? this.getCenter() : e.center[1], this.onMoveEnd(this._parseEventFromCoord(r)); else if (e.prjCenter) {
	            var s;
	            s = t._interupted ? this._getPrjCenter() : e.prjCenter[1];
	            var a = this._parseEventFromCoord(this.getProjection().unproject(s));
	            a.point2d = this._prjToPoint(s), this.onMoveEnd(a);
	        }
	        Dn(e.zoom) || (t._interupted ? this.onZoomEnd(this.getZoom(), n) : i.wheelZoom ? this.onZooming(e.zoom[1], n) : this.onZoomEnd(e.zoom[1], n)), 
	        o && this._fireEvent(o), Dn(e.pitch) || this.getPitch() || this.getRenderer().setToRedraw(), 
	        i.wheelZoom || this._resumePrev(t);
	    },
	    _startAnim: function(t, e) {
	        this._animPlayer && (t.center && this.onMoveStart(), t.zoom && !this.isZooming() && this.onZoomStart(t.zoom[1], e), 
	        (t.pitch || t.bearing) && (this._animRotating = !0), this._fireEvent("animatestart"), 
	        this._animPlayer.play());
	    },
	    _stopAnim: function(t) {
	        t && (delete this._animRotating, "finished" !== t.playState && (t._interupted = !0, 
	        t.cancel()), t === this._animPlayer && delete this._animPlayer, t === this._mapAnimPlayer && delete this._mapAnimPlayer);
	    },
	    _resumePrev: function(t) {
	        if (this._prevAnimPlayer) {
	            var e = this._prevAnimPlayer;
	            "paused" !== e.playState && delete this._prevAnimPlayer, t !== e && (this._animPlayer = e, 
	            e.play());
	        }
	    }
	});

	var Nl = "mousedown mouseup mouseover mouseout mouseenter mouseleave mousemove click dblclick contextmenu keypress touchstart touchmove touchend ";

	function Bl(t, e, n, i, r) {
	    var o = 1 / Math.tan(e / 2), s = 1 / (i - r);
	    return t[0] = o / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = o, t[6] = 0, 
	    t[7] = 0, t[8] = 0, t[9] = 0, t[10] = (r + i) * s, t[11] = -1, t[12] = 0, t[13] = 0, 
	    t[14] = 2 * r * i * s, t[15] = 0, t;
	}

	function Gl(t, e, n) {
	    var i, r, o, s, a, h, l, c, u, f, d, m, g = n[0], p = n[1], _ = n[2];
	    return e === t ? (t[12] = e[0] * g + e[4] * p + e[8] * _ + e[12], t[13] = e[1] * g + e[5] * p + e[9] * _ + e[13], 
	    t[14] = e[2] * g + e[6] * p + e[10] * _ + e[14], t[15] = e[3] * g + e[7] * p + e[11] * _ + e[15]) : (r = e[1], 
	    o = e[2], s = e[3], a = e[4], h = e[5], l = e[6], c = e[7], u = e[8], f = e[9], 
	    d = e[10], m = e[11], t[0] = i = e[0], t[1] = r, t[2] = o, t[3] = s, t[4] = a, t[5] = h, 
	    t[6] = l, t[7] = c, t[8] = u, t[9] = f, t[10] = d, t[11] = m, t[12] = i * g + a * p + u * _ + e[12], 
	    t[13] = r * g + h * p + f * _ + e[13], t[14] = o * g + l * p + d * _ + e[14], t[15] = s * g + c * p + m * _ + e[15]), 
	    t;
	}

	function Vl(t, e, n) {
	    var i = n[0], r = n[1], o = n[2];
	    return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t[3] = e[3] * i, t[4] = e[4] * r, 
	    t[5] = e[5] * r, t[6] = e[6] * r, t[7] = e[7] * r, t[8] = e[8] * o, t[9] = e[9] * o, 
	    t[10] = e[10] * o, t[11] = e[11] * o, t[12] = e[12], t[13] = e[13], t[14] = e[14], 
	    t[15] = e[15], t;
	}

	function Ul(t, e, n) {
	    var i = e[0], r = e[1], o = e[2], s = e[3], a = e[4], h = e[5], l = e[6], c = e[7], u = e[8], f = e[9], d = e[10], m = e[11], g = e[12], p = e[13], _ = e[14], v = e[15], y = n[0], x = n[1], b = n[2], w = n[3];
	    return t[0] = y * i + x * a + b * u + w * g, t[1] = y * r + x * h + b * f + w * p, 
	    t[2] = y * o + x * l + b * d + w * _, t[3] = y * s + x * c + b * m + w * v, t[4] = (y = n[4]) * i + (x = n[5]) * a + (b = n[6]) * u + (w = n[7]) * g, 
	    t[5] = y * r + x * h + b * f + w * p, t[6] = y * o + x * l + b * d + w * _, t[7] = y * s + x * c + b * m + w * v, 
	    t[8] = (y = n[8]) * i + (x = n[9]) * a + (b = n[10]) * u + (w = n[11]) * g, t[9] = y * r + x * h + b * f + w * p, 
	    t[10] = y * o + x * l + b * d + w * _, t[11] = y * s + x * c + b * m + w * v, t[12] = (y = n[12]) * i + (x = n[13]) * a + (b = n[14]) * u + (w = n[15]) * g, 
	    t[13] = y * r + x * h + b * f + w * p, t[14] = y * o + x * l + b * d + w * _, t[15] = y * s + x * c + b * m + w * v, 
	    t;
	}

	function Wl(t, e) {
	    var n = e[0], i = e[1], r = e[2], o = e[3], s = e[4], a = e[5], h = e[6], l = e[7], c = e[8], u = e[9], f = e[10], d = e[11], m = e[12], g = e[13], p = e[14], _ = e[15], v = n * a - i * s, y = n * h - r * s, x = n * l - o * s, b = i * h - r * a, w = i * l - o * a, C = r * l - o * h, M = c * g - u * m, T = c * p - f * m, S = c * _ - d * m, P = u * p - f * g, A = u * _ - d * g, E = f * _ - d * p, O = v * E - y * A + x * P + b * S - w * T + C * M;
	    return O ? (t[0] = (a * E - h * A + l * P) * (O = 1 / O), t[1] = (r * A - i * E - o * P) * O, 
	    t[2] = (g * C - p * w + _ * b) * O, t[3] = (f * w - u * C - d * b) * O, t[4] = (h * S - s * E - l * T) * O, 
	    t[5] = (n * E - r * S + o * T) * O, t[6] = (p * x - m * C - _ * y) * O, t[7] = (c * C - f * x + d * y) * O, 
	    t[8] = (s * A - a * S + l * M) * O, t[9] = (i * S - n * A - o * M) * O, t[10] = (m * w - g * x + _ * v) * O, 
	    t[11] = (u * x - c * w - d * v) * O, t[12] = (a * T - s * P - h * M) * O, t[13] = (n * P - i * T + r * M) * O, 
	    t[14] = (g * y - m * b - p * v) * O, t[15] = (c * b - u * y + f * v) * O, t) : null;
	}

	function Zl(t) {
	    return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, 
	    t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, 
	    t;
	}

	function Xl(t, e) {
	    return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], 
	    t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], 
	    t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
	}

	function Jl(t, e, n, i) {
	    return t[0] = e, t[1] = n, t[2] = i, t;
	}

	function ql(t, e, n) {
	    return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t;
	}

	function Yl(t) {
	    var e = t[0], n = t[1], i = t[2];
	    return Math.sqrt(e * e + n * n + i * i);
	}

	function Kl(t, e) {
	    var n = e[0], i = e[1], r = e[2], o = n * n + i * i + r * r;
	    return o > 0 && (o = 1 / Math.sqrt(o), t[0] = e[0] * o, t[1] = e[1] * o, t[2] = e[2] * o), 
	    t;
	}

	function Ql(t, e, n) {
	    var i = e[0], r = e[1], o = e[2], s = n[0], a = n[1], h = n[2];
	    return t[0] = r * h - o * a, t[1] = o * s - i * h, t[2] = i * a - r * s, t;
	}

	function $l(t, e) {
	    var n = e[0] - t[0], i = e[1] - t[1], r = e[2] - t[2];
	    return Math.hypot ? Math.hypot(n, i, r) : function() {
	        var t = 0, e = arguments.length;
	        for (;e--; ) t += arguments[e] * arguments[e];
	        return Math.sqrt(t);
	    }(n, i, r);
	}

	function tc(t, e, n) {
	    var i = e[0], r = e[1], o = e[2], s = 1 / (n[3] * i + n[7] * r + n[11] * o + n[15]);
	    return t[0] = (n[0] * i + n[4] * r + n[8] * o + n[12]) * s, t[1] = (n[1] * i + n[5] * r + n[9] * o + n[13]) * s, 
	    t[2] = (n[2] * i + n[6] * r + n[10] * o + n[14]) * s, t;
	}

	Fh.include({
	    _registerDomEvents: function() {
	        Mo(this._panels.mapWrapper || this._containerDOM, Nl, this._handleDOMEvent, this);
	    },
	    _removeDomEvents: function() {
	        To(this._panels.mapWrapper || this._containerDOM, Nl, this._handleDOMEvent);
	    },
	    _handleDOMEvent: function(t) {
	        var e = this.options.clickTimeThreshold, n = t.type, i = "mousedown" === n || "touchstart" === n && (!t.touches || 1 === t.touches.length);
	        i && (this._domMouseDownTime = In(), this._domMouseDownView = this.getView());
	        var r = "contextmenu" === n && function(t) {
	            if (!t._domMouseDownView) return !0;
	            var e = t.getView(), n = t._domMouseDownView;
	            return e.bearing !== n.bearing || e.pitch !== n.pitch;
	        }(this);
	        if ("contextmenu" === n) {
	            Po(t);
	            var o = this._domMouseDownTime;
	            In() - o <= e && !r && this._fireDOMEvent(this, t, "dom:" + t.type);
	        } else this._fireDOMEvent(this, t, "dom:" + t.type);
	        if (!this._ignoreEvent(t)) {
	            var s, a = !1;
	            if (i) this._mouseDownTime = In(); else if ("click" === n || "touchend" === n || "contextmenu" === n) {
	                if (!this._mouseDownTime) return;
	                var h = this._mouseDownTime;
	                if (delete this._mouseDownTime, In() - h > e) {
	                    if ("click" === n || "contextmenu" === n) return;
	                } else if ("contextmenu" === n) {
	                    if (r) return;
	                } else "touchend" === n && (a = !0);
	            }
	            a && (this._clickTime && In() - this._clickTime <= e ? (delete this._clickTime, 
	            s = "dblclick", this._fireDOMEvent(this, t, "dom:dblclick")) : (this._clickTime = In(), 
	            s = "click", this._fireDOMEvent(this, t, "dom:click"))), this._ignoreEvent(t) || (this._fireDOMEvent(this, t, n), 
	            s && this._fireDOMEvent(this, t, s));
	        }
	    },
	    _ignoreEvent: function(t) {
	        if (!t || !this._panels.control) return !1;
	        if (this._isEventOutMap(t)) return !0;
	        var e, n = t.srcElement || t.target;
	        if (n) for (;n && n !== this._containerDOM; ) {
	            if (n.className && n.className.indexOf && (n.className.indexOf("maptalks-control") >= 0 || n.className.indexOf("maptalks-ui") >= 0 && e && !e.eventsPropagation)) return !0;
	            e = n, n = n.parentNode;
	        }
	        return !1;
	    },
	    _isEventOutMap: function(t) {
	        if (this.getPitch() > this.options.maxVisualPitch) {
	            var e = Ro(this._getActualEvent(t), this._containerDOM);
	            if (!this.getContainerExtent().contains(e)) return !0;
	        }
	        return !1;
	    },
	    _parseEvent: function(t, e) {
	        if (!t) return null;
	        var n = {
	            domEvent: t
	        };
	        if ("keypress" !== e) {
	            var i = this._getActualEvent(t);
	            if (i && void 0 !== i.clientX) {
	                var r = Ro(i, this._containerDOM);
	                n = kn(n, {
	                    containerPoint: r,
	                    viewPoint: this.containerPointToViewPoint(r)
	                });
	                var o = this.options.maxVisualPitch;
	                (this.getPitch() <= o || r.y >= this.height - this._getVisualHeight(o)) && (n = kn(n, {
	                    coordinate: this.containerPointToCoord(r),
	                    point2d: this._containerPointToPoint(r)
	                }));
	            }
	        }
	        return n;
	    },
	    _parseEventFromCoord: function(t) {
	        var e = this.coordToContainerPoint(t);
	        return {
	            coordinate: t,
	            containerPoint: e,
	            viewPoint: this.containerPointToViewPoint(e),
	            point2d: this.coordToPoint(t)
	        };
	    },
	    _getActualEvent: function(t) {
	        return t.touches && t.touches.length > 0 ? t.touches[0] : t.changedTouches && t.changedTouches.length > 0 ? t.changedTouches[0] : t;
	    },
	    _fireDOMEvent: function(t, e, n) {
	        if (!this.isRemoved()) {
	            var i = this._parseEvent(e, n);
	            this._fireEvent(n, i);
	        }
	    },
	    _getEventParams: function(t) {
	        var e = {
	            domEvent: t
	        }, n = t.touches && t.touches.length > 0 ? t.touches[0] : t.changedTouches && t.changedTouches.length > 0 ? t.changedTouches[0] : t;
	        if (n) {
	            var i = Ro(n, this._containerDOM);
	            e.coordinate = this.containerPointToCoordinate(i), e.containerPoint = i, e.viewPoint = this.containerPointToViewPoint(i), 
	            e.pont2d = this._containerPointToPoint(i);
	        }
	        return e;
	    }
	}), Fh.addOnLoadHook("_registerDomEvents"), Fh.include({
	    isFullScreen: function() {
	        return !!(document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement || document.fullscreenElement);
	    },
	    requestFullScreen: function(t) {
	        return this._fireEvent("fullscreenstart"), this._requestFullScreen(t || this._containerDOM), 
	        this._fireEvent("fullscreenend"), this;
	    },
	    cancelFullScreen: function() {
	        return this._cancelFullScreen(), this._fireEvent("cancelfullscreen"), this;
	    },
	    _requestFullScreen: function(t) {
	        if (t.requestFullscreen) t.requestFullscreen(); else if (t.mozRequestFullScreen) t.mozRequestFullScreen(); else if (t.webkitRequestFullScreen) t.webkitRequestFullScreen(); else if (t.msRequestFullScreen) t.msRequestFullScreen(); else {
	            var e = "fullscreen=1,status=no,resizable=yes,top=0,left=0,scrollbars=no,titlebar=no,menubar=no,location=no,toolbar=no,z-look=yes,width=" + (screen.availWidth - 8) + ",height=" + (screen.availHeight - 45);
	            null !== window.open(location.href, "_blank", e) && (window.opener = null, window.close());
	        }
	    },
	    _cancelFullScreen: function() {
	        if (document.exitFullscreen) document.exitFullscreen(); else if (document.mozCancelFullScreen) document.mozCancelFullScreen(); else if (document.webkitCancelFullScreen) document.webkitCancelFullScreen(); else {
	            null !== window.open(location.href, "_blank", "fullscreen=no,status=yes,resizable=yes,scrollbars=no,titlebar=no,menubar=yes,location=yes,toolbar=yes,z-look=yes") && (window.opener = null, 
	            window.close());
	        }
	    }
	}), Fh.include({
	    panTo: function(t, e, n) {
	        if (void 0 === e && (e = {}), !t) return this;
	        if (Hn(e) && (n = e, e = {}), t = new us(t), void 0 === e.animation || e.animation) {
	            var i = this.getProjection().project(t);
	            return this._panAnimation(i, e.duration, n);
	        }
	        return this.setCenter(t), this;
	    },
	    _panTo: function(t, e) {
	        return void 0 === e && (e = {}), void 0 === e.animation || e.animation ? this._panAnimation(t, e.duration) : (this.onMoveStart(), 
	        this._setPrjCenter(t), this.onMoveEnd(this._parseEventFromCoord(this.getCenter())), 
	        this);
	    },
	    panBy: function(t, e, n) {
	        if (void 0 === e && (e = {}), !t) return this;
	        if (Hn(e) && (n = e, e = {}), t = new Oi$1(t), this.getContainerExtent().ymin > 0 && t.y > 30) {
	            var i = t.y;
	            t.y = 30, t.x = 30 * t.x / i, console.warn("offset is limited to panBy when pitch is above maxPitch");
	        }
	        if (this.onMoveStart(), void 0 === e.animation || e.animation) {
	            t = t.multi(-1);
	            var r = this._containerPointToPrj(new Oi$1(this.width / 2 + t.x, this.height / 2 + t.y));
	            this._panAnimation(r, e.duration, n);
	        } else this._offsetCenterByPixel(t), this.onMoveEnd(this._parseEventFromCoord(this.getCenter()));
	        return this;
	    },
	    _panAnimation: function(t, e, n) {
	        return this._animateTo({
	            prjCenter: t
	        }, {
	            duration: e || this.options.panAnimationDuration
	        }, n);
	    }
	}), Mh.fromJSON = function(t) {
	    if (Array.isArray(t)) {
	        for (var e = [], n = 0, i = t.length; n < i; n++) {
	            var r = Mh.fromJSON(t[n]);
	            Array.isArray(t) ? e = e.concat(r) : e.push(r);
	        }
	        return e;
	    }
	    return t && !t.feature ? ul.toGeometry(t) : (t.subType ? (o = Mh.getJSONClass(t.subType).fromJSON(t), 
	    Dn(t.feature.id) || o.setId(t.feature.id)) : (o = ul.toGeometry(t.feature), t.options && o.config(t.options)), 
	    t.symbol && o.setSymbol(t.symbol), t.infoWindow && o.setInfoWindow(t.infoWindow), 
	    o);
	    var o;
	}, Sh.fromJSON = function(t) {
	    if (!t) return null;
	    var e = t.type, n = Sh.getJSONClass(e);
	    if (!n || !n.fromJSON) throw new Error("unsupported layer type:" + e);
	    return n.fromJSON(t);
	}, Fh.include({
	    JSON_VERSION: "1.0",
	    toJSON: function(t) {
	        t || (t = {});
	        var e = {
	            jsonVersion: this.JSON_VERSION,
	            version: this.VERSION,
	            extent: this.getExtent().toJSON()
	        };
	        e.options = this.config(), e.options.center = this.getCenter(), e.options.zoom = this.getZoom(), 
	        e.options.bearing = this.getBearing(), e.options.pitch = this.getPitch();
	        var n = this.getBaseLayer();
	        (Dn(t.baseLayer) || t.baseLayer) && n && (e.baseLayer = n.toJSON(t.baseLayer));
	        var i = {};
	        t.clipExtent && (i.clipExtent = !0 === t.clipExtent ? this.getExtent() : t.clipExtent);
	        var r = [];
	        if (Dn(t.layers) || t.layers && !Array.isArray(t.layers)) {
	            for (var o = this.getLayers(), s = 0, a = o.length; s < a; s++) if (o[s].toJSON) {
	                var h = kn({}, Fn(t.layers) ? t.layers : {}, i);
	                r.push(o[s].toJSON(h));
	            }
	            e.layers = r;
	        } else if (Zi$1(t.layers)) {
	            for (var l = t.layers, c = 0; c < l.length; c++) {
	                var u = l[c], f = this.getLayer(u.id);
	                if (f.toJSON) {
	                    var d = kn({}, u.options, i);
	                    r.push(f.toJSON(d));
	                }
	            }
	            e.layers = r;
	        } else e.layers = [];
	        return e;
	    }
	}), Fh.fromJSON = function(t, e, n) {
	    if (!t || !e) return null;
	    n || (n = {});
	    var i = new Fh(t, e.options);
	    if (Dn(n.baseLayer) || n.baseLayer) {
	        var r = Sh.fromJSON(e.baseLayer);
	        r && i.setBaseLayer(r);
	    }
	    if (Dn(n.layers) || n.layers) {
	        for (var o = [], s = e.layers, a = 0; a < s.length; a++) {
	            var h = Sh.fromJSON(s[a]);
	            o.push(h);
	        }
	        i.addLayer(o);
	    }
	    return i;
	}, Fh.include({
	    computeLength: function(t, e) {
	        if (!this.getProjection()) return null;
	        var n = new us(t), i = new us(e);
	        return n.equals(i) ? 0 : this.getProjection().measureLength(n, i);
	    },
	    computeGeometryLength: function(t) {
	        return t._computeGeodesicLength(this.getProjection());
	    },
	    computeGeometryArea: function(t) {
	        return t._computeGeodesicArea(this.getProjection());
	    },
	    identify: function(t, e) {
	        var n = new us((t = t || {}).coordinate);
	        return this._identify(t, e, (function(e) {
	            return e.identify(n, t);
	        }));
	    },
	    identifyAtPoint: function(t, e) {
	        var n = new Oi$1((t = t || {}).containerPoint), i = this.containerPointToCoord(n);
	        return this._identify(t, e, (function(e) {
	            return e.identifyAtPoint ? e.identifyAtPoint(n, t) : i ? e.identify(i, t) : [];
	        }));
	    },
	    _identify: function(t, e, n) {
	        var i = t.layers;
	        if (!Zi$1(i)) return this;
	        for (var r = [], o = 0, s = i.length; o < s; o++) jn(i[o]) ? r.push(this.getLayer(i[o])) : r.push(i[o]);
	        for (var a = [], h = r.length - 1; h >= 0 && !(t.count && a.length >= t.count); h--) {
	            var l = r[h];
	            if (l && l.getMap() && (t.includeInvisible || l.isVisible()) && (t.includeInternals || !(l.getId().indexOf("_maptalks__internal_layer_") >= 0))) {
	                var c = n(l);
	                c && (Array.isArray(c) ? Fi$1(a, c) : a.push(c));
	            }
	        }
	        return e.call(this, a), this;
	    }
	}), Fh.include({
	    _zoom: function(t, e) {
	        this.options.zoomable && !this.isZooming() && (e = this._checkZoomOrigin(e), t = this._checkZoom(t), 
	        this.onZoomStart(t, e), this._frameZoom = this.getZoom(), this.onZoomEnd(t, e));
	    },
	    _zoomAnimation: function(t, e, n) {
	        this.options.zoomable && !this.isZooming() && (t = this._checkZoom(t), this.getZoom() !== t && (e = this._checkZoomOrigin(e), 
	        this._startZoomAnim(t, e, n)));
	    },
	    _checkZoomOrigin: function(t) {
	        return t && !this.options.zoomInCenter || (t = new Oi$1(this.width / 2, this.height / 2)), 
	        this.options.zoomOrigin && (t = new Oi$1(this.options.zoomOrigin)), t;
	    },
	    _startZoomAnim: function(t, e, n) {
	        Dn(n) && (n = 1);
	        var i = this._getResolution(this._startZoomVal) / this._getResolution(t), r = this.options.zoomAnimationDuration * Math.abs(i - n) / Math.abs(i - 1);
	        this._frameZoom = this._startZoomVal, this._animateTo({
	            zoom: t,
	            around: e
	        }, {
	            continueOnViewChanged: !0,
	            duration: r
	        });
	    },
	    onZoomStart: function(t, e) {
	        this.options.zoomable && !this.isZooming() && (this._mapAnimPlayer && this._stopAnim(this._mapAnimPlayer), 
	        this._zooming = !0, this._startZoomVal = this.getZoom(), this._startZoomCoord = this._containerPointToPrj(e), 
	        this._fireEvent("zoomstart", {
	            from: this._startZoomVal,
	            to: t
	        }));
	    },
	    onZooming: function(t, e, n) {
	        if (this.options.zoomable && this._frameZoom !== t) {
	            Dn(n) && (n = 1), this._zoomTo(t, e);
	            var i = this.getResolution(t), r = this.getResolution(this._startZoomVal) / i / n, o = this._prjToContainerPoint(this._startZoomCoord, this._startZoomVal), s = this.getViewPoint();
	            if (!this.isRotating() && !o.equals(e) && 1 !== r) {
	                var a = this.getPitch(), h = o._sub(e)._multi(1 / (1 - r));
	                a && (h.y /= Math.cos(a * Math.PI / 180)), e = e.add(h);
	            }
	            var l = {
	                view: [ r, 0, 0, r, (e.x - s.x) * (1 - r), (e.y - s.y) * (1 - r) ]
	            }, c = this.getDevicePixelRatio();
	            1 !== c && (e = e.multi(c)), l.container = [ r, 0, 0, r, e.x * (1 - r), e.y * (1 - r) ], 
	            this._fireEvent("zooming", {
	                from: this._startZoomVal,
	                to: t,
	                origin: e,
	                matrix: l
	            }), this._frameZoom = t;
	        }
	    },
	    onZoomEnd: function(t, e) {
	        if (this.options.zoomable) {
	            var n = this._startZoomVal;
	            this._zoomTo(t, e), this._zooming = !1, this._getRenderer().onZoomEnd(), this._fireEvent("zoomend", {
	                from: n,
	                to: t
	            }), this._verifyExtent(this._getPrjCenter()) || this._panTo(this._prjMaxExtent.getCenter());
	        }
	    },
	    _zoomTo: function(t, e) {
	        this._zoomLevel = t, this._calcMatrices(), e && this._setPrjCoordAtContainerPoint(this._startZoomCoord, e);
	    },
	    _checkZoom: function(t) {
	        var e = this.getMaxZoom(), n = this.getMinZoom();
	        return t < n && (t = n), t > e && (t = e), t;
	    }
	});

	var ec, nc, ic, rc, oc, sc, ac, hc, lc, cc = Math.PI / 180, uc = new us(0, 0);

	function fc() {
	    return Zl(new Array(16));
	}

	Fh.include({
	    getFov: function() {
	        return this._fov || (this._fov = .6435011087932844), this._fov / cc;
	    },
	    setFov: function(t) {
	        if (this.isZooming()) return this;
	        if (t = Math.max(.01, Math.min(60, t)), this._fov === t) return this;
	        var e = this.getFov();
	        return this._fov = t * cc, this._calcMatrices(), this._renderLayers(), this._fireEvent("fovchange", {
	            from: e,
	            to: this.getFov()
	        }), this;
	    },
	    getBearing: function() {
	        return this._angle ? -this._angle / cc : 0;
	    },
	    setBearing: function(t) {
	        return this._mapAnimPlayer && this._stopAnim(this._mapAnimPlayer), this._setBearing(t);
	    },
	    _setBearing: function(t) {
	        if (Mi$1.ie9) throw new Error("map can't rotate in IE9.");
	        var e = -Ui$1(t, -180, 180) * cc;
	        if (this._angle === e) return this;
	        var n = this.getBearing();
	        return this._fireEvent("rotatestart", {
	            from: n,
	            to: e
	        }), this._angle = e, this._calcMatrices(), this._renderLayers(), this._fireEvent("rotate", {
	            from: n,
	            to: e
	        }), this._fireEvent("rotateend", {
	            from: n,
	            to: e
	        }), this;
	    },
	    getPitch: function() {
	        return this._pitch ? this._pitch / Math.PI * 180 : 0;
	    },
	    setPitch: function(t) {
	        return this._mapAnimPlayer && this._stopAnim(this._mapAnimPlayer), this._setPitch(t);
	    },
	    _setPitch: function(t) {
	        if (Mi$1.ie9) throw new Error("map can't tilt in IE9.");
	        var e = Wi$1(t, 0, this.options.maxPitch) * cc;
	        if (this._pitch === e) return this;
	        var n = this.getPitch();
	        return this._fireEvent("pitchstart", {
	            from: n,
	            to: e
	        }), this._pitch = e, this._calcMatrices(), this._renderLayers(), this._fireEvent("pitch", {
	            from: n,
	            to: e
	        }), this._fireEvent("pitchend", {
	            from: n,
	            to: e
	        }), this;
	    },
	    isTransforming: function() {
	        return !(!this._pitch && !this._angle);
	    },
	    getFrustumAltitude: function() {
	        return this._frustumAltitude;
	    },
	    _calcFrustumAltitude: function() {
	        var t = 90 - this.getPitch(), e = this.getFov() / 2, n = this.cameraPosition ? this.cameraPosition[2] : 0;
	        if (e <= t) return n;
	        e = Math.PI * e / 180;
	        var i = new Oi$1(this.cameraPosition).distanceTo(new Oi$1(this.cameraLookAt)), r = n * Math.tan(2 * e);
	        return n + Math.tan(e) * (i + r);
	    },
	    _pointToContainerPoint: function(t, e, n, i) {
	        void 0 === n && (n = 0);
	        var r = this._getResolution(e);
	        return this._pointAtResToContainerPoint(t, r, n, i);
	    },
	    _pointAtResToContainerPoint: function(t, e, n, i) {
	        void 0 === n && (n = 0), i || (i = new Oi$1(0, 0)), t = this._pointAtResToPoint(t, e, i);
	        var r, o = this.isTransforming(), s = e / this._getResolution();
	        return o || n || (r = this._prjToPoint(this._getPrjCenter(), void 0, uc)), this._toContainerPoint(i, o, s, n, r), 
	        i;
	    },
	    _pointsAtResToContainerPoints: function(t, e, n, i) {
	        void 0 === n && (n = []), void 0 === i && (i = []);
	        var r = this.getPitch(), o = this.getBearing();
	        if (0 === r && 0 === o) {
	            var s = this._get2DExtent(), a = s.xmin, h = s.ymin, l = s.xmax, c = s.ymax;
	            if (l > a && c > h) {
	                for (var u = e / this._getResolution(), f = this.getSize(), d = f.height, m = (l - a) / f.width, g = (c - h) / d, p = 0, _ = t.length; p < _; p++) if (t[p]) {
	                    var v = i[p];
	                    v.x = t[p].x, v.y = t[p].y, v._multi(u), v.x = (v.x - a) * m, v.y = d - (v.y - h) * g;
	                } else i[p] = null;
	                return i;
	            }
	        }
	        for (var y = Array.isArray(n), x = this.isTransforming(), b = e / this._getResolution(), w = this._prjToPoint(this._getPrjCenter(), void 0, uc), C = 0, M = t.length; C < M; C++) if (t[C]) {
	            var T = i[C];
	            T.x = t[C].x, T.y = t[C].y, T._multi(b), this._toContainerPoint(T, x, b, y ? n[C] || 0 : n, w);
	        } else i[C] = null;
	        return i;
	    },
	    _toContainerPoint: (lc = [ 0, 0, 0 ], function(t, e, n, i, r) {
	        var o = this.width / 2, s = this.height / 2;
	        if (e || i) {
	            var a = this._glScale;
	            Jl(lc, t.x * a, t.y * a, (i *= n) * a);
	            var h = this._projIfBehindCamera(lc, this.cameraPosition, this.cameraForward);
	            tc(h, h, this.projViewMatrix), t.x = h[0] * o + o, t.y = -h[1] * s + s;
	        } else t._sub(r.x, r.y), t.set(t.x, -t.y), t._add(o, s);
	    }),
	    _projIfBehindCamera: (sc = new Array(3), ac = new Array(3), hc = new Array(3), function(t, e, n) {
	        ql(sc, t, e);
	        var i = function(t, e) {
	            return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
	        }(n, sc);
	        return i <= 0 && (function(t, e, n) {
	            t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n;
	        }(ac, n, 1.01 * i), function(t, e, n) {
	            t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2];
	        }(t, e, ql(hc, sc, ac))), t;
	    }),
	    _containerPointToPoint: function(t, e, n) {
	        var i = this._getResolution(e);
	        return this._containerPointToPointAtRes(t, i, n);
	    },
	    _containerPointToPointAtRes: (ic = [ 0, 0, 0 ], rc = [ 0, 0, 0, 1 ], oc = [ 0, 0, 0, 1 ], 
	    function(t, e, n) {
	        if (this.isTransforming()) {
	            var i = this.width / 2 || 1, r = this.height / 2 || 1;
	            Jl(ic, (t.x - i) / i, (r - t.y) / r, 0), Jl(rc, ic[0], ic[1], 0), Jl(oc, ic[0], ic[1], 1), 
	            rc[3] = oc[3] = 1, tc(rc, rc, this.projViewMatrixInverse), tc(oc, oc, this.projViewMatrixInverse);
	            var o = rc[1], s = oc[1], a = rc[2], h = oc[2], l = a === h ? 0 : (0 - a) / (h - a), c = Vi$1(rc[0], oc[0], l), u = Vi$1(o, s, l);
	            return n ? (n.x = c, n.y = u) : n = new Oi$1(c, u), n._multi(1 / this._glScale), this._getResolution() === e ? n : this._pointToPointAtRes(n, e, n);
	        }
	        var f = this._prjToPointAtRes(this._getPrjCenter(), e, n), d = this._getResolution() / e;
	        return f._add(d * (t.x - this.width / 2), -d * (t.y - this.height / 2));
	    }),
	    _calcMatrices: (nc = fc(), function() {
	        delete this._mapRes, delete this._mapGlRes, delete this._mapExtent2D, delete this._mapGlExtent2D;
	        var t = this.getSize(), e = t.width || 1, n = t.height || 1;
	        this._glScale = this.getGLScale();
	        var i = this._getCameraWorldMatrix(), r = this.getFov() * Math.PI / 180, o = this._getCameraFar(r, this.getPitch());
	        this.cameraFar = o, this.cameraNear = this.cameraCenterDistance / 20;
	        var s = this.projMatrix || fc();
	        Bl(s, r, e / n, this.cameraNear, o), this.projMatrix = s, this.viewMatrix = Wl(this.viewMatrix || fc(), i), 
	        this.projViewMatrix = Ul(this.projViewMatrix || fc(), s, this.viewMatrix), this._calcCascadeMatrixes(), 
	        this.projViewMatrixInverse = Ul(this.projViewMatrixInverse || fc(), i, Wl(nc, s)), 
	        this.domCssMatrix = this._calcDomMatrix(), this._frustumAltitude = this._calcFrustumAltitude(), 
	        this._mapRes = this._getResolution(), this._mapGlRes = this.getGLRes(), this._mapExtent2D = this._get2DExtent(), 
	        this._mapGlExtent2D = this._get2DExtentAtRes(this._mapGlRes);
	    }),
	    _getCameraFar: function(t, e) {
	        var n = this.cameraCenterDistance = $l(this.cameraPosition, this.cameraLookAt), i = n, r = (this.options.cameraInfiniteFar ? 10 : 4) * n;
	        if (e > 0 && (e = e * Math.PI / 180, 2 / Math.PI - e > t / 2)) {
	            var o = Math.tan(t / 2), s = Math.tan(e);
	            r = Math.max(n * o / (1 / s - o), r);
	        }
	        return (i += r) + 1;
	    },
	    _calcCascadeMatrixes: function() {
	        var t = fc();
	        function e(e, n, i) {
	            var r = this.width, o = this.height, s = this.getFov() * Math.PI / 180, a = this._getCameraFar(s, n), h = this.cameraCenterDistance;
	            return a = h + (a - h) / Math.cos((90 - n) * Math.PI / 180) * Math.cos((90 - e) * Math.PI / 180), 
	            Bl(t, s, r / o, .1, a), Ul(i, t, this.viewMatrix);
	        }
	        return function() {
	            var t = this.getPitch(), n = this.options.cascadePitches[0], i = this.options.cascadePitches[1], r = this.cascadeFrustumMatrix0 = this.cascadeFrustumMatrix0 || fc(), o = this.cascadeFrustumMatrix1 = this.cascadeFrustumMatrix1 || fc();
	            t > n ? e.call(this, t, n, r) : Xl(this.cascadeFrustumMatrix0, this.projViewMatrix), 
	            t > i ? e.call(this, t, i, o) : Xl(this.cascadeFrustumMatrix1, this.cascadeFrustumMatrix0);
	        };
	    }(),
	    _calcDomMatrix: function() {
	        var t = fc(), e = fc(), n = [ 1, -1, 1 ], i = [ 0, 0, 0 ];
	        return function() {
	            var r = this.width || 1, o = this.height || 1, s = .5 / Math.tan(this._fov / 2) * o;
	            return Vl(t, this.projMatrix, n), Gl(t, t, Jl(i, 0, 0, -s)), this._pitch && function(t, e, n) {
	                var i = Math.sin(n), r = Math.cos(n), o = e[4], s = e[5], a = e[6], h = e[7], l = e[8], c = e[9], u = e[10], f = e[11];
	                e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], 
	                t[14] = e[14], t[15] = e[15]), t[4] = o * r + l * i, t[5] = s * r + c * i, t[6] = a * r + u * i, 
	                t[7] = h * r + f * i, t[8] = l * r - o * i, t[9] = c * r - s * i, t[10] = u * r - a * i, 
	                t[11] = f * r - h * i;
	            }(t, t, this._pitch), this._angle && function(t, e, n) {
	                var i = Math.sin(n), r = Math.cos(n), o = e[0], s = e[1], a = e[2], h = e[3], l = e[4], c = e[5], u = e[6], f = e[7];
	                e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], 
	                t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = o * r + l * i, t[1] = s * r + c * i, 
	                t[2] = a * r + u * i, t[3] = h * r + f * i, t[4] = l * r - o * i, t[5] = c * r - s * i, 
	                t[6] = u * r - a * i, t[7] = f * r - h * i;
	            }(t, t, this._angle), Zl(e), Vl(e, e, Jl(i, r / 2, -o / 2, 1)), Ul(this.domCssMatrix || fc(), e, t);
	        };
	    }(),
	    _getFovZ: function(t) {
	        var e = this.getGLScale(t), n = this._getFovRatio();
	        return e * (this.height || 1) / 2 / n;
	    },
	    _getCameraWorldMatrix: (ec = {}, function() {
	        var t = this.getGLRes(), e = this._prjToPointAtRes(this._prjCenter, t);
	        this.cameraLookAt = Jl(this.cameraLookAt || [ 0, 0, 0 ], e.x, e.y, 0);
	        var n = this.getPitch() * cc, i = this.getBearing() * cc, r = this._getFovZ(), o = r * Math.cos(n), s = Math.sin(n) * r, a = e.x - s * Math.sin(i), h = e.y - s * Math.cos(i);
	        this.cameraPosition = Jl(this.cameraPosition || [ 0, 0, 0 ], a, h, o), this.cameraToCenterDistance = $l(this.cameraPosition, this.cameraLookAt);
	        var l = s || 1, c = this.cameraUp = Jl(this.cameraUp || [ 0, 0, 0 ], Math.sin(i) * l, Math.cos(i) * l, 0), u = this.cameraWorldMatrix = this.cameraWorldMatrix || fc();
	        !function(t, e, n, i) {
	            var r = [ 0, 0, 0 ], o = [ 0, 0, 0 ], s = [ 0, 0, 0 ];
	            ql(s, e, n), 0 === Yl(s) && (s[2] = 1), Kl(s, s), Ql(r, i, s), 0 === Yl(s) && (1 === Math.abs(i[2]) ? s[0] += 1e-4 : s[2] += 1e-4, 
	            Kl(s, s), Ql(r, i, s)), Kl(r, r), Ql(o, s, r), t[0] = r[0], t[4] = o[0], t[8] = s[0], 
	            t[1] = r[1], t[5] = o[1], t[9] = s[1], t[2] = r[2], t[6] = o[2], t[10] = s[2];
	        }(u, this.cameraPosition, this.cameraLookAt, c);
	        var f, d, m = this.cameraForward || [ 0, 0, 0 ];
	        return ql(m, this.cameraLookAt, this.cameraPosition), this.cameraForward = Kl(m, m), 
	        function(t, e) {
	            var n, i = e[0], r = e[4], o = e[8], s = e[1], a = e[5], h = e[9], l = e[2], c = e[6], u = e[10], f = i + a + u;
	            f > 0 ? (n = .5 / Math.sqrt(f + 1), t.w = .25 / n, t.x = (c - h) * n, t.y = (o - l) * n, 
	            t.z = (s - r) * n) : i > a && i > u ? (n = 2 * Math.sqrt(1 + i - a - u), t.w = (c - h) / n, 
	            t.x = .25 * n, t.y = (r + s) / n, t.z = (o + l) / n) : a > u ? (n = 2 * Math.sqrt(1 + a - i - u), 
	            t.w = (o - l) / n, t.x = (r + s) / n, t.y = .25 * n, t.z = (h + c) / n) : (n = 2 * Math.sqrt(1 + u - i - a), 
	            t.w = (s - r) / n, t.x = (o + l) / n, t.y = (h + c) / n, t.z = .25 * n);
	        }(ec, u), function(t, e) {
	            var n = t, i = e.x, r = e.y, o = e.z, s = e.w, a = i + i, h = r + r, l = o + o, c = i * a, u = i * h, f = i * l, d = r * h, m = r * l, g = o * l, p = s * a, _ = s * h, v = s * l;
	            n[0] = 1 - (d + g), n[4] = u - v, n[8] = f + _, n[1] = u + v, n[5] = 1 - (c + g), 
	            n[9] = m - p, n[2] = f - _, n[6] = m + p, n[10] = 1 - (c + d), n[3] = 0, n[7] = 0, 
	            n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1;
	        }(u, ec), (d = u)[12] = (f = this.cameraPosition)[0], d[13] = f[1], d[14] = f[2], 
	        u;
	    }),
	    _getFovRatio: function() {
	        var t = this.getFov();
	        return Math.tan(t / 2 * cc);
	    },
	    _renderLayers: function() {
	        this.isInteracting() || this._getLayers().forEach((function(t) {
	            if (t) {
	                var e = t._getRenderer();
	                e && e.setToRedraw && e.setToRedraw();
	            }
	        }));
	    }
	}), Fh.include({
	    _onViewChange: function(t) {
	        this._viewHistory || (this._viewHistory = [], this._viewHistoryPointer = 0);
	        for (var e = this._getCurrentView(), n = this._viewHistory.length - 1; n >= 0; n--) if (ir(t, this._viewHistory[n])) return this._viewHistoryPointer = n, 
	        void this._fireViewChange(e, t);
	        this._viewHistoryPointer < this._viewHistory.length - 1 && this._viewHistory.splice(this._viewHistoryPointer + 1), 
	        this._viewHistory.push(t);
	        var i = this.options.viewHistoryCount;
	        i > 0 && this._viewHistory.length > i && this._viewHistory.splice(0, this._viewHistory.length - i), 
	        this._viewHistoryPointer = this._viewHistory.length - 1, this._fireViewChange(e, t);
	    },
	    zoomToPreviousView: function(t) {
	        if (void 0 === t && (t = {}), !this.hasPreviousView()) return null;
	        var e = this._viewHistory[--this._viewHistoryPointer];
	        return this._zoomToView(e, t), e;
	    },
	    hasPreviousView: function() {
	        return !(!this._viewHistory || 0 === this._viewHistoryPointer);
	    },
	    zoomToNextView: function(t) {
	        if (void 0 === t && (t = {}), !this.hasNextView()) return null;
	        var e = this._viewHistory[++this._viewHistoryPointer];
	        return this._zoomToView(e, t), e;
	    },
	    hasNextView: function() {
	        return !(!this._viewHistory || this._viewHistoryPointer === this._viewHistory.length - 1);
	    },
	    _zoomToView: function(t, e) {
	        var n = this, i = this.getView();
	        e.animation ? this._animateTo(t, {
	            duration: e.duration
	        }, (function(e) {
	            "finished" === e.state.playState && n._fireViewChange(i, t);
	        })) : (this.setView(t), this._fireViewChange(i, t));
	    },
	    getViewHistory: function() {
	        return this._viewHistory;
	    },
	    _fireViewChange: function(t, e) {
	        this._fireEvent("viewchange", {
	            old: t,
	            new: e
	        });
	    },
	    _getCurrentView: function() {
	        return this._viewHistory ? this._viewHistory[this._viewHistoryPointer] : null;
	    }
	}), Fh.mergeOptions({
	    viewHistory: !0,
	    viewHistoryCount: 10
	}), Fh.include({
	    getCollisionIndex: function() {
	        return this._collisionIndex || this.createCollisionIndex(), this._collisionIndex || this.createCollisionIndex();
	    },
	    createCollisionIndex: function() {
	        return this.clearCollisionIndex(), this._collisionIndex = new ss, this._collisionIndex;
	    },
	    clearCollisionIndex: function() {
	        return this.collisionFrameTime = 0, this._collisionIndex && this._collisionIndex.clear(), 
	        this;
	    }
	});

	var dc = function(t) {
	    function e(e) {
	        var n;
	        return (n = t.call(this, e) || this).on("enable", n._afterEnable, Si$1(Si$1(n))).on("disable", n._afterDisable, Si$1(Si$1(n))), 
	        n._measureLayers = [], n;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.clear = function() {
	        if (Zi$1(this._measureLayers)) for (var t = 0; t < this._measureLayers.length; t++) this._measureLayers[t].remove();
	        return delete this._lastMeasure, delete this._lastVertex, this._measureLayers = [], 
	        this;
	    }, n.getMeasureLayers = function() {
	        return this._measureLayers;
	    }, n.getLastMeasure = function() {
	        return this._lastMeasure ? this._lastMeasure : 0;
	    }, n.undo = function() {
	        t.prototype.undo.call(this);
	        var e = this._historyPointer;
	        if (e !== this._vertexes.length) for (var n = e; n < this._vertexes.length; n++) this._vertexes[n].label && this._vertexes[n].label.remove(), 
	        this._vertexes[n].marker.remove();
	        return this;
	    }, n.redo = function() {
	        t.prototype.redo.call(this);
	        var e = this._historyPointer - 1;
	        return this._vertexes[e] && (this._vertexes[e].marker.getLayer() || (this._vertexes[e].label && this._vertexes[e].label.addTo(this._measureMarkerLayer), 
	        this._vertexes[e].marker.addTo(this._measureMarkerLayer))), this;
	    }, n._measure = function(t) {
	        var e, n, i = this.getMap();
	        t instanceof Mh ? e = i.computeGeometryLength(t) : Array.isArray(t) && (e = i.getProjection().measureLength(t)), 
	        this._lastMeasure = e, n = "zh-CN" === this.options.language ? [ " 米", " 公里", " 英尺", " 英里" ] : [ " m", " km", " feet", " mile" ];
	        var r = "";
	        return this.options.metric && (r += e < 1e3 ? e.toFixed(0) + n[0] : (e / 1e3).toFixed(2) + n[1]), 
	        this.options.imperial && (r.length > 0 && (r += "\n"), r += (e *= 3.2808399) < 5280 ? e.toFixed(0) + n[2] : (e / 5280).toFixed(2) + n[3]), 
	        r;
	    }, n._registerMeasureEvents = function() {
	        this.on("drawstart", this._msOnDrawStart, this).on("drawvertex", this._msOnDrawVertex, this).on("mousemove", this._msOnMouseMove, this).on("drawend", this._msOnDrawEnd, this);
	    }, n._afterEnable = function() {
	        this._registerMeasureEvents();
	    }, n._afterDisable = function() {
	        this.off("drawstart", this._msOnDrawStart, this).off("drawvertex", this._msOnDrawVertex, this).off("mousemove", this._msOnMouseMove, this).off("drawend", this._msOnDrawEnd, this);
	    }, n._msOnDrawStart = function(t) {
	        var e = this.getMap(), n = e._pointToPrj(t.point2d), i = Di$1(), r = "distancetool_" + i, o = "distancetool_markers_" + i;
	        e.getLayer(r) ? (this._measureLineLayer = e.getLayer(r), this._measureMarkerLayer = e.getLayer(o)) : (this._measureLineLayer = new Il(r).addTo(e), 
	        this._measureMarkerLayer = new Il(o).addTo(e)), this._measureLayers.push(this._measureLineLayer), 
	        this._measureLayers.push(this._measureMarkerLayer);
	        var s = new $h(t.coordinate, {
	            symbol: this.options.vertexSymbol
	        });
	        s._setPrjCoordinates(n);
	        var a = new Ml("zh-CN" === this.options.language ? "起点" : "start", t.coordinate, this.options.labelOptions);
	        a._setPrjCoordinates(n), this._lastVertex = a, this._addVertexMarker(s, a);
	    }, n._msOnMouseMove = function(t) {
	        var e = this._measure(this._msGetCoordsToMeasure(t));
	        if (!this._tailMarker) {
	            var n = ho(this.options.vertexSymbol);
	            n.markerWidth /= 2, n.markerHeight /= 2, this._tailMarker = new $h(t.coordinate, {
	                symbol: n
	            }).addTo(this._measureMarkerLayer), this._tailLabel = new Ml(e, t.coordinate, this.options.labelOptions).addTo(this._measureMarkerLayer);
	        }
	        var i = this._geometry._getPrjCoordinates(), r = i[i.length - 1];
	        this._tailMarker.setCoordinates(t.coordinate), this._tailMarker._setPrjCoordinates(r), 
	        this._tailLabel.setContent(e), this._tailLabel.setCoordinates(t.coordinate), this._tailLabel._setPrjCoordinates(r);
	    }, n._msGetCoordsToMeasure = function(t) {
	        return t.geometry.getCoordinates().concat([ t.coordinate ]);
	    }, n._msOnDrawVertex = function(t) {
	        var e = this._geometry._getPrjCoordinates(), n = e[e.length - 1], i = t.geometry, r = new $h(t.coordinate, {
	            symbol: this.options.vertexSymbol
	        }), o = this._measure(i), s = new Ml(o, t.coordinate, this.options.labelOptions);
	        this._addVertexMarker(r, s), s._setPrjCoordinates(n), r._setPrjCoordinates(n), this._lastVertex = s;
	    }, n._addVertexMarker = function(t, e) {
	        this._vertexes || (this._vertexes = []), void 0 !== this._historyPointer && this._vertexes.length > this._historyPointer - 1 && (this._vertexes.length = this._historyPointer - 1), 
	        this._vertexes.push({
	            label: e,
	            marker: t
	        }), this._measureMarkerLayer.addGeometry(t), e && this._measureMarkerLayer.addGeometry(e);
	    }, n._msOnDrawEnd = function(t) {
	        if (this._clearTailMarker(), t.geometry._getPrjCoordinates().length < 2) return this._lastMeasure = 0, 
	        void this._clearMeasureLayers();
	        var e = this._lastVertex.getSize();
	        e || (e = new Gr(10, 10)), this._addClearMarker(this._lastVertex.getCoordinates(), this._lastVertex._getPrjCoordinates(), e.width);
	        var n = t.geometry.copy();
	        n._setPrjCoordinates(t.geometry._getPrjCoordinates()), n.addTo(this._measureLineLayer), 
	        this._lastMeasure = n.getLength();
	    }, n._addClearMarker = function(t, e, n) {
	        var i = this.options.clearButtonSymbol, r = {
	            markerDx: (i.markerDx || 0) + n,
	            textDx: (i.textDx || 0) + n
	        };
	        Array.isArray(i) && (r = i.map((function(t) {
	            return t ? {
	                markerDx: (t.markerDx || 0) + n,
	                textDx: (t.textDx || 0) + n
	            } : null;
	        }))), i = ho(i, r);
	        var o = new $h(t, {
	            symbol: i
	        }), s = this._measureLineLayer, a = this._measureMarkerLayer;
	        o.on("click", (function() {
	            return s.remove(), a.remove(), !1;
	        }), this), o.addTo(this._measureMarkerLayer), o._setPrjCoordinates(e);
	    }, n._clearTailMarker = function() {
	        this._tailMarker && (this._tailMarker.remove(), delete this._tailMarker), this._tailLabel && (this._tailLabel.remove(), 
	        delete this._tailLabel);
	    }, n._clearMeasureLayers = function() {
	        this._measureLineLayer.remove(), this._measureMarkerLayer.remove();
	    }, e;
	}(zl);

	dc.mergeOptions({
	    mode: "LineString",
	    language: "zh-CN",
	    metric: !0,
	    imperial: !1,
	    symbol: {
	        lineColor: "#000",
	        lineWidth: 3,
	        lineOpacity: 1
	    },
	    vertexSymbol: {
	        markerType: "ellipse",
	        markerFill: "#fff",
	        markerLineColor: "#000",
	        markerLineWidth: 3,
	        markerWidth: 11,
	        markerHeight: 11
	    },
	    labelOptions: {
	        textSymbol: {
	            textFaceName: "monospace",
	            textLineSpacing: 1,
	            textHorizontalAlignment: "right",
	            textDx: 15
	        },
	        boxStyle: {
	            padding: [ 6, 2 ],
	            symbol: {
	                markerType: "square",
	                markerFill: "#fff",
	                markerFillOpacity: .9,
	                markerLineColor: "#b4b3b3"
	            }
	        }
	    },
	    clearButtonSymbol: [ {
	        markerType: "square",
	        markerFill: "#fff",
	        markerLineColor: "#b4b3b3",
	        markerLineWidth: 2,
	        markerWidth: 15,
	        markerHeight: 15,
	        markerDx: 20
	    }, {
	        markerType: "x",
	        markerWidth: 10,
	        markerHeight: 10,
	        markerDx: 20
	    } ]
	});

	(function(t) {
	    function e(e) {
	        var n;
	        return (n = t.call(this, e) || this)._measureLayers = [], n;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n._measure = function(t) {
	        var e, n, i = this.getMap();
	        t instanceof Mh ? e = i.computeGeometryArea(t) : Array.isArray(t) && (e = i.getProjection().measureArea(t)), 
	        this._lastMeasure = e, n = "zh-CN" === this.options.language ? [ " 平方米", " 平方公里", " 平方英尺", " 平方英里" ] : [ " sq.m", " sq.km", " sq.ft", " sq.mi" ];
	        var r = "";
	        if (this.options.metric && (r += e < 1e6 ? e.toFixed(0) + n[0] : (e / 1e6).toFixed(2) + n[1]), 
	        this.options.imperial) {
	            r.length > 0 && (r += "\n");
	            r += (e *= 3.2808399) < 27878400 ? e.toFixed(0) + n[2] : (e / 27878400).toFixed(2) + n[3];
	        }
	        return r;
	    }, n._msGetCoordsToMeasure = function(t) {
	        return t.geometry.getShell().concat([ t.coordinate ]);
	    }, n._msOnDrawVertex = function(t) {
	        var e = this.getMap()._pointToPrj(t.point2d), n = new $h(t.coordinate, {
	            symbol: this.options.vertexSymbol
	        });
	        n._setPrjCoordinates(e), this._measure(t.geometry), this._lastVertex = n, this._addVertexMarker(n);
	    }, n._msOnDrawEnd = function(t) {
	        var e;
	        if (this._clearTailMarker(), t.point2d) e = this.getMap()._pointToPrj(t.point2d); else {
	            var n = t.geometry._getPrjCoordinates();
	            n = n.slice(0, n.length - 1), t.geometry._setPrjCoordinates(n), e = n[n.length - 1];
	        }
	        if (t.geometry._getPrjCoordinates().length < 3) return this._lastMeasure = 0, void this._clearMeasureLayers();
	        var i = this._measure(t.geometry), r = this.getMap().getProjection().unproject(e), o = new Ml(i, r, this.options.labelOptions).addTo(this._measureMarkerLayer);
	        o._setPrjCoordinates(e);
	        var s = o.getSize();
	        s || (s = new Gr(10, 10)), this._addClearMarker(r, e, s.width);
	        var a = t.geometry.copy();
	        a._setPrjCoordinates(t.geometry._getPrjCoordinates()), a.addTo(this._measureLineLayer), 
	        this._lastMeasure = a.getArea();
	    }, e;
	})(dc).mergeOptions({
	    mode: "Polygon",
	    symbol: {
	        lineColor: "#000000",
	        lineWidth: 2,
	        lineOpacity: 1,
	        lineDasharray: "",
	        polygonFill: "#ffffff",
	        polygonOpacity: .5
	    }
	});

	var mc = {
	    create: function(t, e) {
	        var n = t.unproject(e[0]), i = new fl(n, 0);
	        return i._setPrjCoordinates(e[0]), i;
	    },
	    update: function(t, e, n) {
	        var i = n.getMap(), r = Array.isArray(e) ? e[e.length - 1] : e, o = t.unproject(r), s = i.computeLength(n.getCenter(), o);
	        n.setRadius(s);
	    },
	    generate: function(t) {
	        return t;
	    }
	};

	zl.registerMode("circle", kn({
	    clickLimit: 2,
	    action: [ "click", "mousemove", "click" ]
	}, mc)), zl.registerMode("freeHandCircle", kn({
	    action: [ "mousedown touchstart", "mousemove touchmove", "mouseup touchend" ]
	}, mc));

	var gc = {
	    create: function(t, e) {
	        var n = t.unproject(e[0]), i = new dl(n, 0, 0);
	        return i._setPrjCoordinates(e[0]), i;
	    },
	    update: function(t, e, n) {
	        var i = n.getMap(), r = n.getCenter(), o = Array.isArray(e) ? e[e.length - 1] : e, s = t.unproject(o), a = i.computeLength(r, new us({
	            x: s.x,
	            y: r.y
	        })), h = i.computeLength(r, new us({
	            x: r.x,
	            y: s.y
	        }));
	        n.setWidth(2 * a), n.setHeight(2 * h);
	    },
	    generate: function(t) {
	        return t;
	    }
	};

	zl.registerMode("ellipse", kn({
	    clickLimit: 2,
	    action: [ "click", "mousemove", "click" ]
	}, gc)), zl.registerMode("freeHandEllipse", kn({
	    action: [ "mousedown touchstart", "mousemove touchmove", "mouseup touchend" ]
	}, gc));

	var pc = {
	    create: function(t, e) {
	        var n = new Yh([]);
	        return n._firstClick = e[0], n;
	    },
	    update: function(t, e, n, i) {
	        var r = n.getMap(), o = i.containerPoint, s = r._prjToContainerPoint(n._firstClick), a = [ [ s.x, s.y ], [ o.x, s.y ], [ o.x, o.y ], [ s.x, o.y ] ];
	        n.setCoordinates(a.map((function(t) {
	            return r.containerPointToCoord(new Oi$1(t));
	        }))), n._setPrjCoordinates(a.map((function(t) {
	            return r._containerPointToPrj(new Oi$1(t));
	        })));
	    },
	    generate: function(t) {
	        return t;
	    }
	};

	zl.registerMode("rectangle", kn({
	    clickLimit: 2,
	    action: [ "click", "mousemove", "click" ]
	}, pc)), zl.registerMode("freeHandRectangle", kn({
	    action: [ "mousedown touchstart", "mousemove touchmove", "mouseup touchend" ]
	}, pc)), zl.registerMode("point", {
	    clickLimit: 1,
	    action: [ "click", "mousemove" ],
	    create: function(t, e) {
	        var n = t.unproject(e[0]), i = new $h(n);
	        return i._setPrjCoordinates(e[0]), i;
	    },
	    generate: function(t) {
	        return t;
	    },
	    update: function(t, e, n) {
	        if (Array.isArray(e) && (e = e[e.length - 1]), !e) return n;
	        var i = t.unproject(e);
	        return n.setCoordinates(i), n;
	    }
	});

	var _c = {
	    create: function(t, e) {
	        var n = e.map((function(e) {
	            return t.unproject(e);
	        })), i = new el(n);
	        return i._setPrjCoordinates(e), i;
	    },
	    update: function(t, e, n) {
	        var i, r = n.getSymbol();
	        Array.isArray(e) ? i = e : (i = n._getPrjCoordinates()).push(e);
	        var o = i.map((function(e) {
	            return t.unproject(e);
	        }));
	        n.setCoordinates(o), n._setPrjCoordinates(i);
	        var s = n.getLayer();
	        if (s) {
	            var a = s.getGeometryById("polygon");
	            if (!a && i.length >= 3) {
	                if (a = new Yh([ o ], {
	                    id: "polygon"
	                }), r) {
	                    var h = ho(r, {
	                        lineOpacity: 0
	                    });
	                    a.setSymbol(h);
	                }
	                a.addTo(s);
	            }
	            a && a._setPrjCoordinates(i);
	        }
	    },
	    generate: function(t) {
	        var e = new Yh(t.getCoordinates(), {
	            symbol: t.getSymbol()
	        });
	        return e._setPrjCoordinates(t._getPrjCoordinates()), e._projCode = t._projCode, 
	        e;
	    }
	};

	zl.registerMode("polygon", kn({
	    action: [ "click", "mousemove", "dblclick" ]
	}, _c)), zl.registerMode("freeHandPolygon", kn({
	    action: [ "mousedown touchstart", "mousemove touchmove", "mouseup touchend" ]
	}, _c));

	var vc = {
	    create: function(t, e) {
	        var n = e.map((function(e) {
	            return t.unproject(e);
	        })), i = new el(n);
	        return i._setPrjCoordinates(e), i;
	    },
	    update: function(t, e, n) {
	        var i;
	        Array.isArray(e) ? i = e : (i = n._getPrjCoordinates()).push(e);
	        var r = i.map((function(e) {
	            return t.unproject(e);
	        }));
	        n.setCoordinates(r), n._setPrjCoordinates(i);
	    },
	    generate: function(t) {
	        return t;
	    }
	};

	function yc(t) {
	    for (var e = t.tileInfo, n = [ e.cols, e.rows ], i = [], r = e.lods, o = 0, s = r.length; o < s; o++) i.push(r[o].resolution);
	    var a = t.fullExtent, h = e.origin, l = [ 1, -1, h.x, h.y ];
	    return delete a.spatialReference, {
	        spatialReference: {
	            resolutions: i,
	            fullExtent: a
	        },
	        tileSystem: l,
	        tileSize: n
	    };
	}

	function xc(t, e) {
	    return void 0 === e && (e = []), e.forEach((function(e) {
	        t = t.replace(e[0], e[1]);
	    })), t;
	}

	function bc(t) {
	    var e = t.projection, n = t.isArcgis, i = t.isGeoServer, r = t.isSuperMap, o = .0002645833333333333;
	    return (n || i || r) && (o = 28e-5), e && e.indexOf("4326") > -1 && (o = 2.3767925226029154e-9, 
	    (n || r) && (o = 2.518101729011901e-9), i && (o = 2.51528279553466e-9)), o;
	}

	zl.registerMode("linestring", kn({
	    action: [ "click", "mousemove", "dblclick" ]
	}, vc)), zl.registerMode("freeHandLinestring", kn({
	    action: [ "mousedown touchstart", "mousemove touchmove", "mouseup touchend" ]
	}, vc)), zl.registerMode("arccurve", {
	    action: [ "click", "mousemove", "dblclick" ],
	    create: function(t, e) {
	        var n = e.map((function(e) {
	            return t.unproject(e);
	        })), i = new _l(n);
	        return i._setPrjCoordinates(e), i;
	    },
	    update: vc.update,
	    generate: function(t) {
	        return t;
	    }
	}), zl.registerMode("quadbeziercurve", {
	    action: [ "click", "mousemove", "dblclick" ],
	    create: function(t, e) {
	        var n = e.map((function(e) {
	            return t.unproject(e);
	        })), i = new yl(n);
	        return i._setPrjCoordinates(e), i;
	    },
	    update: vc.update,
	    generate: function(t) {
	        return t;
	    }
	}), zl.registerMode("cubicbeziercurve", {
	    action: [ "click", "mousemove", "dblclick" ],
	    create: function(t, e) {
	        var n = e.map((function(e) {
	            return t.unproject(e);
	        })), i = new vl(n);
	        return i._setPrjCoordinates(e), i;
	    },
	    update: vc.update,
	    generate: function(t) {
	        return t;
	    }
	}), zl.registerMode("boxZoom", {
	    action: [ "mousedown", "mousemove", "mouseup" ],
	    create: function(t, e) {
	        var n = t.unproject(e = e[0]), i = new $h(n);
	        return i._firstClick = e, i;
	    },
	    update: function(t, e, n, i) {
	        var r = n.getMap(), o = r._prjToContainerPoint(n._firstClick), s = i.containerPoint;
	        e = r._containerPointToPrj(new us(Math.min(o.x, s.x), Math.min(o.y, s.y)));
	        var a = t.unproject(e);
	        n.setCoordinates(a)._setPrjCoordinates(e), n.updateSymbol({
	            markerWidth: Math.abs(o.x - s.x),
	            markerHeight: Math.abs(o.y - s.y)
	        });
	    },
	    generate: function(t) {
	        return t;
	    }
	}), bh.loadArcgis = function(t, e, n) {
	    if (void 0 === n && (n = {
	        jsonp: !0
	    }), jn(t) && "{" !== t.substring(0, 1)) Wo.getJSON(t, (function(t, n) {
	        if (t) e(t); else {
	            var i = yc(n);
	            e(null, i);
	        }
	    }), n); else {
	        jn(t) && (t = zi$1(t));
	        var i = yc(t);
	        e(null, i);
	    }
	    return this;
	};

	function wc(t, e) {
	    var n = t.getElementsByTagName(e);
	    return n && n.length ? n : t.getElementsByTagName("wmts:" + e);
	}

	function Cc(t, e) {
	    for (var n = 0; n < t.length; n++) {
	        var i = t[n];
	        if ((i = i.getElementsByTagName("ows:Identifier")[0]) && i.textContent === e) return t[n];
	    }
	    return null;
	}

	function Mc(t, e) {
	    void 0 === e && (e = {});
	    var n, i, r, o = wc(t, "TileMatrix"), s = [], a = [], h = [], l = !1;
	    if (!n) {
	        var c = t.getElementsByTagName("ows:SupportedCRS")[0];
	        c && (n = function(t) {
	            var e = t.indexOf("EPSG") > -1 ? t : "EPSG:" + t;
	            return e = xc(e, [ [ "4490", "4326" ], [ "102100", "3857" ], [ "900913", "3857" ] ]);
	        }(n = function(t) {
	            for (var e = "", n = t.split(""), i = n.length - 1; i >= 0 && !isNaN(n[i]); i--) e = n[i] + e;
	            return e;
	        }(n = (n = c.textContent).split("EPSG")[1])));
	    }
	    i || (i = t.getElementsByTagName("ows:Identifier")[0]) && (i = i.textContent), e.projection = n;
	    for (var u = 1 / 0, f = 0; f < o.length; f++) {
	        var d = o[f], m = d.getElementsByTagName("ows:Identifier")[0].textContent;
	        isNaN(parseInt(m)) ? (r = m.substr(0, m.lastIndexOf(":")), m = (m = m.split(":"))[m.length - 1], 
	        m = parseInt(m), l = !0, e.isGeoServer = !0) : m = parseInt(m), u = Math.min(u, m);
	        var g = wc(d, "ScaleDenominator")[0].textContent, p = wc(d, "TopLeftCorner")[0].textContent, _ = wc(d, "TileWidth")[0].textContent, v = wc(d, "TileHeight")[0].textContent;
	        if (0 === h.length && h.push(parseInt(_), parseInt(v)), 0 === a.length) {
	            var y = p.split(" ").filter((function(t) {
	                return "" !== t;
	            })).map((function(t) {
	                return parseFloat(t);
	            })), x = y[0], b = y[1];
	            x > 0 ? a.push(1, -1, b, x) : a.push(1, -1, x, b);
	        }
	        var w = bc(e), C = parseFloat(g) * w;
	        s.push(C);
	    }
	    if (u > 0) for (var M = s[0], T = u - 1; T >= 0; T--) s.splice(0, 0, M *= 2);
	    return {
	        resolutions: s,
	        tileSize: h,
	        tileSystem: a,
	        projection: n,
	        TileMatrixSet: i,
	        isGeoServer: l,
	        levelStr: r
	    };
	}

	bh.loadWMTS = function(t, e, n) {
	    return void 0 === n && (n = {
	        jsonp: !0
	    }), jn(t) && Wo.get(t, (function(i, r) {
	        if (i) e(i); else {
	            var o = function(t, e, n) {
	                null == n.isArcgis && (n.isArcgis = t.indexOf("arcgis") > -1), null == n.isSuperMap && (n.isSuperMap = t.indexOf("supermap") > -1);
	                var i = (new DOMParser).parseFromString(t, "text/xml").querySelectorAll("Contents")[0];
	                if (!i) return [];
	                var r = wc(i, "Layer");
	                if (!r.length) return [];
	                for (var o = [], s = 0, a = i.childNodes.length; s < a; s++) "TileMatrixSet" === i.childNodes[s].localName && o.push(i.childNodes[s]);
	                if (!o.length) return [];
	                for (var h = [], l = 0, c = r.length; l < c; l++) {
	                    var u = r[l], f = u.querySelectorAll("Style")[0];
	                    f && (f = f.getElementsByTagName("ows:Identifier")[0]) && (f = f.textContent);
	                    var d = u.getElementsByTagName("ows:Identifier")[0];
	                    d && (d = d.textContent);
	                    var m = wc(u, "TileMatrixSetLink");
	                    if (0 !== m.length) for (var g = 0, p = m.length; g < p; g++) {
	                        var _ = m[g];
	                        (_ = wc(_, "TileMatrixSet")[0]) && (_ = _.textContent);
	                        var v = Cc(o, _);
	                        if (v) {
	                            var y = u.querySelectorAll("ResourceURL")[0], x = "";
	                            y && (x = y.attributes.template.value);
	                            var b = Mc(v, n), w = b.resolutions, C = b.tileSize, M = b.tileSystem, T = b.projection, S = b.TileMatrixSet, P = b.isGeoServer, A = b.levelStr;
	                            x.length || (x = e.substr(0, e.lastIndexOf("?")), x += "?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER={LAYER}&STYLE={Style}&TILEMATRIXSET={TileMatrixSet}&FORMAT={tiles}&TILEMATRIX={TileMatrix}&TILEROW={TileRow}&TILECOL={TileCol}");
	                            var E = xc(x, [ [ "{LAYER}", d ], [ "{Layer}", d ], [ "{layer}", d ], [ "{STYLE}", f ], [ "{Style}", f ], [ "{style}", f ], [ "{TileMatrixSet}", S ], [ "{TileMatrix}", P ? A + ":{z}" : "{z}" ], [ "{TileRow}", "{y}" ], [ "{TileCol}", "{x}" ], [ "{tiles}", P ? "image/png" : "tiles" ] ]);
	                            h.push({
	                                tileSize: C,
	                                tileSystem: M,
	                                spatialReference: {
	                                    resolutions: w,
	                                    projection: T
	                                },
	                                urlTemplate: E,
	                                info: {
	                                    layerName: d,
	                                    TileMatrixSet: S,
	                                    style: f,
	                                    tileSize: C,
	                                    tileSystem: M,
	                                    resolutions: w,
	                                    projection: T,
	                                    urlTemplate: E
	                                }
	                            });
	                        }
	                    }
	                }
	                return h;
	            }(r, t, n);
	            e(null, o);
	        }
	    }), n), this;
	};

	var Tc = function(t) {
	    function e(e) {
	        return t.call(this, e) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.addTo = function(t) {
	        return this._owner = t, this._switchEvents("on"), this.onAdd && this.onAdd(), this.fire("add"), 
	        this;
	    }, n.getMap = function() {
	        return this._owner ? this._owner.getBaseLayer ? this._owner : this._owner.getMap() : null;
	    }, n.show = function(t) {
	        var e = this.getMap();
	        if (!e) return this;
	        this.options.visible = !0, t = t || this._coordinate || this._owner.getCenter();
	        var n = this.isVisible();
	        this._showBySymbolChange || this.fire("showstart");
	        var i = this._getUIContainer();
	        this._coordinate = t, this._removePrevDOM(), this._mapEventsOn || this._switchMapEvents("on");
	        var r = this.__uiDOM = this.buildOn(e);
	        if (r.eventsPropagation = this.options.eventsPropagation, this._observerDomSize(r), 
	        !r) return this._showBySymbolChange || this.fire("showend"), this;
	        this._measureSize(r), this._singleton() && (r._uiComponent = this, e[this._uiDomKey()] = r), 
	        this._setPosition(), r.style[xo] = null, i.appendChild(r);
	        var o = this._getAnimation();
	        if (n && (o.ok = !1), o.ok && (o.fade && (r.style.opacity = 0), o.scale)) {
	            if (this.getTransformOrigin) {
	                var s = this.getTransformOrigin();
	                r.style[yo] = s;
	            }
	            r.style[vo] = this._toCSSTranslate(this._pos) + " scale(0)";
	        }
	        this.isSupportZoomFilter() || (r.style.display = ""), this.options.eventsToStop && Ho(r, this.options.eventsToStop, Ao), 
	        this.options.autoPan && this._autoPan();
	        var a = o.transition;
	        return o.ok && a && (a && (r.style[xo] = a), o.fade && (r.style.opacity = 1), o.scale && (r.style[vo] = this._toCSSTranslate(this._pos) + " scale(1)")), 
	        this._showBySymbolChange || this.fire("showend"), this;
	    }, n.hide = function() {
	        var t = this;
	        if (!this.getDOM()) return this;
	        this.options.visible = !1;
	        var e = this._getAnimation(), n = this.getDOM();
	        return this.options.animationOnHide || (e.ok = !1), e.ok ? (n.style[xo] = e.transition, 
	        setTimeout((function() {
	            n.style.display = "none", t.fire("hide");
	        }), this.options.animationDuration)) : (n.style.display = "none", this.fire("hide")), 
	        e.fade && (n.style.opacity = 0), e.scale && (n.style[vo] = this._toCSSTranslate(this._pos) + " scale(0)"), 
	        this._switchMapEvents("off"), this;
	    }, n.isVisible = function() {
	        if (!this.options.visible) return !1;
	        var t = this.getDOM();
	        return this.getMap() && t && t.parentNode && "none" !== t.style.display;
	    }, n.remove = function() {
	        return delete this._mapEventsOn, this._owner ? (this.hide(), this._switchEvents("off"), 
	        this.onRemove && this.onRemove(), !this._singleton() && this.__uiDOM && this._removePrevDOM(), 
	        delete this._owner, this.fire("remove"), this) : this;
	    }, n.getSize = function() {
	        return this._domContentRect && this._size && (this._size.width = this._domContentRect.width, 
	        this._size.height = this._domContentRect.height), this._size ? this._size.copy() : null;
	    }, n.getOwner = function() {
	        return this._owner;
	    }, n.getDOM = function() {
	        return this.__uiDOM;
	    }, n._roundPoint = function(t) {
	        return this.options.roundPoint && (t = t._round()), t;
	    }, n.getPosition = function() {
	        if (!this.getMap()) return null;
	        var t = this._roundPoint(this._getViewPoint());
	        if (this.getOffset) {
	            var e = this._roundPoint(this.getOffset());
	            e && t._add(e);
	        }
	        return t;
	    }, n._getAnimation = function() {
	        for (var t = {
	            fade: !1,
	            scale: !1
	        }, e = this.options.animation ? this.options.animation.split(",") : [], n = 0; n < e.length; n++) {
	            var i = Vr(e[n]);
	            "fade" === i ? t.fade = !0 : "scale" === i && (t.scale = !0);
	        }
	        var r = null;
	        return t.fade && (r = "opacity " + this.options.animationDuration + "ms"), t.scale && (r = r ? r + "," : "", 
	        r += vo + " " + this.options.animationDuration + "ms"), t.transition = r, t.ok = null !== r, 
	        t;
	    }, n._getViewPoint = function() {
	        var t = 0, e = this._coordinate || {};
	        Ln(e.z) ? t = e.z : this._owner && this._owner.getAltitude && (t = this._owner.getAltitude() || 0);
	        var n = this._meterToPoint(this._coordinate, t);
	        return this.getMap().coordToViewPoint(this._coordinate, void 0, n)._add(this.options.dx, this.options.dy);
	    }, n._meterToPoint = function(t, e) {
	        var n = this.getMap();
	        return n.altitudeToPoint(e, n._getResolution()) * Bi$1(e);
	    }, n._autoPan = function() {
	        var t = this.getMap(), e = this.getDOM();
	        if (!t.isMoving()) {
	            var n = this._getViewPoint()._round(), i = t.width, r = t.height, o = t.viewPointToContainerPoint(n), s = this.getOffset(), a = o.add(s), h = t._viewPointToPrj(n), l = parseInt(e.clientWidth), c = parseInt(e.clientHeight), u = 0, f = 0;
	            if (a.x < 0 ? u = 50 - a.x : a.x + l > i && (u = -(a.x + l - i) - 50), a.y - c < 0 ? f = Math.abs(a.y - c) + 50 : a.y + c > r && (f = r - (a.y + c) - 50), 
	            l >= i && (u = i / 2 - o.x), 0 !== f || 0 !== u) {
	                var d = o.add(u, f), m = t._containerPointToPoint(d)._sub(t._prjToPoint(t._getPrjCenter())), g = t._pointToPrj(t._prjToPoint(h).sub(m));
	                t._panAnimation(g);
	            }
	        }
	    }, n._measureSize = function(t) {
	        var e = this._getUIContainer();
	        t.style.position = "absolute";
	        var n = t.style.bottom ? "bottom" : "top";
	        if (t.style.display = "", e.appendChild(t), t.getBoundingClientRect) {
	            var i = t.getBoundingClientRect();
	            this._size = new Gr(i.width, i.height);
	        } else this._size = new Gr(t.clientWidth, t.clientHeight);
	        return t.style.display = "none", t.style.left = "0px", t.style[n] = "0px", this._size;
	    }, n._removePrevDOM = function() {
	        this.onDomRemove && this.onDomRemove();
	        var t = this.options.eventsToStop;
	        if (this._singleton()) {
	            var e = this.getMap(), n = this._uiDomKey();
	            if (e[n]) {
	                t && No(e[n], t, Ao);
	                var i = e[n]._uiComponent;
	                i && i !== this && i.isVisible() && i.fire("hide"), Co(e[n]), i && !this.hideDom && i._switchMapEvents("off"), 
	                delete e[n];
	            }
	            delete this.__uiDOM;
	        } else this.__uiDOM && (t && No(this.__uiDOM, t, Ao), Co(this.__uiDOM), delete this.__uiDOM);
	        this._resizeObserver && (this._resizeObserver.disconnect(), delete this._resizeObserver, 
	        delete this._domContentRect);
	    }, n._uiDomKey = function() {
	        return "__ui_" + this._getClassName();
	    }, n._singleton = function() {
	        return this.options.single;
	    }, n._getUIContainer = function() {
	        return this.getMap()._panels.ui;
	    }, n._getClassName = function() {
	        return "UIComponent";
	    }, n._switchMapEvents = function(t) {
	        var e = this.getMap();
	        if (e) {
	            this._mapEventsOn = "on" === t;
	            var n = this._getDefaultEvents();
	            if (this.getEvents && kn(n, this.getEvents()), n) for (var i in n) n.hasOwnProperty(i) && e[t](i, n[i], this);
	        }
	    }, n._switchEvents = function(t) {
	        var e = this._getOwnerEvents();
	        if (this._owner) for (var n in e) e.hasOwnProperty(n) && this._owner[t](n, e[n], this);
	    }, n._getDefaultEvents = function() {
	        return {
	            "zooming rotate pitch": this.onEvent,
	            zoomend: this.onZoomEnd,
	            moving: this.onMoving,
	            moveend: this.onMoving,
	            resize: this.onResize
	        };
	    }, n._getOwnerEvents = function() {
	        var t = {};
	        return this._owner && this._owner instanceof Mh && (t.positionchange = this.onGeometryPositionChange, 
	        t.symbolchange = this._updatePosition), this.getOwnerEvents && kn(t, this.getOwnerEvents()), 
	        t;
	    }, n.onGeometryPositionChange = function(t) {
	        this._owner && this.isVisible() && (this._showBySymbolChange = !0, this.show(t.target.getCenter()), 
	        delete this._showBySymbolChange);
	    }, n.onMoving = function() {
	        this.isVisible() && this.getMap().isTransforming() && this._updatePosition();
	    }, n.onEvent = function() {
	        this.isVisible() && this._updatePosition();
	    }, n.onZoomEnd = function() {
	        this.isVisible() && this._setPosition();
	    }, n.onResize = function() {
	        this.isVisible() && this._setPosition();
	    }, n.onDomSizeChange = function() {
	        this.isVisible() && this._setPosition();
	    }, n._updatePosition = function() {
	        return this.getMap() ? (this.getMap()._getRenderer().callInNextFrame(this._setPosition.bind(this)), 
	        this) : this;
	    }, n._setPosition = function() {
	        var t = this.getDOM();
	        if (t) {
	            t.style[xo] = null;
	            var e = this.getPosition();
	            this._pos = e, t.style[vo] = this._toCSSTranslate(e) + " scale(1)";
	        }
	    }, n._toCSSTranslate = function(t) {
	        if (!t) return "";
	        if (Mi$1.any3d) {
	            var e = this.getMap(), n = e ? e.getBearing() : 0, i = e ? e.getPitch() : 0, r = "";
	            return this.options.pitchWithMap && i && (r += " rotateX(" + Math.round(i) + "deg)"), 
	            this.options.rotateWithMap && n && (r += " rotateZ(" + Math.round(-n) + "deg)"), 
	            "translate3d(" + t.x + "px," + t.y + "px, 0px)" + r;
	        }
	        return "translate(" + t.x + "px," + t.y + "px)";
	    }, n._observerDomSize = function(t) {
	        var e = this;
	        return t && Mi$1.resizeObserver && !this._resizeObserver ? (this._resizeObserver = new ResizeObserver((function(t) {
	            t.length ? e._domContentRect = t[0].contentRect : delete e._domContentRect, e.onDomSizeChange && e.onDomSizeChange();
	        })), this._resizeObserver.observe(t), this) : this;
	    }, n.isSupportZoomFilter = function() {
	        return !1;
	    }, e.isSupport = function(t) {
	        return !!(t && Hn(t.on) && Hn(t.off) && Hn(t.getCenter));
	    }, e;
	}(ts(ns));

	Tc.mergeOptions({
	    eventsPropagation: !1,
	    eventsToStop: null,
	    dx: 0,
	    dy: 0,
	    autoPan: !1,
	    autoPanDuration: 600,
	    single: !0,
	    animation: "scale",
	    animationOnHide: !1,
	    animationDuration: 500,
	    pitchWithMap: !1,
	    rotateWithMap: !1,
	    visible: !0,
	    roundPoint: !1
	});

	var Sc = "mousedown mouseup mouseenter mouseover mouseout mousemove click dblclick contextmenu keypress touchstart touchmove touchend", Pc = function(t) {
	    function e(e, n) {
	        var i;
	        return (i = t.call(this, n) || this)._markerCoord = new us(e), i;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n._getClassName = function() {
	        return "UIMarker";
	    }, n.setCoordinates = function(t) {
	        return this._markerCoord = t, this.fire("positionchange"), this.isVisible() && (this._coordinate = this._markerCoord, 
	        this._setPosition()), this;
	    }, n.getCoordinates = function() {
	        return this._markerCoord;
	    }, n.getCenter = function() {
	        return this.getCoordinates();
	    }, n.getAltitude = function() {
	        var t = this.getCoordinates() || {};
	        return Ln(t.z) ? t.z : this.options.altitude || 0;
	    }, n.setContent = function(t) {
	        var e = this.options.content;
	        return this.options.content = t, this.fire("contentchange", {
	            old: e,
	            new: t
	        }), this.isVisible() && this.show(), this;
	    }, n.getContent = function() {
	        return this.options.content;
	    }, n.onAdd = function() {
	        this.show();
	    }, n.show = function() {
	        return t.prototype.show.call(this, this._markerCoord);
	    }, n.flash = function(t, e, n, i) {
	        return or.call(this, t, e, n, i);
	    }, n.buildOn = function() {
	        var t, e = this.options.content, n = jn(e);
	        return n || Hn(e) ? (t = bo("div"), n ? t.innerHTML = this.options.content : e.bind(this)(t)) : t = this.options.content, 
	        this.options.containerClass && (t.className = this.options.containerClass), this._registerDOMEvents(t), 
	        t;
	    }, n.getOffset = function() {
	        var t = this.getSize();
	        return new Oi$1(-t.width / 2, -t.height / 2);
	    }, n.getTransformOrigin = function() {
	        return "center center";
	    }, n.onDomRemove = function() {
	        var t = this.getDOM();
	        this._removeDOMEvents(t);
	    }, n.isDragging = function() {
	        return !!this.draggable && this.draggable.isDragging();
	    }, n._registerDOMEvents = function(t) {
	        Ho(t, Sc, this._onDomEvents, this);
	    }, n._onDomEvents = function(t) {
	        var e = this.getMap()._parseEvent(t, t.type), n = t.type;
	        if ("mousedown" === n && (this._mousedownEvent = t), "mouseup" === n && (this._mouseupEvent = t), 
	        ("click" !== n || !this._mouseClickPositionIsChange()) && ("touchstart" === n && (this._touchstartTime = In()), 
	        this.fire(t.type, e), "touchend" === n && Mi$1.touch)) {
	            var i = this.getMap().options.clickTimeThreshold || 280;
	            In() - this._touchstartTime < i && this._onDomEvents(kn({}, t, {
	                type: "click"
	            }));
	        }
	    }, n._removeDOMEvents = function(t) {
	        No(t, Sc, this._onDomEvents);
	    }, n._mouseClickPositionIsChange = function() {
	        var t = this._mousedownEvent || {}, e = this._mouseupEvent || {};
	        return t.x !== e.x || t.y !== e.y;
	    }, n._getConnectPoints = function() {
	        var t = this.getMap(), e = t.coordToContainerPoint(this.getCoordinates()), n = this.getSize(), i = n.width, r = n.height;
	        return [ t.containerPointToCoordinate(e.add(-i / 2, 0)), t.containerPointToCoordinate(e.add(i / 2, 0)), t.containerPointToCoordinate(e.add(0, r / 2)), t.containerPointToCoordinate(e.add(0, -r / 2)) ];
	    }, n._getViewPoint = function() {
	        var t = 0;
	        if (this._owner) {
	            var e = this.getAltitude();
	            e > 0 && (t = this._meterToPoint(this._coordinate, e));
	        }
	        return this.getMap().coordToViewPoint(this._coordinate, void 0, t)._add(this.options.dx, this.options.dy);
	    }, n._getDefaultEvents = function() {
	        return kn({}, t.prototype._getDefaultEvents.call(this), {
	            "zooming zoomend": this.onZoomFilter
	        });
	    }, n._setPosition = function() {
	        this.onZoomFilter(), t.prototype._setPosition.call(this);
	    }, n.onZoomFilter = function() {
	        var t = this.getDOM();
	        t && (this.isVisible() || "none" === t.style.display ? this.isVisible() && "none" === t.style.display && (t.style.display = "") : t.style.display = "none");
	    }, n.isVisible = function() {
	        var t = this.getMap();
	        if (!t) return !1;
	        if (!this.options.visible) return !1;
	        var e = t.getZoom(), n = this.options, i = n.minZoom, r = n.maxZoom;
	        return !(!Dn(i) && e < i || !Dn(r) && e > r) && (this.getDOM() && !0);
	    }, n.isSupportZoomFilter = function() {
	        return !0;
	    }, e;
	}(as(Tc));

	Pc.mergeOptions({
	    containerClass: null,
	    eventsPropagation: !0,
	    draggable: !1,
	    single: !1,
	    content: null,
	    altitude: 0,
	    minZoom: 0,
	    maxZoom: null
	});

	var Ac = Mi$1.touch ? "touchstart mousedown" : "mousedown", Ec = function(t) {
	    function e(e) {
	        return t.call(this, e) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.addHooks = function() {
	        this.target.on(Ac, this._startDrag, this);
	    }, n.removeHooks = function() {
	        this.target.off(Ac, this._startDrag, this);
	    }, n._startDrag = function(t) {
	        var e = t.domEvent;
	        e.touches && e.touches.length > 1 || 2 === e.button || this.isDragging() || (this.target.on("click", this._endDrag, this), 
	        this._lastCoord = t.coordinate, this._lastPoint = t.containerPoint, this._prepareDragHandler(), 
	        this._dragHandler.onMouseDown(t.domEvent), this.target.fire("dragstart", t));
	    }, n._prepareDragHandler = function() {
	        this._dragHandler = new cs(this.target.getDOM(), {
	            cancelOn: this._cancelOn.bind(this),
	            ignoreMouseleave: !0
	        }), this._dragHandler.on("mousedown", this._onMouseDown, this), this._dragHandler.on("dragging", this._dragging, this), 
	        this._dragHandler.on("mouseup", this._endDrag, this), this._dragHandler.enable();
	    }, n._cancelOn = function(t) {
	        var e = (t.srcElement || t.target).tagName.toLowerCase();
	        return "button" === e || "input" === e || "select" === e || "option" === e || "textarea" === e;
	    }, n._onMouseDown = function(t) {
	        Ao(t.domEvent);
	    }, n._dragging = function(t) {
	        var e = this.target, n = e.getMap()._parseEvent(t.domEvent), i = n.domEvent;
	        if (!(i.touches && i.touches.length > 1)) if (this._isDragging) {
	            var r = n.coordinate, o = n.containerPoint;
	            this._lastCoord || (this._lastCoord = r), this._lastPoint || (this._lastPoint = o);
	            var s = r.sub(this._lastCoord), a = o.sub(this._lastPoint);
	            this._lastCoord = r, this._lastPoint = o, this.target.setCoordinates(this.target.getCoordinates().add(s)), 
	            n.coordOffset = s, n.pointOffset = a, e.fire("dragging", n);
	        } else this._isDragging = !0;
	    }, n._endDrag = function(t) {
	        var e = this.target, n = e.getMap();
	        if (this._dragHandler && (e.off("click", this._endDrag, this), this._dragHandler.disable(), 
	        delete this._dragHandler), delete this._lastCoord, delete this._lastPoint, this._isDragging = !1, 
	        n) {
	            var i = n._parseEvent(t.domEvent);
	            e && e._mouseClickPositionIsChange && e._mouseClickPositionIsChange() && e.fire("dragend", i);
	        }
	    }, n.isDragging = function() {
	        return !!this._isDragging;
	    }, e;
	}(es);

	Pc.addInitHook("addHandler", "draggable", Ec);

	var Oc = /\{ *([\w_]+) *\}/g, Rc = {
	    containerClass: "maptalks-msgBox",
	    autoPan: !0,
	    autoCloseOn: null,
	    autoOpenOn: "click",
	    width: "auto",
	    minHeight: 120,
	    custom: !1,
	    title: null,
	    content: null,
	    enableTemplate: !1
	}, Ic = new Gr(0, 0), kc = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n._getClassName = function() {
	        return "InfoWindow";
	    }, n.addTo = function(e) {
	        return e instanceof Mh && (e.getInfoWindow() && e.getInfoWindow() !== this && e.removeInfoWindow(), 
	        e._infoWindow = this), t.prototype.addTo.call(this, e);
	    }, n.setContent = function(t) {
	        var e = this.options.content;
	        return this.options.content = t, this.fire("contentchange", {
	            old: e,
	            new: t
	        }), this.isVisible() && this.show(this._coordinate), this;
	    }, n.getContent = function() {
	        return this.options.content;
	    }, n.setTitle = function(t) {
	        var e = t;
	        return this.options.title = t, this.fire("contentchange", {
	            old: e,
	            new: t
	        }), this.isVisible() && this.show(this._coordinate), this;
	    }, n.getTitle = function() {
	        return this.options.title;
	    }, n.buildOn = function() {
	        var t = Hn(this.options.content), e = jn(this.options.content);
	        if (this.options.custom) {
	            if (e || t) {
	                var n = bo("div");
	                return e ? (n.innerHTML = this.options.content, this._replaceTemplate(n)) : this.options.content.bind(this)(n), 
	                n;
	            }
	            return this._replaceTemplate(this.options.content), this.options.content;
	        }
	        var i = bo("div");
	        this.options.containerClass && (i.className = this.options.containerClass);
	        var r = this._getWindowWidth();
	        i.style.width = Ln(r) ? r + "px" : "auto", i.style.bottom = "0px";
	        var o = '<em class="maptalks-ico"></em>';
	        this.options.title && (o += "<h2>" + this.options.title + "</h2>"), i.innerHTML = o += '<a href="javascript:void(0);" class="maptalks-close"></a><div class="maptalks-msgContent"></div>', 
	        this._replaceTemplate(i);
	        var s = i.querySelector(".maptalks-msgContent");
	        return e || t ? e ? s.innerHTML = this.options.content : this.options.content.bind(this)(s) : s.appendChild(this.options.content), 
	        this._onCloseBtnClick = this.hide.bind(this), Mo(i.querySelector(".maptalks-close"), "click touchend", this._onCloseBtnClick), 
	        t || this._replaceTemplate(s), i;
	    }, n._replaceTemplate = function(t) {
	        if (this.options.enableTemplate && this._owner && this._owner.getProperties && t && t.innerHTML) {
	            var e = this._owner.getProperties() || {};
	            if (Fn(e)) t.innerHTML = t.innerHTML.replace(Oc, (function(t, n) {
	                return e[n];
	            }));
	        }
	        return this;
	    }, n.getTransformOrigin = function() {
	        return this.getSize().width / 2 + "px bottom";
	    }, n.getOffset = function() {
	        var t = this.getSize(), e = new Oi$1(-t.width / 2, 0);
	        this.options.custom ? e._sub(0, t.height) : e._sub(4, 12);
	        var n = this.getOwner();
	        if (n instanceof $h || n instanceof sl) {
	            var i, r;
	            if (n instanceof $h) i = n._getPainter(), r = n.getSize(); else {
	                var o = n.getGeometries();
	                if (!o || !o.length) return e;
	                i = o[0]._getPainter(), r = o[0].getSize();
	            }
	            if (r || (r = Ic), i) {
	                var s = i.getFixedExtent();
	                e._add(s.xmax - r.width / 2, s.ymin);
	            } else e._add(0, -r.height);
	        }
	        return e;
	    }, n.show = function(e) {
	        return this.getMap() && this.getMap().options.enableInfoWindow ? t.prototype.show.call(this, e) : this;
	    }, n.getEvents = function() {
	        if (!this.options.autoCloseOn) return null;
	        var t = {};
	        return t[this.options.autoCloseOn] = this.hide, t;
	    }, n.getOwnerEvents = function() {
	        var t = this.getOwner();
	        if (!this.options.autoOpenOn || !t) return null;
	        var e = {};
	        return e[this.options.autoOpenOn] = this._onAutoOpen, e;
	    }, n.onRemove = function() {
	        this.onDomRemove();
	    }, n.onDomRemove = function() {
	        this._onCloseBtnClick && (To(this.getDOM().childNodes[2], "click touchend", this._onCloseBtnClick), 
	        delete this._onCloseBtnClick);
	    }, n._onAutoOpen = function(t) {
	        var e = this, n = this.getOwner();
	        setTimeout((function() {
	            n instanceof $h || n instanceof Tc ? e.show(n.getCoordinates()) : n instanceof sl ? e.show(n.findClosest(t.coordinate)) : n instanceof el || n instanceof hl ? (e.getMap().getScale() >= 8 && (t.coordinate = e._rectifyMouseCoordinte(n, t.coordinate)), 
	            e.show(t.coordinate)) : e.show(t.coordinate);
	        }), 1);
	    }, n._rectifyMouseCoordinte = function(t, e) {
	        var n = this;
	        return t instanceof el ? this._rectifyLineStringMouseCoordinate(t, e).coordinate : t instanceof hl ? t.getGeometries().map((function(t) {
	            return n._rectifyLineStringMouseCoordinate(t, e);
	        })).sort((function(t, e) {
	            return t.dis - e.dis;
	        }))[0].coordinate : e;
	    }, n._rectifyLineStringMouseCoordinate = function(t, e) {
	        for (var n = this, i = t.getCoordinates().map((function(t) {
	            return n.getMap().coordToContainerPoint(t);
	        })), r = this.getMap().coordToContainerPoint(e), o = 1 / 0, s = -1, a = 0, h = i.length; a < h; a++) {
	            var l = r.distanceTo(i[a]);
	            l < o && (o = l, s = a);
	        }
	        var c = [];
	        0 === s ? c.push(i[0], i[1]) : s === i.length - 1 ? c.push(i[s - 1], i[s]) : c.push(i[s - 1], i[s], i[s + 1]);
	        for (var u = [], f = this.getMap().getSize(), d = f.width, m = f.height, g = 0, p = c.length - 1; g < p; g++) {
	            var _ = c[g], v = c[g + 1];
	            if (_.x === v.x) for (var y = Math.max(0, Math.min(_.y, v.y)), x = Math.min(m, Math.max(_.y, v.y)), b = y; b <= x; b++) u.push(new Oi$1(_.x, b)); else for (var w = (v.y - _.y) / (v.x - _.x), C = Math.max(0, Math.min(_.x, v.x)), M = Math.min(d, Math.max(_.x, v.x)), T = C; T <= M; T++) {
	                u.push(new Oi$1(T, w * (T - _.x) + _.y));
	            }
	        }
	        for (var S = 1 / 0, P = -1, A = 0, E = u.length; A < E; A++) {
	            var O = r.distanceTo(u[A]);
	            O < S && (S = O, P = A);
	        }
	        return {
	            dis: S,
	            coordinate: P < 0 ? e : this.getMap().containerPointToCoord(u[P])
	        };
	    }, n._getWindowWidth = function() {
	        var t = this.options.width;
	        return t || (t = Rc.width), t;
	    }, e;
	}(Tc);

	kc.mergeOptions(Rc);

	var Dc = "remove hide shapechange positionchange dragend animatestart";

	(function(t) {
	    Ti$1(n, t);
	    var e = n.prototype;
	    function n(e, n) {
	        var i;
	        return void 0 === n && (n = {}), (i = t.call(this, n) || this)._content = e, i;
	    }
	    return e._getClassName = function() {
	        return "ToolTip";
	    }, e.addTo = function(e) {
	        if (n.isSupport(e)) return e.on("mousemove", this.onMouseMove, this), e.on("mouseout", this.onMouseOut, this), 
	        e.on(Dc, this.hideDom, this), t.prototype.addTo.call(this, e);
	        throw new Error("Invalid geometry or UIMarker the tooltip is added to.");
	    }, e.setStyle = function(t) {
	        return this.options.containerClass = t, this;
	    }, e.getStyle = function() {
	        return this.options.containerClass;
	    }, e.getContent = function() {
	        return this._content;
	    }, e.buildOn = function() {
	        var t = bo("div"), e = this.options || {};
	        e.height && (t.style.height = e.height + "px"), e.width && (t.style.width = e.width + "px");
	        var n = e.containerClass || e.cssName;
	        return !n && e.height && (t.style.lineHeight = e.height + "px"), Hn(this._content) ? this._content.bind(this)(t) : t.innerHTML = '<div class="' + n + '">' + this._content + "</div>", 
	        t;
	    }, e.onMouseOut = function() {
	        clearTimeout(this._timeout), this.isVisible() && this._removePrevDOM(), this._switchMapEvents("off");
	    }, e.onMouseMove = function(t) {
	        var e = this;
	        clearTimeout(this._timeout);
	        var n = this.getMap();
	        if (n) {
	            var i = n.locateByPoint(t.coordinate, -5, 25);
	            0 === this.options.showTimeout ? this.show(i) : this._timeout = setTimeout((function() {
	                n && e.show(i);
	            }), this.options.showTimeout);
	        }
	    }, e.onRemove = function() {
	        clearTimeout(this._timeout), this._owner && (this._owner.off("mouseover", this.onMouseOver, this), 
	        this._owner.off("mouseout", this.onMouseOut, this), this._owner.off(Dc, this.hideDom, this));
	    }, e.hideDom = function() {
	        return this.hide();
	    }, e.onEvent = function() {
	        return t.prototype.onEvent.call(this), this.hideDom(), this;
	    }, e._getViewPoint = function() {
	        return this.getMap().coordToViewPoint(this._coordinate, void 0, 0)._add(this.options.dx, this.options.dy);
	    }, n;
	})(Tc).mergeOptions({
	    width: 0,
	    height: 0,
	    animation: "fade",
	    containerClass: "maptalks-tooltip",
	    showTimeout: 400
	});

	var Lc = function(t) {
	    function e(e) {
	        return t.call(this, e) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n._getClassName = function() {
	        return "Menu";
	    }, n.addTo = function(t) {
	        return t._menu && t._menu !== this && t.removeMenu(), t._menu = this, this._owner = t, 
	        Tc.prototype.addTo.apply(this, arguments);
	    }, n.setItems = function(t) {
	        return this.options.items = t, this;
	    }, n.getItems = function() {
	        return this.options.items || [];
	    }, n.buildOn = function() {
	        if (this.options.custom) {
	            if (jn(this.options.items)) {
	                var t = bo("div");
	                return t.innerHTML = this.options.items, t;
	            }
	            return this.options.items;
	        }
	        var e = bo("div");
	        this.options.containerClass && Do(e, this.options.containerClass), e.style.width = this._getMenuWidth() + "px";
	        var n = this._createMenuItemDom();
	        return e.appendChild(n), Ho(e, "contextmenu", Po), e;
	    }, n.getOffset = function() {
	        if (!this.getMap()) return null;
	        var t = this.getMap().getSize(), e = this.getMap().viewPointToContainerPoint(this._getViewPoint()), n = this.getSize(), i = 0, r = 0;
	        return e.x + n.width > t.width && (i = -n.width), e.y + n.height > t.height && (r = -n.height), 
	        new Oi$1(i, r);
	    }, n.getTransformOrigin = function() {
	        var t = this.getOffset()._multi(-1);
	        return t.x + "px " + t.y + "px";
	    }, n.getEvents = function() {
	        return {
	            "_zoomstart _zoomend _movestart _dblclick _click": this._removePrevDOM
	        };
	    }, n._createMenuItemDom = function() {
	        var t = this, e = this.getMap(), n = bo("ul");
	        Do(n, "maptalks-menu-items");
	        var i, r, o = this.getItems();
	        function s(n) {
	            return function(i) {
	                var r = e._parseEvent(i, "click");
	                r.target = t, r.owner = t._owner, r.index = n, !1 !== this._callback(r) && (t.hide(), 
	                t._owner && t._owner.fire("closemenu"));
	            };
	        }
	        for (var a = 0, h = o.length; a < h; a++) {
	            if ("-" === (i = o[a]) || "_" === i) Do(r = bo("li"), "maptalks-menu-splitter"); else {
	                r = bo("li");
	                var l = i.item;
	                Hn(l) && (l = l({
	                    owner: this._owner,
	                    index: a
	                })), r.innerHTML = l, r._callback = i.click, Ho(r, "click", s(a));
	            }
	            n.appendChild(r);
	        }
	        var c = this.options.maxHeight || 0;
	        return c > 0 && Io(n, "max-height: " + c + "px; overflow-y: auto;"), n;
	    }, n._getMenuWidth = function() {
	        return this.options.width || 160;
	    }, e;
	}(Tc);

	Lc.mergeOptions({
	    containerClass: "maptalks-menu",
	    animation: null,
	    animationDelay: 10,
	    animationOnHide: !1,
	    autoPan: !1,
	    width: 160,
	    maxHeight: 0,
	    custom: !1,
	    items: []
	});

	var zc = {
	    setMenu: function(t) {
	        return this._menuOptions = t, this._menu ? this._menu.setOptions(t) : this.on("contextmenu", this._defaultOpenMenu, this), 
	        this;
	    },
	    getMenu: function() {
	        return this._menu;
	    },
	    openMenu: function(t) {
	        var e = this instanceof Fh ? this : this.getMap();
	        return t || (t = this.getCenter()), this._menu ? this._menu.show(t) : this._menuOptions && e && (this._bindMenu(), 
	        this._menu.show(t)), this.fire("openmenu", {
	            coordinate: t
	        }), this;
	    },
	    setMenuItems: function(t) {
	        return this._menuOptions || (this._menuOptions = {}), Array.isArray(t) && (this._menuOptions.custom = !1), 
	        this._menuOptions.items = t, this.setMenu(this._menuOptions), this;
	    },
	    getMenuItems: function() {
	        return this._menu ? this._menu.getItems() : this._menuOptions && this._menuOptions.items || [];
	    },
	    closeMenu: function() {
	        return this._menu && this._menu.hide(), this.fire("closemenu", {}), this;
	    },
	    removeMenu: function() {
	        return this.off("contextmenu", this._defaultOpenMenu, this), this._unbindMenu(), 
	        delete this._menuOptions, this.fire("removemenu", {}), this;
	    },
	    _bindMenu: function() {
	        return this._menuOptions ? (this._menu = new Lc(this._menuOptions), this._menu.addTo(this), 
	        this) : this;
	    },
	    _unbindMenu: function() {
	        return this._menu && (this.closeMenu(), this._menu.remove(), delete this._menu), 
	        this;
	    },
	    _defaultOpenMenu: function(t) {
	        return this.openMenu(t.coordinate), !1;
	    }
	};

	Fh.include(zc), Mh.include(zc);

	var Fc = function(t) {
	    function e(e) {
	        return e && e.position && !jn(e.position) && (e.position = kn({}, e.position)), 
	        t.call(this, e) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.addTo = function(t) {
	        if (this.remove(), !t.options.control) return this;
	        this._map = t;
	        var e = t._panels.control;
	        return this.__ctrlContainer = bo("div"), Io(this.__ctrlContainer, "position:absolute;overflow:visible;"), 
	        this.update(), e.appendChild(this.__ctrlContainer), this.onAdd && this.onAdd(), 
	        this.fire("add", {
	            dom: e
	        }), this;
	    }, n.update = function() {
	        return this.__ctrlContainer.innerHTML = "", this._controlDom = this.buildOn(this.getMap()), 
	        this._controlDom && (this._updatePosition(), this.__ctrlContainer.appendChild(this._controlDom)), 
	        this;
	    }, n.getMap = function() {
	        return this._map;
	    }, n.getPosition = function() {
	        return kn({}, this._parse(this.options.position));
	    }, n.setPosition = function(t) {
	        return this.options.position = jn(t) ? t : kn({}, t), this._updatePosition(), this;
	    }, n.getContainerPoint = function() {
	        var t, e, n = this.getPosition(), i = this.getMap().getSize();
	        return Dn(n.left) ? Dn(n.right) || (t = i.width - parseInt(n.right)) : t = parseInt(n.left), 
	        Dn(n.top) ? Dn(n.bottom) || (e = i.height - parseInt(n.bottom)) : e = parseInt(n.top), 
	        new Oi$1(t, e);
	    }, n.getContainer = function() {
	        return this.__ctrlContainer;
	    }, n.getDOM = function() {
	        return this._controlDom;
	    }, n.show = function() {
	        return this.__ctrlContainer.style.display = "", this;
	    }, n.hide = function() {
	        return this.__ctrlContainer.style.display = "none", this;
	    }, n.isVisible = function() {
	        return this.__ctrlContainer && "" === this.__ctrlContainer.style.display;
	    }, n.remove = function() {
	        return this._map ? (Co(this.__ctrlContainer), this.onRemove && this.onRemove(), 
	        delete this._map, delete this.__ctrlContainer, delete this._controlDom, this.fire("remove"), 
	        this) : this;
	    }, n._parse = function(t) {
	        var n = t;
	        return jn(t) && (n = e.positions[n]), n;
	    }, n._updatePosition = function() {
	        var t = this.getPosition();
	        for (var e in t || (t = {
	            top: 20,
	            left: 20
	        }), t) t.hasOwnProperty(e) && (t[e] = parseInt(t[e]), this.__ctrlContainer.style[e] = t[e] + "px");
	        this.fire("positionchange", {
	            position: kn({}, t)
	        });
	    }, e;
	}(ts(ns));

	Fc.positions = {
	    "top-left": {
	        top: 20,
	        left: 20
	    },
	    "top-right": {
	        top: 20,
	        right: 20
	    },
	    "bottom-left": {
	        bottom: 20,
	        left: 20
	    },
	    "bottom-right": {
	        bottom: 20,
	        right: 20
	    }
	}, Fh.mergeOptions({
	    control: !0
	}), Fh.include({
	    addControl: function(t) {
	        return this._containerDOM.getContext || t.addTo(this), this;
	    },
	    removeControl: function(t) {
	        return t && t.getMap() === this ? (t.remove(), this) : this;
	    }
	});

	var jc = "addlayer removelayer setbaselayer baselayerremove", Hc = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.buildOn = function() {
	        return this._attributionContainer = bo("div"), this._attributionContainer.className = "maptalks-attribution", 
	        this._update(), this._attributionContainer;
	    }, n.onAdd = function() {
	        this.getMap().on(jc, this._update, this);
	    }, n.onRemove = function() {
	        this.getMap().off(jc, this._update, this);
	    }, n._update = function() {
	        var t = this.getMap();
	        if (t) {
	            var e = t._getLayers((function(t) {
	                return t.options.attribution;
	            })).reverse().map((function(t) {
	                return t.options.attribution;
	            })), n = this.options.content + (e.length > 0 ? " - " + e.join(", ") : "");
	            this._attributionContainer.innerHTML = '<span style="padding:0px 4px">' + n + "</span>";
	        }
	    }, e;
	}(Fc);

	Hc.mergeOptions({
	    position: {
	        bottom: 0,
	        left: 0
	    },
	    content: '<a href="http://maptalks.org" target="_blank">maptalks</a>'
	}), Fh.mergeOptions({
	    attribution: !0
	}), Fh.addOnLoadHook((function() {
	    var t = this.options.attribution || this.options.attributionControl;
	    t && (this.attributionControl = new Hc(t), this.addControl(this.attributionControl));
	}));

	var Nc = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.buildOn = function() {
	        var t = this.container = bo("div", this.options.containerClass), e = this.panel = bo("div", "panel"), n = this.button = bo("button");
	        return t.appendChild(n), t.appendChild(e), t;
	    }, n.onAdd = function() {
	        Ho(this.button, "mouseover", this._show, this), Ho(this.panel, "mouseleave", this._hide, this), 
	        Ho(this.getMap(), "click", this._hide, this);
	    }, n.onRemove = function() {
	        this.panel && (No(this.button, "mouseover", this._show), No(this.panel, "mouseleave", this._hide), 
	        No(this.getMap(), "click", this._hide), Co(this.panel), Co(this.button), delete this.panel, 
	        delete this.button, delete this.container);
	    }, n._show = function() {
	        ko(this.container, "shown") || (Do(this.container, "shown"), this._createPanel());
	    }, n._hide = function(t) {
	        this.panel.contains(t.toElement || t.relatedTarget) || Lo(this.container, this.options.containerClass);
	    }, n._createPanel = function() {
	        this.panel.innerHTML = "";
	        var t = bo("ul");
	        this.panel.appendChild(t), this._renderLayers(this.getMap(), t);
	    }, n._renderLayers = function(t, e) {
	        var n = this, i = t.getBaseLayer(), r = t.getLayers(), o = r.length;
	        if (i) {
	            var s = i.layers || [ i ], a = bo("li", "group"), h = bo("ul"), l = bo("label");
	            l.innerHTML = this.options.baseTitle, a.appendChild(l);
	            for (var c = 0, u = s.length; c < u; c++) {
	                this._isExcluded(s[c]) && (h.appendChild(this._renderLayer(s[c], !0)), a.appendChild(h), 
	                e.appendChild(a));
	            }
	        }
	        if (o) {
	            var f = bo("li", "group"), d = bo("ul"), m = bo("label"), g = bo("input");
	            g.type = "checkbox", g.checked = !0, m.innerHTML = this.options.overlayTitle, f.appendChild(g), 
	            f.appendChild(m);
	            for (var p = function(t) {
	                var e = t.target.checked, n = t.target.parentNode;
	                if (n) {
	                    var i = n.getElementsByTagName("ul")[0];
	                    if (i) {
	                        var r = function(t) {
	                            var n = t._layer;
	                            n && n[e ? "show" : "hide"]();
	                        }, o = function(t) {
	                            var n = t._layer, i = t.childNodes[0];
	                            i && (i.checked = e), n && n[e ? "show" : "hide"]();
	                        };
	                        r(n), i.childNodes.forEach((function(t) {
	                            o(t);
	                            var e = t.getElementsByTagName("ul")[0];
	                            e && (r(t), e.childNodes.forEach((function(t) {
	                                o(t);
	                            })));
	                        }));
	                    }
	                }
	            }, _ = 0; _ < o; _++) {
	                var v = r[_];
	                this._isExcluded(v) && (v.getLayers ? function() {
	                    var t = bo("li", "group"), e = bo("ul"), i = bo("label"), r = bo("input");
	                    i.innerHTML = v.getId(), r.type = "checkbox", r.checked = v.isVisible(), r.onchange = p, 
	                    t.appendChild(r), t.appendChild(i), t.appendChild(e), t._layer = v, d.appendChild(t), 
	                    (v.getLayers() || []).forEach((function(t) {
	                        e.appendChild(n._renderLayer(t, !1, r.checked));
	                    }));
	                }() : d.appendChild(this._renderLayer(v)), v && !v.isVisible() && (g.checked = !1));
	            }
	            f.appendChild(d), e.appendChild(f), g.onchange = p;
	        }
	    }, n._isExcluded = function(t) {
	        var e = t.getId(), n = this.options.excludeLayers;
	        return !(n.length && n.indexOf(e) >= 0);
	    }, n._renderLayer = function(t, e, n) {
	        var i = this;
	        void 0 === n && (n = !0);
	        var r = bo("li", "layer"), o = bo("label"), s = bo("input"), a = this.getMap(), h = t.options.visible;
	        t.options.visible = !0;
	        var l = t.isVisible();
	        return t.options.visible = h, r.className = "layer", e ? (s.type = "radio", s.name = "base") : s.type = "checkbox", 
	        s.checked = h && l, n || (s.checked = !1), l || s.setAttribute("disabled", "disabled"), 
	        s.onchange = function(e) {
	            if ("radio" === e.target.type) {
	                var n = a.getBaseLayer(), r = n.layers;
	                if (r) for (var o = 0, s = r.length; o < s; o++) {
	                    var h = r[o];
	                    h[h === t ? "show" : "hide"]();
	                } else n.isVisible() || n.show();
	                a._fireEvent("setbaselayer");
	            } else t[e.target.checked ? "show" : "hide"]();
	            i.fire("layerchange", {
	                target: t
	            });
	        }, r.appendChild(s), o.innerHTML = t.getId(), r.appendChild(o), r._layer = t, r;
	    }, e;
	}(Fc);

	Nc.mergeOptions({
	    position: "top-right",
	    baseTitle: "Base Layers",
	    overlayTitle: "Layers",
	    excludeLayers: [],
	    containerClass: "maptalks-layer-switcher"
	}), Fh.mergeOptions({
	    layerSwitcherControl: !1
	}), Fh.addOnLoadHook((function() {
	    this.options.layerSwitcherControl && (this.layerSwitcherControl = new Nc(this.options.layerSwitcherControl), 
	    this.addControl(this.layerSwitcherControl));
	}));

	var Bc = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.buildOn = function() {
	        var t = this.options.size;
	        this.options.maximize || (t = [ 0, 0 ]);
	        var e = bo("div"), n = this.mapContainer = bo("div");
	        n.style.width = t[0] + "px", n.style.height = t[1] + "px", n.className = this.options.containerClass;
	        var i = this.button = bo("div");
	        return i.className = this.options.buttonClass, e.appendChild(n), e.appendChild(i), 
	        e;
	    }, n.onAdd = function() {
	        this.options.maximize && this._createOverview(), this.getMap().on("resize moving zooming rotate dragrotating viewchange", this._update, this).on("setbaselayer", this._updateBaseLayer, this).on("spatialreferencechange", this._updateSpatialReference, this), 
	        Ho(this.button, "click", this._onButtonClick, this), this._updateButtonText();
	    }, n.onRemove = function() {
	        this.getMap().off("resize moving zooming rotate dragrotating viewchange", this._update, this).off("setbaselayer", this._updateBaseLayer, this).off("spatialreferencechange", this._updateSpatialReference, this), 
	        this._overview && (this._overview.remove(), delete this._overview, delete this._perspective), 
	        No(this.button, "click", this._onButtonClick);
	    }, n.maxmize = function() {
	        var t = this.options.size, e = this.mapContainer;
	        return e.style.width = t[0] + "px", e.style.height = t[1] + "px", this._createOverview(), 
	        this;
	    }, n.minimize = function() {
	        this._overview && this._overview.remove(), delete this._overview, delete this._perspective;
	        var t = this.mapContainer;
	        return t.style.width = "0px", t.style.height = "0px", this;
	    }, n.getOverviewMap = function() {
	        return this._overview;
	    }, n._onButtonClick = function() {
	        this._overview ? this.minimize() : this.maxmize(), this._updateButtonText();
	    }, n._updateButtonText = function() {
	        this.button.innerHTML = this._overview ? "-" : "+";
	    }, n._createOverview = function() {
	        var t = this.getMap(), e = this.mapContainer, n = t.config();
	        kn(n, {
	            center: t.getCenter(),
	            zoom: this._getOverviewZoom(),
	            zoomAnimationDuration: 150,
	            pitch: 0,
	            bearing: 0,
	            scrollWheelZoom: !1,
	            checkSize: !1,
	            doubleClickZoom: !1,
	            touchZoom: !1,
	            control: !1,
	            draggable: !1,
	            maxExtent: null
	        }), this._overview = new Fh(e, n), this._updateBaseLayer(), this._perspective = new Yh(this._getPerspectiveCoords(), {
	            draggable: !0,
	            cursor: "move",
	            symbol: this.options.symbol
	        }).on("dragend", this._onDragEnd, this), new Il("perspective_layer", this._perspective).addTo(this._overview), 
	        this.fire("load");
	    }, n._getOverviewZoom = function() {
	        var t = this.getMap(), e = t.getZoom(), n = t.getMinZoom(), i = this.options.level;
	        if (i > 0) {
	            for (var r = i; r > 0; r--) if (e - r >= n) return e - r;
	        } else for (var o = i; o < 0; o++) if (e - o >= n) return e - o;
	        return e;
	    }, n._onDragEnd = function() {
	        var t = this._perspective.getCenter();
	        this._overview.setCenter(t), this.getMap().panTo(t);
	    }, n._getPerspectiveCoords = function() {
	        var t = this.getMap(), e = t.getProjection();
	        return t.getContainerExtent().toArray().map((function(n) {
	            if (e) {
	                var i = t._containerPointToPrj(n);
	                return t._fixPrjOnWorldWide(i), e.unproject(i);
	            }
	            return t.containerPointToCoordinate(n);
	        }));
	    }, n._update = function() {
	        if (this._overview) {
	            Oo(this._overview._containerDOM);
	            var t = this._getPerspectiveCoords();
	            this._perspective.setCoordinates(t), this._overview.setCenterAndZoom(this.getMap().getCenter(), this._getOverviewZoom());
	        }
	    }, n._updateSpatialReference = function() {
	        if (this._overview) {
	            var t = this.getMap();
	            this._overview.setSpatialReference(t.options.spatialReference);
	        }
	    }, n._updateBaseLayer = function() {
	        if (this._overview) {
	            var t = this.getMap().getBaseLayer();
	            if (t) {
	                var e = t.layers, n = 0;
	                if (e) for (var i = 0, r = e.length; i < r; i++) {
	                    if (e[i].isVisible()) {
	                        n = i;
	                        break;
	                    }
	                }
	                var o = t.toJSON(), s = null;
	                e ? (s = o.layers[n].options).visible = !0 : s = o.options, this._overview.setMinZoom(s.minZoom || null).setMaxZoom(s.maxZoom || null), 
	                delete s.minZoom, delete s.maxZoom, delete o.options.canvas, o.options.visible = !0, 
	                o.options.renderer = "canvas";
	                var a = Sh.fromJSON(o);
	                for (var h in t) Hn(t[h]) && t.hasOwnProperty(h) && t[h] !== t.constructor.prototype[h] && (a[h] = t[h]);
	                this._overview.setBaseLayer(a);
	            } else this._overview.setBaseLayer(null);
	        }
	    }, e;
	}(Fc);

	Bc.mergeOptions({
	    level: 4,
	    position: {
	        right: 1,
	        bottom: 1
	    },
	    size: [ 300, 200 ],
	    maximize: !0,
	    symbol: {
	        lineWidth: 3,
	        lineColor: "#1bbc9b",
	        polygonFill: "#1bbc9b",
	        polygonOpacity: .4
	    },
	    containerClass: "maptalks-overview",
	    buttonClass: "maptalks-overview-button"
	}), Fh.mergeOptions({
	    overviewControl: !1
	}), Fh.addOnLoadHook((function() {
	    this.options.overviewControl && (this.overviewControl = new Bc(this.options.overviewControl), 
	    this.addControl(this.overviewControl));
	}));

	(function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.buildOn = function() {
	        var t;
	        if (this.options.custom) jn(this.options.content) ? (t = bo("div")).innerHTML = this.options.content : t = this.options.content; else {
	            if (t = bo("div", "maptalks-panel"), this.options.closeButton) {
	                var e = bo("a", "maptalks-close");
	                e.href = "javascript:;", e.onclick = function() {
	                    t.style.display = "none";
	                }, t.appendChild(e);
	            }
	            var n = bo("div", "maptalks-panel-content");
	            n.innerHTML = this.options.content, t.appendChild(n);
	        }
	        return this.draggable = new cs(t, {
	            cancelOn: this._cancelOn.bind(this),
	            ignoreMouseleave: !0
	        }), this.draggable.on("dragstart", this._onDragStart, this).on("dragging", this._onDragging, this).on("dragend", this._onDragEnd, this), 
	        this.options.draggable && this.draggable.enable(), t;
	    }, n.update = function() {
	        return this.draggable && (this.draggable.disable(), delete this.draggable), Fc.prototype.update.call(this);
	    }, n.setContent = function(t) {
	        var e = this.options.content;
	        return this.options.content = t, this.fire("contentchange", {
	            old: e,
	            new: t
	        }), this.isVisible() && this.update(), this;
	    }, n.getContent = function() {
	        return this.options.content;
	    }, n._cancelOn = function(t) {
	        var e = (t.srcElement || t.target).tagName.toLowerCase();
	        return "button" === e || "input" === e || "select" === e || "option" === e || "textarea" === e;
	    }, n._onDragStart = function(t) {
	        this._startPos = t.mousePos, this._startPosition = kn({}, this.getPosition()), this.fire("dragstart", t);
	    }, n._onDragging = function(t) {
	        var e = t.mousePos.sub(this._startPos), n = this._startPosition, i = this.getPosition();
	        Dn(i.top) || (i.top = parseInt(n.top) + e.y), Dn(i.bottom) || (i.bottom = parseInt(n.bottom) - e.y), 
	        Dn(i.left) || (i.left = parseInt(n.left) + e.x), Dn(i.right) || (i.right = parseInt(n.right) - e.x), 
	        this.setPosition(i), this.fire("dragging", t);
	    }, n._onDragEnd = function(t) {
	        delete this._startPos, delete this._startPosition, this.fire("dragend", t);
	    }, n._getConnectPoints = function() {
	        var t = this.getMap(), e = this.getContainerPoint(), n = this.getDOM(), i = parseInt(n.clientWidth), r = parseInt(n.clientHeight);
	        return [ t.containerPointToCoordinate(e.add(i / 2, 0)), t.containerPointToCoordinate(e.add(i, r / 2)), t.containerPointToCoordinate(e.add(i / 2, r)), t.containerPointToCoordinate(e.add(0, r / 2)) ];
	    }, e;
	})(Fc).mergeOptions({
	    position: "top-right",
	    draggable: !0,
	    custom: !1,
	    content: "",
	    closeButton: !0
	});

	var Gc = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.buildOn = function(t) {
	        return this._map = t, this._scaleContainer = bo("div", this.options.containerClass), 
	        this._addScales(), t.on("zoomend", this._update, this), this._map._loaded && this._update(), 
	        this._scaleContainer;
	    }, n.onRemove = function() {
	        this.getMap().off("zoomend", this._update, this);
	    }, n._addScales = function() {
	        var t = "border: 2px solid #000000;border-top: none;line-height: 1.1;padding: 0px;color: #000000;font-size: 11px;text-align:center;white-space: nowrap;overflow: hidden;-moz-box-sizing: content-box;box-sizing: content-box;background: #fff; background: rgba(255, 255, 255, 0);";
	        this.options.metric && (this._mScale = wo("div", this.options.containerClass ? null : t, this._scaleContainer)), 
	        this.options.imperial && (this._iScale = wo("div", this.options.containerClass ? null : t, this._scaleContainer));
	    }, n._update = function() {
	        var t = this._map.pixelToDistance(this.options.maxWidth, 0);
	        this._updateScales(t);
	    }, n._updateScales = function(t) {
	        this.options.metric && t && this._updateMetric(t), this.options.imperial && t && this._updateImperial(t);
	    }, n._updateMetric = function(t) {
	        var e = this._getRoundNum(t);
	        this._updateScale(this._mScale, e < 1e3 ? e + " m" : e / 1e3 + " km", e / t);
	    }, n._updateImperial = function(t) {
	        var e, n, i, r = 3.2808399 * t;
	        r > 5280 ? (n = this._getRoundNum(e = r / 5280), this._updateScale(this._iScale, n + " mile", n / e)) : (i = this._getRoundNum(r), 
	        this._updateScale(this._iScale, i + " feet", i / r));
	    }, n._updateScale = function(t, e, n) {
	        t.style.width = Math.round(this.options.maxWidth * n) + "px", t.innerHTML = e;
	    }, n._getRoundNum = function(t) {
	        var e = Math.pow(10, (Math.floor(t) + "").length - 1), n = t / e;
	        return e * (n = n >= 10 ? 10 : n >= 5 ? 5 : n >= 3 ? 3 : n >= 2 ? 2 : 1);
	    }, e;
	}(Fc);

	Gc.mergeOptions({
	    position: "bottom-left",
	    maxWidth: 100,
	    metric: !0,
	    imperial: !1,
	    containerClass: null
	}), Fh.mergeOptions({
	    scaleControl: !1
	}), Fh.addOnLoadHook((function() {
	    this.options.scaleControl && (this.scaleControl = new Gc(this.options.scaleControl), 
	    this.addControl(this.scaleControl));
	}));

	(function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.buildOn = function(t) {
	        this._map = t;
	        var e = bo("div"), n = bo("ul", "maptalks-toolbar-hx");
	        e.appendChild(n), Do(e, this.options.vertical ? "maptalks-toolbar-vertical" : "maptalks-toolbar-horizonal");
	        var i = this;
	        function r(t, e, n, r) {
	            var o = i._getItems()[e];
	            return function(i) {
	                return Ao(i), t({
	                    target: o,
	                    index: e,
	                    childIndex: n,
	                    dom: r
	                });
	            };
	        }
	        var o = this.options.items;
	        if (Zi$1(o)) for (var s = 0, a = o.length; s < a; s++) {
	            var h = o[s], l = bo("li");
	            if (28 !== this.options.height && (l.style.lineHeight = this.options.height + "px"), 
	            l.style.height = this.options.height + "px", l.style.cursor = "pointer", /<[a-z\][\s\S]*>/i.test(h.item)) {
	                l.style.textAlign = "center";
	                var c = Fo("div", h.item);
	                l.innerHTML = '<div style="margin-top:' + (this.options.height - c.height) / 2 + 'px;">' + h.item + "</div>";
	            } else l.innerHTML = h.item;
	            if (h.click && Ho(l, "click", r(h.click, s, null, l)), Zi$1(h.children)) {
	                var u = this._createDropMenu(s);
	                l.appendChild(u), l._menu = u, Ho(l, "mouseover", (function() {
	                    this._menu.style.display = "";
	                })), Ho(l, "mouseout", (function() {
	                    this._menu.style.display = "none";
	                }));
	            }
	            n.appendChild(l);
	        }
	        return e;
	    }, n._createDropMenu = function(t) {
	        var e = this;
	        function n(t, n, i) {
	            var r = e._getItems()[n].children[i];
	            return function(e) {
	                return Ao(e), t({
	                    target: r,
	                    index: n,
	                    childIndex: i
	                });
	            };
	        }
	        var i = bo("div", "maptalks-dropMenu"), r = this._getItems(), o = r.length, s = bo("ul"), a = r[t].children;
	        t === o - 1 && a && (i.style.cssText = "right: 0px;", s.style.cssText = "right: 0px;position: absolute;", 
	        this.options.reverseMenu && (s.style.bottom = 0)), i.appendChild(bo("em", "maptalks-ico"));
	        for (var h = 0, l = 0, c = a.length; l < c; l++) {
	            var u = qr(a[l].item, "12px");
	            u.width > h && (h = u.width);
	        }
	        for (var f = 0, d = a.length; f < d; f++) {
	            var m = a[f], g = bo("li");
	            g.innerHTML = '<a href="javascript:;">' + m.item + "</a>", g.style.cursor = "pointer", 
	            g.style.width = h + 24 + "px", Ho(g.childNodes[0], "click", n(m.click, t, f)), s.appendChild(g);
	        }
	        if (this.options.vertical) {
	            var p = h < 95 ? 95 : h;
	            this.options.reverseMenu ? i.style.right = -(p + 20) + "px" : i.style.left = -(p + 20) + "px";
	        } else this.options.reverseMenu ? i.style.bottom = "28px" : i.style.top = "28px";
	        return i.appendChild(s), i.style.display = "none", i;
	    }, n._getItems = function() {
	        return this.options.items || [];
	    }, e;
	})(Fc).mergeOptions({
	    height: 28,
	    vertical: !1,
	    position: "top-right",
	    reverseMenu: !1,
	    items: {}
	});

	var Vc = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.buildOn = function(t) {
	        var e = this.options, n = bo("div", "maptalks-zoom");
	        if (e.zoomLevel) {
	            var i = bo("span", "maptalks-zoom-zoomlevel");
	            n.appendChild(i), this._levelDOM = i;
	        }
	        var r = bo("div", "maptalks-zoom-slider"), o = bo("a", "maptalks-zoom-zoomin");
	        if (o.href = "javascript:;", o.innerHTML = "+", r.appendChild(o), this._zoomInButton = o, 
	        e.slider) {
	            var s = bo("div", "maptalks-zoom-slider-box"), a = bo("div", "maptalks-zoom-slider-ruler"), h = bo("span", "maptalks-zoom-slider-reading"), l = bo("span", "maptalks-zoom-slider-dot");
	            a.appendChild(h), s.appendChild(a), s.appendChild(l), r.appendChild(s), this._sliderBox = s, 
	            this._sliderRuler = a, this._sliderReading = h, this._sliderDot = l;
	        }
	        var c = bo("a", "maptalks-zoom-zoomout");
	        return c.href = "javascript:;", c.innerHTML = "-", r.appendChild(c), this._zoomOutButton = c, 
	        n.appendChild(r), t.on("_zoomend _zooming _zoomstart _spatialreferencechange", this._update, this), 
	        this._update(), this._registerDomEvents(), n;
	    }, n.onRemove = function() {
	        this.getMap().off("_zoomend _zooming _zoomstart _spatialreferencechange", this._update, this), 
	        this._zoomInButton && No(this._zoomInButton, "click", this._onZoomInClick), this._zoomOutButton && No(this._zoomOutButton, "click", this._onZoomOutClick), 
	        this._sliderRuler && (No(this._sliderRuler, "click", this._onClickRuler), this.dotDragger.disable(), 
	        delete this.dotDragger);
	    }, n._update = function() {
	        var t = this.getMap();
	        if (this._sliderBox) {
	            var e = 10 * (t.getMaxZoom() - t.getMinZoom());
	            this._sliderBox.style.height = e + 16 + "px", this._sliderRuler.style.height = e + 8 + "px", 
	            this._sliderRuler.style.cursor = "pointer";
	            var n = 10 * (t.getMaxZoom() - t.getZoom());
	            this._sliderReading.style.height = 10 * (t.getZoom() - t.getMinZoom() + 1) + "px", 
	            this._sliderDot.style.top = n + "px";
	        }
	        this._updateText();
	    }, n._updateText = function() {
	        if (this._levelDOM) {
	            var t = this.getMap().getZoom();
	            zn(t) || (t = Math.floor(10 * t) / 10), this._levelDOM.innerHTML = t;
	        }
	    }, n._registerDomEvents = function() {
	        this._zoomInButton && Ho(this._zoomInButton, "click", this._onZoomInClick, this), 
	        this._zoomOutButton && Ho(this._zoomOutButton, "click", this._onZoomOutClick, this), 
	        this._sliderRuler && (Ho(this._sliderRuler, "click", this._onClickRuler, this), 
	        this.dotDragger = new cs(this._sliderDot, {
	            ignoreMouseleave: !0
	        }), this.dotDragger.on("dragstart", this._onDotDragstart, this).on("dragging dragend", this._onDotDrag, this).enable());
	    }, n._onZoomInClick = function(t) {
	        Po(t), this.getMap().zoomIn();
	    }, n._onZoomOutClick = function(t) {
	        Po(t), this.getMap().zoomOut();
	    }, n._onClickRuler = function(t) {
	        Po(t);
	        var e = this.getMap(), n = Ro(t, this._sliderRuler).y, i = e.getMaxZoom(), r = Math.floor(i - n / 10);
	        e.setZoom(r);
	    }, n._onDotDragstart = function(t) {
	        Po(t.domEvent);
	        var e = this.getMap(), n = e.getSize().toPoint()._multi(.5);
	        e.onZoomStart(e.getZoom(), n);
	    }, n._onDotDrag = function(t) {
	        Po(t.domEvent);
	        var e = this.getMap(), n = e.getSize().toPoint()._multi(.5), i = Ro(t.domEvent, this._sliderRuler), r = e.getMaxZoom(), o = e.getMinZoom(), s = i.y, a = r - s / 10;
	        r < a ? (a = r, s = 0) : o > a && (a = o, s = 10 * (r - o)), "dragging" === t.type ? e.onZooming(a, n, 1) : "dragend" === t.type && e.onZoomEnd(this.options.seamless ? a : Math.round(a), n), 
	        this._sliderDot.style.top = s + "px", this._sliderReading.style.height = 10 * (e.getZoom() - o + 1) + "px", 
	        this._updateText();
	    }, e;
	}(Fc);

	Vc.mergeOptions({
	    position: "top-left",
	    slider: !0,
	    zoomLevel: !0,
	    seamless: !1
	}), Fh.mergeOptions({
	    zoomControl: !1
	}), Fh.addOnLoadHook((function() {
	    this.options.zoomControl && (this.zoomControl = new Vc(this.options.zoomControl), 
	    this.addControl(this.zoomControl));
	}));

	var Uc = function() {
	    function t(t, e, n, i) {
	        Array.isArray(t) ? (this.scale = {
	            x: t[0],
	            y: t[1]
	        }, this.origin = {
	            x: t[2],
	            y: t[3]
	        }) : (this.scale = {
	            x: t,
	            y: e
	        }, this.origin = {
	            x: n,
	            y: i
	        });
	    }
	    return t.getDefault = function(t) {
	        return "baidu" === t.code.toLowerCase() ? "baidu" : t.code.toLowerCase() === "EPSG:4326".toLowerCase() ? "tms-global-geodetic" : "identity" === t.code.toLowerCase() ? [ 1, -1, 0, 0 ] : "web-mercator";
	    }, t;
	}(), Wc = 6378137 * Math.PI;

	kn(Uc, {
	    "web-mercator": new Uc([ 1, -1, -Wc, Wc ]),
	    "tms-global-mercator": new Uc([ 1, 1, -Wc, -Wc ]),
	    "tms-global-geodetic": new Uc([ 1, 1, -180, -90 ]),
	    baidu: new Uc([ 1, 1, 0, 0 ])
	});

	var Zc = function() {
	    function t(t, e, n, i) {
	        this.map = t, this.tileSize = i, this.fullExtent = n, this.prepareTileInfo(e, n), 
	        this._xScale = n.right >= n.left ? 1 : -1, this._yScale = n.top >= n.bottom ? 1 : -1;
	        var r = t.getGLRes();
	        this._pointOrigin = t._prjToPointAtRes(new Oi$1(this.tileSystem.origin), r), this._glRes = r;
	    }
	    var e = t.prototype;
	    return e.prepareTileInfo = function(t, e) {
	        if (jn(t) ? t = Uc[t.toLowerCase()] : Array.isArray(t) && (t = new Uc(t)), !t) throw new Error("Invalid TileSystem");
	        this.tileSystem = t, this.transformation = new As([ e.right > e.left ? 1 : -1, e.top > e.bottom ? -1 : 1, t.origin.x, t.origin.y ]);
	    }, e._getTileNum = function(t, e) {
	        var n = this.tileSystem, i = this.tileSize, r = Math.floor(1e-7 * n.scale.x + t.x / (i.width * e)), o = Math.ceil(1e-7 * n.scale.y + t.y / (i.height * e));
	        return {
	            x: n.scale.x * r,
	            y: n.scale.y * o
	        };
	    }, e.getTileIndex = function(t, e, n) {
	        var i = this.tileSystem, r = this.transformation.transform(t, 1), o = this._getTileNum(r, e);
	        return i.scale.x < 0 && (o.x -= 1), i.scale.y > 0 && (o.y -= 1), this.getNeighorTileIndex(o.x, o.y, 0, 0, e, n);
	    }, e.getNeighorTileIndex = function(t, e, n, i, r, o) {
	        var s = this.tileSystem, a = t + s.scale.x * n, h = e - s.scale.y * i, l = !1, c = a, u = h, f = this._getTileFullIndex(r);
	        return o && (!0 !== o && "x" !== o || (f.xmax === f.xmin ? a = f.xmin : a < f.xmin ? (a = f.xmax - (f.xmin - a) % (f.xmax - f.xmin)) === f.xmax && (a = f.xmin) : a >= f.xmax && (a = f.xmin + (a - f.xmin) % (f.xmax - f.xmin))), 
	        !0 !== o && "y" !== o || (f.ymax === f.ymin ? h = f.ymin : h >= f.ymax ? h = f.ymin + (h - f.ymin) % (f.ymax - f.ymin) : h < f.ymin && (h = f.ymax - (f.ymin - h) % (f.ymax - f.ymin)) === f.ymax && (h = f.ymin))), 
	        (a < f.xmin || a > f.xmax || h > f.ymax || h < f.ymin) && (l = !0), {
	            x: a,
	            y: h,
	            idx: c,
	            idy: u,
	            out: l
	        };
	    }, e._getTileFullIndex = function(t) {
	        if (this._tileFullIndex || (this._tileFullIndex = {}), this._tileFullIndex[t]) return this._tileFullIndex[t];
	        var e = this.fullExtent, n = this.transformation, i = this._getTileNum(n.transform(new us(e.left, e.top), 1), t), r = this._getTileNum(n.transform(new us(e.right, e.bottom), 1), t), o = this.tileSystem;
	        return o.scale.x < 0 && (i.x -= 1, r.x -= 1), o.scale.y > 0 && (i.y -= 1, r.y -= 1), 
	        this._tileFullIndex[t] = new Ts(i, r), this._tileFullIndex[t];
	    }, e.getTilePrjNW = function(t, e, n) {
	        var i = this.tileSystem, r = this.tileSize;
	        return new us(i.origin.x + this._xScale * i.scale.x * (t + (1 === i.scale.x ? 0 : 1)) * n * r.width, i.origin.y + this._yScale * i.scale.y * (e + (1 === i.scale.y ? 1 : 0)) * n * r.height);
	    }, e.getTilePointNW = function(t, e, n) {
	        var i = this._glRes / n, r = this.tileSystem, o = this.tileSize;
	        return new Oi$1(this._pointOrigin.x * i + this._xScale * r.scale.x * (t + (1 === r.scale.x ? 0 : 1)) * o.width, this._pointOrigin.y * i + this._yScale * r.scale.y * (e + (1 === r.scale.y ? 1 : 0)) * o.height);
	    }, e.getTilePrjSE = function(t, e, n) {
	        var i = this.tileSystem, r = this.tileSize;
	        return new us(i.origin.x + this._xScale * i.scale.x * (t + (1 === i.scale.x ? 1 : 0)) * n * r.width, i.origin.y + this._yScale * i.scale.y * (e + (1 === i.scale.y ? 0 : 1)) * n * r.height);
	    }, e.getTilePointSE = function(t, e, n) {
	        var i = this._glRes / n, r = this.tileSystem, o = this.tileSize;
	        return new Oi$1(this._pointOrigin.x * i + this._xScale * r.scale.x * (t + (1 === r.scale.x ? 1 : 0)) * o.width, this._pointOrigin.y * i + this._yScale * r.scale.y * (e + (1 === r.scale.y ? 0 : 1)) * o.height);
	    }, e.getTilePrjExtent = function(t, e, n) {
	        var i = this.getTilePrjNW(t, e, n), r = this.getTilePrjSE(t, e, n);
	        return new Ts(i, r);
	    }, t;
	}(), Xc = new Oi$1(0, 0), Jc = "undefined" != typeof Set, qc = function() {
	    function t() {
	        this._table = Jc ? new Set : {};
	    }
	    var e = t.prototype;
	    return e.add = function(t) {
	        Jc ? this._table.add(t) : this._table[t] = !0;
	    }, e.has = function(t) {
	        return Jc ? this._table.has(t) : this._table[t];
	    }, e.reset = function() {
	        Jc ? this._table.clear() : this._table = {};
	    }, t;
	}(), Yc = {
	    urlTemplate: null,
	    subdomains: null,
	    errorUrl: null,
	    repeatWorld: !0,
	    background: !0,
	    backgroundZoomDiff: 6,
	    loadingLimitOnInteracting: 3,
	    tileRetryCount: 0,
	    placeholder: !1,
	    crossOrigin: null,
	    tileSize: [ 256, 256 ],
	    offset: [ 0, 0 ],
	    tileSystem: null,
	    fadeAnimation: !Wn,
	    debug: !1,
	    spatialReference: null,
	    maxCacheSize: 256,
	    renderer: Mi$1.webgl ? "gl" : "canvas",
	    clipByPitch: !0,
	    maxAvailableZoom: null,
	    cascadeTiles: !0,
	    zoomOffset: 0,
	    pyramidMode: 1,
	    decodeImageInWorker: !1,
	    tileLimitPerFrame: 0,
	    backZoomOffset: 0
	}, Kc = /\{ *([\w_]+) *\}/g, Qc = new Oi$1(0, 0), $c = new Oi$1(0, 0), tu = new Oi$1(0, 0), eu = new Oi$1(0, 0), nu = new Oi$1(0, 0), iu = new Oi$1(0, 0), ru = [ [ 0, 0, 0 ], [ 0, 0, 0 ] ], ou = [ 0, 0, 0 ], su = [ 0, 0, 0 ], au = [], hu = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t), e.fromJSON = function(t) {
	        return t && "TileLayer" === t.type ? new e(t.id, t.options) : null;
	    };
	    var n = e.prototype;
	    return n.getTileSize = function() {
	        if (this._tileSize) return this._tileSize;
	        var t = this.options.tileSize;
	        return Ln(t) && (t = [ t, t ]), this._tileSize = new Gr(t), this._tileSize;
	    }, n.getTiles = function(t, e) {
	        return this._coordCache = {}, this._isPyramidMode() ? this._getPyramidTiles(t, e) : this._getCascadeTiles(t, e);
	    }, n._isPyramidMode = function() {
	        var t = this.getSpatialReference();
	        return !this._disablePyramid && !this._hasOwnSR && this.options.pyramidMode && t && t.isPyramid();
	    }, n._getTileFullExtent = function() {
	        if (this._tileFullExtent) return this._tileFullExtent;
	        var t = this.getSpatialReference(), e = t.getFullExtent(), n = t.getResolution(0), i = this.getMap();
	        return this._tileFullExtent = e.convertTo((function(t) {
	            return i._prjToPointAtRes(t, n, Xc);
	        })), this._tileFullExtent;
	    }, n._getRootNodes = function(t) {
	        var e = this.getMap();
	        if (this._rootNodes) {
	            var n = this._rootNodes, i = n.tiles;
	            if (e.width !== n.mapWidth || e.height !== n.mapHeight) {
	                for (var r = this._getRootError(), o = 0; o < i.length; o++) i[o].error = r;
	                this._rootNodes.mapWidth = e.width, this._rootNodes.mapHeight = e.height;
	            }
	            for (var s = 0; s < i.length; s++) i[s].offset[0] = t[0], i[s].offset[1] = t[1];
	            return this._rootNodes;
	        }
	        var a = this.getSpatialReference(), h = a.getResolution(0), l = this._getTileConfig(), c = a.getFullExtent(), u = l.tileSystem, f = u.origin, d = u.scale, m = l.getTilePrjExtent(0, 0, h), g = m.getWidth(), p = m.getHeight(), _ = Math.abs((f.x - c.left) / g);
	        _ = Math.ceil(_ - 1e-5);
	        var v = Math.abs((c.right - f.x) / g);
	        v = Math.ceil(v - 1e-5);
	        var y = Math.ceil(Math.abs(c.top - f.y) / p);
	        y = Math.ceil(y - 1e-5);
	        var x = Math.ceil(Math.abs(c.bottom - f.y) / p);
	        if ((v + _) * ((x = Math.ceil(x - 1e-5)) + y) > 32) return {
	            status: 0,
	            error: "Too many root nodes"
	        };
	        for (var b = this._getRootError(), w = [], C = -_; C < v; C++) for (var M = -y; M < x; M++) {
	            var T = d.y < 0 ? M : -(M + 1);
	            w.push({
	                x: C,
	                y: T,
	                z: 0,
	                idx: C,
	                idy: T,
	                res: h,
	                extent2d: l.getTilePrjExtent(C, T, h).convertTo((function(t) {
	                    return e._prjToPointAtRes(t, h, Xc);
	                })),
	                id: this._getTileId(C, T, 0),
	                url: this.getTileUrl(C, T, 0 + this.options.zoomOffset),
	                offset: [ 0, 0 ],
	                error: b,
	                children: []
	            });
	        }
	        return this._rootNodes = {
	            status: 1,
	            tiles: w,
	            mapWidth: e.width,
	            mapHeight: e.height
	        }, this._getRootNodes(t);
	    }, n._getRootError = function() {
	        var t = this.getMap(), e = Vn(t.getFov()), n = t.width / t.height, i = t.cameraPosition[2], r = i * Math.tan(.5 * e), o = r * n, s = Math.sqrt(i * i + r * r + o * o);
	        return t._getFovZ(0) * (s / i) * this.getSpatialReference().getResolution(0) / t.getResolution(0);
	    }, n._getPyramidTiles = function(t, e) {
	        var n = this.getMap();
	        isNaN(+t) && (t = this._getTileZoom(n.getZoom()));
	        var i, r = this.getSpatialReference(), o = Math.min(t, this.getMaxZoom()), s = n.projViewMatrix, a = this._getTileFullExtent(), h = this._getTileOffset(0);
	        if (this.options.repeatWorld) {
	            var l = n.getContainerExtent(), c = this._convertToExtent2d(l), u = r.getResolution(0) / n.getResolution();
	            if (c.within(a.copy()._scale(u))) {
	                var f = this._getRootNodes(h);
	                if (1 !== f.status) return console.warn(f.error), this._disablePyramid = !0, this.getTiles(t, e);
	                i = f.tiles.concat();
	            } else {
	                var d = n.getPitch(), m = n.options.cascadePitches[1], g = Math.floor(n._getVisualHeight(m)), p = d <= m ? l : new Ps(0, n.height - g, n.width, n.height);
	                this._visitedTiles = new qc;
	                var _ = this._getTiles(0, p, 2, e && e.getRenderer(), !0), v = this._getRootError();
	                _.tiles.forEach((function(t) {
	                    t.error = v;
	                })), i = _.tiles;
	            }
	        } else {
	            var y = this._getRootNodes(h);
	            if (1 !== y.status) return console.warn(y.error), this._disablePyramid = !0, this.getTiles(t, e);
	            i = y.tiles.concat();
	        }
	        for (var x = n.getGLRes(), b = {
	            0: h
	        }, w = this.options.backZoomOffset + t, C = new Ps, M = []; i.length > 0; ) {
	            var T = i.pop();
	            T.z !== o ? (b[T.z + 1] || (b[T.z + 1] = this._getTileOffset(T.z + 1)), this._splitNode(T, s, i, M, C, o, b[T.z + 1], e && e.getRenderer(), x), 
	            w < t && M[M.length - 1] !== T && w === T.z && M.push(T)) : (C._combine(T.extent2d), 
	            M.push(T));
	        }
	        return {
	            tileGrids: [ {
	                extent: C,
	                count: M.length,
	                tiles: M,
	                offset: [ 0, 0 ],
	                zoom: t
	            } ],
	            count: M.length
	        };
	    }, n._splitNode = function(t, e, n, i, r, o, s, a, h) {
	        for (var l = this._getTileConfig().tileSystem.scale.y, c = t.z + 1, u = this.getSpatialReference(), f = t.x, d = t.y, m = t.extent2d, g = t.idx, p = t.idy, _ = m.getWidth() / 2 * 2, v = m.getHeight() / 2 * 2, y = 2 * m.xmin, x = 2 * m.ymax, b = 2 * m.ymin, w = a || this.getRenderer(), C = !1, M = [], T = u.getResolution(c), S = T / h, P = 0; P < 4; P++) {
	            var A = P % 2, E = P >> 1, O = (f << 1) + A, R = (d << 1) + E, I = (g << 1) + A, k = (p << 1) + E;
	            t.children || (t.children = []);
	            var D = t.children[P];
	            D || (D = this._getTileId(I, k, c), t.children[P] = D);
	            var L = w.isTileCachedOrLoading(D), z = void 0, F = L && L.info;
	            if (!F) {
	                if (this.tileInfoCache || (this.tileInfoCache = new Uo(4 * this.options.maxCacheSize)), 
	                !(F = this.tileInfoCache.get(D))) {
	                    if (l < 0) {
	                        var j = y + A * _, H = x - E * v;
	                        z = new Ps(j, H - v, j + _, H);
	                    } else {
	                        var N = y + A * _, B = b + E * v;
	                        z = new Ps(N, B, N + _, B + v);
	                    }
	                    F = {
	                        x: O,
	                        y: R,
	                        idx: I,
	                        idy: k,
	                        z: c,
	                        extent2d: z,
	                        error: t.error / 2,
	                        res: T,
	                        id: D,
	                        parentNodeId: t.id,
	                        children: [],
	                        url: this.getTileUrl(O, R, c + this.options.zoomOffset),
	                        offset: s
	                    }, this.tileInfoCache.add(D, F);
	                }
	                a && (F.layer = this.getId());
	            }
	            F.error = t.error / 2, F.offset[0] = s[0], F.offset[1] = s[1];
	            var G = this._isTileVisible(F, e, S, o, s);
	            if (1 === G) C = !0; else {
	                if (-1 === G) continue;
	                if (0 === G && c !== o) return i.push(t), void r._combine(t.extent2d);
	            }
	            M.push(F);
	        }
	        c === o ? C ? n.push.apply(n, M) : (i.push(t), r._combine(t.extent2d)) : n.push.apply(n, M);
	    }, n._isTileVisible = function(t, e, n, i, r) {
	        if (0 === t.z) return 1;
	        if (!this._isTileInFrustum(t, e, n, r)) return -1;
	        var o = this.options.maxError;
	        return Dn(o) && (o = 1), this._getScreenSpaceError(t, n, i, r) >= o ? 1 : 0;
	    }, n._isTileInFrustum = function(t, e, n, i) {
	        if (!this._zScale) {
	            var r = this.getMap(), o = r.getGLRes();
	            this._zScale = r.altitudeToPoint(100, o) / 100;
	        }
	        var s = t.extent2d, a = s.ymin, h = s.xmax, l = s.ymax;
	        return ru[0][0] = (s.xmin - i[0]) * n, ru[0][1] = (a - i[1]) * n, ru[0][2] = (t.minAltitude || 0) * this._zScale, 
	        ru[1][0] = (h - i[0]) * n, ru[1][1] = (l - i[1]) * n, ru[1][2] = (t.maxAltitude || 0) * this._zScale, 
	        Cn(e, ru);
	    }, n._getScreenSpaceError = function(t, e, n, i) {
	        var r = t.error, o = this.getMap(), s = t.extent2d, a = s.ymin, h = s.xmax, l = s.ymax;
	        ou[0] = (s.xmin - i[0]) * e, ou[1] = (a - i[1]) * e, su[0] = (h - i[0]) * e, su[1] = (l - i[1]) * e;
	        var c, u, f, d, m, g, p = (c = ou, u = su, f = o.cameraPosition, d = Math.max(c[0] - f[0], 0, f[0] - u[0]), 
	        m = Math.max(c[1] - f[1], 0, f[1] - u[1]), g = Math.max(c[2] - f[2], 0, f[2] - u[2]), 
	        Math.sqrt(d * d + m * m + g * g)), _ = Math.max(Math.abs(p), 1e-7), v = Math.abs(t.z - n);
	        return r * (o.height < 1e3 || v <= 1 ? 1 : v <= 2 ? .7 : .605) / _;
	    }, n._getCascadeTiles = function(t, e) {
	        var n = this.getMap(), i = n.getPitch(), r = e && e.getRenderer(), o = n.getContainerExtent(), s = [], a = 0, h = this.getMinZoom(), l = n.options.cascadePitches[0], c = n.options.cascadePitches[1], u = Math.floor(n._getVisualHeight(c)), f = Dn(t) ? this._getTileZoom(n.getZoom()) : t;
	        if (this._visitedTiles = new qc, !Dn(t) || !this.options.cascadeTiles || i <= l || !Dn(h) && f <= h) {
	            var d = i <= c ? o : new Ps(0, n.height - u, n.width, n.height), m = this._getTiles(f, d, 2, r);
	            return m && (a += m.tiles.length, s.push(m)), {
	                tileGrids: s,
	                count: a
	            };
	        }
	        var g = Math.floor(n._getVisualHeight(l)), p = new Ps(0, n.height - g, n.width, n.height), _ = this._getTiles(f, p, 0, r);
	        a += _ ? _.tiles.length : 0, s.push(_);
	        var v, y, x = p.ymin, b = n.getSpatialReference().getZoomDirection(), w = b;
	        if (i > c) {
	            f - w <= h && (w = 0);
	            var C = new Ps(0, n.height - u, n.width, x);
	            a += (v = this._getTiles(f - w, C, 1, r)) ? v.tiles.length : 0, x = C.ymin, w += 4 * b, 
	            s.push(v);
	        }
	        if (f - w >= h) {
	            var M = new Ps(0, o.ymin, n.width, x);
	            a += (y = this._getTiles(f - w, M, 2, r)) ? y.tiles.length : 0, s.push(y);
	        }
	        return v && y && (s[1] = y, s[2] = v), {
	            tileGrids: s,
	            count: a
	        };
	    }, n.getTileUrl = function(t, e, n) {
	        var i = this.options.urlTemplate, r = "";
	        if (this.options.subdomains) {
	            var o = this.options.subdomains;
	            if (Zi$1(o)) {
	                var s = (t + e) % o.length;
	                s < 0 && (s = 0), r = o[s];
	            }
	        }
	        if (Hn(i)) return i(t, e, n, r);
	        var a = {
	            x: t,
	            y: e,
	            z: n,
	            s: r
	        };
	        return this.options.token && (a.token = this.options.token), this.options.customTags && kn(a, this.options.customTags), 
	        i.replace(Kc, (function(t, e) {
	            var n = a[e];
	            if (void 0 === n) throw new Error("No value provided for variable " + t);
	            return "function" == typeof n && (n = n(a)), n;
	        }));
	    }, n.clear = function() {
	        return this._renderer && this._renderer.clear(), this.tileInfoCache && this.tileInfoCache.reset(), 
	        this.fire("clear"), this;
	    }, n.toJSON = function() {
	        return {
	            type: this.getJSONType(),
	            id: this.getId(),
	            options: this.config()
	        };
	    }, n.getSpatialReference = function() {
	        var t = this.getMap();
	        if (t && (!this.options.spatialReference || bh.equals(this.options.spatialReference, t.options.spatialReference))) return t.getSpatialReference();
	        if (this._sr) return this._sr;
	        var e = this.options.spatialReference;
	        if (jn(e) && !(e = bh.getPreset(e))) throw new Error("Unsupported spatial reference: " + this.options.spatialReference + ", possible values: " + bh.getAllPresets().join());
	        return this._sr = new bh(e), this._srMinZoom = this._sr.getMinZoom(), this._srMaxZoom = this._sr.getMaxZoom(), 
	        this._hasOwnSR = this._sr.toJSON().projection !== t.getSpatialReference().toJSON().projection, 
	        this._sr;
	    }, n.getMinZoom = function() {
	        return this.getSpatialReference() !== this.getMap().getSpatialReference() ? Math.max(t.prototype.getMinZoom.call(this), this._srMinZoom) : t.prototype.getMinZoom.call(this);
	    }, n.getMaxZoom = function() {
	        return this.getSpatialReference() !== this.getMap().getSpatialReference() ? Math.min(t.prototype.getMaxZoom.call(this), this._srMaxZoom) : t.prototype.getMaxZoom.call(this);
	    }, n._getTileZoom = function(t) {
	        if (!this._hasOwnSR) {
	            var e = this.getMap().getResolution(t), n = this.getSpatialReference().getResolution(t);
	            t += Math.log(n / e) * Math.LOG2E;
	        }
	        var i = this.options.maxAvailableZoom;
	        return !Dn(i) && t > i && (t = i), zn(t) || (t = Math.round(t)), t = Math.max(0, t);
	    }, n._getTiles = function(t, e, n, i, r) {
	        var o = this.getMap(), s = t, a = o.projViewMatrix, h = o.getResolution(t) / o.getResolution(t - 1) == .5;
	        n < 2 && (0 === n && h && (s -= 1), a = 0 === n ? o.cascadeFrustumMatrix0 : 1 === n ? o.cascadeFrustumMatrix1 : o.projViewMatrix);
	        var l = s + this.options.zoomOffset, c = this._getTileOffset(l), u = c[0] || c[1], f = {
	            zoom: s,
	            extent: null,
	            offset: c,
	            tiles: []
	        };
	        if (l < 0) return f;
	        if (!(o && this.isVisible() && o.width && o.height)) return f;
	        if (!r) {
	            var d = this.getMinZoom(), m = this.getMaxZoom();
	            if (!Dn(d) && s < d || !Dn(m) && s > m) return f;
	        }
	        var g = this._getTileConfig();
	        if (!g) return f;
	        var p, _ = {
	            zoom: c
	        }, v = this.getSpatialReference().getResolution(l);
	        p = this._hasOwnSR ? o.getGLScale(s) : v / o.getGLRes();
	        var y = !this._hasOwnSR && this.options.repeatWorld, x = this._convertToExtent2d(e), b = this._getMask2DExtent();
	        if (b) {
	            var w = b.intersection(x);
	            if (!w) return f;
	            e = w.convertTo((function(t) {
	                return o._pointToContainerPoint(t, void 0, 0, Xc);
	            }));
	        }
	        var C, M = o._containerPointToPrj(e.getCenter(), Qc), T = o._prjToPoint(M, l, $c);
	        C = this._project(u ? o._pointToPrj(T._add(c), l, $c) : M, $c);
	        var S = o.getGLScale() / o.getGLScale(l);
	        tu.x = x.xmin * S, tu.y = x.ymax * S, eu.x = x.xmax * S, eu.y = x.ymin * S;
	        for (var P = this._project(o._pointToPrj(tu._add(c), l, tu), tu), A = this._project(o._pointToPrj(eu._add(c), l, eu), eu), E = g.getTileIndex(C, v, y), O = g.getTileIndex(P, v, y), R = g.getTileIndex(A, v, y), I = Math.ceil(Math.abs(E.idy - O.idy)), k = Math.ceil(Math.abs(E.idx - O.idx)), D = Math.ceil(Math.abs(E.idy - R.idy)), L = Math.ceil(Math.abs(E.idx - R.idx)), z = (I + D + 1) * (k + L + 1), F = this.getTileSize(), j = this.getRenderer() || i, H = this._getTileConfig().tileSystem.scale, N = [], B = new Ps, G = new Oi$1(0, 0), V = -I; V <= D; V++) for (var U = -k, W = -1 / 0, Z = !1; U >= W && U <= L; ) {
	            var X = g.getNeighorTileIndex(E.idx, E.idy, U, V, v, y);
	            W === -1 / 0 ? U++ : U--;
	            var J = this._getTileId(X.idx, X.idy, s);
	            if (!(X.out || this._visitedTiles && this._visitedTiles.has(J))) {
	                var q = j && j.isTileCachedOrLoading(J);
	                q && (q = q.info);
	                var Y = void 0;
	                if (q) {
	                    var K = q.extent2d;
	                    G.set(K.xmin, K.ymax), Y = G;
	                } else if (this._hasOwnSR) {
	                    var Q = g.getTilePrjNW(X.x, X.y, v);
	                    Y = o._prjToPoint(this._unproject(Q, eu), s);
	                } else Y = g.getTilePointNW(X.x, X.y, v);
	                var $ = void 0, tt = void 0;
	                if (this._hasOwnSR) {
	                    var et = void 0;
	                    if (this._hasOwnSR) {
	                        var nt = g.getTilePrjSE(X.x, X.y, v);
	                        et = o._prjToPoint(this._unproject(nt, eu), s, eu);
	                    } else et = g.getTilePointSE(X.x, X.y, v);
	                    $ = Math.ceil(Math.abs(et.x - Y.x)), tt = Math.ceil(Math.abs(et.y - Y.y));
	                } else $ = F.width, tt = F.height;
	                var it = H.x * (X.idx - X.x) * $, rt = H.y * (X.idy - X.y) * tt;
	                q || !it && !rt || Y._add(it, rt);
	                var ot = q && q.extent2d || new Ps(Y.x, Y.y - tt, Y.x + $, Y.y);
	                if (z <= 4 || Z || this._isTileInExtent(a, ot, c, p)) {
	                    var st = this._hasOwnSR ? o._getResolution(s) : v;
	                    this._visitedTiles && 0 === n && this._visitedTiles.add(J), h && 0 === n ? (this._splitTiles(a, N, j, X, s + 1, st, ot, it, rt, _, i), 
	                    B._combine(ot)) : (q ? (q.offset[0] = c[0], q.offset[1] = c[1]) : (q = {
	                        z: s,
	                        x: X.x,
	                        y: X.y,
	                        idx: X.idx,
	                        idy: X.idy,
	                        extent2d: ot,
	                        offset: c,
	                        id: J,
	                        res: st,
	                        url: this.getTileUrl(X.x, X.y, s)
	                    }, i && (q.layer = this.getId())), N.push(q), B._combine(ot)), W === -1 / 0 ? (W = U, 
	                    U = L) : Z || (Z = !0);
	                }
	            }
	        }
	        if (N.length) {
	            var at = o._containerPointToPoint(e.getCenter(), s, Xc)._add(c), ht = new Oi$1(0, 0), lt = new Oi$1(0, 0);
	            N.sort((function(t, e) {
	                return ht.set((t.extent2d.xmin + t.extent2d.xmax) / 2, (t.extent2d.ymin + t.extent2d.ymax) / 2), 
	                lt.set((e.extent2d.xmin + e.extent2d.xmax) / 2, (e.extent2d.ymin + e.extent2d.ymax) / 2), 
	                ht.distanceTo(at) - lt.distanceTo(at);
	            }));
	        }
	        return {
	            offset: c,
	            zoom: t,
	            extent: B,
	            tiles: N
	        };
	    }, n._convertToExtent2d = function(t) {
	        var e = this, n = this.getMap();
	        return t.convertTo((function(t) {
	            if (t.y > 0 && t.y < n.height) {
	                var i = (0 === t.x ? 0 : 1) + t.y;
	                e._coordCache[i] || (e._coordCache[i] = n._containerPointToPoint(t)), e._coordCache[i];
	            }
	            return n._containerPointToPoint(t, void 0, Xc);
	        }));
	    }, n._splitTiles = function(t, e, n, i, r, o, s, a, h, l, c) {
	        var u = this._getTileConfig().tileSystem.scale.y, f = this.getMap().getGLScale(r), d = nu.set(2 * s.xmin, u < 0 ? 2 * s.ymax : 2 * s.ymin), m = s.getWidth(), g = s.getHeight(), p = 2 * i.idx, _ = 2 * i.idy, v = 2 * i.x, y = 2 * i.y, x = this._checkAndAddTile(t, n, p, _, v, y, r, o, 0, 0, m, g, d, f, l, c);
	        x && e.push(x), (x = this._checkAndAddTile(t, n, p, _, v, y, r, o, 0, 1, m, g, d, f, l, c)) && e.push(x), 
	        (x = this._checkAndAddTile(t, n, p, _, v, y, r, o, 1, 0, m, g, d, f, l, c)) && e.push(x), 
	        (x = this._checkAndAddTile(t, n, p, _, v, y, r, o, 1, 1, m, g, d, f, l, c)) && e.push(x);
	    }, n._checkAndAddTile = function(t, e, n, i, r, o, s, a, h, l, c, u, f, d, m, g) {
	        var p = this._getTileId(n + h, i + l, s);
	        if (this._visitedTiles && this._visitedTiles.has(p)) return null;
	        var _ = m[s];
	        _ || (_ = m[s] = this._getTileOffset(s));
	        var v = this._getTileConfig().tileSystem.scale.y, y = new Ps(f.x + h * c, f.y + v * l * u, f.x + (h + 1) * c, f.y + v * (l + 1) * u);
	        if (!this._isSplittedTileInExtent(t, y, _, d)) return null;
	        var x = a / 2, b = e && e.isTileCachedOrLoading(p);
	        return b ? b = b.info : (b = {
	            z: s,
	            x: r + h,
	            y: o + l,
	            extent2d: y,
	            id: p,
	            offset: _,
	            res: x,
	            url: this.getTileUrl(r + h, o + l, s + this.options.zoomOffset)
	        }, g && (b.layer = this.getId())), b;
	    }, n._getTileOffset = function(t) {
	        var e = this.options.offset;
	        return Hn(e) && (e = e.call(this, t)), Ln(e) ? [ e, e ] : e || [ 0, 0 ];
	    }, n._getTileId = function(t, e, n, i) {
	        return (i || this.getId()) + "_" + e + "_" + t + "_" + n;
	    }, n._project = function(t, e) {
	        if (this._hasOwnSR) {
	            var n = this.getMap().getProjection();
	            return this.getSpatialReference().getProjection().project(n.unproject(t, e), e);
	        }
	        return t;
	    }, n._unproject = function(t, e) {
	        if (this._hasOwnSR) {
	            var n = this.getMap(), i = this.getSpatialReference(), r = n.getProjection(), o = i.getProjection();
	            return r.project(o.unproject(t, e), e);
	        }
	        return t;
	    }, n._initTileConfig = function() {
	        var t = this.getMap(), e = this.getTileSize(), n = this.getSpatialReference(), i = n.getProjection(), r = n.getFullExtent();
	        this._defaultTileConfig = new Zc(t, Uc.getDefault(i), r, e), this.options.hasOwnProperty("tileSystem") && (this._tileConfig = new Zc(t, this.options.tileSystem, r, e)), 
	        delete this._rootNodes, delete this._tileFullExtent, delete this._disablePyramid;
	    }, n._getTileConfig = function() {
	        return this._defaultTileConfig || this._initTileConfig(), this._tileConfig || this._defaultTileConfig;
	    }, n._bindMap = function(e) {
	        var n = e.getBaseLayer();
	        return n === this && (n.options.hasOwnProperty("forceRenderOnMoving") || this.config({
	            forceRenderOnMoving: !0
	        })), this._onSpatialReferenceChange(), t.prototype._bindMap.apply(this, arguments);
	    }, n._isTileInExtent = function(t, e, n, i) {
	        var r, o = this.getMap();
	        if (t !== o.projViewMatrix) {
	            var s = e.getCenter(iu)._sub(n[0], n[1])._multi(i);
	            Jl(au, s.x, s.y, 0), r = function(t, e, n) {
	                var i = e[0], r = e[1], o = e[2], s = n[3] * i + n[7] * r + n[11] * o + n[15];
	                return t[0] = (n[0] * i + n[4] * r + n[8] * o + n[12]) / (s = s || 1), t[1] = (n[1] * i + n[5] * r + n[9] * o + n[13]) / s, 
	                t[2] = (n[2] * i + n[6] * r + n[10] * o + n[14]) / s, t;
	            }(au, au, o.projViewMatrix)[1] < 0 ? o.projViewMatrix : t;
	        } else r = o.projViewMatrix;
	        return ru[0][0] = (e.xmin - n[0]) * i, ru[0][1] = (e.ymin - n[1]) * i, ru[1][0] = (e.xmax - n[0]) * i, 
	        ru[1][1] = (e.ymax - n[1]) * i, Cn(r, ru);
	    }, n._isSplittedTileInExtent = function(t, e, n, i) {
	        var r = this.getMap();
	        return ru[0][0] = (e.xmin - n[0]) * i, ru[0][1] = (e.ymin - n[1]) * i, ru[1][0] = (e.xmax - n[0]) * i, 
	        ru[1][1] = (e.ymax - n[1]) * i, Cn(r.projViewMatrix, ru);
	    }, n.getEvents = function() {
	        return {
	            spatialreferencechange: this._onSpatialReferenceChange
	        };
	    }, n._onSpatialReferenceChange = function() {
	        delete this._tileConfig, delete this._defaultTileConfig, delete this._sr, delete this._srMinZoom, 
	        delete this._hasOwnSR, delete this._rootNodes, this.tileInfoCache && this.tileInfoCache.reset();
	        var t = this.getRenderer();
	        t && t.clear();
	    }, e;
	}(Sh);

	hu.registerJSONType("TileLayer"), hu.mergeOptions(Yc);

	Mi$1.decodeImageInWorker && (Js["core-fetch-image"] = function() {
	    return "\nfunction (exports) {\n    exports.onmessage = function (msg, postResponse) {\n        var url = msg.data.url;\n        var fetchOptions = msg.data.fetchOptions;\n        requestImageOffscreen(url, function (err, data) {\n            var buffers = [];\n            if (data && data.data && data.data.buffer) {\n                buffers.push(data.data.buffer);\n            }\n            postResponse(err, data, buffers);\n        }, fetchOptions);\n    };\n\n    var offCanvas, offCtx;\n    function requestImageOffscreen(url, cb, fetchOptions) {\n        if (!offCanvas) {\n            offCanvas = new OffscreenCanvas(2, 2);\n            offCtx = offCanvas.getContext('2d');\n        }\n        fetch(url, fetchOptions ? fetchOptions : {})\n            .then(response => response.blob())\n            .then(blob => createImageBitmap(blob))\n            .then(bitmap => {\n                var { width, height } = bitmap;\n                offCanvas.width = width;\n                offCanvas.height = height;\n                offCtx.drawImage(bitmap, 0, 0);\n                bitmap.close();\n                var imgData = offCtx.getImageData(0, 0, width, height);\n                // debugger\n                cb(null, { width, height, data: new Uint8Array(imgData.data) });\n            }).catch(err => {\n                console.warn('error when loading tile:', url);\n                console.warn(err);\n                cb(err);\n            });\n    }\n}";
	});

	var lu = new Gr(256, 256), cu = "show hide remove";

	function uu(t) {
	    return Array.isArray(t) || (t = [ t ]), t;
	}

	var fu = function(t) {
	    function e(e, n, i) {
	        var r;
	        return (r = t.call(this, e, i) || this).layers = n || [], r._checkChildren(), r.layerMap = {}, 
	        r._groupChildren = [], r;
	    }
	    Ti$1(e, t), e.fromJSON = function(t) {
	        if (!t || "GroupTileLayer" !== t.type) return null;
	        var n = t.layers.map((function(t) {
	            return Sh.fromJSON(t);
	        }));
	        return new e(t.id, n, t.options);
	    };
	    var n = e.prototype;
	    return n.getLayers = function() {
	        return this.layers;
	    }, n.addLayer = function(t) {
	        var e = this;
	        void 0 === t && (t = []), t = uu(t);
	        var n = this.layers.length;
	        return t.forEach((function(t) {
	            t instanceof hu && (-1 !== e.layers.indexOf(t) || e.layerMap[t.getId()] || e.layers.push(t));
	        })), n !== this.layers.length && (this._sortLayers(), this._refresh(), this._renderLayers()), 
	        this;
	    }, n.removeLayer = function(t) {
	        var e = this;
	        void 0 === t && (t = []), t = uu(t);
	        var n = this.layers.length;
	        return t.forEach((function(t) {
	            if (t instanceof hu || (t = e.layerMap[t]), t instanceof hu) {
	                var n = e.layers.indexOf(t);
	                n >= 0 && (e.layers.splice(n, 1), t._doRemove(), t.off(cu, e._onLayerShowHide, e));
	            }
	        })), n !== this.layers.length && (this._refresh(), this._renderLayers()), this;
	    }, n.clearLayers = function() {
	        var t = this;
	        return this.layers.forEach((function(e) {
	            e._doRemove(), e.off(cu, t._onLayerShowHide, t);
	        })), this.layers = [], this._refresh(), this._renderLayers(), this;
	    }, n.toJSON = function() {
	        return {
	            type: this.getJSONType(),
	            id: this.getId(),
	            layers: this.layers.map((function(t) {
	                return t.toJSON();
	            })),
	            options: this.config()
	        };
	    }, n.getTileSize = function(t) {
	        var e = this.getLayer(t);
	        return e ? e.getTileSize() : lu;
	    }, n.getTiles = function(t, e) {
	        for (var n = this.layers, i = [], r = 0, o = 0, s = n.length; o < s; o++) {
	            var a = n[o];
	            if (a && a.options.visible && a.isVisible() && a.getMap()) {
	                var h = a.getTiles(t, e || this);
	                h && 0 !== h.count && (r += h.count, Fi$1(i, h.tileGrids));
	            }
	        }
	        return {
	            count: r,
	            tileGrids: i
	        };
	    }, n.onAdd = function() {
	        this._sortLayers(), this._refresh(), t.prototype.onAdd.call(this);
	    }, n.onRemove = function() {
	        var e = this;
	        this.layers.forEach((function(t) {
	            t._doRemove(), t.off(cu, e._onLayerShowHide, e);
	        })), this.layerMap = {}, this._groupChildren = [], t.prototype.onRemove.call(this);
	    }, n.getLayer = function(t) {
	        return this.getChildLayer(t);
	    }, n.getChildLayer = function(t) {
	        var e = this.layerMap[t];
	        if (e) return e;
	        for (var n = 0; n < this._groupChildren.length; n++) {
	            var i = this._groupChildren[n].getChildLayer(t);
	            if (i) return i;
	        }
	        return null;
	    }, n._onLayerShowHide = function(t) {
	        var e = t || {}, n = e.target;
	        return "remove" === e.type && n && (this.layers.splice(this.layers.indexOf(n), 1), 
	        n._doRemove(), n.off(cu, this._onLayerShowHide, this), this._refresh()), this._renderLayers(), 
	        this;
	    }, n._renderLayers = function() {
	        var t = this.getRenderer();
	        return t && t.setToRedraw(), this;
	    }, n._refresh = function() {
	        var t = this, e = this.getMap();
	        return this._groupChildren = [], this.layerMap = {}, this.layers.forEach((function(n) {
	            t.layerMap[n.getId()] = n, n.getChildLayer && t._groupChildren.push(n), n.getMap() || n._bindMap(e), 
	            n.on(cu, t._onLayerShowHide, t);
	        })), this;
	    }, n.isVisible = function() {
	        if (!t.prototype.isVisible.call(this)) return !1;
	        for (var e = this.layers, n = 0, i = e.length; n < i; n++) if (e[n].isVisible()) return !0;
	        return !1;
	    }, n._checkChildren = function() {
	        var t = this, e = {};
	        this.layers.forEach((function(n) {
	            var i = n.getId();
	            if (e[i]) throw new Error("Duplicate child layer id (" + i + ") in the GroupTileLayer (" + t.getId() + ")");
	            e[i] = 1;
	        }));
	    }, n._sortLayers = function() {
	        this.layers.sort((function(t, e) {
	            return t.options.zIndex - e.options.zIndex;
	        }));
	    }, e;
	}(hu);

	fu.registerJSONType("GroupTileLayer"), fu.mergeOptions({
	    maxCacheSize: 1024
	});

	var du = {
	    crs: null,
	    uppercase: !1,
	    detectRetina: !1
	}, mu = {
	    service: "WMS",
	    request: "GetMap",
	    layers: "",
	    styles: "",
	    format: "image/jpeg",
	    transparent: !1,
	    version: "1.1.1"
	}, gu = function(t) {
	    function e(e, n) {
	        var i;
	        i = t.call(this, e) || this;
	        var r = kn({}, mu);
	        for (var o in n) o in i.options || (r[o] = n[o]);
	        i.setOptions(n), i.setZIndex(n.zIndex);
	        var s = i.getTileSize();
	        return r.width = s.width, r.height = s.height, i.wmsParams = r, i._wmsVersion = parseFloat(r.version), 
	        i;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.onAdd = function() {
	        var e = this.getMap().getDevicePixelRatio(), n = du.detectRetina ? e : 1;
	        this.wmsParams.width *= n, this.wmsParams.height *= n;
	        var i = this.options.crs || this.getMap().getProjection().code;
	        this.wmsParams[this._wmsVersion >= 1.3 ? "crs" : "srs"] = i, t.prototype.onAdd.call(this);
	    }, n.getTileUrl = function(e, n, i) {
	        var r = this.getSpatialReference().getResolution(i), o = this._getTileConfig().getTilePrjExtent(e, n, r), s = o.getMax(), a = o.getMin(), h = (this._wmsVersion >= 1.3 && "EPSG:4326" === this.wmsParams.crs ? [ a.y, a.x, s.y, s.x ] : [ a.x, a.y, s.x, s.y ]).join(","), l = t.prototype.getTileUrl.call(this, e, n, i);
	        return l + function(t, e, n) {
	            var i = [];
	            for (var r in t) i.push(encodeURIComponent(n ? r.toUpperCase() : r) + "=" + encodeURIComponent(t[r]));
	            return (e && -1 !== e.indexOf("?") ? "&" : "?") + i.join("&");
	        }(this.wmsParams, l, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + h;
	    }, n.toJSON = function() {
	        return {
	            type: "WMSTileLayer",
	            id: this.getId(),
	            options: this.config()
	        };
	    }, e.fromJSON = function(t) {
	        return t && "WMSTileLayer" === t.type ? new e(t.id, t.options) : null;
	    }, e;
	}(hu);

	gu.registerJSONType("WMSTileLayer"), gu.mergeOptions(du);

	var pu = function(t) {
	    function e(e, n) {
	        var i;
	        return (i = t.call(this, e, n) || this).options.hasOwnProperty("forceRenderOnMoving") || (i.options.forceRenderOnMoving = !1), 
	        i;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.drawTile = function() {}, n.toJSON = function() {
	        return {
	            type: "CanvasTileLayer",
	            id: this.getId(),
	            options: this.config()
	        };
	    }, e.fromJSON = function(t) {
	        return t && "CanvasTileLayer" === t.type ? new e(t.id, t.options) : null;
	    }, e;
	}(hu);

	function _u(t, e, n) {
	    var i = t.createShader(e);
	    if (t.shaderSource(i, n), t.compileShader(i), !t.getShaderParameter(i, t.COMPILE_STATUS)) {
	        var r = t.getShaderInfoLog(i);
	        throw t.deleteShader(i), new Error("Failed to compile shader: " + r);
	    }
	    return i;
	}

	function vu(t, e, n) {
	    var i = _u(t, t.VERTEX_SHADER, e), r = _u(t, t.FRAGMENT_SHADER, n);
	    if (!i || !r) return null;
	    var o = t.createProgram();
	    return o ? (t.attachShader(o, i), t.attachShader(o, r), t.linkProgram(o), {
	        program: o,
	        vertexShader: i,
	        fragmentShader: r
	    }) : null;
	}

	function yu(t, e, n) {
	    if (Array.isArray(n[0])) {
	        for (var i = Float32Array.BYTES_PER_ELEMENT, r = 0, o = 0; o < n.length; o++) r += n[o][1] || 0;
	        for (var s = 0, a = 0; a < n.length; a++) {
	            var h = t.getAttribLocation(e, n[a][0]);
	            if (h < 0) throw new Error("Failed to get the storage location of " + n[a][0]);
	            t.vertexAttribPointer(h, n[a][1], t[n[a][2] || "FLOAT"], !1, i * r, i * s), s += n[a][1] || 0, 
	            t.enableVertexAttribArray(h);
	        }
	    } else {
	        var l = t.getAttribLocation(e, n[0]);
	        t.vertexAttribPointer(l, n[1], t[n[2] || "FLOAT"], !1, 0, 0), t.enableVertexAttribArray(l);
	    }
	}

	pu.registerJSONType("CanvasTileLayer");

	var xu = "\n        attribute vec2 a_position;\n\n        attribute vec2 a_texCoord;\n\n        uniform mat4 u_matrix;\n\n        varying vec2 v_texCoord;\n\n        void main() {\n            gl_Position = u_matrix * vec4(a_position, 0., 1.);\n\n            v_texCoord = a_texCoord;\n        }\n    ", bu = "\n        precision mediump float;\n\n        uniform sampler2D u_image;\n\n        uniform float u_opacity;\n        uniform float u_debug_line;\n\n        varying vec2 v_texCoord;\n\n        void main() {\n            if (u_debug_line == 1.) {\n                gl_FragColor = vec4(0., 1., 0., 1.);\n            } else {\n                gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n            }\n        }\n    ", wu = [ 0, 0 ], Cu = [ 0, 0, 0 ], Mu = new Array(16), Tu = new Oi$1(20, 20), Su = function(t) {
	    var e, n = function(t) {
	        function e() {
	            return t.apply(this, arguments) || this;
	        }
	        Ti$1(e, t);
	        var n = e.prototype;
	        return n.drawGLImage = function(t, e, n, i, r, o, s, a) {
	            this.gl.program !== this.program && this.useProgram(this.program);
	            var h = this.gl;
	            if (this.loadTexture(t), this.canvas.gl && this.canvas.gl.wrap) {
	                var l = this.layer && this.layer.options.opacity;
	                Dn(l) && (l = 1), s *= l;
	            }
	            Cu[0] = e || 0, Cu[1] = n || 0;
	            var c = Zl(Mu);
	            Gl(c, c, Cu), Vl(c, c, [ o, o, 1 ]), Ul(c, this.getMap().projViewMatrix, c), h.uniformMatrix4fv(this.program.u_matrix, !1, c), 
	            h.uniform1f(this.program.u_opacity, s), h.uniform1f(this.program.u_debug_line, 0);
	            var u = t.glBuffer;
	            !u || u.width === i && u.height === r || (this.saveImageBuffer(u), delete t.glBuffer), 
	            t.glBuffer ? h.bindBuffer(h.ARRAY_BUFFER, u) : t.glBuffer = this.bufferTileData(0, 0, i, r), 
	            wu[0] = "a_position", wu[1] = 2, wu[2] = t.glBuffer.type, this.enableVertexAttrib(wu), 
	            h.drawArrays(h.TRIANGLE_STRIP, 0, 4), a && this.drawDebug(c, 0, 0, i, r, a);
	        }, n.drawDebug = function(t, e, n, i, r, o) {
	            var s = this.gl;
	            s.bindBuffer(s.ARRAY_BUFFER, this._debugBuffer), this.enableVertexAttrib([ "a_position", 2, "FLOAT" ]), 
	            s.bufferData(s.ARRAY_BUFFER, new Float32Array([ e, n, e + i, n, e + i, n - r, e, n - r, e, n ]), s.DYNAMIC_DRAW), 
	            s.uniformMatrix4fv(this.program.u_matrix, !1, t), s.uniform1f(this.program.u_opacity, 1), 
	            s.uniform1f(this.program.u_debug_line, 1), s.drawArrays(s.LINE_STRIP, 0, 5);
	            var a = this._debugInfoCanvas;
	            if (!a) {
	                var h = this.getMap().getDevicePixelRatio() > 1 ? 2 : 1;
	                (a = this._debugInfoCanvas = document.createElement("canvas")).width = 256 * h, 
	                a.height = 32 * h;
	                var l = a.getContext("2d");
	                l.font = "20px monospace", l.scale(h, h);
	            }
	            var c = a.getContext("2d");
	            c.clearRect(0, 0, a.width, a.height), qo.fillText(c, o, Tu, this.layer.options.debugOutline), 
	            this.loadTexture(a), s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, s.RGBA, s.UNSIGNED_BYTE, a);
	            var u = e + (i = 256), f = n - r + 32, d = n - r;
	            s.bufferData(s.ARRAY_BUFFER, this.set8(e, f, e, d, u, f, u, d), s.DYNAMIC_DRAW), 
	            s.uniform1f(this.program.u_debug_line, 0), s.drawArrays(s.TRIANGLE_STRIP, 0, 4);
	        }, n.bufferTileData = function(t, e, n, i, r) {
	            var o, s = t, a = t + n, h = e, l = e - i;
	            o = zn(s) && zn(a) && zn(h) && zn(l) ? this.set8Int(s, h, s, l, a, h, a, l) : this.set8(s, h, s, l, a, h, a, l);
	            var c = this.loadImageBuffer(o, r);
	            return c.width = n, c.height = i, c.type = o instanceof Int16Array ? "SHORT" : "FLOAT", 
	            c;
	        }, n.drawTinImage = function(t, e, n, i, r) {
	            var o = this.gl;
	            this.loadTexture(t), o.uniformMatrix4fv(this.program.u_matrix, !1, this.getMap().projViewMatrix), 
	            o.uniform1f(this.program.u_opacity, r), o.bindBuffer(o.ARRAY_BUFFER, this.posBuffer), 
	            this.enableVertexAttrib([ "a_position", 3 ]), o.bufferData(o.ARRAY_BUFFER, new Float32Array(e), o.DYNAMIC_DRAW), 
	            o.bindBuffer(o.ARRAY_BUFFER, this.texBuffer), this.enableVertexAttrib([ "a_texCoord", 2 ]), 
	            o.bufferData(o.ARRAY_BUFFER, new Float32Array(n), o.DYNAMIC_DRAW), o.bufferData(o.ELEMENT_ARRAY_BUFFER, new Uint16Array(i), o.DYNAMIC_DRAW), 
	            o.drawElements(o.TRIANGLES, i.length, o.UNSIGNED_SHORT, 0);
	        }, n.createCanvas2 = function() {
	            this.canvas2 = qo.createCanvas(this.canvas.width, this.canvas.height);
	        }, n.createGLContext = function() {
	            this.gl = this.canvas.gl && this.canvas.gl.wrap ? this.canvas.gl.wrap() : function(t, e) {
	                for (var n = {
	                    alpha: !0,
	                    stencil: !0,
	                    preserveDrawingBuffer: !0,
	                    antialias: !1
	                }, i = [ "webgl", "experimental-webgl" ], r = null, o = 0; o < i.length; ++o) {
	                    try {
	                        r = t.getContext(i[o], e || n);
	                    } catch (t) {}
	                    if (r) break;
	                }
	                return r;
	            }(this.canvas2 || this.canvas, this.layer.options.glOptions);
	            var t = this.gl;
	            t.clearColor(0, 0, 0, 0), t.disable(t.DEPTH_TEST), t.enable(t.STENCIL_TEST), t.enable(t.BLEND), 
	            t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA), this.program = this.createProgram(xu, this.layer.options.fragmentShader || bu), 
	            this._debugBuffer = this.createBuffer(), this.useProgram(this.program), this.texBuffer = this.createBuffer(), 
	            t.bindBuffer(t.ARRAY_BUFFER, this.texBuffer), this.enableVertexAttrib([ "a_texCoord", 2, "UNSIGNED_BYTE" ]), 
	            t.bufferData(t.ARRAY_BUFFER, new Uint8Array([ 0, 0, 0, 1, 1, 0, 1, 1 ]), t.STATIC_DRAW), 
	            this.enableSampler("u_image"), t.activeTexture(t.TEXTURE0), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0);
	        }, n.resizeGLCanvas = function() {
	            this.gl && this.gl.viewport(0, 0, this.canvas.width, this.canvas.height), this.canvas2 && (this.canvas2.width === this.canvas.width && this.canvas2.height === this.canvas.height || (this.canvas2.width = this.canvas.width, 
	            this.canvas2.height = this.canvas.height));
	        }, n.clearGLCanvas = function() {
	            this.gl && (this.gl.clearStencil(255), this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.STENCIL_BUFFER_BIT));
	        }, n.disposeImage = function(t) {
	            t && (t.texture && this.saveTexture(t.texture), t.glBuffer && this.saveImageBuffer(t.glBuffer), 
	            delete t.texture, delete t.glBuffer);
	        }, n._createTexture = function(t) {
	            var e = this.gl, n = this.getTexture() || e.createTexture();
	            return e.bindTexture(e.TEXTURE_2D, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), 
	            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), 
	            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t), 
	            zn(Gi$1(t.width)) && zn(Gi$1(t.width)) && e.generateMipmap(e.TEXTURE_2D), n;
	        }, n.getTexture = function() {
	            this._textures || (this._textures = []);
	            var t = this._textures;
	            return t && t.length > 0 ? t.pop() : null;
	        }, n.saveTexture = function(t) {
	            this._textures.push(t);
	        }, n.loadTexture = function(t) {
	            var e = this.gl, n = t.texture;
	            return n || (n = this._createTexture(t), t.texture = n), e.bindTexture(e.TEXTURE_2D, n), 
	            n;
	        }, n.getImageBuffer = function() {
	            this._imageBuffers || (this._imageBuffers = []);
	            var t = this._imageBuffers;
	            return t && t.length > 0 ? t.pop() : null;
	        }, n.saveImageBuffer = function(t) {
	            this._imageBuffers || (this._imageBuffers = []), this._imageBuffers.push(t);
	        }, n.loadImageBuffer = function(t, e) {
	            var n = this.gl, i = e || this.createImageBuffer();
	            return n.bindBuffer(n.ARRAY_BUFFER, i), n.bufferData(n.ARRAY_BUFFER, t, n.STATIC_DRAW), 
	            i;
	        }, n.createImageBuffer = function() {
	            return this.getImageBuffer() || this.createBuffer();
	        }, n.removeGLCanvas = function() {
	            var t = this.gl;
	            if (t) {
	                if (this._debugBuffer && (t.deleteBuffer(this._debugBuffer), delete this._debugBuffer), 
	                this._buffers && (this._buffers.forEach((function(e) {
	                    t.deleteBuffer(e);
	                })), delete this._buffers), this._textures && (this._textures.forEach((function(e) {
	                    return t.deleteTexture(e);
	                })), delete this._textures), this._debugInfoCanvas) {
	                    var e = this._debugInfoCanvas.texture;
	                    e && t.deleteTexture(e), delete this._debugInfoCanvas.texture, delete this._debugInfoCanvas;
	                }
	                var n = t.program;
	                t.deleteShader(n.fragmentShader), t.deleteShader(n.vertexShader), t.deleteProgram(n), 
	                delete this.gl, delete this.canvas2;
	            }
	        }, n.createBuffer = function() {
	            var t = this.gl.createBuffer();
	            if (!t) throw new Error("Failed to create the buffer object");
	            return this._buffers || (this._buffers = []), this._buffers.push(t), t;
	        }, n.enableVertexAttrib = function(t) {
	            yu(this.gl, this.gl.program, t);
	        }, n.createProgram = function(t, e) {
	            for (var n = this.gl, i = vu(n, t, e), r = i.program, o = i.vertexShader, s = i.fragmentShader, a = n.getProgramParameter(r, 35718), h = [], l = 0; l < a; ++l) {
	                var c = n.getActiveUniform(r, l);
	                h.push(c.name);
	            }
	            return r.vertexShader = o, r.fragmentShader = s, this._initUniforms(r, h), r;
	        }, n.useProgram = function(t) {
	            var e = this.gl;
	            return e.useProgram(t), e.program = t, this;
	        }, n.enableSampler = function(t, e) {
	            var n = this.gl, i = this._getUniform(n.program, t);
	            return e || (e = 0), n.uniform1i(i, e), i;
	        }, n._initUniforms = function(t, e) {
	            for (var n = 0; n < e.length; n++) {
	                var i = e[n], r = e[n], o = i.indexOf("[");
	                o >= 0 && (i = i.substring(0, o), Wn || (r = r.substring(0, o))), t[i] = this._getUniform(t, r);
	            }
	        }, n._getUniform = function(t, e) {
	            var n = this.gl.getUniformLocation(t, e);
	            if (!n) throw new Error("Failed to get the storage location of " + e);
	            return n;
	        }, e;
	    }(t);
	    return kn(n.prototype, {
	        set8: (e = Mi$1.ie9 ? null : new Float32Array(8), function(t, n, i, r, o, s, a, h) {
	            return e[0] = t, e[1] = n, e[2] = i, e[3] = r, e[4] = o, e[5] = s, e[6] = a, e[7] = h, 
	            e;
	        }),
	        set8Int: function() {
	            var t = Mi$1.ie9 ? null : new Int16Array(8);
	            return function(e, n, i, r, o, s, a, h) {
	                return t[0] = e, t[1] = n, t[2] = i, t[3] = r, t[4] = o, t[5] = s, t[6] = a, t[7] = h, 
	                t;
	            };
	        }()
	    }), n;
	}, Pu = {
	    renderer: Mi$1.webgl ? "gl" : "canvas",
	    crossOrigin: null
	}, Au = new Oi$1(0, 0), Eu = function(t) {
	    function e(e, n, i) {
	        var r;
	        return !n || Array.isArray(n) || n.url || (i = n, n = null), (r = t.call(this, e, i) || this)._images = n, 
	        r;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.onAdd = function() {
	        this._prepareImages(this._images);
	    }, n.setImages = function(t) {
	        return this._images = t, this._prepareImages(t), this;
	    }, n.getImages = function() {
	        return this._images;
	    }, n._prepareImages = function(t) {
	        t = t || [], Array.isArray(t) || (t = [ t ]);
	        var e = this.getMap(), n = e.getGLRes();
	        this._imageData = t.map((function(t) {
	            var i = new Ts(t.extent);
	            return kn({}, t, {
	                extent: i,
	                extent2d: i.convertTo((function(t) {
	                    return e.coordToPointAtRes(t, n);
	                }))
	            });
	        })), this._images = t;
	        var i = this.getRenderer();
	        i && i.refreshImages();
	    }, e;
	}(Sh);

	Eu.mergeOptions(Pu);

	var Ou = [], Ru = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.isDrawable = function() {
	        return !this.getMap().getPitch() || (console && console.warn("ImageLayer with canvas renderer can't be pitched, use gl renderer ('renderer' : 'gl') instead."), 
	        !1);
	    }, n.checkResources = function() {
	        var t = this;
	        if (this._imageLoaded) return Ou;
	        var e = this.layer._imageData.map((function(t) {
	            return [ t.url, null, null ];
	        }));
	        if (this.resources) {
	            var n = [], i = new la;
	            e.forEach((function(e) {
	                if (t.resources.isResourceLoaded(e)) {
	                    var r = t.resources.getImage(e);
	                    i.addResource(e, r);
	                } else n.push(e);
	            })), this.resources.forEach((function(e, n) {
	                i.isResourceLoaded(e) || t.retireImage(n.image);
	            })), this.resources = i, e = n;
	        }
	        return this._imageLoaded = !0, e;
	    }, n.retireImage = function(t) {
	        t.close && t.close();
	    }, n.refreshImages = function() {
	        this._imageLoaded = !1, this.setToRedraw();
	    }, n.draw = function() {
	        this.isDrawable() && (this.prepareCanvas(), this._painted = !1, this._drawImages(), 
	        this.completeRender());
	    }, n._drawImages = function() {
	        var t = this.layer._imageData, e = this.getMap(), n = e._get2DExtentAtRes(e.getGLRes());
	        if (t && t.length) for (var i = 0; i < t.length; i++) {
	            var r = t[i].extent2d, o = this.resources && this.resources.getImage(t[i].url);
	            o && n.intersects(r) && (this._painted = !0, this._drawImage(o, r, t[i].opacity || 1));
	        }
	    }, n._drawImage = function(t, e, n) {
	        var i = 0, r = this.context;
	        n < 1 && (i = r.globalAlpha, r.globalAlpha = n);
	        var o = this.getMap(), s = Au.set(e.xmin, e.ymax), a = o._pointAtResToContainerPoint(s, o.getGLRes()), h = a.x, l = a.y, c = o.getBearing();
	        c && (r.save(), r.translate(h, l), c && r.rotate(-c * Math.PI / 180), h = l = 0);
	        var u = o.getGLScale();
	        r.drawImage(t, h, l, e.getWidth() / u, e.getHeight() / u), c && r.restore(), i && (r.globalAlpha = i);
	    }, n.drawOnInteracting = function() {
	        this.draw();
	    }, e;
	}(ha), Iu = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.isDrawable = function() {
	        return !0;
	    }, n._drawImage = function(t, e, n) {
	        this.drawGLImage(t, e.xmin, e.ymax, e.getWidth(), e.getHeight(), 1, n);
	    }, n.createContext = function() {
	        this.createGLContext();
	    }, n.resizeCanvas = function(e) {
	        this.canvas && (t.prototype.resizeCanvas.call(this, e), this.resizeGLCanvas());
	    }, n.clearCanvas = function() {
	        this.canvas && (t.prototype.clearCanvas.call(this), this.clearGLCanvas());
	    }, n.retireImage = function(t) {
	        t.close && t.close(), this.disposeImage(t);
	    }, n.onRemove = function() {
	        this.removeGLCanvas(), t.prototype.onRemove.call(this);
	    }, e;
	}(Su(Ru));

	Eu.registerRenderer("canvas", Ru), Eu.registerRenderer("gl", Iu);

	var ku = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getPrepareParams = function() {
	        return [];
	    }, n.getDrawParams = function() {
	        return [];
	    }, n.onCanvasCreate = function() {
	        this.canvas && this.layer.options.doubleBuffer && (this.buffer = qo.createCanvas(this.canvas.width, this.canvas.height, this.getMap().CanvasClass));
	    }, n.needToRedraw = function() {
	        return !!this.layer.options.animation || !(this.getMap().isInteracting() && !this.layer.drawOnInteracting) && t.prototype.needToRedraw.call(this);
	    }, n.draw = function() {
	        this.prepareCanvas(), this.prepareDrawContext(), this._drawLayer.apply(this, arguments);
	    }, n.drawOnInteracting = function() {
	        this._drawLayerOnInteracting.apply(this, arguments);
	    }, n.getCanvasImage = function() {
	        var e = t.prototype.getCanvasImage.call(this);
	        if (e && e.image && this.layer.options.doubleBuffer) {
	            var n = e.image;
	            this.buffer.width === n.width && this.buffer.height === n.height || (this.buffer.width = n.width, 
	            this.buffer.height = n.height);
	            var i = this.buffer.getContext("2d"), r = this.layer.doubleBuffer(i, this.context);
	            (void 0 === r || r) && (qo.image(i, n, 0, 0), e.image = this.buffer);
	        }
	        return e;
	    }, n.remove = function() {
	        return delete this._drawContext, t.prototype.remove.call(this);
	    }, n.onZoomStart = function(e) {
	        this.layer.onZoomStart(e), t.prototype.onZoomStart.call(this, e);
	    }, n.onZooming = function(e) {
	        this.layer.onZooming(e), t.prototype.onZooming.call(this, e);
	    }, n.onZoomEnd = function(e) {
	        this.layer.onZoomEnd(e), t.prototype.onZoomEnd.call(this, e);
	    }, n.onMoveStart = function(e) {
	        this.layer.onMoveStart(e), t.prototype.onMoveStart.call(this, e);
	    }, n.onMoving = function(e) {
	        this.layer.onMoving(e), t.prototype.onMoving.call(this, e);
	    }, n.onMoveEnd = function(e) {
	        this.layer.onMoveEnd(e), t.prototype.onMoveEnd.call(this, e);
	    }, n.onResize = function(e) {
	        this.layer.onResize(e), t.prototype.onResize.call(this, e);
	    }, n.prepareDrawContext = function() {
	        if (!this._predrawed) {
	            var t = Du(this.getPrepareParams());
	            this._drawContext = this.layer.prepareToDraw.apply(this.layer, [ this.context ].concat(t)), 
	            this._drawContext || (this._drawContext = []), Array.isArray(this._drawContext) || (this._drawContext = [ this._drawContext ]), 
	            this._predrawed = !0;
	        }
	    }, n._prepareDrawParams = function() {
	        if (!this.getMap()) return null;
	        var t = this.getViewExtent();
	        if (t.maskExtent && !t.extent.intersects(t.maskExtent)) return this.completeRender(), 
	        null;
	        var e = [ this.context, t ], n = Du(this.getDrawParams());
	        return e.push.apply(e, n), e.push.apply(e, this._drawContext), e;
	    }, n._drawLayer = function() {
	        var t = this._prepareDrawParams();
	        if (t) {
	            for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
	            this.layer.draw.apply(this.layer, t.concat(n)), this.completeRender();
	        }
	    }, n._drawLayerOnInteracting = function() {
	        if (this.layer.drawOnInteracting) {
	            var t = this._prepareDrawParams();
	            if (t) {
	                for (var e = arguments.length, n = new Array(e), i = 0; i < e; i++) n[i] = arguments[i];
	                this.layer.drawOnInteracting.apply(this.layer, t.concat(n)), this.completeRender();
	            }
	        }
	    }, e;
	}(ha);

	function Du(t) {
	    return t || (t = []), Array.isArray(t) || (t = [ t ]), t;
	}

	var Lu = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.isCanvasRender = function() {
	        return !0;
	    }, n.prepareToDraw = function() {}, n.draw = function() {}, n.redraw = function() {
	        return this._getRenderer() && this._getRenderer().setToRedraw(), this;
	    }, n.play = function() {
	        return this.config("animation", !0), this;
	    }, n.pause = function() {
	        return this.config("animation", !1), this;
	    }, n.isPlaying = function() {
	        return this.options.animation;
	    }, n.clearCanvas = function() {
	        return this._getRenderer() && this._getRenderer().clearCanvas(), this;
	    }, n.requestMapToRender = function() {
	        return this._getRenderer() && this._getRenderer().requestMapToRender(), this;
	    }, n.completeRender = function() {
	        return this._getRenderer() && this._getRenderer().completeRender(), this;
	    }, n.onCanvasCreate = function() {
	        return this;
	    }, n.onZoomStart = function() {}, n.onZooming = function() {}, n.onZoomEnd = function() {}, 
	    n.onMoveStart = function() {}, n.onMoving = function() {}, n.onMoveEnd = function() {}, 
	    n.onResize = function() {}, n.doubleBuffer = function(t) {
	        return t.clearRect(0, 0, t.canvas.width, t.canvas.height), this;
	    }, e;
	}(Sh);

	Lu.mergeOptions({
	    doubleBuffer: !1,
	    animation: !1
	}), Lu.registerRenderer("canvas", ku);

	var zu = new Oi$1(0, 0), Fu = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getParticles = function() {}, n.draw = function(t, e) {
	        var n = this.getParticles(In());
	        if (n && 0 !== n.length) {
	            var i = this.getMap(), r = e.extent;
	            e.maskExtent && (r = e.extent.intersection(e.maskExtent)), r = r.convertTo((function(t) {
	                return i._pointToContainerPoint(t, void 0, 0, zu);
	            }));
	            for (var o = 2 * Math.PI, s = 0, a = n.length; s < a; s++) {
	                var h = n[s].point;
	                if (r.contains(h)) {
	                    var l = n[s].color || this.options.lineColor || "#fff", c = n[s].r;
	                    t.fillStyle !== l && (t.fillStyle = l), c <= 2 ? t.fillRect(h.x - c / 2, h.y - c / 2, c, c) : (t.beginPath(), 
	                    t.arc(h.x, h.y, c / 2, 0, o), t.fill());
	                }
	            }
	            this._fillCanvas(t);
	        } else {
	            this._getRenderer() && (this._getRenderer()._shouldClear = !0);
	        }
	    }, n._fillCanvas = function(t) {
	        var e = t.globalCompositeOperation;
	        t.globalCompositeOperation = "destination-out", t.fillStyle = "rgba(0, 0, 0, " + 1 / (this.options.trail || 30) + ")", 
	        t.fillRect(0, 0, t.canvas.width, t.canvas.height), t.globalCompositeOperation = e;
	    }, e;
	}(Lu);

	Fu.mergeOptions({
	    animation: !0
	}), Fu.registerRenderer("canvas", function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.draw = function() {
	        this.canvas && this.layer.options.animation && !this._shouldClear || (this.prepareCanvas(), 
	        this._shouldClear = !1), this.prepareDrawContext(), this._drawLayer();
	    }, n.drawOnInteracting = function() {
	        this.draw(), this._shouldClear = !1;
	    }, n.onSkipDrawOnInteracting = function() {
	        this._shouldClear = !0;
	    }, e;
	}(ku));

	var ju, Hu, Nu = new la, Bu = function(t) {
	    function e(e, n, i) {
	        var r;
	        (r = t.call(this, i) || this).target = e, e.once("remove", r.delete, Si$1(Si$1(r)));
	        var o = r.options.symbol, s = o.markerLineWidth || 1;
	        return r.w = o.markerWidth + s, r.h = o.markerHeight + s, r.opacity = Dn(o.opacity) ? 1 : o.opacity, 
	        r.map = n, r.events = i.events, r._fetchImage(), r.addTo(n), r;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getCursor = function() {
	        return this.options.cursor || "default";
	    }, n._fetchImage = function() {
	        var t = this.map, e = this.options.symbol, n = e.markerFile;
	        this.url = n || so(e);
	        var i = Nu.getImage(this.url);
	        if (!i) {
	            var r = this.w, o = this.h;
	            if (n) (i = new Image).onload = function() {
	                var e = t.getRenderer();
	                e && e.setToRedraw();
	            }, i.src = this.url; else {
	                var s = document.createElement("canvas");
	                s.width = r, s.height = o, i = Ga(s.getContext("2d"), {
	                    x: r / 2,
	                    y: o / 2
	                }, e, Nu);
	            }
	            Nu.addResource([ this.url, r, o ], i);
	        }
	        Nu.login(this.url), this._img = i;
	    }, n.setContainerPoint = function(t) {
	        this._point = t, this._point._sub(this.w / 2, this.h / 2);
	    }, n.getContainerPoint = function() {
	        return this._point.add(this.w / 2, this.h / 2);
	    }, n.offset = function(t) {
	        this._point._add(t);
	    }, n.render = function(t) {
	        if (!this._img) return !1;
	        var e = this.options.symbol, n = e.markerDx || 0, i = e.markerDy || 0, r = this.map, o = this._point, s = o.x, a = o.y, h = this.w, l = this.h;
	        if (s + h > 0 && s < r.width && a + l > 0 && a < r.height) {
	            var c = r.getDevicePixelRatio();
	            return t.globalAlpha = this.opacity, t.drawImage(this._img, Math.round((s + n) * c), Math.round((a + i) * c), Math.round(h * c), Math.round(l * c)), 
	            !0;
	        }
	        return !1;
	    }, n.delete = function() {
	        if (this.map) {
	            var t = this.map.getRenderer();
	            t && t.removeTopElement(this);
	        }
	        Nu.logout(this.url), this._dragger && (this._dragger.disable(), delete this._dragger), 
	        delete this.map;
	    }, n.hitTest = function(t) {
	        var e = this.options.symbol, n = this._point.x + (e.markerDx || 0), i = this._point.y + (e.markerDy || 0);
	        return t.x >= n && t.x <= n + this.w && t.y >= i && t.y <= i + this.h;
	    }, n.addTo = function(t) {
	        this.map = t, t.getRenderer().addTopElement(this);
	    }, n.onEvent = function(t) {
	        this.fire(t.type, t);
	    }, n.mousedown = function(t) {
	        var e = this.options.cursor;
	        e && t.target.setCursor(e), this.onDragstart(t);
	    }, n.onDragstart = function(t) {
	        var e = t.containerPoint, n = t.target, i = this._dragger = new cs(n._panels.mapWrapper || n._containerDOM);
	        i.on("dragging", this.onDragging, this).on("mouseup", this.onDragend, this).enable(), 
	        i.type = "handle", i.onMouseDown(t.domEvent), ju = e.x, Hu = e.y, this.fire("dragstart", {
	            containerPoint: e
	        });
	    }, n.onDragging = function(t) {
	        if (this._dragger) {
	            var e = this.map, n = Ro(t.domEvent, e._containerDOM), i = {
	                x: n.x - ju,
	                y: n.y - Hu
	            }, r = e.containerPointToCoord(new Oi$1(ju, Hu)), o = e.containerPointToCoord(n);
	            ju = n.x, Hu = n.y, this.offset(i), this.fire("dragging", {
	                containerPoint: n,
	                coordOffset: o._sub(r)
	            });
	        }
	    }, n.onDragend = function(t) {
	        if (this._dragger) {
	            var e = this.map;
	            e.resetCursor();
	            var n = Ro(t.domEvent, e._containerDOM);
	            this.offset({
	                x: n.x - ju,
	                y: n.y - Hu
	            }), this._dragger.disable(), delete this._dragger, this.fire("dragend", {
	                containerPoint: n
	            });
	        }
	    }, e;
	}(ts(ns)), Gu = function() {
	    function t(t, e) {
	        this.target = t, t.once("remove", this.delete, this), this.map = e, this.addTo(e);
	    }
	    var e = t.prototype;
	    return e.setPoints = function(t) {
	        this.points = t;
	        var e = t.map((function(t) {
	            return t.x;
	        })), n = t.map((function(t) {
	            return t.y;
	        }));
	        this.xmin = Math.min.apply(Math, e), this.xmax = Math.max.apply(Math, e), this.ymin = Math.min.apply(Math, n), 
	        this.ymax = Math.max.apply(Math, n);
	    }, e.hitTest = function() {
	        return !1;
	    }, e.render = function(t) {
	        var e = this.map;
	        if (!(this.xmax <= 0 || this.xmin >= e.width || this.ymax <= 0 || this.ymin >= e.height)) {
	            var n = e.getDevicePixelRatio();
	            t.lineWidth = 1, t.strokeStyle = "#000", t.globalAlpha = 1, t.beginPath();
	            var i = this.points;
	            t.moveTo(o(i[0].x), o(i[0].y));
	            for (var r = 1; r < this.points.length; r++) t.lineTo(o(i[r].x), o(i[r].y));
	            t.closePath(), t.stroke();
	        }
	        function o(t) {
	            return Math.round(t) * n + .5;
	        }
	    }, e.addTo = function(t) {
	        this.map = t, t.getRenderer().addTopElement(this);
	    }, e.delete = function() {
	        if (this.map) {
	            var t = this.map.getRenderer();
	            t && t.removeTopElement(this);
	        }
	    }, t;
	}();

	function Vu(t, e) {
	    return {
	        markerType: t,
	        markerFill: "#fff",
	        markerLineColor: "#000",
	        markerLineWidth: 2,
	        markerWidth: 10,
	        markerHeight: 10,
	        opacity: e
	    };
	}

	var Uu = {
	    fixAspectRatio: !1,
	    symbol: null,
	    removeVertexOn: "contextmenu",
	    centerHandleSymbol: Vu("ellipse", 1),
	    vertexHandleSymbol: Vu("square", 1),
	    newVertexHandleSymbol: Vu("square", .4)
	}, Wu = function(t) {
	    function e(e, n) {
	        var i;
	        return (i = t.call(this, n) || this)._geometry = e, i._geometry ? i : Si$1(i);
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getMap = function() {
	        return this._geometry.getMap();
	    }, n.prepare = function() {
	        var t = this.getMap();
	        t && (t.on("drawtopstart", this._refresh, this), this.options.symbol && (this._originalSymbol = this._geometry.getSymbol(), 
	        this._geometry.setSymbol(this.options.symbol)), this._prepareEditStageLayer());
	    }, n._prepareEditStageLayer = function() {
	        var t = this._geometry.getLayer();
	        if ("canvas" === t.options.renderer) {
	            var e = this.getMap(), n = "_maptalks__internal_layer__edit_stage_" + Di$1() + "_shadow";
	            if (this._shadowLayer = e.getLayer(n), !this._shadowLayer) this._shadowLayer = new (t.constructor)(n), e.addLayer(this._shadowLayer);
	        }
	    }, n.start = function() {
	        if (this._geometry && this._geometry.getMap() && !this._geometry.editing) {
	            this.editing = !0, this.prepare();
	            var t, e = this._geometry, n = "canvas" === this._geometry.getLayer().options.renderer;
	            this._geometryDraggble = e.options.draggable, n ? (e.config("draggable", !1), (t = e.copy()).setSymbol(e._getInternalSymbol()), 
	            t.copyEventListeners(e), e._getParent() && t.copyEventListeners(e._getParent()), 
	            t._setEventTarget(e), t.setId(null).config({
	                draggable: !1
	            }), this._shadow = t, e.hide()) : e instanceof $h && e.config("draggable", !0), 
	            this._switchGeometryEvents("on"), (e instanceof $h || e instanceof fl || e instanceof ml || e instanceof dl) && this._createOrRefreshOutline(), 
	            this._shadowLayer && this._shadowLayer.bringToFront().addGeometry(t), e instanceof $h ? t && (t.config("draggable", !0), 
	            t.on("dragend", this._onMarkerDragEnd, this)) : this._createCenterHandle(), e instanceof $h && !1 !== this.options.resize ? this.createMarkerEditor() : e instanceof fl ? this.createCircleEditor() : e instanceof ml || e instanceof dl ? this.createEllipseOrRectEditor() : e instanceof gl || (e instanceof Yh || e instanceof el) && this.createPolygonEditor();
	        }
	    }, n.stop = function() {
	        delete this._history, delete this._historyPointer, delete this._editOutline, this._switchGeometryEvents("off"), 
	        this.getMap() ? (this._geometry.config("draggable", this._geometryDraggble), this._shadow && (delete this._shadow, 
	        delete this._geometryDraggble, this._geometry.show()), this._shadowLayer && (this._shadowLayer.remove(), 
	        delete this._shadowLayer), this._refreshHooks = [], this.options.symbol && (this._geometry.setSymbol(this._originalSymbol), 
	        delete this._originalSymbol), this.editing = !1, this.fire("remove")) : this.fire("remove");
	    }, n.isEditing = function() {
	        return !Dn(this.editing) && this.editing;
	    }, n._getGeometryEvents = function() {
	        return {
	            symbolchange: this._onGeoSymbolChange,
	            dragstart: this._onDragStart,
	            dragend: this._onDragEnd,
	            "positionchange shapechange": this._exeAndReset
	        };
	    }, n._switchGeometryEvents = function(t) {
	        if (this._geometry) {
	            var e = this._getGeometryEvents();
	            for (var n in e) this._geometry[t](n, e[n], this);
	        }
	    }, n._onGeoSymbolChange = function(t) {
	        this._shadow && this._shadow.setSymbol(t.target._getInternalSymbol());
	    }, n._onMarkerDragEnd = function() {
	        this._update("setCoordinates", this._shadow.getCoordinates().toArray());
	    }, n._createOrRefreshOutline = function() {
	        var t = this._geometry, e = this._editOutline;
	        e || (this._editOutline = new Gu(this, this.getMap()), this._addRefreshHook(this._createOrRefreshOutline));
	        var n = this._editOutline.points;
	        if (t instanceof $h) this._editOutline.setPoints(t.getContainerExtent().toArray(n)); else {
	            var i = this.getMap();
	            (n = t._getPrjExtent().toArray(n)).forEach((function(t) {
	                return i._prjToContainerPoint(t, null, t);
	            })), this._editOutline.setPoints(n);
	        }
	        return e;
	    }, n._createCenterHandle = function() {
	        var t, e = this, n = this.getMap(), i = this.options.centerHandleSymbol, r = n.coordToContainerPoint(this._geometry.getCenter()), o = this.createHandle(r, {
	            symbol: i,
	            cursor: "move",
	            onDown: function() {
	                if (e._shadow) {
	                    var n = ao((t = e._shadow.copy())._getInternalSymbol(), .5);
	                    t.setSymbol(n).addTo(e._geometry.getLayer());
	                }
	            },
	            onMove: function(n) {
	                var i = n.coordOffset;
	                t ? t.translate(i) : e._geometry.translate(i);
	            },
	            onUp: function() {
	                e._update("setCoordinates", us.toNumberArrays((t || e._geometry).getCoordinates())), 
	                t && t.remove();
	            }
	        });
	        this._addRefreshHook((function() {
	            var t = e._geometry.getCenter();
	            o.setContainerPoint(n.coordToContainerPoint(t));
	        }));
	    }, n._createHandleInstance = function(t, e) {
	        var n = this.getMap(), i = xr(e.symbol, (function() {
	            return [ n.getZoom(), {
	                "{bearing}": n.getBearing(),
	                "{pitch}": n.getPitch(),
	                "{zoom}": n.getZoom()
	            } ];
	        })), r = new Bu(this, n, {
	            symbol: i,
	            cursor: e.cursor,
	            events: this.options.removeVertexOn
	        });
	        return r.setContainerPoint(t), r;
	    }, n.createHandle = function(t, e) {
	        e || (e = {});
	        var n = this._createHandleInstance(t, e), i = this;
	        return n.on("dragstart", (function(t) {
	            return this._updating = !0, e.onDown && (this._geometry.fire("handledragstart"), 
	            e.onDown.call(i, t.containerPoint, t)), !1;
	        }), this), n.on("dragging", (function(t) {
	            return i._hideContext(), e.onMove && (this._geometry.fire("handledragging"), e.onMove.call(i, t)), 
	            !1;
	        }), this), n.on("dragend", (function(t) {
	            return e.onUp && (this._geometry.fire("handledragend"), e.onUp.call(i, t)), this._updating = !1, 
	            !1;
	        }), this), e.onRefresh && (n.refresh = e.onRefresh), n;
	    }, n._createResizeHandles = function(t, e, n) {
	        var i = this, r = [ "nw-resize", "n-resize", "ne-resize", "w-resize", "e-resize", "sw-resize", "s-resize", "se-resize" ], o = [ null, "y", null, "x", "x", null, "y", null ], s = this._geometry, a = s instanceof $h;
	        t || (t = []);
	        var h = this, l = [], c = {}, u = this.getMap(), f = this.options.vertexHandleSymbol, d = function() {
	            for (var d = function() {
	                if (a) {
	                    var t = s.getContainerExtent();
	                    return [ new Oi$1(t.xmin, t.ymin), new Oi$1((t.xmax + t.xmin) / 2, t.ymin), new Oi$1(t.xmax, t.ymin), new Oi$1(t.xmin, (t.ymin + t.ymax) / 2), new Oi$1(t.xmax, (t.ymin + t.ymax) / 2), new Oi$1(t.xmin, t.ymax), new Oi$1((t.xmax + t.xmin) / 2, t.ymax), new Oi$1(t.xmax, t.ymax) ];
	                }
	                var e = s._getPrjExtent();
	                return [ new Oi$1(e.xmin, e.ymax), new Oi$1((e.xmax + e.xmin) / 2, e.ymax), new Oi$1(e.xmax, e.ymax), new Oi$1(e.xmin, (e.ymax + e.ymin) / 2), new Oi$1(e.xmax, (e.ymax + e.ymin) / 2), new Oi$1(e.xmin, e.ymin), new Oi$1((e.xmax + e.xmin) / 2, e.ymin), new Oi$1(e.xmax, e.ymin) ];
	            }(), m = function(m) {
	                if (Array.isArray(t) && t.some((function(t) {
	                    return t === m;
	                }))) return "continue";
	                var g, p = d[m], _ = a ? p : u._prjToContainerPoint(p);
	                if (l.length < d.length - t.length) {
	                    var v = i.createHandle(_, {
	                        symbol: f,
	                        cursor: r[m],
	                        axis: o[m],
	                        onMove: (g = m, function(t) {
	                            h._updating = !0, e(t.containerPoint, g), s.fire("resizing");
	                        }),
	                        onUp: function() {
	                            h._updating = !1, n();
	                        }
	                    });
	                    c[m] = l.length, l.push(v);
	                } else l[c[m]].setContainerPoint(_);
	            }, g = 0; g < d.length; g++) m(g);
	        };
	        return d(), this._addRefreshHook(d), l;
	    }, n.createMarkerEditor = function() {
	        var t = this, e = this._shadow || this._geometry, n = this.getMap();
	        if (e._canEdit()) {
	            this._history || this._recordHistory(d());
	            var i = e._getInternalSymbol(), r = new Oi$1(0, 0);
	            Ln(i.markerDx) && (r.x = i.markerDx), Ln(i.markerDy) && (r.y = i.markerDy);
	            var o = null, s = "middle", a = "middle";
	            if (oh.test(i)) {
	                var h = i.markerType;
	                "pin" === h || "pie" === h || "bar" === h ? (o = [ 5, 6, 7 ], s = "bottom") : "rectangle" === h && (o = [ 0, 1, 2, 3, 5 ], 
	                s = "top", a = "left");
	            } else ($a.test(i) || sh.test(i)) && (s = "bottom", o = [ 5, 6, 7 ]);
	            var l, c = [ 2, 1, 2, 0, 0, 2, 1, 2 ];
	            if (this.options.fixAspectRatio) {
	                var u = e.getSize();
	                l = u.width / u.height;
	            }
	            var f = this._createResizeHandles(o, (function(i, h) {
	                if (o && o.indexOf(h) >= 0) {
	                    var u = n.containerPointToCoordinate(i.sub(r)), d = e.getCoordinates();
	                    u.x = d.x, e.setCoordinates(u), t._updateCoordFromShadow(!0), i = f[f.length - 1 - h].getContainerPoint();
	                }
	                var m = n.coordToContainerPoint(e.getCoordinates()).add(r), g = e._getInternalSymbol(), p = i.sub(m);
	                "bottom" === s && i.y > m.y && (p.y = 0);
	                var _ = "middle" === s ? 2 : 1, v = "left" === a ? 1 : 2, y = Math.abs(p.x) * v, x = Math.abs(p.y) * _;
	                l && (x = (y = Math.max(y, x * l)) / l);
	                var b = c[h];
	                e instanceof Cl ? ((l || 0 === b || 2 === b) && (e.setWidth(y), e !== t._geometry && t._geometry.setWidth(y)), 
	                (l || 1 === b || 2 === b) && (e.setHeight(x), e !== t._geometry && t._geometry.setHeight(x))) : ((l || 0 === b || 2 === b) && (g.markerWidth = Math.min(y, t._geometry.options.maxMarkerWidth || 1 / 0)), 
	                (l || 1 === b || 2 === b) && (g.markerHeight = Math.min(x, t._geometry.options.maxMarkerHeight || 1 / 0)), 
	                e.setSymbol(g), e !== t._geometry && t._geometry.setSymbol(g));
	            }), (function() {
	                t._update(d());
	            }));
	        } else console && console.warn("A marker can't be resized with symbol:", e.getSymbol());
	        function d() {
	            var t = [ [ "setCoordinates", e.getCoordinates().toArray() ] ];
	            return e instanceof Cl ? (t.push([ "setWidth", e.getWidth() ]), t.push([ "setHeight", e.getHeight() ])) : t.push([ "setSymbol", e.getSymbol() ]), 
	            t;
	        }
	    }, n.createCircleEditor = function() {
	        var t = this, e = this._shadow || this._geometry, n = this.getMap();
	        this._history || this._recordHistory([ [ "setCoordinates", e.getCoordinates().toArray() ], [ "setRadius", e.getRadius() ] ]), 
	        this._createResizeHandles(null, (function(i) {
	            var r = e.getCenter(), o = n.containerPointToCoord(i), s = new el([ [ r.x, r.y ], [ o.x, r.y ] ]), a = new el([ [ r.x, r.y ], [ r.x, o.y ] ]), h = Math.max(n.computeGeometryLength(s), n.computeGeometryLength(a));
	            e.setRadius(h), e !== t._geometry && t._geometry.setRadius(h);
	        }), (function() {
	            t._update("setRadius", e.getRadius());
	        }));
	    }, n.createEllipseOrRectEditor = function() {
	        var t = this, e = [ 2, 1, 2, 0, 0, 2, 1, 2 ], n = this._shadow || this._geometry;
	        this._history || this._recordHistory(a());
	        var i, r = this.getMap(), o = this._geometry instanceof ml;
	        this.options.fixAspectRatio && (i = n.getWidth() / n.getHeight());
	        var s = this._createResizeHandles(null, (function(a, h) {
	            var l, c, u, f = o ? 1 : 2, d = s[h].getContainerPoint(), m = e[h];
	            if (o) {
	                var g = s[7 - h].getContainerPoint(), p = (l = d.sub(g)).abs();
	                c = r.pixelToDistance(p.x, 0), u = r.pixelToDistance(0, p.y);
	                var _ = n.getSize(), v = n.getCoordinates(), y = n.getWidth(), x = n.getHeight(), b = r.containerPointToCoord(a), w = r.containerPointToCoord(g), C = new el([ [ w.x, w.y ], [ b.x, w.y ] ]), M = new el([ [ w.x, w.y ], [ w.x, b.y ] ]);
	                if (c = r.computeGeometryLength(C), u = r.computeGeometryLength(M), 0 === m) if (i && (p.y = p.x / i, 
	                _.height = Math.abs(p.y), u = c / i), d.y = g.y - _.height / 2, b.y = v.y, 4 === h) b.x = Math.min(b.x, v.x); else {
	                    var T = r.locate(v, y, 0);
	                    b.x = r.locate(new us(T.x, b.y), -c, 0).x;
	                } else if (1 === m) i && (p.x = p.y * i, _.width = Math.abs(p.x), c = u * i), d.x = g.x - _.width / 2, 
	                b.x = v.x, b.y = Math.max(b.y, w.y); else {
	                    if (i && (c > u * i ? (u = c / i, d.y = g.y + p.x * Bi$1(l.y) / i) : (c = u * i, d.x = g.x + p.y * Bi$1(l.x) * i)), 
	                    0 === h || 5 === h) {
	                        var S = r.locate(v, y, 0 === h ? 0 : -x);
	                        b.x = r.locate(new us(S.x, b.y), -c, 0).x;
	                    } else b.x = Math.min(b.x, w.x);
	                    b.y = Math.max(b.y, w.y);
	                }
	                n.setCoordinates(b), t._updateCoordFromShadow(!0);
	            } else {
	                var P = n.getCenter(), A = r.containerPointToCoord(d), E = new el([ [ P.x, P.y ], [ A.x, P.y ] ]), O = new el([ [ P.x, P.y ], [ P.x, A.y ] ]);
	                c = r.computeGeometryLength(E), u = r.computeGeometryLength(O), i && (u = (c = Math.max(c, u * i)) / i);
	            }
	            (i || 0 === m || 2 === m) && (n.setWidth(c * f), n !== t._geometry && t._geometry.setWidth(c * f)), 
	            (i || 1 === m || 2 === m) && (n.setHeight(u * f), n !== t._geometry && t._geometry.setHeight(u * f));
	        }), (function() {
	            t._update(a());
	        }));
	        function a() {
	            return [ [ "setCoordinates", n.getCoordinates().toArray() ], [ "setWidth", n.getWidth() ], [ "setHeight", n.getHeight() ] ];
	        }
	    }, n.createPolygonEditor = function() {
	        var t = this.getMap(), e = this._shadow || this._geometry, n = this;
	        this._history || this._recordHistory("setCoordinates", us.toNumberArrays(e.getCoordinates()));
	        var i = e instanceof Yh ? 3 : 2, r = "maptalks--editor-vertex-index", o = {
	            0: []
	        }, s = {
	            0: []
	        };
	        function a(t) {
	            if (void 0 === t && (t = 0), e instanceof Yh) {
	                var n = e.getCoordinates()[t] || [];
	                return n.slice(0, n.length - 1);
	            }
	            return e.getCoordinates();
	        }
	        function h(t) {
	            return void 0 === t && (t = 0), 0 === t ? e._getPrjCoordinates() : e._getPrjHoles()[t - 1];
	        }
	        function l() {
	            for (var t in o) {
	                for (var e = o[t].length - 1; e >= 0; e--) o[t][e][r] = e;
	                for (var i = s[t].length - 1; i >= 0; i--) s[t][i][r] = i;
	            }
	            n._updateCoordFromShadow();
	        }
	        function c(t) {
	            n._updating = !0;
	            var a = t.target, c = a[r], u = Ln(a._ringIndex) ? a._ringIndex : 0, f = h(u);
	            if (!(f.length <= i)) {
	                var d, m = e instanceof el && (0 === c || c === f.length - 1);
	                f.splice(c, 1), u > 0 ? e._prjHoles[u - 1] = f : e._setPrjCoordinates(f), e._updateCache(), 
	                o[u].splice(c, 1)[0].delete(), c < s[u].length && s[u].splice(c, 1)[0].delete(), 
	                s[u].splice(d = 0 === c ? s[u].length - 1 : c - 1, 1)[0].delete(), m || s[u].splice(d, 0, p.call(n, d, u)), 
	                l(), n._updating = !1;
	            }
	        }
	        function u(i, r, o) {
	            void 0 === o && (o = 0);
	            var a = n._geometry.snapTo;
	            a && Hn(a) && (i = n._geometry.snapTo(i) || i);
	            var l, c = h(o), u = t._containerPointToPrj(i.sub(d())), f = c[r];
	            f.x = u.x, f.y = u.y, e._updateCache(), e.onShapeChanged(), n._updateCoordFromShadow(!0), 
	            l = 0 === r ? s[o].length - 1 : r - 1, s[o][r] && s[o][r].refresh(), s[o][l] && s[o][l].refresh();
	        }
	        var f = new Oi$1(0, 0);
	        function d() {
	            var t = e._getCompiledSymbol();
	            return f.x = t.lineDx || 0, f.y = t.lineDy || 0, f;
	        }
	        function m(e, i, o) {
	            void 0 === i && (i = 0);
	            var s = (o || a(i))[e], h = n.createHandle(t.coordToContainerPoint(s)._add(d()), {
	                symbol: n.options.vertexHandleSymbol,
	                cursor: "pointer",
	                axis: null,
	                onMove: function() {
	                    u(h.getContainerPoint(), h[r], i);
	                },
	                onRefresh: function(e, n) {
	                    s = (n || a(i))[h[r]];
	                    var o = t.coordToContainerPoint(s);
	                    h.setContainerPoint(o._add(d()));
	                },
	                onUp: function() {
	                    n._updateCoordFromShadow();
	                },
	                onDown: function(t, e) {}
	            });
	            return h[r] = e, h._ringIndex = i, h.on(n.options.removeVertexOn, c), h;
	        }
	        var g = !1;
	        function p(i, c, f) {
	            void 0 === c && (c = 0);
	            var _ = f || a(c), v = _[i].add(i + 1 >= _.length ? _[0] : _[i + 1]).multi(.5), y = n.createHandle(v, {
	                symbol: n.options.newVertexHandleSymbol,
	                cursor: "pointer",
	                axis: null,
	                onDown: function(i, o) {
	                    if (!o || !o.domEvent || 2 !== o.domEvent.button) {
	                        var a = h(c), l = y[r], u = y.getContainerPoint(), f = t._containerPointToPrj(u);
	                        a.splice(l + 1, 0, f), c > 0 ? e._prjHoles[c - 1] = a : e._setPrjCoordinates(a), 
	                        e._updateCache(), y.opacity = 1, s[c].splice(l, 0, p.call(n, l, c), p.call(n, l + 1, c)), 
	                        g = !0;
	                    }
	                },
	                onMove: function() {
	                    u(y.getContainerPoint(), y[r] + 1, c);
	                },
	                onUp: function(t) {
	                    if (t && t.domEvent && 2 === t.domEvent.button) g = !1; else {
	                        var e = y[r];
	                        ji$1(y, s[c]), y.delete(), o[c].splice(e + 1, 0, m.call(n, e + 1, c)), l(), n._updateCoordFromShadow(), 
	                        g = !1;
	                    }
	                },
	                onRefresh: function(e, n) {
	                    _ = n || a(e);
	                    var i = y[r], o = _[i].add(_[i === _.length - 1 ? 0 : i + 1]).multi(.5), s = t.coordToContainerPoint(o);
	                    y.setContainerPoint(s._add(d()));
	                }
	            });
	            return y[r] = i, y;
	        }
	        if (e instanceof Yh) for (var _ = e.getHoles().length + 1, v = 0; v < _; v++) {
	            o[v] = [], s[v] = [];
	            for (var y = a(v), x = 0, b = y.length; x < b; x++) o[v].push(m.call(this, x, v, y)), 
	            x < b - 1 && s[v].push(p.call(this, x, v, y));
	            s[v].push(p.call(this, y.length - 1, v, y));
	        } else {
	            for (var w = a(0), C = 0, M = w.length; C < M; C++) o[0].push(m.call(this, C, 0, w)), 
	            C < M - 1 && s[0].push(p.call(this, C, 0, w));
	            s[0].length && 2 === e.getCoordinates().length && (s[0][0].options.symbol.markerDx = 12);
	        }
	        this._addRefreshHook((function() {
	            if (!g) {
	                for (var t in s) for (var n = a(t), i = s[t].length - 1; i >= 0; i--) s[t][i].refresh(t, n);
	                for (var r in s[0].length && e instanceof el && (2 === e.getCoordinates().length ? s[0][0].options.symbol.markerDx = 12 : e.getCoordinates().length > 2 && (s[0][0].options.symbol.markerDx = 0)), 
	                o) for (var h = a(r), l = o[r].length - 1; l >= 0; l--) o[r][l].refresh(r, h);
	            }
	        }));
	    }, n._refresh = function() {
	        if (this._refreshHooks) for (var t = this._refreshHooks.length - 1; t >= 0; t--) this._refreshHooks[t].call(this);
	    }, n._hideContext = function() {
	        this._geometry && (this._geometry.closeMenu(), this._geometry.closeInfoWindow());
	    }, n._addRefreshHook = function(t) {
	        t && (this._refreshHooks || (this._refreshHooks = []), this._refreshHooks.push(t));
	    }, n._update = function(t) {
	        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
	        this._exeHistory([ t, n ]), this._recordHistory.apply(this, [ t ].concat(n));
	    }, n._updateCoordFromShadow = function(t) {
	        var e = (this._shadow || this._geometry).getCoordinates(), n = this._geometry, i = this._updating;
	        this._updating = !0, n.setCoordinates(e), t || this._recordHistory("setCoordinates", us.toNumberArrays(n.getCoordinates())), 
	        this._updating = i;
	    }, n._recordHistory = function(t) {
	        this._history || (this._history = [], this._historyPointer = 0);
	        for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
	        if (this._history.length) {
	            var r = this._history[this._history.length - 1];
	            if (r[0] === t && JSON.stringify(r[1]) === JSON.stringify(n)) return;
	        }
	        this._historyPointer < this._history.length - 1 && this._history.splice(this._historyPointer + 1), 
	        this._history.push([ t, n ]), this._historyPointer = this._history.length - 1, this._geometry.fire("editrecord");
	    }, n.cancel = function() {
	        return this._history && 0 !== this._historyPointer ? (this._historyPointer = 0, 
	        this._exeAndReset(this._history[0]), this) : this;
	    }, n.undo = function() {
	        if (!this._history || 0 === this._historyPointer) return this;
	        var t = this._history[--this._historyPointer];
	        return this._exeAndReset(t), this;
	    }, n.redo = function() {
	        if (!this._history || this._historyPointer === this._history.length - 1) return this;
	        var t = this._history[++this._historyPointer];
	        return this._exeAndReset(t), this;
	    }, n._exeAndReset = function(t) {
	        if (!this._updating) {
	            this._exeHistory(t);
	            var e = this._history, n = this._historyPointer;
	            this.stop(), this._history = e, this._historyPointer = n, this.start();
	        }
	    }, n._onDragStart = function() {
	        this._updating = !0;
	    }, n._onDragEnd = function() {
	        this._updating = !1;
	    }, n._exeHistory = function(t) {
	        if (Array.isArray(t)) {
	            var e = this._updating;
	            this._updating = !0;
	            var n = this._shadow || this._geometry, i = this._geometry;
	            Array.isArray(t[0]) ? t[0].forEach((function(t) {
	                var e = t[0], r = t.slice(1);
	                n[e].apply(n, r), n !== i && i[e].apply(i, r);
	            })) : (n[t[0]].apply(n, t[1]), n !== i && i[t[0]].apply(i, t[1])), this._updating = e;
	        }
	    }, e;
	}(ts(ns));

	Wu.mergeOptions(Uu), wl.include({
	    startEditText: function() {
	        return this.getMap() ? (this.hide(), this.endEditText(), this._prepareEditor(), 
	        this._fireEvent("edittextstart"), this) : this;
	    },
	    endEditText: function() {
	        if (this._textEditor) {
	            var t = this._textEditor.innerHTML;
	            t = t.replace(/<p>/gi, "").replace(/<\/p>/gi, "<br/>"), this._textEditor.innerHTML = t;
	            var e = this._textEditor.innerText.replace(/[\r\n]+$/gi, "");
	            this.setContent(e), No(this._textEditor, "mousedown dblclick", Ao), this.getMap().off("mousedown", this.endEditText, this), 
	            this._editUIMarker.remove(), delete this._editUIMarker, this._textEditor.onkeyup = null, 
	            delete this._textEditor, this.show(), this._fireEvent("edittextend");
	        }
	        return this;
	    },
	    isEditingText: function() {
	        return !!this._textEditor;
	    },
	    getTextEditor: function() {
	        return this._editUIMarker;
	    },
	    _prepareEditor: function() {
	        var t = this.getMap(), e = this._createEditor();
	        this._textEditor = e, t.on("mousedown", this.endEditText, this);
	        var n = this._getEditorOffset();
	        this._editUIMarker = new Pc(this.getCoordinates(), {
	            animation: null,
	            content: e,
	            dx: n.dx,
	            dy: n.dy
	        }).addTo(t), this._setCursorToLast(this._textEditor);
	    },
	    _getEditorOffset: function() {
	        var t = this._getInternalSymbol() || {}, e = 0, n = 0, i = t.textHorizontalAlignment;
	        return "middle" === i || Dn(i) ? (e = (t.textDx || 0) - 2, n = (t.textDy || 0) - 2) : (e = (t.markerDx || 0) - 2, 
	        n = (t.markerDy || 0) - 2), {
	            dx: e,
	            dy: n
	        };
	    },
	    _createEditor: function() {
	        var t = this.getContent(), e = this.getSize(), n = this._getInternalSymbol() || {}, i = e.width, r = n.textFill || "#000000", o = n.textSize || 12, s = e.height, a = n.markerLineColor || "#000", h = n.markerFill || "#3398CC", l = n.textLineSpacing || 0, c = bo("div");
	        return c.contentEditable = !0, c.style.cssText = "background:" + h + "; border:1px solid " + a + ";\n            color:" + r + ";font-size:" + o + "px;width:" + (i - 2) + "px;height:" + (s - 2) + "px;margin: auto;\n            line-height:" + (o + l) + "px;outline: 0; padding:0; margin:0;word-wrap: break-word;\n            overflow: hidden;-webkit-user-modify: read-write-plaintext-only;", 
	        c.innerText = t, Ho(c, "mousedown dblclick", Ao), c.onkeyup = function(t) {
	            13 === t.keyCode && (c.style.height = parseInt(c.style.height || 0) + o / 2 + "px");
	        }, c;
	    },
	    _setCursorToLast: function(t) {
	        var e;
	        window.getSelection ? (t.focus(), (e = window.getSelection()).selectAllChildren(t), 
	        e.collapseToEnd()) : document.selection && ((e = document.selection.createRange()).moveToElementText(t), 
	        e.collapse(!1), e.select());
	    }
	}), Mh.include({
	    animate: function(t, e, n) {
	        var i = this;
	        this._animPlayer && this._animPlayer.finish(), Hn(e) && (n = e), e || (e = {});
	        var r, o = this.getMap(), s = this._getProjection(), a = this._prepareAnimationStyles(t), h = e.focus;
	        if (delete this._animationStarted, o) {
	            var l = o._getRenderer();
	            e.framer = function(t) {
	                l.callInNextFrame(t);
	            };
	        }
	        var c = Jh.animate(a, e, (function(t) {
	            if (o && o.isRemoved()) c.finish(); else {
	                o && !i._animationStarted && h && o.onMoveStart();
	                var e = t.styles;
	                for (var a in e) if ("symbol" !== a && "translate" !== a && e.hasOwnProperty(a)) {
	                    var l = "set" + a[0].toUpperCase() + a.slice(1);
	                    i[l](e[a]);
	                }
	                var u = e.translate;
	                if (u) {
	                    var f = u;
	                    r && (f = u.sub(r)), r = u, i.translate(f);
	                }
	                var d = e.symbol;
	                if (d) {
	                    var m = i.getSymbol() || {};
	                    i.setSymbol(ho(m, d));
	                }
	                if (o && h) {
	                    var g = s.project(i.getCenter());
	                    o._setPrjCenter(g);
	                    var p = o._parseEventFromCoord(s.unproject(g));
	                    "running" !== c.playState ? o.onMoveEnd(p) : o.onMoving(p);
	                }
	                i._fireAnimateEvent(c.playState), n && n(t);
	            }
	        }), this);
	        return this._animPlayer = c, this._animPlayer.play();
	    },
	    _prepareAnimationStyles: function(t) {
	        var e = this._getInternalSymbol(), n = {};
	        for (var i in t) if (t.hasOwnProperty(i)) {
	            var r = t[i];
	            if ("translate" !== i && "symbol" !== i) {
	                var o = this["get" + i[0].toUpperCase() + i.substring(1)]();
	                n[i] = [ o, r ];
	            } else if ("symbol" === i) {
	                var s = void 0;
	                if (Array.isArray(t.symbol)) {
	                    if (!Array.isArray(e)) throw new Error("geometry'symbol isn't a composite symbol, while the symbol in styles is.");
	                    s = [];
	                    for (var a = t.symbol, h = 0; h < a.length; h++) if (a[h]) {
	                        var l = {};
	                        for (var c in a[h]) a[h].hasOwnProperty(c) && (l[c] = [ e[h][c], a[h][c] ]);
	                        s.push(l);
	                    } else s.push(null);
	                } else {
	                    if (Array.isArray(e)) throw new Error("geometry'symbol is a composite symbol, while the symbol in styles isn't.");
	                    for (var u in s = {}, r) r.hasOwnProperty(u) && (s[u] = [ e[u], r[u] ]);
	                }
	                n.symbol = s;
	            } else "translate" === i && (n.translate = new us(r));
	        }
	        return n;
	    },
	    _fireAnimateEvent: function(t) {
	        "finished" === t ? (delete this._animationStarted, this._fireEvent("animateend")) : "running" === t && (this._animationStarted ? this._fireEvent("animating") : (this._fireEvent("animatestart"), 
	        this._animationStarted = !0));
	    }
	});

	var Zu = Mi$1.touch ? "touchstart mousedown" : "mousedown", Xu = function(t) {
	    function e(e) {
	        return t.call(this, e) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.addHooks = function() {
	        this.target.on(Zu, this._startDrag, this);
	    }, n.removeHooks = function() {
	        this._endDrag(), this.target.off(Zu, this._startDrag, this), delete this.container;
	    }, n._prepareDragHandler = function() {
	        this._dragHandler = new cs(this.container), this._dragHandler.on("dragging", this._dragging, this).on("mouseup", this._endDrag, this).enable();
	    }, n._prepareShadow = function() {
	        var t = this, e = this.target;
	        if ("canvas" === e.getLayer().options.renderer) {
	            this._prepareDragStageLayer(), this._shadow && this._shadow.remove();
	            var n = this._shadow = e.copy();
	            if (n.getGeometries) {
	                var i = n.getGeometries(), r = e.getGeometries();
	                i.forEach((function(e, n) {
	                    t._updateShadowSymbol(e, r[n]);
	                }));
	            } else this._updateShadowSymbol(n, e);
	            n.setId(null), this._prepareShadowConnectors();
	        }
	    }, n._updateShadowSymbol = function(t, e) {
	        if (t.setSymbol(e._getInternalSymbol()), e.options.dragShadow) {
	            var n = ao(t._getInternalSymbol(), .5);
	            t.setSymbol(n);
	        }
	    }, n._prepareShadowConnectors = function() {
	        var t = this.target, e = this._shadow, n = this._dragStageLayer._getRenderer().resources, i = [];
	        if (Pl._hasConnectors(t)) for (var r = Pl._getConnectors(t), o = 0, s = r.length; o < s; o++) {
	            var a = r[o], h = a.config(), l = a._getInternalSymbol();
	            h.symbol = ao(l, .5);
	            var c = void 0;
	            c = a.getConnectSource() === t ? new a.constructor(e, a.getConnectTarget(), h) : new a.constructor(a.getConnectSource(), e, h), 
	            i.push(c), a.getLayer() && a.getLayer()._getRenderer() && n.merge(a.getLayer()._getRenderer().resources);
	        }
	        this._shadowConnectors = i, i.push(e), this._dragStageLayer.bringToFront().addGeometry(i);
	    }, n._onTargetUpdated = function() {
	        this._shadow && this._shadow.setSymbol(this.target._getSymbol());
	    }, n._prepareDragStageLayer = function() {
	        var t = this.target.getMap(), e = this.target.getLayer();
	        this._dragStageLayer = t.getLayer("_maptalks__internal_layer__drag_stage"), this._dragStageLayer || (this._dragStageLayer = new Il("_maptalks__internal_layer__drag_stage", {
	            enableAltitude: e.options.enableAltitude,
	            altitudeProperty: e.options.altitudeProperty
	        }), t.addLayer(this._dragStageLayer));
	        var n = new la;
	        n.merge(e._getRenderer().resources), this._dragStageLayer._getRenderer().resources = n;
	    }, n._startDrag = function(t) {
	        var e = this.target.getMap();
	        if (e && (!this.target._getParent() && !this.isDragging())) {
	            var n = t.domEvent;
	            n.touches && n.touches.length > 1 || 2 === n.button || (this.container = e._panels.mapWrapper || e._containerDOM, 
	            this.target.on("click", this._endDrag, this), this._lastCoord = this._correctCoord(t.coordinate), 
	            this._lastPoint = t.containerPoint, this._prepareDragHandler(), this._dragHandler.onMouseDown(t.domEvent), 
	            Ho(this.container, "mouseleave", this._endDrag, this), this._startParam = t, this._moved = !1);
	        }
	    }, n._dragging = function(t) {
	        var e = this.target, n = e.getMap(), i = n._parseEvent(t.domEvent), r = i.domEvent;
	        if (!(r.touches && r.touches.length > 1)) {
	            var o = n._getVisualHeight(n.options.maxVisualPitch);
	            if (!(i.containerPoint.y < n.height - o)) {
	                if (!this._moved) return this._moved = !0, e.on("symbolchange", this._onTargetUpdated, this), 
	                this._isDragging = !0, this._prepareShadow(), this._shadow && (e.options.dragShadow || e.hide(), 
	                this._shadow._fireEvent("dragstart", i)), this.target._fireEvent("dragstart", this._startParam || i), 
	                void delete this._startParam;
	                var s = this._shadow || e, a = s.options.dragOnAxis, h = s.options.dragOnScreenAxis, l = i.containerPoint, c = i.coordinate;
	                this._lastPoint = this._lastPoint || l, this._lastCoord = this._lastCoord || c, 
	                h ? ("x" === a ? l.y = this._lastPoint.y : "y" === a && (l.x = this._lastPoint.x), 
	                c = n.containerPointToCoord(l)) : c = this._correctCoord(c);
	                var u = l.sub(this._lastPoint), f = c.sub(this._lastCoord);
	                h || ("x" === a ? u.y = f.y = 0 : "y" === a && (u.x = f.x = 0)), this._lastPoint = l, 
	                this._lastCoord = c, s.translate(f), s === e || e.options.dragShadow || e.translate(f), 
	                i.coordOffset = f, i.pointOffset = u, s._fireEvent("dragging", i), s !== e && e._fireEvent("dragging", i);
	            }
	        }
	    }, n._endDrag = function(t) {
	        if (this._dragHandler && (this._dragHandler.disable(), delete this._dragHandler), 
	        this.container && No(this.container, "mouseleave", this._endDrag), this.target) {
	            var e = this.target;
	            e.off("click", this._endDrag, this), e.off("symbolchange", this._onTargetUpdated, this), 
	            delete this._lastCoord, delete this._lastPoint, this._isDragging = !1;
	            var n = e.getMap();
	            if (this.enabled() && n) {
	                var i = n._parseEvent(t ? t.domEvent : null);
	                this._updateTargetAndRemoveShadow(i), this._moved && e._fireEvent("dragend", i);
	            }
	        }
	    }, n.isDragging = function() {
	        return !!this._isDragging;
	    }, n._updateTargetAndRemoveShadow = function(t) {
	        if (this._shadow) {
	            var e = this.target, n = e.getMap();
	            e.options.dragShadow || e.show();
	            var i = this._shadow;
	            if (i) {
	                if (e.options.dragShadow) if (e.getGeometries) {
	                    var r = i.getGeometries(), o = e.getGeometries();
	                    r.forEach((function(t, e) {
	                        o[e].setCoordinates(r[e].getCoordinates());
	                    }));
	                } else e.setCoordinates(i.getCoordinates());
	                i._fireEvent("dragend", t), i.remove(), delete this._shadow;
	            }
	            this._shadowConnectors && (n.getLayer("_maptalks__internal_layer__drag_stage").removeGeometry(this._shadowConnectors), 
	            delete this._shadowConnectors), this._dragStageLayer && (this._dragStageLayer._getRenderer().resources = new la, 
	            this._dragStageLayer.remove());
	        }
	    }, n._correctCoord = function(t) {
	        var e = this.target.getMap();
	        if (!e.getPitch()) return t;
	        var n = this.target;
	        if (!n.getMinAltitude()) return t;
	        var i = (n.getMinAltitude() + n.getMaxAltitude()) / 2;
	        return e.locateByPoint(t, 0, -i);
	    }, e;
	}(es);

	Mh.mergeOptions({
	    draggable: !1,
	    dragShadow: !0,
	    dragOnAxis: null,
	    dragOnScreenAxis: !1
	}), Mh.addInitHook("addHandler", "draggable", Xu), Mh.include({
	    isDragging: function() {
	        return this._getParent() ? this._getParent().isDragging() : !!this.draggable && this.draggable.isDragging();
	    }
	}), Mh.include({
	    startEdit: function(t) {
	        return this.getMap() && this.options.editable ? (this.endEdit(), this._editor = new Wu(this, t), 
	        this._editor.start(), this._getParent() || this.fire("editstart"), this) : this;
	    },
	    endEdit: function() {
	        return this._editor && (this._editor.stop(), delete this._editor, this._getParent() || this.fire("editend")), 
	        this;
	    },
	    redoEdit: function() {
	        return this.isEditing() ? (this._editor.redo(), this._getParent() || this.fire("redoedit"), 
	        this) : this;
	    },
	    undoEdit: function() {
	        return this.isEditing() ? (this._editor.undo(), this._getParent() || this.fire("undoedit"), 
	        this) : this;
	    },
	    cancelEdit: function() {
	        return this.isEditing() ? (this._editor.cancel(), this._getParent() || this.fire("canceledit"), 
	        this) : this;
	    },
	    isEditing: function() {
	        return !!this._editor && this._editor.isEditing();
	    }
	}), Mh.include({
	    _onEvent: function(t, e) {
	        var n = this.getMap();
	        if (n) {
	            var i = e || this._getEventTypeToFire(t);
	            "contextmenu" === i && this.listens("contextmenu") && (Ao(t), Po(t));
	            var r = n._getEventParams(t);
	            Ln(this._pickGeometryIndex) && (r.pickGeometryIndex = this._pickGeometryIndex), 
	            this._fireEvent(i, r);
	        }
	    },
	    _getEventTypeToFire: function(t) {
	        return t.type;
	    }
	}), Mh.include({
	    setInfoWindow: function(t) {
	        return this.removeInfoWindow(), t instanceof kc ? (this._infoWindow = t, this._infoWinOptions = kn({}, this._infoWindow.options), 
	        this._infoWindow.addTo(this), this) : (this._infoWinOptions = kn({}, t), this._infoWindow ? this._infoWindow.setOptions(t) : this.getMap() && this._bindInfoWindow(), 
	        this);
	    },
	    getInfoWindow: function() {
	        return this._infoWindow ? this._infoWindow : null;
	    },
	    openInfoWindow: function(t) {
	        return this.getMap() ? (t || (t = this.getCenter()), this._infoWindow ? this._infoWindow.show(t) : this._infoWinOptions && this.getMap() && (this._bindInfoWindow(), 
	        this._infoWindow.show(t)), this) : this;
	    },
	    closeInfoWindow: function() {
	        return this._infoWindow && this._infoWindow.hide(), this;
	    },
	    removeInfoWindow: function() {
	        return this._unbindInfoWindow(), delete this._infoWinOptions, delete this._infoWindow, 
	        this;
	    },
	    _bindInfoWindow: function() {
	        var t = this._infoWinOptions;
	        return t ? (this._infoWindow = new kc(t), this._infoWindow.addTo(this), this) : this;
	    },
	    _unbindInfoWindow: function() {
	        return this._infoWindow && (this.closeInfoWindow(), this._infoWindow.remove(), delete this._infoWindow), 
	        this;
	    }
	});

	var Ju = new Oi$1(0, 0), qu = new Oi$1(0, 0), Yu = new Oi$1(0, 0), Ku = new Oi$1(0, 0), Qu = [], $u = function(t) {
	    function e() {
	        return t.call(this, "core-fetch-image") || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.checkUrl = function(t) {
	        return t && jn(t) ? lr(t) : t;
	    }, n.fetchImage = function(t, e, n, i) {
	        t = this.checkUrl(t), this.send({
	            url: t,
	            fetchOptions: i
	        }, Qu, n, e);
	    }, e;
	}(oa), tf = new Image, ef = function(t) {
	    function e(e) {
	        var n;
	        return (n = t.call(this, e) || this).tilesInView = {}, n.tilesLoading = {}, n._parentTiles = [], 
	        n._childTiles = [], n._tileQueue = [], n.tileCache = new Uo(e.options.maxCacheSize, n.deleteTile.bind(Si$1(Si$1(n)))), 
	        !Mi$1.decodeImageInWorker || !n.layer.options.decodeImageInWorker || "gl" !== e.options.renderer && Mi$1.safari || (n._tileImageWorkerConn = new $u), 
	        n._compareTiles = rf.bind(Si$1(Si$1(n))), n;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getCurrentTileZoom = function() {
	        return this._tileZoom;
	    }, n.draw = function(t, e) {
	        var n = this.getMap();
	        if (this.isDrawable()) {
	            var i = this.prepareCanvas();
	            if (!i || i.intersects(this.canvasExtent2D)) {
	                var r;
	                this._renderTimestamp !== t && (this._consumeTileQueue(), this._renderTimestamp = t);
	                var o = !1, s = this._frameTiles;
	                if (s && t === s.timestamp) {
	                    if (s.empty) return;
	                    r = s;
	                } else {
	                    if (!(r = this._getTilesInCurrentFrame())) return this._frameTiles = {
	                        empty: !0,
	                        timestamp: t
	                    }, void this.completeRender();
	                    o = !0, this._frameTiles = r, this._frameTiles.timestamp = t, r.loadingCount && this.loadTileQueue(r.tileQueue);
	                }
	                var a = r.loading, h = r.loadingCount;
	                this._drawTiles(r.tiles, r.parentTiles, r.childTiles, r.placeholders, e), h || a || (n.isAnimating() || !this._parentTiles.length && !this._childTiles.length || (this._parentTiles = [], 
	                this._childTiles = [], this.setToRedraw()), this.completeRender()), o && this._retireTiles();
	            } else this.completeRender();
	        }
	    }, n.getTileGridsInCurrentFrame = function() {
	        return this._frameTileGrids;
	    }, n._getTilesInCurrentFrame = function() {
	        var t = this.getMap(), e = this.layer.getTiles();
	        if (this._frameTileGrids = e, !(e = e.tileGrids) || !e.length) return null;
	        var n = e.reduce((function(t, e) {
	            return t + (e && e.tiles && e.tiles.length || 0);
	        }), 0);
	        n >= this.tileCache.max / 2 && this.tileCache.setMaxSize(2 * n + 1);
	        var i = 0, r = !1, o = {}, s = [], a = [], h = {}, l = [], c = {}, u = [], f = {}, d = {}, m = this._markTiles(), g = this._getLoadLimit(), p = e.length;
	        this._tileZoom = e[0].zoom;
	        for (var _ = 0; _ < p; _++) {
	            var v = e[_].tiles, y = void 0;
	            v.length && (y = this._generatePlaceHolder(v[0].res));
	            for (var x = 0, b = v.length; x < b; x++) {
	                var w = v[x], C = w.id, M = !1;
	                if (this._isLoadingTile(C)) M = r = !0, this.tilesLoading[C].current = !0; else {
	                    var T = this._getCachedTile(C);
	                    if (T) T.image && this.getTileOpacity(T.image) < 1 && (M = r = !0, this.setToRedraw()), 
	                    s.push(T); else if (M = r = !0, !(g && i + m[0] > g) && (!t.isInteracting() || t.isMoving() || t.isRotating())) i++, 
	                    d[C] = w;
	                }
	                if (M && !o[C]) {
	                    o[C] = 1, y && !f[C] && (w.cache = !1, u.push({
	                        image: y,
	                        info: w
	                    }), f[C] = 1);
	                    var S = this._findParentTile(w);
	                    if (S) {
	                        var P = S.info.id;
	                        void 0 === h[P] && (h[P] = a.length, a.push(S));
	                    } else if (!a.length) {
	                        var A = this._findChildTiles(w);
	                        A.length && A.forEach((function(t) {
	                            c[t.info.id] || (l.push(t), c[t.info.id] = 1);
	                        }));
	                    }
	                }
	            }
	        }
	        return a.length && (l.length = 0, this._childTiles.length = 0), {
	            childTiles: l,
	            parentTiles: a,
	            tiles: s,
	            placeholders: u,
	            loading: r,
	            loadingCount: i,
	            tileQueue: d
	        };
	    }, n.isTileCachedOrLoading = function(t) {
	        return this.tileCache.get(t) || this.tilesInView[t] || this.tilesLoading[t];
	    }, n._drawTiles = function(t, e, n, i, r) {
	        var o = this;
	        e.length && (e.sort((function(t, e) {
	            return Math.abs(e.info.z - o._tileZoom) - Math.abs(t.info.z - o._tileZoom);
	        })), this._parentTiles = e), n.length && (this._childTiles = n);
	        var s = {
	            tiles: t,
	            parentTiles: this._parentTiles,
	            childTiles: this._childTiles,
	            parentContext: r
	        };
	        this.onDrawTileStart(s, r), 1 === this.layer.options.opacity && (this._childTiles.forEach((function(t) {
	            return o._drawTile(t.info, t.image, r);
	        })), this._parentTiles.forEach((function(t) {
	            return o._drawTile(t.info, t.image, r);
	        }))), t.sort(this._compareTiles);
	        for (var a = 0, h = t.length; a < h; a++) this._drawTileAndCache(t[a], r);
	        this.layer.options.opacity < 1 && (this._childTiles.forEach((function(t) {
	            return o._drawTile(t.info, t.image, r);
	        })), this._parentTiles.forEach((function(t) {
	            return o._drawTile(t.info, t.image, r);
	        }))), i.forEach((function(t) {
	            return o._drawTile(t.info, t.image, r);
	        })), this.onDrawTileEnd(s, r);
	    }, n.onDrawTileStart = function() {}, n.onDrawTileEnd = function() {}, n._drawTile = function(t, e, n) {
	        e && this.drawTile(t, e, n);
	    }, n._drawTileAndCache = function(t, e) {
	        t.current = !0, this.tilesInView[t.info.id] = t, this._drawTile(t.info, t.image, e), 
	        this.tileCache.add(t.info.id, t);
	    }, n.drawOnInteracting = function(t, e, n) {
	        this.draw(e, n);
	    }, n.needToRedraw = function() {
	        var e = this.getMap();
	        return !!this._tileQueue.length || (e.getPitch() ? t.prototype.needToRedraw.call(this) : !(!e.isRotating() && !e.isZooming()) || (e.isMoving() ? !!this.layer.options.forceRenderOnMoving : t.prototype.needToRedraw.call(this)));
	    }, n.hitDetect = function() {
	        return !1;
	    }, n._getLoadLimit = function() {
	        return this.getMap().isInteracting() ? this.layer.options.loadingLimitOnInteracting : 0;
	    }, n.isDrawable = function() {
	        return !this.getMap().getPitch() || (console && console.warn("TileLayer with canvas renderer can't be pitched, use gl renderer ('renderer' : 'gl') instead."), 
	        this.clear(), !1);
	    }, n.clear = function() {
	        this._retireTiles(!0), this.tileCache.reset(), this.tilesInView = {}, this.tilesLoading = {}, 
	        this._parentTiles = [], this._childTiles = [], t.prototype.clear.call(this);
	    }, n._isLoadingTile = function(t) {
	        return !!this.tilesLoading[t];
	    }, n.clipCanvas = function(e) {
	        return t.prototype.clipCanvas.call(this, e);
	    }, n._clipByPitch = function(t) {
	        var e = this.getMap();
	        if (e.getPitch() <= e.options.maxVisualPitch) return !1;
	        if (!this.layer.options.clipByPitch) return !1;
	        var n = e.getContainerExtent(), i = e.getDevicePixelRatio();
	        return t.save(), t.strokeStyle = "rgba(0, 0, 0, 0)", t.beginPath(), t.rect(0, Math.ceil(n.ymin) * i, Math.ceil(n.getWidth()) * i, Math.ceil(n.getHeight()) * i), 
	        t.stroke(), t.clip(), !0;
	    }, n.loadTileQueue = function(t) {
	        for (var e in t) if (t.hasOwnProperty(e)) {
	            var n = t[e], i = this.loadTile(n);
	            void 0 === i.loadTime && (this.tilesLoading[n.id] = {
	                image: i,
	                current: !0,
	                info: n
	            });
	        }
	    }, n.loadTile = function(t) {
	        var e;
	        if (this._tileImageWorkerConn && this.loadTileImage === this.constructor.prototype.loadTileImage) this._fetchImage(e = {}, t); else {
	            var n = this.layer.getTileSize(t.layer);
	            (e = new Image).width = n.width, e.height = n.height, e.onload = this.onTileLoad.bind(this, e, t), 
	            e.onerror = this.onTileError.bind(this, e, t), this.loadTileImage(e, t.url);
	        }
	        return e;
	    }, n._fetchImage = function(t, e) {
	        var n = this;
	        if (t instanceof Image) t.src = e.url; else {
	            var i = Math.abs(e.x + e.y) % this._tileImageWorkerConn.workers.length;
	            this._tileImageWorkerConn.fetchImage(e.url, i, (function(i, r) {
	                i ? n.onTileError(t, e, i) : hr(r, (function(t) {
	                    n.onTileLoad(t, e);
	                }));
	            }), this.layer.options.fetchOptions || {
	                referrer: document.location.href,
	                headers: {
	                    accept: "image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8"
	                }
	            });
	        }
	    }, n.loadTileImage = function(t, e) {
	        var n = this.layer.options.crossOrigin;
	        return Dn(n) || (t.crossOrigin = n), Ii$1(t, [ e ]);
	    }, n.abortTileLoading = function(t) {
	        t && (t.onload = nf, t.onerror = nf, t.src = nr);
	    }, n.onTileLoad = function(t, e) {
	        this._tileQueue.push({
	            tileInfo: e,
	            tileData: t
	        });
	    }, n._consumeTileQueue = function() {
	        for (var t = 0, e = this.layer.options.tileLimitPerFrame, n = this._tileQueue; n.length && (e <= 0 || t < e); ) {
	            var i = n.shift(), r = i.tileData, o = i.tileInfo;
	            this.checkTileInQueue(r, o) && (this.consumeTile(r, o), t++);
	        }
	    }, n.checkTileInQueue = function() {
	        return !0;
	    }, n.consumeTile = function(t, e) {
	        if (this.layer) {
	            var n = e.id;
	            if (this.tilesInView) {
	                var i = {
	                    tile: e,
	                    tileImage: t
	                };
	                this.layer.fire("tileload", i), (t = i.tileImage).loadTime = In(), delete this.tilesLoading[n], 
	                this._addTileToCache(e, t), this.setToRedraw();
	            }
	        }
	    }, n.onTileError = function(t, e) {
	        if (this.layer) {
	            if (t.onerrorTick = t.onerrorTick || 0, this.layer.options.tileRetryCount > t.onerrorTick) return t.onerrorTick++, 
	            void this._fetchImage(t, e);
	            var n = this.layer.options.errorUrl;
	            if (n) {
	                if (t instanceof Image && t.src !== n) return void (t.src = n);
	                (t = new Image).src = n;
	            }
	            t = t instanceof Image ? t : tf, this.abortTileLoading(t, e), t.loadTime = 0, delete this.tilesLoading[e.id], 
	            this._addTileToCache(e, t), this.setToRedraw(), this.layer.fire("tileerror", {
	                tile: e
	            });
	        }
	    }, n.drawTile = function(t, e) {
	        if (e && this.getMap()) {
	            var n = t.extent2d, i = t.offset, r = Ju.set(n.xmin - i[0], n.ymax - i[1]), o = t.z, s = t.id, a = this.getMap(), h = a.getZoom(), l = this.context, c = a._pointAtResToContainerPoint(r, t.res, 0, qu), u = a.getBearing(), f = u || h !== o, d = this.getTileOpacity(e), m = l.globalAlpha;
	            d < 1 && (l.globalAlpha = d, this.setToRedraw()), f || c._round();
	            var g = c.x, p = c.y, _ = t.extent2d.xmax - t.extent2d.xmin, v = t.extent2d.ymax - t.extent2d.ymin;
	            if (f) {
	                l.save(), l.translate(g, p), u && (l.rotate(-u * Math.PI / 180), _ += .1, v += .1);
	                var y = a._getResolution();
	                if (y !== t.res) {
	                    var x = t.res / y;
	                    l.scale(x, x);
	                }
	                g = p = 0;
	            }
	            if (qo.image(l, e, g, p, _, v), this.layer.options.debug) {
	                var b = this.layer.options.debugOutline;
	                l.save(), l.strokeStyle = b, l.fillStyle = b, l.strokeWidth = 10, l.font = "20px monospace";
	                var w = new Oi$1(g, p);
	                qo.rectangle(l, w, {
	                    width: _,
	                    height: v
	                }, 1, 0), qo.fillText(l, this.getDebugInfo(s), w._add(32, v - 14), b), qo.drawCross(l, g + _ / 2, p + v / 2, 2, b), 
	                l.restore();
	            }
	            f && l.restore(), l.globalAlpha !== m && (l.globalAlpha = m), this.setCanvasUpdated();
	        }
	    }, n.getDebugInfo = function(t) {
	        var e = t.split("_"), n = e.length;
	        return "x:" + e[n - 2] + ", y:" + e[n - 3] + ", z:" + e[n - 1];
	    }, n._findChildTiles = function(t) {
	        var e = this._getLayerOfTile(t.layer);
	        if (!e || !e.options.background) return [];
	        for (var n = this.getMap(), i = [], r = t.res, o = t.extent2d.getMin(), s = t.extent2d.getMax(), a = e._project(n._pointToPrjAtRes(o, r, Yu), Yu), h = e._project(n._pointToPrjAtRes(s, r, Ku), Ku), l = 1; l < 3; l++) this._findChildTilesAt(i, a, h, e, t.z + l);
	        return i;
	    }, n._findChildTilesAt = function(t, e, n, i, r) {
	        var o = i.options.zoomOffset, s = i.getId(), a = i.getSpatialReference().getResolution(r + o);
	        if (a) for (var h, l, c = i._getTileConfig().getTileIndex(e, a), u = i._getTileConfig().getTileIndex(n, a), f = Math.min(c.idx, u.idx), d = Math.max(c.idx, u.idx), m = Math.min(c.idy, u.idy), g = Math.max(c.idy, u.idy), p = f; p < d; p++) for (var _ = m; _ < g; _++) h = i._getTileId(p, _, r + o, s), 
	        this.tileCache.has(h) && (l = this.tileCache.getAndRemove(h), t.push(l), this.tileCache.add(h, l));
	    }, n._findParentTile = function(t) {
	        var e = this.getMap(), n = this._getLayerOfTile(t.layer);
	        if (!n || !n.options.background) return null;
	        for (var i = n.getSpatialReference(), r = i.getZoomDirection(), o = n.options.zoomOffset, s = n.options.backgroundZoomDiff, a = t.res, h = t.extent2d.getCenter(), l = n._project(e._pointToPrjAtRes(h, a)), c = 1; c <= s; c++) {
	            var u = t.z - r * c, f = i.getResolution(u + o);
	            if (f) {
	                var d = n._getTileConfig().getTileIndex(l, f), m = n._getTileId(d.x, d.y, u + o, t.layer);
	                if (this.tileCache.has(m)) {
	                    var g = this.tileCache.getAndRemove(m);
	                    return this.tileCache.add(m, g), g;
	                }
	            }
	        }
	        return null;
	    }, n._getLayerOfTile = function(t) {
	        return this.layer.getChildLayer ? this.layer.getChildLayer(t) : this.layer;
	    }, n._getCachedTile = function(t) {
	        var e = this.tilesInView, n = this.tileCache.getAndRemove(t);
	        if (n) {
	            e[t] = n;
	            var i = this.tilesLoading;
	            if (i && i[t]) {
	                i[t].current = !1;
	                var r = i[t];
	                this.abortTileLoading(r.image, r.info), delete i[t];
	            }
	        } else n = e[t];
	        return n;
	    }, n._addTileToCache = function(t, e) {
	        this.tilesInView[t.id] = {
	            image: e,
	            current: !0,
	            info: t
	        };
	    }, n.getTileOpacity = function(t) {
	        return this.layer.options.fadeAnimation && t.loadTime ? Math.min(1, (In() - t.loadTime) / (1e3 / 60 * 10)) : 1;
	    }, n.onRemove = function() {
	        this.clear(), delete this.tileCache, delete this._tilePlaceHolder, t.prototype.onRemove.call(this);
	    }, n._markTiles = function() {
	        var t = 0, e = 0;
	        if (this.tilesLoading) for (var n in this.tilesLoading) this.tilesLoading[n].current = !1, 
	        t++;
	        if (this.tilesInView) for (var i in this.tilesInView) this.tilesInView[i].current = !1, 
	        e++;
	        return [ t, e ];
	    }, n._retireTiles = function(t) {
	        for (var e in this.tilesLoading) {
	            var n = this.tilesLoading[e];
	            !t && n.current || (n.image && this.abortTileLoading(n.image, n.info), this.deleteTile(n), 
	            delete this.tilesLoading[e]);
	        }
	        for (var i in this.tilesInView) {
	            var r = this.tilesInView[i];
	            r.current || (delete this.tilesInView[i], this.tileCache.has(i) || this.deleteTile(r));
	        }
	    }, n.deleteTile = function(t) {
	        t && t.image && (t.image.close && t.image.close(), t.image.onload = null, t.image.onerror = null);
	    }, n._generatePlaceHolder = function(t) {
	        var e = this.getMap(), n = this.layer.options.placeholder;
	        if (!n || e.getPitch()) return null;
	        var i = this.layer.getTileSize(), r = t / e._getResolution(), o = this._tilePlaceHolder = this._tilePlaceHolder || qo.createCanvas(1, 1, e.CanvasClass);
	        return o.width = i.width * r, o.height = i.height * r, Hn(n) ? n(o) : function(t) {
	            var e = t.getContext("2d"), n = t.width, i = t.height, r = n / 16, o = i / 16;
	            e.beginPath();
	            for (var s = 0; s < 16; s++) e.moveTo(0, s * o), e.lineTo(n, s * o), e.moveTo(s * r, 0), 
	            e.lineTo(s * r, i);
	            e.strokeStyle = "rgba(180, 180, 180, 0.1)", e.lineWidth = 1, e.stroke(), e.beginPath();
	            for (var a = [ [ 0, 0 ], [ n, 0 ], [ 0, i ], [ n, i ], [ 0, 0 ], [ 0, i ], [ n, 0 ], [ n, i ], [ 0, i / 2 ], [ n, i / 2 ], [ n / 2, 0 ], [ n / 2, i ] ], h = 1; h < a.length; h += 2) e.moveTo(a[h - 1][0], a[h - 1][1]), 
	            e.lineTo(a[h][0], a[h][1]);
	            e.lineWidth = 4, e.stroke();
	        }(o), o;
	    }, e;
	}(ha);

	function nf() {
	    return !1;
	}

	function rf(t, e) {
	    return Math.abs(this._tileZoom - t.info.z) - Math.abs(this._tileZoom - e.info.z);
	}

	hu.registerRenderer("canvas", ef);

	var of = new Oi$1(0, 0), sf = {
	    properties: {}
	}, af = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.isDrawable = function() {
	        return !0;
	    }, n.needToRedraw = function() {
	        var e = this.getMap();
	        return !(!this._gl() || e.getPitch() || !e.isZooming() || e.isMoving() || e.isRotating()) || t.prototype.needToRedraw.call(this);
	    }, n.onDrawTileStart = function(t, e) {
	        var n = this.gl;
	        if (n.stencilOp(n.KEEP, n.KEEP, n.REPLACE), e && e.renderTarget) {
	            var i = e.renderTarget.fbo;
	            if (i) {
	                var r = e.renderTarget.getFramebuffer(i);
	                n.bindFramebuffer(n.FRAMEBUFFER, r);
	            }
	        }
	    }, n.onDrawTileEnd = function(t, e) {
	        var n = this.gl;
	        e && e.renderTarget && (e.renderTarget.fbo && n.bindFramebuffer(n.FRAMEBUFFER, null));
	    }, n.drawTile = function(e, n, i) {
	        if (!i || !i.sceneFilter || i.sceneFilter(sf)) {
	            var r = this.getMap();
	            if (e && r && n) {
	                var o = e._glScale = e._glScale || e.res / r.getGLRes(), s = e.extent2d.xmax - e.extent2d.xmin, a = e.extent2d.ymax - e.extent2d.ymin;
	                if (!1 !== e.cache && this._bindGLBuffer(n, s, a), this._gl()) {
	                    var h = e.offset, l = of.set(e.extent2d.xmin - h[0], e.extent2d.ymax - h[1]), c = l.x * o, u = l.y * o, f = this.getTileOpacity(n), d = null;
	                    this.layer.options.debug && (d = this.getDebugInfo(e.id));
	                    var m = this.gl;
	                    m.stencilFunc(m.LEQUAL, Math.abs(this.getCurrentTileZoom() - e.z), 255), this.drawGLImage(n, c, u, s, a, o, f, d), 
	                    f < 1 ? this.setToRedraw() : this.setCanvasUpdated();
	                } else t.prototype.drawTile.call(this, e, n);
	            }
	        }
	    }, n._bindGLBuffer = function(t, e, n) {
	        t.glBuffer || (t.glBuffer = this.bufferTileData(0, 0, e, n));
	    }, n.loadTileImage = function(t, e) {
	        var n = this.layer.options.crossOrigin;
	        t.crossOrigin = null !== n ? n : "", t.src = e;
	    }, n.onCanvasCreate = function() {
	        this.canvas.gl && this.canvas.gl.wrap || this.createCanvas2();
	    }, n.createContext = function() {
	        t.prototype.createContext.call(this), this.createGLContext();
	    }, n.resizeCanvas = function(e) {
	        this.canvas && (t.prototype.resizeCanvas.call(this, e), this.resizeGLCanvas());
	    }, n.clearCanvas = function() {
	        this.canvas && (t.prototype.clearCanvas.call(this), this.clearGLCanvas());
	    }, n.getCanvasImage = function() {
	        if (!this._gl() || !this.canvas2) return t.prototype.getCanvasImage.call(this);
	        var e = t.prototype.getCanvasImage.call(this);
	        return e && (e.image = this.canvas2), e;
	    }, n._gl = function() {
	        if (this.canvas.gl && this.canvas.gl.wrap) return !0;
	        var t = this.getMap();
	        return t && (t.getPitch() || t.getBearing()) || this.layer && !!this.layer.options.fragmentShader;
	    }, n.deleteTile = function(e) {
	        t.prototype.deleteTile.call(this, e), e && e.image && this.disposeImage(e.image), 
	        delete e.image;
	    }, n.onRemove = function() {
	        t.prototype.onRemove.call(this), this.removeGLCanvas();
	    }, e;
	}(Su(ef));

	function hf(t) {
	    var e = this.layer.getTileSize(), n = this.canvas.constructor, i = this.getMap(), r = i.getDevicePixelRatio(), o = qo.createCanvas(e.width * r, e.height * r, n);
	    o.layer = this.layer;
	    var s = this, a = new Oi$1(t.extent2d.xmin, t.extent2d.ymax), h = new Ts(i.pointToCoordinate(a), i.pointToCoordinate(a.add(e.width, e.height)), i.getProjection());
	    return this.layer.drawTile(o, {
	        url: t.url,
	        point: a,
	        center: i.pointToCoordinate(a.add(e.width / 2, e.height / 2)),
	        extent: h,
	        z: t.z,
	        x: t.x,
	        y: t.y
	    }, (function(e) {
	        e ? s.onTileError(o, t) : s.onTileLoad(o, t);
	    })), o;
	}

	hu.registerRenderer("gl", af);

	var lf = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    return Ti$1(e, t), e.prototype.loadTile = function() {
	        return hf.apply(this, arguments);
	    }, e;
	}(ef), cf = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    return Ti$1(e, t), e.prototype.loadTile = function() {
	        return hf.apply(this, arguments);
	    }, e;
	}(af);

	pu.registerRenderer("canvas", lf), pu.registerRenderer("gl", cf);

	var df = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.checkResources = function() {
	        var t = this._geosToCheck;
	        if (this._resourceChecked || t || (t = this.layer._geoList), !Zi$1(t)) return [];
	        for (var e = [], n = {}, i = t.length - 1; i >= 0; i--) {
	            var r = t[i]._getExternalResources();
	            if (r.length) if (this.resources) for (var o = 0; o < r.length; o++) {
	                var s = r[o][0];
	                this.resources.isResourceLoaded(r[o]) || n[s] || (e.push(r[o]), n[s] = 1);
	            } else e.push.apply(e, r);
	        }
	        return this._resourceChecked = !0, delete this._geosToCheck, e;
	    }, n.render = function() {
	        return this.layer._sortGeometries(), t.prototype.render.apply(this, arguments);
	    }, n._addGeoToCheckRes = function(t) {
	        t && (Array.isArray(t) || (t = [ t ]), this._geosToCheck || (this._geosToCheck = []), 
	        Fi$1(this._geosToCheck, t));
	    }, n.onGeometryAdd = function(t) {
	        this._addGeoToCheckRes(t), mf(this);
	    }, n.onGeometryRemove = function() {
	        mf(this);
	    }, n.onGeometrySymbolChange = function(t) {
	        this._addGeoToCheckRes(t.target), mf(this);
	    }, n.onGeometryShapeChange = function() {
	        mf(this);
	    }, n.onGeometryPositionChange = function() {
	        mf(this);
	    }, n.onGeometryZIndexChange = function() {
	        mf(this);
	    }, n.onGeometryShow = function() {
	        mf(this);
	    }, n.onGeometryHide = function() {
	        mf(this);
	    }, n.onGeometryPropertiesChange = function() {
	        mf(this);
	    }, e;
	}(ha);

	function mf(t) {
	    t.layer.options.drawImmediate && t.render(), t.setToRedraw();
	}

	var gf = new Ps, pf = [], _f = new Ps, vf = function(t) {
	    function e() {
	        return t.apply(this, arguments) || this;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.getImageData = function() {
	        if (!this.layer.options.geometryEvents || !this._lastRenderTime || In() - this._lastRenderTime < 32) return null;
	        if (!this.context || !this.context.canvas) return null;
	        if (!this._imageData) {
	            var t = this.context.canvas, e = t.width, n = t.height;
	            try {
	                this._imageData = this.context.getImageData(0, 0, e, n);
	            } catch (t) {
	                console.warn("hit detect failed with tainted canvas, some geometries have external resources in another domain:\n", t);
	            }
	        }
	        return this._imageData;
	    }, n.clearImageData = function() {
	        this._imageData = null, delete this._imageData, this._lastRenderTime = In();
	    }, n.checkResources = function() {
	        var e = this, n = t.prototype.checkResources.apply(this, arguments), i = this.layer.getStyle();
	        return i && (Array.isArray(i) || (i = [ i ]), i.forEach((function(t) {
	            for (var i = Hr(t.symbol, !0), r = 0, o = i.length; r < o; r++) e.resources.isResourceLoaded(i[r]) || n.push(i[r]);
	        }))), n;
	    }, n.needToRedraw = function() {
	        var e = this.getMap();
	        return !(!e.isInteracting() || !this.layer.options.enableAltitude) || !(e.isZooming() && !e.isRotating() && !e.getPitch() && !this._hasPoint && this.layer.constructor === Il) && t.prototype.needToRedraw.call(this);
	    }, n.draw = function() {
	        if (this.getMap()) {
	            if (!this.layer.isVisible() || this.layer.isEmpty()) return this.clearCanvas(), 
	            void this.completeRender();
	            this.prepareCanvas(), this.drawGeos(), this.completeRender();
	        }
	    }, n.isBlank = function() {
	        return !!this.context && !this.context.canvas._drawn;
	    }, n.drawOnInteracting = function() {
	        if (this._geosToDraw) {
	            this._updateMapStateCache(), this._updateDisplayExtent();
	            var t = this.getMap(), e = this.layer.getCount(), n = this.mapStateCache.resolution;
	            (t.isZooming() && t.options.seamlessZoom && void 0 !== this._drawnRes && n > 1.5 * this._drawnRes && this._geosToDraw.length < e || t.isMoving() || t.isInteracting()) && (this.prepareToDraw(), 
	            this._batchConversionMarkers(this.mapStateCache.glRes), this._onlyHasPoint || this.forEachGeo(this.checkGeo, this), 
	            this._drawnRes = n), this._sortByDistanceToCamera(t.cameraPosition);
	            for (var i = 0, r = this._geosToDraw.length; i < r; i++) {
	                var o = this._geosToDraw[i];
	                o._isCheck || o.isVisible() ? (o._paint(this._displayExtent), this._geosToDraw[i]._cPoint = void 0, 
	                this._geosToDraw[i]._inCurrentView = void 0) : (delete o._cPoint, delete o._inCurrentView);
	            }
	            this.clearImageData();
	        }
	    }, n.show = function() {
	        this.layer.forEach((function(t) {
	            t._repaint();
	        })), t.prototype.show.apply(this, arguments);
	    }, n.forEachGeo = function(t, e) {
	        this.layer.forEach(t, e);
	    }, n.drawGeos = function() {
	        this._updateMapStateCache(), this._drawnRes = this.mapStateCache.resolution, this._updateDisplayExtent(), 
	        this.prepareToDraw(), this._batchConversionMarkers(this.mapStateCache.glRes), this._onlyHasPoint || this.forEachGeo(this.checkGeo, this), 
	        this._sortByDistanceToCamera(this.getMap().cameraPosition);
	        for (var t = 0, e = this._geosToDraw.length; t < e; t++) this._geosToDraw[t]._paint(), 
	        this._geosToDraw[t]._cPoint = void 0, this._geosToDraw[t]._inCurrentView = void 0;
	        this.clearImageData();
	    }, n.prepareToDraw = function() {
	        this._hasPoint = !1, this._geosToDraw = [];
	    }, n.checkGeo = function(t) {
	        if ("Point" !== t.type || void 0 === this._onlyHasPoint) {
	            if (t._isCheck = !1, t && t.isVisible() && t.getMap() && t.getLayer() && t.getLayer().isCanvasRender()) {
	                var e = t._getPainter(), n = !0;
	                if (t._inCurrentView) n = !0; else if (!1 === t._inCurrentView) n = !1; else {
	                    var i = e.get2DExtent(this.resources, gf);
	                    i && i.intersects(this._displayExtent) || (n = !1);
	                }
	                n && (e.hasPoint() && (this._hasPoint = !0), t._isCheck = !0, this._geosToDraw.push(t));
	            }
	        } else t._inCurrentView && (this._hasPoint = !0, t._isCheck = !0, this._geosToDraw.push(t));
	    }, n.onZoomEnd = function() {
	        delete this.canvasExtent2D, t.prototype.onZoomEnd.apply(this, arguments);
	    }, n.onRemove = function() {
	        this.forEachGeo((function(t) {
	            t.onHide();
	        })), delete this._geosToDraw;
	    }, n.onGeometryPropertiesChange = function(e) {
	        e && this.layer._styleGeometry(e.target), t.prototype.onGeometryPropertiesChange.call(this, e);
	    }, n._updateDisplayExtent = function() {
	        var t = this.canvasExtent2D;
	        if (this._maskExtent) {
	            if (!this._maskExtent.intersects(t)) return void this.completeRender();
	            t = t.intersection(this._maskExtent);
	        }
	        this._displayExtent = t;
	    }, n.identifyAtPoint = function(t, e) {
	        void 0 === e && (e = {});
	        var n = this._geosToDraw;
	        return n ? this.layer._hitGeos(n, t, e) : [];
	    }, n._updateMapStateCache = function() {
	        var t = this.getMap(), e = t._pointToContainerPoint(this.southWest)._add(0, -t.height), n = t.getResolution(), i = t.getPitch(), r = t.getBearing(), o = t.getGLScale(), s = t.getGLRes(), a = t.getContainerExtent(), h = t._get2DExtent(), l = t._get2DExtentAtRes(s);
	        return this.mapStateCache = {
	            resolution: n,
	            pitch: i,
	            bearing: r,
	            glScale: o,
	            glRes: s,
	            _2DExtent: h,
	            glExtent: l,
	            containerExtent: a,
	            offset: e
	        }, this;
	    }, n._batchConversionMarkers = function(t) {
	        if (this._onlyHasPoint = void 0, !this._constructorIsThis()) return [];
	        var e = [], n = [], i = [], r = {}, o = this.layer, s = o.options, a = o.getAltitude ? o.getAltitude() : 0, h = o.isCanvasRender();
	        this._onlyHasPoint = !0;
	        for (var l = 0, c = 0, u = this.layer._geoList.length; c < u; c++) {
	            var f = this.layer._geoList[c];
	            if ("Point" === f.getType()) {
	                var d = f._painter;
	                d || (d = f._getPainter());
	                var m = d.getRenderPoints("center")[0][0], g = s.enableAltitude ? f.getAltitude() : a;
	                void 0 === r[g] && (r[g] = d.getAltitude()), e[l] = m, i[l] = r[g], n[l] = f, l++;
	            } else this._onlyHasPoint = !1;
	        }
	        if (0 === l) return [];
	        var p = this.getMap(), _ = sr(e, "_pt");
	        _ = p._pointsAtResToContainerPoints(e, t, i, _);
	        for (var v = p.getContainerExtent(), y = v.xmax, x = v.ymax, b = v.xmin, w = v.ymin, C = {}, M = 0, T = n.length; M < T; M++) {
	            var S = n[M];
	            if (S._cPoint = _[M], S._cPoint) {
	                var P = _[M], A = P.x, E = P.y;
	                if (S._inCurrentView = A >= b && E >= w && A <= y && E <= x, !S._inCurrentView) {
	                    var O = S.getSymbolHash(), R = void 0;
	                    R = O ? C[O] = C[O] || S._painter.getFixedExtent() : S._painter.getFixedExtent(), 
	                    _f.set(R.xmin, R.ymin, R.xmax, R.ymax), _f._add(_[M]), S._inCurrentView = _f.intersects(v);
	                }
	                S._inCurrentView && (S.isVisible() && h || (S._inCurrentView = !1), this._onlyHasPoint && S._inCurrentView && (this._hasPoint = !0, 
	                S._isCheck = !0, this._geosToDraw.push(S)));
	            } else S._inCurrentView = !1;
	        }
	        return _;
	    }, n._sortByDistanceToCamera = function(t) {
	        if (this.layer.options.sortByDistanceToCamera && this._geosToDraw.length) {
	            var e = this.getMap(), n = e.distanceToPoint(1e3, 0, e.getGLScale()).x / 1e3;
	            this._geosToDraw.sort((function(e, i) {
	                var r = e.getType(), o = i.getType();
	                if ("Point" !== r || "Point" !== o) return 0;
	                var s = e._painter, a = i._painter;
	                if (!s || !a) return 0;
	                var h = s.getRenderPoints("center")[0][0], l = a.getRenderPoints("center")[0][0], c = s.getAltitude() * n, u = a.getAltitude() * n;
	                Jl(pf, h.x, h.y, c);
	                var f = $l(pf, t);
	                return Jl(pf, l.x, l.y, u), $l(pf, t) - f;
	            }));
	        }
	    }, n._constructorIsThis = function() {
	        return this.constructor === e;
	    }, e;
	}(df);

	Il.registerRenderer("canvas", vf);

	var yf = function(t) {
	    function e(e) {
	        var n;
	        return (n = t.call(this, e) || this)._containerIsCanvas = !!e._containerDOM.getContext, 
	        n._thisVisibilitychange = n._onVisibilitychange.bind(Si$1(Si$1(n))), n._registerEvents(), 
	        n._loopTime = 0, n;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.load = function() {
	        this.initContainer();
	    }, n.renderFrame = function(t) {
	        var e = this.map;
	        if (!e || !e.options.renderable) return !1;
	        if (e.options.stopRenderOnOffscreen && this._containerIsOffscreen()) return !0;
	        this._updateDomPosition(t), delete this._isViewChanged, e._fireEvent("framestart"), 
	        this.updateMapDOM(), e.clearCollisionIndex();
	        var n = this._getAllLayerToRender();
	        return this.drawLayers(n, t), this.drawLayerCanvas(n) && (this.drawTops(), this._drawCenterCross()), 
	        e._fireEvent("frameend"), this._recordView(), this._mapview = this._getMapView(), 
	        delete this._spatialRefChanged, this._fireLayerLoadEvents(), this.executeFrameCallbacks(), 
	        this._canvasUpdated = !1, !0;
	    }, n.updateMapDOM = function() {
	        var t = this.map;
	        if (!t.isZooming()) {
	            var e = t._getViewPointFrameOffset();
	            e ? t.offsetPlatform(e) : this.domChanged() && this.offsetPlatform(null, !0);
	        }
	    }, n.drawLayers = function(t, e) {
	        for (var n = this.map, i = n.isInteracting(), r = [], o = [], s = n.options.fpsOnInteracting || 0, a = 0 === s ? 0 : 1e3 / s, h = this.map.options.layerCanvasLimitOnInteracting, l = t.length, c = n.getBaseLayer(), u = 0, f = 0; f < l; f++) {
	            var d = t[f];
	            if (d.isVisible()) {
	                var m = d.isCanvasRender();
	                m && r.push(d.getId());
	                var g = d._getRenderer();
	                if (g) {
	                    var p = this._checkLayerRedraw(d);
	                    m && g.isCanvasUpdated() && (p || o.push(d.getId()), this.setLayerCanvasUpdated());
	                    var _ = g.__zoomTransformMatrix;
	                    if (delete g.__zoomTransformMatrix, p) {
	                        if (i && m) {
	                            if (h > 0 && l - 1 - f > h && d !== c) {
	                                d._getRenderer().clearCanvas();
	                                continue;
	                            }
	                            u += this._drawCanvasLayerOnInteracting(d, u, a, e);
	                        } else i && g.drawOnInteracting ? (g.prepareRender && g.prepareRender(), g.checkAndDraw ? g.checkAndDraw(g.drawOnInteracting, this._eventParam, e) : g.drawOnInteracting(this._eventParam, e)) : (g.render(e), 
	                        m && _ && g.isLoadingResource() && (g.__zoomTransformMatrix = _));
	                        m && (o.push(d.getId()), this.setLayerCanvasUpdated());
	                    } else m && i && (n.isZooming() && !n.getPitch() ? (g.prepareRender(), g.__zoomTransformMatrix = this._zoomMatrix) : (n.getPitch() || n.isRotating()) && g.clearCanvas());
	                }
	            }
	        }
	        var v = this._canvasIds || [], y = this._updatedIds || [];
	        if (this._canvasIds = r, this._updatedIds = o, !this.isLayerCanvasUpdated()) {
	            v.join("---") === r.join("---") && y.join("---") === o.join("---") || this.setLayerCanvasUpdated();
	        }
	    }, n._checkLayerRedraw = function(t) {
	        if (this.isSpatialReferenceChanged()) return !0;
	        var e = this.map, n = t._getRenderer();
	        return t.isCanvasRender() ? n.testIfNeedRedraw() : !(!n.needToRedraw || !n.needToRedraw()) || (e.isInteracting() || this.isViewChanged());
	    }, n._drawCanvasLayerOnInteracting = function(t, e, n, i) {
	        var r = this.map, o = t._getRenderer(), s = o.getDrawTime(), a = 0 === n || n > 0 && e + s <= n;
	        if (o.mustRenderOnInteracting && o.mustRenderOnInteracting()) o.render(i); else {
	            if (o.drawOnInteracting && (t === r.getBaseLayer() || a || r.isZooming() && t.options.forceRenderOnZooming || r.isMoving() && t.options.forceRenderOnMoving || r.isRotating() && t.options.forceRenderOnRotating)) return o.prepareRender(), 
	            o.prepareCanvas(), o.checkAndDraw ? o.checkAndDraw(o.drawOnInteracting, this._eventParam, i) : o.drawOnInteracting(this._eventParam, i), 
	            s;
	            !r.isZooming() || r.getPitch() || r.isRotating() ? (r.getPitch() || r.isRotating()) && o.clearCanvas() : (o.prepareRender(), 
	            o.__zoomTransformMatrix = this._zoomMatrix);
	        }
	        return o.drawOnInteracting && !a && o.onSkipDrawOnInteracting(this._eventParam, i), 
	        0;
	    }, n._fireLayerLoadEvents = function() {
	        if (this._updatedIds && this._updatedIds.length > 0) {
	            var t = this.map;
	            this._updatedIds.reverse().forEach((function(e) {
	                var n = t.getLayer(e);
	                if (n) {
	                    var i = n._getRenderer();
	                    i && i.isRenderComplete() && n.fire("layerload");
	                }
	            }));
	        }
	    }, n.isLayerCanvasUpdated = function() {
	        return this._canvasUpdated;
	    }, n.setLayerCanvasUpdated = function() {
	        this._canvasUpdated = !0;
	    }, n.drawLayerCanvas = function(t) {
	        var e = this.map;
	        if (!e) return !1;
	        if (!this.isLayerCanvasUpdated() && !this.isViewChanged()) return !1;
	        this.canvas || this.createCanvas(), e._fireEvent("renderstart", {
	            context: this.context
	        }), this._updateCanvasSize() || this.clearCanvas();
	        for (var n, i = e.isInteracting(), r = e.options.layerCanvasLimitOnInteracting, o = t.length, s = [], a = 0; a < o; a++) {
	            if (t[a].isVisible() && t[a].isCanvasRender()) if (t[a]._getRenderer()) {
	                var h = this._getLayerImage(t[a]);
	                h && h.image && (t[a] === e.getBaseLayer() ? n = [ t[a], h ] : s.push([ t[a], h ]));
	            }
	        }
	        var l = this.canvas.width, c = this.canvas.height;
	        n && (this._drawLayerCanvasImage(n[0], n[1], l, c), this._drawFog()), o = s.length;
	        for (var u = i && r >= 0 && o > r ? o - r : 0; u < o; u++) this._drawLayerCanvasImage(s[u][0], s[u][1], l, c);
	        return e._fireEvent("renderend", {
	            context: this.context
	        }), !0;
	    }, n.setToRedraw = function() {
	        for (var t = this._getAllLayerToRender(), e = 0, n = t.length; e < n; e++) {
	            var i = t[e].getRenderer();
	            i && i.canvas && i.setToRedraw && i.setToRedraw();
	        }
	    }, n.updateMapSize = function(t) {
	        if (t && !this._containerIsCanvas) {
	            var e = t.height + "px", n = this.map._panels;
	            n.mapWrapper.style.width = t.width + "px", n.mapWrapper.style.height = e, this._updateCanvasSize();
	        }
	    }, n.getMainPanel = function() {
	        return this.map ? this._containerIsCanvas ? this.map._containerDOM : this.map._panels ? this.map._panels.mapWrapper : null : null;
	    }, n.toDataURL = function(t, e) {
	        return this.canvas ? this.canvas.toDataURL(t, e) : null;
	    }, n.remove = function() {
	        Mi$1.webgl && "undefined" != typeof document && To(document, "visibilitychange", this._thisVisibilitychange), 
	        this._resizeInterval && clearInterval(this._resizeInterval), delete this.context, 
	        delete this.canvas, delete this.map, delete this._spatialRefChanged, this._cancelFrameLoop();
	    }, n.hitDetect = function(t) {
	        var e = this.map;
	        if (e && e.options.hitDetect && !e.isInteracting()) {
	            var n = e._getLayers(), i = "default", r = e.options.hitDetectLimit || 0, o = 0;
	            t && t._round && t._round();
	            for (var s = n.length - 1; s >= 0; s--) {
	                var a = n[s];
	                if (!(!a.options.hitDetect || a.isEmpty && a.isEmpty())) {
	                    var h = a._getRenderer();
	                    if (h && h.hitDetect && (!h.isBlank || !h.isBlank())) {
	                        if ("default" !== a.options.cursor && h.hitDetect(t)) {
	                            i = a.options.cursor || "pointer";
	                            break;
	                        }
	                        if (o++, r > 0 && o > r) break;
	                    }
	                }
	            }
	            e._trySetCursor(i);
	        }
	    }, n._getLayerImage = function(t) {
	        var e = t._getRenderer();
	        return e.getCanvasImage ? e.getCanvasImage() : null;
	    }, n.initContainer = function() {
	        var t = this.map._panels;
	        function e(e, n, i, r) {
	            var o, s = bo("div", n);
	            return i && (s.style.cssText = i), t[e] = s, r || ((o = s).onselectstart = function() {
	                return !1;
	            }, o.ondragstart = function() {
	                return !1;
	            }, o.setAttribute("unselectable", "on")), s;
	        }
	        var n = this.map._containerDOM;
	        if (!this._containerIsCanvas) {
	            n.innerHTML = "";
	            var i = "position:absolute;top:0px;left:0px;", r = e("mapWrapper", "maptalks-wrapper", "position:absolute;overflow:hidden;", !0), o = e("allLayers", "maptalks-all-layers", i + "padding:0px;margin:0px;z-index:0;overflow:visible;", !0), s = e("backStatic", "maptalks-back-static", i + "z-index:0;", !0), a = e("back", "maptalks-back", i + "z-index:1;"), h = e("backLayer", "maptalks-back-layer", i), l = e("canvasContainer", "maptalks-canvas-layer", i + "border:none;z-index:2;"), c = e("frontStatic", "maptalks-front-static", i + "z-index:3;", !0), u = e("front", "maptalks-front", i + "z-index:4;", !0), f = e("frontLayer", "maptalks-front-layer", i + "z-index:0;"), d = e("ui", "maptalks-ui", i + "border:none;z-index:1;", !0), m = e("control", "maptalks-control", "z-index:1", !0);
	            n.appendChild(r), o.appendChild(s), a.appendChild(h), a.layerDOM = h, o.appendChild(a), 
	            o.appendChild(l), u.appendChild(f), u.layerDOM = f, u.uiDOM = d, o.appendChild(c), 
	            o.appendChild(u), u.appendChild(d), r.appendChild(o), r.appendChild(m), this.createCanvas(), 
	            this.resetContainer();
	            var g = this.map._getContainerDomSize();
	            this.updateMapSize(g);
	        }
	    }, n.isViewChanged = function() {
	        if (void 0 !== this._isViewChanged) return this._isViewChanged;
	        var t = this._mapview, e = this._getMapView();
	        return this._isViewChanged = !t || !ir(t, e), this._isViewChanged;
	    }, n._recordView = function() {
	        var t = this.map;
	        !t._onViewChange || t.isInteracting() || t.isAnimating() || ir(t.getView(), t._getCurrentView()) || t._onViewChange(t.getView());
	    }, n.isSpatialReferenceChanged = function() {
	        return this._spatialRefChanged;
	    }, n._getMapView = function() {
	        var t = this.map, e = t._getPrjCenter();
	        return {
	            x: e.x,
	            y: e.y,
	            zoom: t.getZoom(),
	            pitch: t.getPitch(),
	            bearing: t.getBearing(),
	            width: t.width,
	            height: t.height
	        };
	    }, n._frameLoop = function(t) {
	        var e = this;
	        this.map ? (this._frameTimestamp = t = t || 0, this._resizeCount = 0, this.renderFrame(t), 
	        this._animationFrame = Pi$1((function(t) {
	            e._frameLoop(t);
	        }))) : this._cancelFrameLoop();
	    }, n._cancelFrameLoop = function() {
	        this._animationFrame && Ai$1(this._animationFrame);
	    }, n._drawLayerCanvasImage = function(t, e, n, i) {
	        var r = this.context, o = e.point.round(), s = this.map.getDevicePixelRatio();
	        1 !== s && o._multi(s);
	        var a = e.image, h = a.width, l = a.height;
	        if (!(o.x + h <= 0 || o.y + l <= 0)) {
	            var c = t.options.opacity;
	            if (Ln(c) || (c = 1), !(c <= 0)) {
	                var u = e.opacity;
	                if (Ln(u) || (u = 1), !(u <= 0)) {
	                    var f = r.globalAlpha;
	                    c < 1 && (r.globalAlpha *= c), u < 1 && (r.globalAlpha *= u), t.options.cssFilter && (r.filter = t.options.cssFilter);
	                    var d = t.getRenderer(), m = d.__zoomTransformMatrix, g = d.clipCanvas(this.context);
	                    m && (r.save(), r.setTransform.apply(r, m)), r.drawImage(a, 0, 0, h, l, o.x, o.y, n, i), 
	                    m && r.restore(), g && r.restore(), "none" !== r.filter && (r.filter = "none"), 
	                    r.globalAlpha = f;
	                }
	            }
	        }
	    }, n._drawCenterCross = function() {
	        var t = this.map.options.centerCross;
	        if (t) {
	            var e = this.context, n = new Oi$1(this.canvas.width / 2, this.canvas.height / 2);
	            Hn(t) ? t(e, n) : qo.drawCross(this.context, n.x, n.y, 2, "#f00");
	        }
	    }, n._drawContainerExtent = function() {
	        var t = this.map.options.cascadePitches, e = this.map.height - this.map._getVisualHeight(t[0]), n = this.map.height - this.map._getVisualHeight(t[1]), i = this.map.getContainerExtent(), r = this.context;
	        r.beginPath(), r.moveTo(0, i.ymin), r.lineTo(i.xmax, i.ymin), r.stroke(), r.beginPath(), 
	        r.moveTo(0, e), r.lineTo(i.xmax, e), r.stroke(), r.beginPath(), r.moveTo(0, n), 
	        r.lineTo(i.xmax, n), r.stroke();
	    }, n._drawFog = function() {
	        var t = this.map;
	        if (!(t.getPitch() <= t.options.maxVisualPitch) && t.options.fog) {
	            var e = t.getDevicePixelRatio(), n = this.context, i = t.getContainerExtent(), r = (t.height - t._getVisualHeight(75)) * e;
	            r < 0 && (r = 0);
	            var o = i.ymin * e, s = Math.ceil(o - r), a = t.options.fogColor.join(), h = n.createLinearGradient(0, r, 0, o + 30), l = 1 - 30 / (s + 30);
	            h.addColorStop(0, "rgba(" + a + ", 0)"), h.addColorStop(.3, "rgba(" + a + ", 0.3)"), 
	            h.addColorStop(l, "rgba(" + a + ", 1)"), h.addColorStop(1, "rgba(" + a + ", 0)"), 
	            n.beginPath(), n.fillStyle = h, n.fillRect(0, r, Math.ceil(i.getWidth()) * e, Math.ceil(s + 30));
	        }
	    }, n._getAllLayerToRender = function() {
	        return this.map._getLayers();
	    }, n.clearCanvas = function() {
	        this.canvas && qo.clearRect(this.context, 0, 0, this.canvas.width, this.canvas.height);
	    }, n._updateCanvasSize = function() {
	        if (!this.canvas || this._containerIsCanvas) return !1;
	        var t = this.map, e = t.getSize(), n = this.canvas, i = ur(e, t.getDevicePixelRatio()), r = i.width, o = i.height, s = i.cssWidth, a = i.cssHeight;
	        return !n.style || n.style.width === s && n.style.height === a || (n.style.width = s, 
	        n.style.height = a), (r !== n.width || o !== n.height) && (n.height = o, n.width = r, 
	        this.topLayer.width = n.width, this.topLayer.height = n.height, !0);
	    }, n.createCanvas = function() {
	        this.topLayer = bo("canvas"), this.topCtx = this.topLayer.getContext("2d"), this._containerIsCanvas ? this.canvas = this.map._containerDOM : (this.canvas = bo("canvas"), 
	        this._updateCanvasSize(), this.map._panels.canvasContainer.appendChild(this.canvas)), 
	        this.context = this.canvas.getContext("2d");
	    }, n._updateDomPosition = function(t) {
	        return void 0 === this._checkPositionTime && (this._checkPositionTime = -1 / 0), 
	        Math.abs(t - this._checkPositionTime) >= 500 && (Oo(this.map._containerDOM), this._checkPositionTime = Math.min(t, this._checkPositionTime)), 
	        this;
	    }, n._checkSize = function() {
	        this.map && this.map.checkSize();
	    }, n._setCheckSizeInterval = function(t) {
	        var e = this;
	        Mi$1.resizeObserver ? (this._resizeObserver && this._resizeObserver.disconnect(), 
	        this.map && (this._resizeObserver = new ResizeObserver((function(t) {
	            !e.map || e.map.isRemoved() ? e._resizeObserver.disconnect() : t.length && (e.map._containerDomContentRect = t[0].contentRect, 
	            e._checkSize(t[0].contentRect), e._resizeCount = e._resizeCount || 0, e.renderFrame((e._frameTimestamp || 0) + ++e._resizeCount / 100));
	        })), this._resizeObserver.observe(this.map._containerDOM))) : (clearInterval(this._resizeInterval), 
	        this._checkSizeInterval = t, this._resizeInterval = setInterval((function() {
	            !e.map || e.map.isRemoved() ? clearInterval(e._resizeInterval) : e._checkSize();
	        }), this._checkSizeInterval));
	    }, n._registerEvents = function() {
	        var t = this, e = this.map;
	        e.options.checkSize && !Wn && "undefined" != typeof window && this._setCheckSizeInterval(e.options.checkSizeInterval), 
	        Mi$1.mobile || e.on("_mousemove", this._onMapMouseMove, this), e.on("_dragrotatestart _dragrotating _dragrotateend _movestart _moving _moveend _zoomstart", (function(e) {
	            t._eventParam = e;
	        })), e.on("_zooming", (function(n) {
	            e.getPitch() || (t._zoomMatrix = n.matrix.container), t._eventParam = n;
	        })), e.on("_zoomend", (function(e) {
	            t._eventParam = e, delete t._zoomMatrix;
	        })), e.on("_spatialreferencechange", (function() {
	            t._spatialRefChanged = !0;
	        })), Mi$1.webgl && "undefined" != typeof document && Mo(document, "visibilitychange", this._thisVisibilitychange, this), 
	        Mi$1.addDPRListening && Mi$1.addDPRListening(this.map);
	    }, n._onMapMouseMove = function(t) {
	        var e = this, n = this.map;
	        !n.isInteracting() && n.options.hitDetect && (this._hitDetectFrame && Ai$1(this._hitDetectFrame), 
	        this._hitDetectFrame = Pi$1((function() {
	            e.hitDetect(t.containerPoint);
	        })));
	    }, n._getCanvasLayers = function() {
	        return this.map._getLayers((function(t) {
	            return t.isCanvasRender();
	        }));
	    }, n._onVisibilitychange = function() {
	        "visible" === document.visibilityState && this.setToRedraw();
	    }, n.addTopElement = function(t) {
	        this._tops || (this._tops = []), this._tops.push(t);
	    }, n.removeTopElement = function(t) {
	        if (this._tops) {
	            var e = this._tops.indexOf(t);
	            e >= 0 && this._tops.splice(e, 1);
	        }
	    }, n.getTopElements = function() {
	        return this._tops || [];
	    }, n.drawTops = function() {
	        this.topCtx.clearRect(0, 0, this.topLayer.width, this.topLayer.height), this.map.fire("drawtopstart"), 
	        this.map.fire("drawtops");
	        for (var t = this.getTopElements(), e = !1, n = 0; n < t.length; n++) t[n].render(this.topCtx) && (e = !0);
	        e && this.context.drawImage(this.topLayer, 0, 0), this.map.fire("drawtopsend");
	    }, n._containerIsOffscreen = function() {
	        var t = this.map.getContainer();
	        return !t || !t.style || "none" === t.style.display || Math.min(t.clientWidth, t.clientHeight) <= 0;
	    }, e;
	}(function(t) {
	    function e(e) {
	        var n;
	        return (n = t.call(this) || this).map = e, n._handlerQueue = [], n;
	    }
	    Ti$1(e, t);
	    var n = e.prototype;
	    return n.callInNextFrame = function(t) {
	        this._handlerQueue.push(t);
	    }, n.executeFrameCallbacks = function() {
	        var t = this._handlerQueue;
	        this._handlerQueue = [];
	        for (var e = 0, n = t.length; e < n; e++) t[e]();
	    }, n.offsetPlatform = function(t, e) {
	        if (!this.map._panels.front) return this;
	        if (!e && 0 === t.x && 0 === t.y) return this;
	        var n = this.map._panels, i = this._frontCount = n.back.layerDOM.childElementCount, r = this._backCount = n.front.layerDOM.childElementCount, o = this._uiCount = n.front.uiDOM.childElementCount;
	        if (i || r || o) {
	            var s = this.map.offsetPlatform();
	            s = t ? s.add(t)._round() : s.round(), r && Eo(n.back, s), (i || o) && Eo(n.front, s);
	        }
	        return this;
	    }, n.domChanged = function() {
	        var t = this.map._panels;
	        return !!t.front && (void 0 === this._frontCount || this._frontCount !== t.back.layerDOM.childElementCount || (void 0 === this._backCount || this._backCount !== t.front.layerDOM.childElementCount || (void 0 === this._uiCount || this._uiCount !== t.front.uiDOM.childElementCount)));
	    }, n.resetContainer = function() {
	        if (this.map && (this.map._resetMapViewPoint(), this.map._panels.front)) {
	            var t = new Oi$1(0, 0);
	            Eo(this.map._panels.back, t), Eo(this.map._panels.front, t);
	        }
	    }, n.onZoomEnd = function() {
	        this.resetContainer();
	    }, n.onLoad = function() {
	        this._frameLoop();
	    }, e;
	}(ns));

	Fh.registerRenderer("canvas", yf), Fh.mergeOptions({
	    fog: !1,
	    fogColor: [ 233, 233, 233 ]
	});

	var xf = {
	    _getRenderPoints: function() {
	        return [ [ this._getCenter2DPoint(this.getMap().getGLRes()) ], null ];
	    }
	};

	$h.include(xf), dl.include(xf), fl.include(xf), gl.include(xf), ml.include({
	    _getRenderPoints: function(t) {
	        var e = this.getMap(), n = e.getGLRes();
	        if ("vertex" === t) {
	            for (var i = this._trimRing(this.getShell()), r = [], o = 0, s = i.length; o < s; o++) r.push(e.coordToPointAtRes(i[o], n));
	            return [ r, null ];
	        }
	        return [ [ e.coordToPointAtRes(this.getCenter(), n) ], null ];
	    }
	});

	var bf = {
	    _getRenderPoints: function(t) {
	        var e, n = this.getMap(), i = n.getGLRes(), r = null;
	        if ("point" === t) (e = this._getPath2DPoints(this._getPrjCoordinates(), !1, i)) && e.length > 0 && Array.isArray(e[0]) && (e = e[0].concat(e[1])); else if ("vertex" === t) if (r = [], 
	        (e = this._getPath2DPoints(this._getPrjCoordinates(), !1, i)) && e.length > 0 && Array.isArray(e[0])) {
	            for (var o = 0, s = e.length; o < s; o++) for (var a = 0, h = e[o].length; a < h; a++) r.push(0 === a ? [ e[o][a], e[o][a + 1] ] : [ e[o][a - 1], e[o][a] ]);
	            e = e[0].concat(e[1]);
	        } else for (var l = 0, c = e.length; l < c; l++) r.push(0 === l ? [ e[l], e[l + 1] ] : [ e[l - 1], e[l] ]); else if ("line" === t) {
	            e = [], r = [];
	            var u = this._getPath2DPoints(this._getPrjCoordinates(), !1, i);
	            if (u.length > 0 && Array.isArray(u[0])) for (var f, d = 1, m = u.length; d < m; d++) {
	                f = u[d], this instanceof Yh && f.length > 0 && !f[0].equals(f[f.length - 1]) && f.push(f[0]);
	                for (var g = 1, p = f.length; g < p; g++) e.push(f[g].add(f[g - 1])._multi(.5)), 
	                r.push([ f[g - 1], f[g] ]);
	            } else {
	                this instanceof Yh && u.length > 0 && !u[0].equals(u[u.length - 1]) && u.push(u[0]);
	                for (var _ = 1, v = u.length; _ < v; _++) e.push(u[_].add(u[_ - 1])._multi(.5)), 
	                r.push([ u[_ - 1], u[_] ]);
	            }
	        } else if ("vertex-first" === t) {
	            var y = this._getPrjCoordinates(), x = y.length, b = x ? n._prjToPointAtRes(y[0], i) : null;
	            e = x ? [ b ] : [], r = x ? [ [ b, y[1] ? n._prjToPointAtRes(y[1], i) : b ] ] : [];
	        } else if ("vertex-last" === t) {
	            var w = this._getPrjCoordinates(), C = w.length, M = C ? n._prjToPointAtRes(w[C - 1], i) : null;
	            e = C ? [ M ] : [];
	            var T = C > 1 ? C - 2 : C - 1;
	            r = C ? [ [ w[T] ? n._prjToPointAtRes(w[T], i) : M, M ] ] : [];
	        } else {
	            var S = this.getCenter();
	            if (S) {
	                var P = this._getProjection().project(S);
	                e = [ n._prjToPointAtRes(P, i) ];
	            } else e = [];
	        }
	        return [ e, r ];
	    }
	};

	el.include(bf), Yh.include(bf);

	var wf = {
	    within: !1,
	    center: [ 0, 0 ]
	};

	function Cf(t) {
	    if (t && t._containerBbox) {
	        wf.within = !1;
	        var e = t._containerBbox, n = e.minx, i = e.miny, r = e.maxx, o = e.maxy, s = Math.abs(r - n), a = Math.abs(o - i);
	        s <= 1 && a <= 1 && (wf.within = !0, wf.center[0] = (n + r) / 2, wf.center[1] = (i + o) / 2), 
	        delete t._containerBbox;
	    } else wf.within = !1;
	    return wf;
	}

	Mh.include({
	    _redrawWhenPitch: function() {
	        return !1;
	    },
	    _redrawWhenRotate: function() {
	        return !1;
	    }
	});

	var Mf = {
	    _redrawWhenPitch: function() {
	        return !0;
	    },
	    _redrawWhenRotate: function() {
	        return this instanceof dl || this instanceof gl;
	    },
	    _paintAsPath: function() {
	        var t = this.getMap();
	        return this.getAltitude() > 0 || t.getPitch() || this instanceof dl && t.getBearing();
	    },
	    _getPaintParams: function() {
	        var t = this.getMap();
	        if (this._paintAsPath()) return Yh.prototype._getPaintParams.call(this, !0);
	        var e = this._getPrjCoordinates(), n = t._prjToPointAtRes(e, t.getGLRes()), i = this._getRenderSize(n);
	        return [ n ].concat(i);
	    },
	    _paintOn: function() {
	        return this._paintAsPath() ? qo.polygon.apply(qo, arguments) : qo.ellipse.apply(qo, arguments);
	    },
	    _getRenderSize: function(t) {
	        var e = this.getMap(), n = e.getGLRes(), i = this._getPrjExtent(), r = e._prjToPointAtRes(i.getMin(), n), o = e._prjToPointAtRes(i.getMax(), n);
	        return [ Math.abs(o.x - r.x) / 2, Math.abs(o.y - t.y), Math.abs(t.y - r.y) ];
	    }
	};

	dl.include(Mf), fl.include(Mf), ml.include({
	    _getPaintParams: function() {
	        var t = this.getMap(), e = this._getPrjShell();
	        return [ this._getPath2DPoints(e, !1, t.getGLRes()) ];
	    },
	    _paintOn: qo.polygon
	}), gl.include(Mf, {
	    _redrawWhenPitch: function() {
	        return !0;
	    },
	    _getPaintParams: function() {
	        if (this._paintAsPath()) return Yh.prototype._getPaintParams.call(this, !0);
	        var t = this.getMap(), e = t._prjToPointAtRes(this._getPrjCoordinates(), t.getGLRes());
	        return [ e, this._getRenderSize(e)[0], [ this.getStartAngle(), this.getEndAngle() ] ];
	    },
	    _paintOn: function() {
	        if (this._paintAsPath()) return qo.polygon.apply(qo, arguments);
	        var t = this.getMap().getBearing(), e = arguments;
	        return t && (e[3] = e[3].slice(0), e[3][0] += t, e[3][1] += t), qo.sector.apply(qo, e);
	    }
	}), qh.include({
	    _paintAsPath: function() {
	        return !0;
	    }
	}), el.include({
	    arrowStyles: {
	        classic: [ 3, 4 ]
	    },
	    _getArrowShape: function(t, e, n, i, r) {
	        if (!t || !e || t.equals(e)) return null;
	        r || (r = 0);
	        var o, s = n * i[1] + r, a = n * i[0] / 2 + r;
	        (o = e.sub(e.nextCtrlPoint || e.prevCtrlPoint ? new Oi$1(e.prevCtrlPoint ? e.prevCtrlPoint : e.nextCtrlPoint) : t))._unit();
	        var h = e.sub(o.multi(s));
	        o._perp();
	        var l = h.add(o.multi(a));
	        return o._multi(-1), [ l, e, h.add(o.multi(a)), l ];
	    },
	    _getPaintParams: function() {
	        var t = this._getPrjCoordinates();
	        return [ this._getPath2DPoints(t, !1, this.getMap().getGLRes()) ];
	    },
	    _paintOn: function(t, e, n, i, r) {
	        var o = Cf(this._painter);
	        o.within ? qo.pixelRect(t, o.center, n, i) : this.options.smoothness ? qo.paintSmoothLine(t, e, n, this.options.smoothness, !1, this._animIdx, this._animTailRatio) : qo.path(t, e, n, null, r), 
	        this._paintArrow(t, e, n);
	    },
	    _getArrowPlacement: function() {
	        return this.options.arrowPlacement;
	    },
	    _getArrowStyle: function() {
	        var t = this.options.arrowStyle;
	        return t ? Array.isArray(t) ? t : this.arrowStyles[t] : null;
	    },
	    _getArrows: function(t, e, n) {
	        var i = this._getArrowStyle();
	        if (!i || t.length < 2) return [];
	        for (var r = t.length > 0 && Array.isArray(t[0]) ? t : [ t ], o = this._getArrowPlacement(), s = [], a = this.getMap(), h = a.coordToContainerPoint(this.getFirstCoordinate()), l = a.coordToContainerPoint(this.getLastCoordinate()), c = r.length - 1; c >= 0; c--) {
	            if ("vertex-first" === o || "vertex-firstlast" === o && r[c][0].closeTo(h, .01)) {
	                var u = this._getArrowShape(r[c][1], r[c][0], e, i, n);
	                u && s.push(u);
	            }
	            if ("vertex-last" === o || "vertex-firstlast" === o && r[c][r[c].length - 1].closeTo(l, .01)) {
	                var f = this._getArrowShape(r[c][r[c].length - 2], r[c][r[c].length - 1], e, i, n);
	                f && s.push(f);
	            } else "point" === o && this._getArrowPoints(s, r[c], e, i, n);
	        }
	        return s;
	    },
	    _getArrowPoints: function(t, e, n, i, r) {
	        for (var o = 0, s = e.length - 1; o < s; o++) {
	            var a = this._getArrowShape(e[o], e[o + 1], n, i, r);
	            a && t.push(a);
	        }
	    },
	    _paintArrow: function(t, e, n) {
	        var i = this._getInternalSymbol().lineWidth;
	        (!Ln(i) || i < 3) && (i = 3);
	        var r = this._getArrows(e, i);
	        if (r.length) {
	            t.setLineDash && t.setLineDash([]);
	            for (var o = r.length - 1; o >= 0; o--) t.fillStyle = t.strokeStyle, qo.polygon(t, r[o], n, n);
	        }
	    }
	}), Yh.include({
	    _getPaintParams: function(t) {
	        var e = this.getMap().getGLRes(), n = this._getPrjShell(), i = this._getPath2DPoints(n, t, e), r = i.length > 0 && Array.isArray(i[0]);
	        r && (i = [ [ i[0] ], [ i[1] ] ]);
	        var o = this._getPrjHoles(), s = [];
	        if (o && o.length > 0) {
	            for (var a = this._simplified, h = 0; h < o.length; h++) {
	                var l = this._getPath2DPoints(o[h], t, e);
	                Array.isArray(l) && r ? Array.isArray(l[0]) ? (i[0].push(l[0]), i[1].push(l[1])) : i[0].push(l) : s.push(l);
	            }
	            a && (this._simplified = a);
	        }
	        return r || Fi$1(i = [ i ], s), [ i ];
	    },
	    _paintOn: function(t, e, n, i, r) {
	        var o = Cf(this._painter);
	        o.within ? qo.pixelRect(t, o.center, n, i) : qo.polygon(t, e, n, i, r, this.options.smoothness);
	    }
	}), Fh.VERSION = "1.0.0-rc.14";

	var Tf = "attribute vec3 aPosition;\nuniform mat4 positionMatrix;\nuniform mat4 projViewModelMatrix;\n#include <get_output>\nvoid main() {\n  mat4 c = getPositionMatrix();\n  vec4 d = c * getPosition(aPosition);\n  gl_Position = projViewModelMatrix * d;\n}", Sf = {
	    exports: {}
	};

	function Pf(t, e, n) {
	    n = n || 2;
	    var i, r, o, s, a, h, l, c = e && e.length, u = c ? e[0] * n : t.length, f = Af(t, 0, u, n, !0), d = [];
	    if (!f || f.next === f.prev) return d;
	    if (c && (f = function(t, e, n, i) {
	        var r, o, s, a = [];
	        for (r = 0, o = e.length; r < o; r++) (s = Af(t, e[r] * i, r < o - 1 ? e[r + 1] * i : t.length, i, !1)) === s.next && (s.steiner = !0), 
	        a.push(Hf(s));
	        for (a.sort(Lf), r = 0; r < a.length; r++) n = zf(a[r], n);
	        return n;
	    }(t, e, f, n)), t.length > 80 * n) {
	        i = o = t[0], r = s = t[1];
	        for (var m = n; m < u; m += n) (a = t[m]) < i && (i = a), (h = t[m + 1]) < r && (r = h), 
	        a > o && (o = a), h > s && (s = h);
	        l = 0 !== (l = Math.max(o - i, s - r)) ? 32767 / l : 0;
	    }
	    return Of(f, d, n, i, r, l, 0), d;
	}

	function Af(t, e, n, i, r) {
	    var o, s;
	    if (r === Qf(t, e, n, i) > 0) for (o = e; o < n; o += i) s = qf(o, t[o], t[o + 1], s); else for (o = n - i; o >= e; o -= i) s = qf(o, t[o], t[o + 1], s);
	    return s && Vf(s, s.next) && (Yf(s), s = s.next), s;
	}

	function Ef(t, e) {
	    if (!t) return t;
	    e || (e = t);
	    var n, i = t;
	    do {
	        if (n = !1, i.steiner || !Vf(i, i.next) && 0 !== Gf(i.prev, i, i.next)) i = i.next; else {
	            if (Yf(i), (i = e = i.prev) === i.next) break;
	            n = !0;
	        }
	    } while (n || i !== e);
	    return e;
	}

	function Of(t, e, n, i, r, o, s) {
	    if (t) {
	        !s && o && function(t, e, n, i) {
	            var r = t;
	            do {
	                0 === r.z && (r.z = jf(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, 
	                r = r.next;
	            } while (r !== t);
	            r.prevZ.nextZ = null, r.prevZ = null, function(t) {
	                var e, n, i, r, o, s, a, h, l = 1;
	                do {
	                    for (n = t, t = null, o = null, s = 0; n; ) {
	                        for (s++, i = n, a = 0, e = 0; e < l && (a++, i = i.nextZ); e++) ;
	                        for (h = l; a > 0 || h > 0 && i; ) 0 !== a && (0 === h || !i || n.z <= i.z) ? (r = n, 
	                        n = n.nextZ, a--) : (r = i, i = i.nextZ, h--), o ? o.nextZ = r : t = r, r.prevZ = o, 
	                        o = r;
	                        n = i;
	                    }
	                    o.nextZ = null, l *= 2;
	                } while (s > 1);
	            }(r);
	        }(t, i, r, o);
	        for (var a, h, l = t; t.prev !== t.next; ) if (a = t.prev, h = t.next, o ? If(t, i, r, o) : Rf(t)) e.push(a.i / n | 0), 
	        e.push(t.i / n | 0), e.push(h.i / n | 0), Yf(t), t = h.next, l = h.next; else if ((t = h) === l) {
	            s ? 1 === s ? Of(t = kf(Ef(t), e, n), e, n, i, r, o, 2) : 2 === s && Df(t, e, n, i, r, o) : Of(Ef(t), e, n, i, r, o, 1);
	            break;
	        }
	    }
	}

	function Rf(t) {
	    var e = t.prev, n = t, i = t.next;
	    if (Gf(e, n, i) >= 0) return !1;
	    for (var r = e.x, o = n.x, s = i.x, a = e.y, h = n.y, l = i.y, c = r < o ? r < s ? r : s : o < s ? o : s, u = a < h ? a < l ? a : l : h < l ? h : l, f = r > o ? r > s ? r : s : o > s ? o : s, d = a > h ? a > l ? a : l : h > l ? h : l, m = i.next; m !== e; ) {
	        if (m.x >= c && m.x <= f && m.y >= u && m.y <= d && Nf(r, a, o, h, s, l, m.x, m.y) && Gf(m.prev, m, m.next) >= 0) return !1;
	        m = m.next;
	    }
	    return !0;
	}

	function If(t, e, n, i) {
	    var r = t.prev, o = t, s = t.next;
	    if (Gf(r, o, s) >= 0) return !1;
	    for (var a = r.x, h = o.x, l = s.x, c = r.y, u = o.y, f = s.y, d = a < h ? a < l ? a : l : h < l ? h : l, m = c < u ? c < f ? c : f : u < f ? u : f, g = a > h ? a > l ? a : l : h > l ? h : l, p = c > u ? c > f ? c : f : u > f ? u : f, _ = jf(d, m, e, n, i), v = jf(g, p, e, n, i), y = t.prevZ, x = t.nextZ; y && y.z >= _ && x && x.z <= v; ) {
	        if (y.x >= d && y.x <= g && y.y >= m && y.y <= p && y !== r && y !== s && Nf(a, c, h, u, l, f, y.x, y.y) && Gf(y.prev, y, y.next) >= 0) return !1;
	        if (y = y.prevZ, x.x >= d && x.x <= g && x.y >= m && x.y <= p && x !== r && x !== s && Nf(a, c, h, u, l, f, x.x, x.y) && Gf(x.prev, x, x.next) >= 0) return !1;
	        x = x.nextZ;
	    }
	    for (;y && y.z >= _; ) {
	        if (y.x >= d && y.x <= g && y.y >= m && y.y <= p && y !== r && y !== s && Nf(a, c, h, u, l, f, y.x, y.y) && Gf(y.prev, y, y.next) >= 0) return !1;
	        y = y.prevZ;
	    }
	    for (;x && x.z <= v; ) {
	        if (x.x >= d && x.x <= g && x.y >= m && x.y <= p && x !== r && x !== s && Nf(a, c, h, u, l, f, x.x, x.y) && Gf(x.prev, x, x.next) >= 0) return !1;
	        x = x.nextZ;
	    }
	    return !0;
	}

	function kf(t, e, n) {
	    var i = t;
	    do {
	        var r = i.prev, o = i.next.next;
	        !Vf(r, o) && Uf(r, i, i.next, o) && Xf(r, o) && Xf(o, r) && (e.push(r.i / n | 0), 
	        e.push(i.i / n | 0), e.push(o.i / n | 0), Yf(i), Yf(i.next), i = t = o), i = i.next;
	    } while (i !== t);
	    return Ef(i);
	}

	function Df(t, e, n, i, r, o) {
	    var s = t;
	    do {
	        for (var a = s.next.next; a !== s.prev; ) {
	            if (s.i !== a.i && Bf(s, a)) {
	                var h = Jf(s, a);
	                return s = Ef(s, s.next), h = Ef(h, h.next), Of(s, e, n, i, r, o, 0), void Of(h, e, n, i, r, o, 0);
	            }
	            a = a.next;
	        }
	        s = s.next;
	    } while (s !== t);
	}

	function Lf(t, e) {
	    return t.x - e.x;
	}

	function zf(t, e) {
	    var n = function(t, e) {
	        var n, i = e, r = t.x, o = t.y, s = -1 / 0;
	        do {
	            if (o <= i.y && o >= i.next.y && i.next.y !== i.y) {
	                var a = i.x + (o - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
	                if (a <= r && a > s && (s = a, n = i.x < i.next.x ? i : i.next, a === r)) return n;
	            }
	            i = i.next;
	        } while (i !== e);
	        if (!n) return null;
	        var h, l = n, c = n.x, u = n.y, f = 1 / 0;
	        i = n;
	        do {
	            r >= i.x && i.x >= c && r !== i.x && Nf(o < u ? r : s, o, c, u, o < u ? s : r, o, i.x, i.y) && (h = Math.abs(o - i.y) / (r - i.x), 
	            Xf(i, t) && (h < f || h === f && (i.x > n.x || i.x === n.x && Ff(n, i))) && (n = i, 
	            f = h)), i = i.next;
	        } while (i !== l);
	        return n;
	    }(t, e);
	    if (!n) return e;
	    var i = Jf(n, t);
	    return Ef(i, i.next), Ef(n, n.next);
	}

	function Ff(t, e) {
	    return Gf(t.prev, t, e.prev) < 0 && Gf(e.next, t, t.next) < 0;
	}

	function jf(t, e, n, i, r) {
	    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - n) * r | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - i) * r | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;
	}

	function Hf(t) {
	    var e = t, n = t;
	    do {
	        (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
	    } while (e !== t);
	    return n;
	}

	function Nf(t, e, n, i, r, o, s, a) {
	    return (r - s) * (e - a) >= (t - s) * (o - a) && (t - s) * (i - a) >= (n - s) * (e - a) && (n - s) * (o - a) >= (r - s) * (i - a);
	}

	function Bf(t, e) {
	    return t.next.i !== e.i && t.prev.i !== e.i && !function(t, e) {
	        var n = t;
	        do {
	            if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Uf(n, n.next, t, e)) return !0;
	            n = n.next;
	        } while (n !== t);
	        return !1;
	    }(t, e) && (Xf(t, e) && Xf(e, t) && function(t, e) {
	        var n = t, i = !1, r = (t.x + e.x) / 2, o = (t.y + e.y) / 2;
	        do {
	            n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), 
	            n = n.next;
	        } while (n !== t);
	        return i;
	    }(t, e) && (Gf(t.prev, t, e.prev) || Gf(t, e.prev, e)) || Vf(t, e) && Gf(t.prev, t, t.next) > 0 && Gf(e.prev, e, e.next) > 0);
	}

	function Gf(t, e, n) {
	    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
	}

	function Vf(t, e) {
	    return t.x === e.x && t.y === e.y;
	}

	function Uf(t, e, n, i) {
	    var r = Zf(Gf(t, e, n)), o = Zf(Gf(t, e, i)), s = Zf(Gf(n, i, t)), a = Zf(Gf(n, i, e));
	    return r !== o && s !== a || (!(0 !== r || !Wf(t, n, e)) || (!(0 !== o || !Wf(t, i, e)) || (!(0 !== s || !Wf(n, t, i)) || !(0 !== a || !Wf(n, e, i)))));
	}

	function Wf(t, e, n) {
	    return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y);
	}

	function Zf(t) {
	    return t > 0 ? 1 : t < 0 ? -1 : 0;
	}

	function Xf(t, e) {
	    return Gf(t.prev, t, t.next) < 0 ? Gf(t, e, t.next) >= 0 && Gf(t, t.prev, e) >= 0 : Gf(t, e, t.prev) < 0 || Gf(t, t.next, e) < 0;
	}

	function Jf(t, e) {
	    var n = new Kf(t.i, t.x, t.y), i = new Kf(e.i, e.x, e.y), r = t.next, o = e.prev;
	    return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, 
	    i.prev = o, i;
	}

	function qf(t, e, n, i) {
	    var r = new Kf(t, e, n);
	    return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, 
	    r.next = r), r;
	}

	function Yf(t) {
	    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), 
	    t.nextZ && (t.nextZ.prevZ = t.prevZ);
	}

	function Kf(t, e, n) {
	    this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, 
	    this.prevZ = null, this.nextZ = null, this.steiner = !1;
	}

	function Qf(t, e, n, i) {
	    for (var r = 0, o = e, s = n - i; o < n; o += i) r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), 
	    s = o;
	    return r;
	}

	Sf.exports = Pf, Sf.exports.default = Pf, Pf.deviation = function(t, e, n, i) {
	    var r = e && e.length, o = Math.abs(Qf(t, 0, r ? e[0] * n : t.length, n));
	    if (r) for (var s = 0, a = e.length; s < a; s++) {
	        o -= Math.abs(Qf(t, e[s] * n, s < a - 1 ? e[s + 1] * n : t.length, n));
	    }
	    var h = 0;
	    for (s = 0; s < i.length; s += 3) {
	        var l = i[s] * n, c = i[s + 1] * n, u = i[s + 2] * n;
	        h += Math.abs((t[l] - t[u]) * (t[c + 1] - t[l + 1]) - (t[l] - t[c]) * (t[u + 1] - t[l + 1]));
	    }
	    return 0 === o && 0 === h ? 0 : Math.abs((h - o) / o);
	}, Pf.flatten = function(t) {
	    for (var e = t[0][0].length, n = {
	        vertices: [],
	        holes: [],
	        dimensions: e
	    }, i = 0, r = 0; r < t.length; r++) {
	        for (var o = 0; o < t[r].length; o++) for (var s = 0; s < e; s++) n.vertices.push(t[r][o][s]);
	        r > 0 && n.holes.push(i += t[r - 1].length);
	    }
	    return n;
	};

	var $f = Sf.exports;

	const td = [], ed = [], nd = [ 1, 1, 1 ], id = [ 0, 0, 0, 1 ];

	class rd {
	    constructor(t, e) {
	        this.regl = t, this._viewport = e, this.renderer = new N$1(t), this._init();
	    }
	    _init() {
	        this._maskColorFbo = this.renderer.regl.framebuffer({
	            color: this.renderer.regl.texture({
	                width: 1,
	                height: 1,
	                wrap: "clamp",
	                mag: "linear",
	                min: "linear"
	            }),
	            depth: !0
	        }), this._maskModeFbo = this.renderer.regl.framebuffer({
	            color: this.renderer.regl.texture({
	                width: 1,
	                height: 1,
	                wrap: "clamp",
	                mag: "nearest",
	                min: "nearest"
	            }),
	            depth: !0
	        });
	        const t = [ {
	            name: "projViewModelMatrix",
	            type: "function",
	            fn: (t, n) => multiply$5([], n.projViewMatrix, n.modelMatrix)
	        } ];
	        this._maskColorShader = new ie$1({
	            vert: Tf,
	            frag: "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec4 maskColor;\nvoid main() {\n  gl_FragColor = maskColor;\n}",
	            uniforms: t,
	            extraCommandProps: {
	                viewport: this._viewport
	            }
	        }), this._maskModeShader = new ie$1({
	            vert: Tf,
	            frag: "#ifdef GL_ES\nprecision highp float;\n#endif\nuniform float maskMode;\nuniform float flatHeight;\nuniform vec2 heightRange;\nvoid main() {\n  gl_FragColor = vec4(maskMode, flatHeight, heightRange.x, heightRange.y);\n}",
	            uniforms: t,
	            extraCommandProps: {
	                viewport: this._viewport
	            }
	        }), this._scene = new yt$1;
	    }
	    setExtentPositions(t) {
	        this._disposeMeshes();
	        const e = this._calExtent(t), n = [ (e[0] + e[2]) / 2, (e[1] + e[3]) / 2, 0 ], i = [];
	        for (let e = 0; e < t.length; e++) {
	            const r = this._createMesh(t[e], n);
	            i.push(r);
	        }
	        this._meshes = i;
	    }
	    _createMesh(t, n) {
	        const i = [], {position: r, maskColor: o, maskMode: a, flatHeight: h, heightRange: l} = t;
	        for (let t = 0; t < r.length; t++) {
	            const e = r[t];
	            i.push(e[0] - n[0]), i.push(e[1] - n[1]), i.push(e[2]);
	        }
	        const c = $f(i, null, 3), u = new Q$1({
	            POSITION: i
	        }, c, 0, {
	            positionAttribute: "POSITION"
	        });
	        u.generateBuffers(this.regl);
	        const f = new ft$1(u);
	        f.setUniform("maskColor", o), f.setUniform("maskMode", a), f.setUniform("flatHeight", h), 
	        f.setUniform("heightRange", l);
	        const d = fromRotationTranslationScale(td, identity$1(ed), n, nd);
	        return f.localTransform = d, f;
	    }
	    render(t) {
	        this._resize(), this.renderer.clear({
	            color: id,
	            depth: 1,
	            framebuffer: this._maskColorFbo
	        }), this.renderer.clear({
	            color: id,
	            depth: 1,
	            framebuffer: this._maskModeFbo
	        }), this._scene.setMeshes(this._meshes);
	        const e = {
	            projViewMatrix: t
	        };
	        return this.renderer.render(this._maskColorShader, e, this._scene, this._maskColorFbo), 
	        this.renderer.render(this._maskModeShader, e, this._scene, this._maskModeFbo), {
	            colorExtent: this._maskColorFbo,
	            modeExtent: this._maskModeFbo
	        };
	    }
	    _calExtent(t) {
	        let e = 1 / 0, n = 1 / 0, i = -1 / 0, r = -1 / 0;
	        for (let o = 0; o < t.length; o++) {
	            const {position: s} = t[o];
	            for (let t = 0; t < s.length; t++) s[t][0] < e && (e = s[t][0]), s[t][1] < n && (n = s[t][1]), 
	            s[t][0] > i && (i = s[t][0]), s[t][1] > r && (r = s[t][1]);
	        }
	        return [ e, n, i, r ];
	    }
	    _resize() {
	        const t = po.isFunction(this._viewport.width) ? this._viewport.width() : this._viewport.width.data(), e = po.isFunction(this._viewport.height) ? this._viewport.height() : this._viewport.height.data();
	        !this._maskColorFbo || this._maskColorFbo.width === t && this._maskColorFbo.height === e || (this._maskColorFbo.resize(t, e), 
	        this._maskModeFbo.resize(t, e));
	    }
	    _disposeMeshes() {
	        this._meshes && (this._meshes.forEach(t => {
	            t.geometry.dispose(), t.dispose();
	        }), delete this._meshes);
	    }
	    dispose() {
	        this._maskColorFbo && (this._maskColorFbo.destroy(), delete this._maskColorFbo), 
	        this._maskModeFbo && (this._maskModeFbo.destroy(), delete this._maskModeFbo), this._maskColorShader && (this._maskColorShader.dispose(), 
	        delete this._maskColorShader), this._maskModeShader && (this._maskModeShader.dispose(), 
	        delete this._maskModeShader), this._disposeMeshes();
	    }
	}

	const od = [];

	class sd {
	    constructor(t, e, n) {
	        this._regl = t, this.joints = e, this.inverseBindMatrices = [], this.jointMatrices = [], 
	        this.jointData = new Float32Array(16 * e.length);
	        for (let t = 0; t < e.length; ++t) this.inverseBindMatrices.push(new Float32Array(n.buffer, n.byteOffset + 16 * Float32Array.BYTES_PER_ELEMENT * t, 16)), 
	        this.jointMatrices.push(new Float32Array(this.jointData.buffer, 16 * Float32Array.BYTES_PER_ELEMENT * t, 16));
	        this.jointTextureSize = [ 4, 6 ];
	    }
	    update(t, n) {
	        invert$2(od, t);
	        for (let t = 0; t < this.joints.length; ++t) {
	            const i = this.jointMatrices[t];
	            multiply$5(i, od, n[this.joints[t].nodeIndex]), multiply$5(i, i, this.inverseBindMatrices[t]);
	        }
	        return this._regl.texture({
	            width: 4,
	            type: "float",
	            height: this.joints.length,
	            data: this.jointData
	        });
	    }
	}

	const ad = [ 0, 0, 0 ], hd = [ 0, 0, 0, 1 ], ld = [ 1, 1, 1 ], cd = [];

	class ud {
	    constructor(t = [ 0, 0, 0 ], e = [ 0, 0, 0, 1 ], n = [ 1, 1, 1 ]) {
	        this.translation = t, this.rotation = e, this.scale = n;
	    }
	    getMatrix() {
	        return fromRotationTranslationScale(cd, this.rotation, this.translation, this.scale);
	    }
	    decompose(t) {
	        getTranslation$1(this.translation, t), getRotation(this.rotation, t), getScaling(this.scale, t);
	    }
	    update(t) {
	        t && (t.translation && !equals$4(t.translation, ad) && copy$4(this.translation, t.translation), 
	        t.rotation && !equals$2(t.rotation, hd) && copy$2(this.rotation, t.rotation), t.scale && !equals$4(t.scale, ld) && copy$4(this.scale, t.scale));
	    }
	}

	class fd {
	    constructor(t) {
	        this._init(t);
	    }
	    _init(t) {
	        this.geometry = t.geometry, this.nodeMatrix = t.nodeMatrix, this.materialInfo = t.materialInfo, 
	        this.extraInfo = t.extraInfo, this.animationMatrix = t.animationMatrix, this.morphWeights = t.morphWeights, 
	        this.skin = t.skin, this.nodeIndex = t.nodeIndex;
	    }
	    copy() {
	        this.copyGeometry || (this.copyGeometry = this._copyGeometry(this.geometry));
	    }
	    createCopyBarycentric() {
	        this.copyGeometry && !this.copyGeometry.data.aBarycentric && (this.copyGeometry.buildUniqueVertex(), 
	        this.copyGeometry.createBarycentric("aBarycentric"));
	    }
	    _copyGeometry(t) {
	        const e = t.data, n = t.elements, i = {};
	        for (const n in e) if (y$1(e[n])) i[n] = e[n].slice(); else if (e[n].buffer && e[n].buffer.destroy) i[n] = {
	            buffer: e[n].buffer
	        }, y$1(e[n].array) && (i[n].array = e[n].array.slice()); else {
	            const e = t._getAttributeData(n);
	            i[n] = n !== t.desc.positionAttribute ? e : e.slice();
	        }
	        const r = void 0 !== n.length ? n.slice() : n, o = t.count, s = JSON.parse(JSON.stringify(t.desc)), a = new Q$1(i, r, o, s);
	        return a.properties = t.properties, a;
	    }
	}

	let dd = 0;

	class md {
	    constructor(t, e) {
	        this.gltf = t, this.regl = e, this.geometries = [], e && (this._emptyTexture = e.texture({
	            width: 2,
	            height: 2
	        }));
	    }
	    getMeshesInfo() {
	        if (!this.gltf) return null;
	        if (this.geometries.length) return this.geometries;
	        this._createTextures(this.gltf.textures), this._createSkins(this.gltf.skins);
	        return this.gltf.scenes[0].nodes.forEach(t => {
	            this._parserNode(t, this.geometries);
	        }), this.geometries;
	    }
	    _createSkins(t) {
	        if (t) {
	            this._skinMap = {};
	            for (let e = 0; e < t.length; e++) {
	                const n = t[e];
	                n.joints = n.joints.map(t => this.gltf.nodes[t]), this._skinMap[e] = new sd(this.regl, n.joints, n.inverseBindMatrices.array), 
	                delete n.inverseBindMatrices;
	            }
	        }
	    }
	    _createTextures(t) {
	        if (t) {
	            this._textureMap = {};
	            for (let e = 0; e < t.length; e++) {
	                const n = t[e];
	                this._textureMap[e] || (this._textureMap[e] = this._toTexture(n), delete n.image);
	            }
	        }
	    }
	    dispose() {
	        this._emptyTexture && this._emptyTexture.destroy();
	        const t = this.getMeshesInfo();
	        if (t) {
	            t.forEach(t => {
	                t.geometry.dispose();
	                for (const e in t.materialInfo) {
	                    const n = t.materialInfo[e];
	                    n.destroy && !n[L$1] && n.destroy();
	                }
	            });
	            for (const t in this._textureMap) {
	                const e = this._textureMap[t];
	                e.destroy && !e[L$1] && e.destroy();
	            }
	            delete this.gltf;
	        }
	    }
	    updateAnimation(e, n, i, r, o, s, a) {
	        const h = this.gltf;
	        if (!h) return;
	        if (dd = h.animations ? k$2.getAnimationTimeSpan(h, r) : null, !dd) return;
	        e -= o;
	        let l = 0;
	        l = n || !n && this._isFirstLoop(e, i, r, o) ? e * i * .001 % (dd.max - dd.min) + dd.min : e * i * .001 + dd.min, 
	        h.scenes[0].nodes.forEach(t => {
	            this._updateNodeMatrix(r, l, t, null, s);
	        });
	        for (const t in this.gltf.nodes) {
	            const e = this.gltf.nodes[t], n = s[e.nodeIndex];
	            if (e.skin && n) {
	                const t = e.skin.update(n, s);
	                a[e.nodeIndex] = {
	                    jointTextureSize: [ 4, 6 ],
	                    numJoints: e.skin.joints.length,
	                    jointTexture: t
	                };
	            }
	        }
	    }
	    _isFirstLoop(e, n, i, r) {
	        const o = this.gltf;
	        return !r || !o || (dd = o.animations ? k$2.getAnimationTimeSpan(o, i) : null, 
	        e * n * .001 / (dd.max - dd.min) < 1);
	    }
	    hasSkinAnimation() {
	        return !!this._isAnimation;
	    }
	    _updateNodeMatrix(n, i, r, o, s) {
	        if (r.trs) {
	            const e = k$2.getAnimationClip(this.gltf, Number(r.nodeIndex), i, n);
	            e.weights && this._updateMorph(r, e.weights), r.trs.update(e);
	        }
	        s[r.nodeIndex] = o ? multiply$5(s[r.nodeIndex] || [], o, r.matrix || r.trs.getMatrix()) : copy$5(s[r.nodeIndex] || [], r.matrix || r.trs.getMatrix()), 
	        r.children && r.children.forEach(t => {
	            this._updateNodeMatrix(n, i, t, s[r.nodeIndex], s);
	        }), this._updateSkinTexture(r);
	    }
	    _updateMorph(t, e) {
	        const n = e.length;
	        if (!t.influencesList) {
	            t.influencesList = [];
	            for (let e = 0; e < n; e++) t.influencesList[e] = [ e, 0 ];
	        }
	        const i = t.influencesList;
	        for (let t = 0; t < i.length; t++) {
	            const n = i[t];
	            n[0] = t, n[1] = e[t];
	        }
	        i.sort(pd);
	        const r = [];
	        for (let t = 0; t < 8; t++) r[t] = [ t, 0 ];
	        for (let t = 0; t < 8; t++) t < n && i[t][1] ? (r[t][0] = i[t][0], r[t][1] = i[t][1]) : (r[t][0] = Number.MAX_SAFE_INTEGER, 
	        r[t][1] = 0);
	        r.sort(gd);
	        t.geometries.forEach(t => {
	            const e = t.properties.morphTargets;
	            for (let n = 0; n < 8; n++) {
	                const i = r[n], o = i[0], s = i[1];
	                o !== Number.MAX_SAFE_INTEGER && s ? (t.updateData("POSITION" + n, e["POSITION_" + o].array), 
	                t.properties.morphWeights[n] = s) : t.properties.morphWeights[n] = 0;
	            }
	        });
	    }
	    _updateSkinTexture(t) {
	        if (!this.gltf.joints) return;
	        const e = this.gltf.animations;
	        if (!e) return;
	        const n = this.gltf.joints.length;
	        e.forEach(e => {
	            const i = e.channels;
	            for (let e = 0; e < i.length; e++) {
	                if (i[e].target.node === t.nodeIndex) {
	                    t.skin.updateJointTexture(n);
	                }
	            }
	        });
	    }
	    _parserNode(t, n, i) {
	        if (t.isParsed) return;
	        t.nodeMatrix = t.nodeMatrix || identity$2([]), t.localMatrix = t.localMatrix || identity$2([]), 
	        t.matrix ? (t.trs = new ud, t.trs.decompose(t.matrix)) : t.trs = new ud(t.translation, t.rotation, t.scale), 
	        t.localMatrix = t.trs.getMatrix(), i ? multiply$5(t.nodeMatrix, i, t.matrix || t.localMatrix) : copy$5(t.nodeMatrix, t.matrix || t.localMatrix);
	        const r = t.nodeMatrix;
	        if (t.children) for (let e = 0; e < t.children.length; e++) {
	            this._parserNode(t.children[e], n, r);
	        }
	        if (f(t.skin)) {
	            this._isAnimation = !0;
	            const e = t.skin;
	            t.trs = new ud, t.skin = this._skinMap[e];
	        }
	        if (f(t.mesh)) {
	            t.mesh = this.gltf.meshes[t.mesh], t.mesh.node = t, t.geometries = t.geometries || [], 
	            t.mesh.primitives.forEach(e => {
	                const i = function(t, e) {
	                    const n = t.attributes, i = n.COLOR_0;
	                    if (i && i.array instanceof Float32Array) {
	                        const t = new Uint8Array(i.array.length);
	                        for (let e = 0; e < t.length; e++) t[e] = Math.round(255 * i.array[e]);
	                        i.array = t;
	                    } else if (i && i.array instanceof Uint16Array) {
	                        const t = new Uint8Array(i.array);
	                        i.array = t;
	                    }
	                    const r = {};
	                    for (const t in n) r[t] = g({}, n[t]), e && (r[t].buffer = Nt$1(e, n[t], {
	                        dimension: n[t].itemSize
	                    }));
	                    if (t.morphTargets) {
	                        const t = E$1(r.POSITION) ? r.POSITION.itemSize * r.POSITION.count : r.POSITION.array.length;
	                        for (let e = 0; e < 8; e++) r["POSITION" + e] || (r["POSITION" + e] = new Float32Array(t).fill(0));
	                        for (let t = 0; t < 4; t++) {
	                            const e = r.NORMAL.array ? r.NORMAL.array.length : r.NORMAL.length;
	                            r["NORMAL" + t] || (r["NORMAL" + t] = new Float32Array(e).fill(0));
	                        }
	                    }
	                    let o = t.indices;
	                    o && void 0 === o.bufferView && o.array && (o = o.array);
	                    const s = new Q$1(r, o, 0, {
	                        primitive: _$2(t.mode) ? Pt$1(t.mode) : t.mode,
	                        positionAttribute: "POSITION",
	                        normalAttribute: "NORMAL",
	                        uv0Attribute: "TEXCOORD_0",
	                        uv1Attribute: "TEXCOORD_1",
	                        color0Attribute: "COLOR_0"
	                    });
	                    t.morphTargets && (s.properties.morphWeights = []);
	                    t.mode > 3 && !s.data.NORMAL && s.createNormal("NORMAL");
	                    return s;
	                }(e, this.regl);
	                i.properties.morphTargets = e.morphTargets, t.geometries.push(i);
	                const o = this._createMaterialInfo(e.material), s = {
	                    geometry: i,
	                    nodeMatrix: r,
	                    materialInfo: o,
	                    extraInfo: this._createExtralInfo(e.material),
	                    animationMatrix: t.trs.getMatrix(),
	                    morphWeights: t.weights,
	                    nodeIndex: t.nodeIndex
	                };
	                t.skin && (s.skin = {
	                    jointTextureSize: [ 4, 6 ],
	                    numJoints: t.skin.joints.length,
	                    jointTexture: t.skin.jointTexture
	                });
	                const a = new fd(s);
	                n.push(a);
	            });
	        }
	        t.isParsed = !0;
	    }
	    _createMaterialInfo(t) {
	        const e = {};
	        if (this.gltf.materials && this.gltf.materials[t]) {
	            const n = this.gltf.materials[t], i = n.pbrMetallicRoughness;
	            if (i) {
	                const t = i.metallicRoughnessTexture, n = i.baseColorTexture;
	                n && (e.baseColorTexture = this._getTexture(n), n.KHR_texture_transform && (e.khr_offset = n.KHR_texture_transform.offset || [ 0, 0 ], 
	                e.khr_rotation = n.KHR_texture_transform.rotation || 0, e.khr_scale = n.KHR_texture_transform.scale || [ 1, 1 ])), 
	                i.baseColorFactor && (e.baseColorFactor = i.baseColorFactor), t ? e.metallicRoughnessTexture = this._getTexture(t) : (f(i.metallicFactor) && (e.metallicFactor = i.metallicFactor), 
	                f(i.roughnessFactor) && (e.roughnessFactor = i.roughnessFactor));
	            }
	            const r = n.extensions;
	            if (r && r.KHR_materials_pbrSpecularGlossiness) {
	                const t = r.KHR_materials_pbrSpecularGlossiness;
	                e.name = "pbrSpecularGlossiness";
	                for (const n in t) e[n] = f(t[n].index) ? this._getTexture(t[n]) : t[n];
	            }
	            n.normalTexture && (e.normalTexture = this._getTexture(n.normalTexture)), n.occlusionTexture && (e.occlusionTexture = this._getTexture(n.occlusionTexture)), 
	            n.emissiveTexture && (e.emissiveTexture = this._getTexture(n.emissiveTexture)), 
	            n.emissiveFactor && (e.emissiveFactor = n.emissiveFactor), e.alphaCutoff = n.alphaCutoff || .5;
	        }
	        return e;
	    }
	    _createExtralInfo(t) {
	        const e = {};
	        if (this.gltf.materials && this.gltf.materials[t]) {
	            const n = this.gltf.materials[t];
	            e.doubleSided = n.doubleSided, e.alphaMode = n.alphaMode || "OPAQUE";
	        }
	        return e;
	    }
	    _getTexture(t) {
	        const e = t.extensions, n = t.index;
	        if (!f(n)) return null;
	        e && e.KHR_texture_transform && (t.KHR_texture_transform = e.KHR_texture_transform);
	        const i = this._textureMap[n];
	        return i.texInfo = t, i;
	    }
	    _toTexture(t) {
	        if (!t) return this._emptyTexture;
	        const e = t.sampler || {};
	        return new Vt$1({
	            width: t.image.width,
	            height: t.image.height,
	            data: t.image.array,
	            mag: kt$1(e.magFilter) || "linear",
	            min: Lt$1(e.minFilter) || "linear",
	            wrapS: Ft$1(e.wrapS) || "repeat",
	            wrapT: Ft$1(e.wrapT) || "repeat"
	        });
	    }
	}

	function gd(t, e) {
	    return t[0] - e[0];
	}

	function pd(t, e) {
	    return Math.abs(e[1]) - Math.abs(t[1]);
	}

	function _d(e) {
	    const n = e.lastIndexOf("/"), i = e.slice(0, n), r = e.slice(e.lastIndexOf(".")).toLowerCase();
	    return ".gltf" === r ? function(e, n) {
	        return w$2.getJSON(e, n);
	    }(e, {}).then(t => yd(i, t)) : ".glb" === r ? function(e, n) {
	        return w$2.getArrayBuffer(e, n);
	    }(e, {}).then(t => yd(i, {
	        buffer: t.data,
	        byteOffset: 0
	    })) : null;
	}

	function vd(t, e) {
	    return new md(t, e);
	}

	function yd(e, n) {
	    return new k$2(e, n).load();
	}

	var xd = Object.freeze({
	    __proto__: null,
	    load: _d,
	    exportGLTFPack: vd,
	    loadGLTF: yd
	});

	const bd = [ -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, 1 ], wd = [ 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0 ], Cd = [ 3, 1, 0, 0, 2, 3 ], Md = [ 0, 0, 1, 0, 0, 1, 1, 1 ], Td = {
	    vertices: [ -.8111000061035156, 2.0102999210357666, -.8111000061035156, 0, .010300000198185444, -0, -.8111000061035156, 2.0102999210357666, .8111000061035156, -.8111000061035156, 2.0102999210357666, .8111000061035156, 0, .010300000198185444, -0, .8111000061035156, 2.0102999210357666, .8111000061035156, .8111000061035156, 2.0102999210357666, .8111000061035156, 0, .010300000198185444, -0, .8111000061035156, 2.0102999210357666, -.8111000061035156, .8111000061035156, 2.0102999210357666, -.8111000061035156, 0, .010300000198185444, -0, -.8111000061035156, 2.0102999210357666, -.8111000061035156, .8111000061035156, 2.0102999210357666, -.8111000061035156, -.8111000061035156, 2.0102999210357666, -.8111000061035156, 0, 2.9419000148773193, -0, .8111000061035156, 2.0102999210357666, .8111000061035156, .8111000061035156, 2.0102999210357666, -.8111000061035156, 0, 2.9419000148773193, -0, -.8111000061035156, 2.0102999210357666, -.8111000061035156, -.8111000061035156, 2.0102999210357666, .8111000061035156, 0, 2.9419000148773193, -0, -.8111000061035156, 2.0102999210357666, .8111000061035156, .8111000061035156, 2.0102999210357666, .8111000061035156, 0, 2.9419000148773193, -0 ],
	    normals: [ -.9267006516456604, -.3758002817630768, -0, -.9267006516456604, -.3758002817630768, -0, -.9267006516456604, -.3758002817630768, -0, 0, -.3758002817630768, .9267006516456604, 0, -.3758002817630768, .9267006516456604, 0, -.3758002817630768, .9267006516456604, .9267006516456604, -.3758002817630768, -0, .9267006516456604, -.3758002817630768, -0, .9267006516456604, -.3758002817630768, -0, 0, -.3758002817630768, -.9267006516456604, 0, -.3758002817630768, -.9267006516456604, 0, -.3758002817630768, -.9267006516456604, 0, .656676173210144, -.7541726231575012, 0, .656676173210144, -.7541726231575012, 0, .656676173210144, -.7541726231575012, .7541726231575012, .656676173210144, -0, .7541726231575012, .656676173210144, -0, .7541726231575012, .656676173210144, -0, -.7541726231575012, .656676173210144, -0, -.7541726231575012, .656676173210144, -0, -.7541726231575012, .656676173210144, -0, 0, .656676173210144, .7541726231575012, 0, .656676173210144, .7541726231575012, 0, .656676173210144, .7541726231575012 ],
	    indices: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23 ]
	}, Sd = {
	    cube: {
	        meshes: [ {
	            primitives: [ {
	                attributes: {
	                    POSITION: {
	                        array: new Int8Array([ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1 ])
	                    },
	                    NORMAL: {
	                        array: new Int8Array([ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1 ])
	                    }
	                },
	                indices: new Uint16Array([ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23 ]),
	                mode: 4
	            } ]
	        } ],
	        scenes: [ {
	            nodes: [ {
	                mesh: 0
	            } ]
	        } ]
	    },
	    plane: {
	        meshes: [ {
	            primitives: [ {
	                attributes: {
	                    POSITION: {
	                        array: new Int8Array(bd)
	                    },
	                    NORMAL: {
	                        array: new Int8Array(wd)
	                    },
	                    TEXCOORD_0: {
	                        array: new Int8Array(Md)
	                    }
	                },
	                indices: new Uint16Array(Cd),
	                mode: 4
	            } ]
	        } ],
	        scenes: [ {
	            nodes: [ {
	                mesh: 0
	            } ]
	        } ]
	    },
	    pyramid: {
	        meshes: [ {
	            primitives: [ {
	                attributes: {
	                    POSITION: {
	                        array: new Float32Array(Td.vertices)
	                    },
	                    NORMAL: {
	                        array: new Float32Array(Td.normals)
	                    },
	                    TEXCOORD_0: {
	                        array: new Float32Array(Td.uv)
	                    }
	                },
	                indices: new Uint16Array(Td.indices),
	                mode: 4
	            } ]
	        } ],
	        scenes: [ {
	            nodes: [ {
	                mesh: 0
	            } ]
	        } ]
	    }
	};

	class Pd {
	    constructor(t, e) {
	        this.regl = t, this.resourceMap = {}, this._requestor = e;
	    }
	    getGLTF(t) {
	        return this.resourceMap[t];
	    }
	    loginGLTF(t) {
	        if (this.resourceMap[t]) this.resourceMap[t].refCount += 1; else {
	            if (Sd[t]) {
	                const e = function(t) {
	                    let e = null;
	                    return Sd[t] && (e = {
	                        meshes: Sd[t].meshes
	                    }, e.scenes = JSON.parse(JSON.stringify(Sd[t].scenes))), e;
	                }(t);
	                this.resourceMap[t] = this._exportGLTFResource(e, t, !1);
	            } else this.resourceMap[t] = this._requestor ? this._requestor(t).then(e => {
	                const n = this._exportGLTFResource(e, t);
	                return this.resourceMap[t] = n, n;
	            }) : this._loadGLTFModel(t).catch(t => t);
	            this.resourceMap[t].refCount = 1;
	        }
	    }
	    logoutGLTF(t) {
	        if (this.resourceMap[t] && (this.resourceMap[t].refCount -= 1, this.resourceMap[t].refCount < 1)) {
	            const e = this.resourceMap[t].resources;
	            if (e) for (let t = 0; t < e.length; t++) e[t].geometry.dispose(), e[t].copyGeometry && e[t].copyGeometry.dispose(), 
	            e[t].material && e[t].material.dispose();
	            this.resourceMap[t].gltfPack && this.resourceMap[t].gltfPack.dispose(), delete this.resourceMap[t];
	        }
	    }
	    isSimpleModel(t) {
	        return Sd[t];
	    }
	    _exportGLTFResource(t, e, n = !0) {
	        const i = vd(t, n ? this.regl : null), r = i.getMeshesInfo();
	        return {
	            gltfPack: i,
	            resources: r,
	            json: {
	                asset: t.asset,
	                animations: t.animations ? t.animations.map(t => ({
	                    name: t.name
	                })) : null
	            },
	            refCount: this.resourceMap[e] ? this.resourceMap[e].refCount : 0
	        };
	    }
	    _loadData(t) {
	        return _d(t).then(t => t);
	    }
	    _loadGLTFModel(t) {
	        return this._loadData(t).then(e => (this.resourceMap[t] = this._exportGLTFResource(e, t), 
	        this.resourceMap[t]));
	    }
	}

	const Ad = function() {
	    const t = [ 0, 0, 0 ], n = 90 * Math.PI / 180, i = [ 0, 0, 0, 0 ], r = new Array(16);
	    return function(o, s, a, h, l, c) {
	        const u = [ lookAt([], t, [ 1, 0, 0 ], c && c[0] || [ 0, -1, 0 ]), lookAt([], t, [ -1, 0, 0 ], c && c[1] || [ 0, -1, 0 ]), lookAt([], t, [ 0, 1, 0 ], c && c[2] || [ 0, 0, 1 ]), lookAt([], t, [ 0, -1, 0 ], c && c[3] || [ 0, 0, -1 ]), lookAt([], t, [ 0, 0, 1 ], c && c[4] || [ 0, -1, 0 ]), lookAt([], t, [ 0, 0, -1 ], c && c[5] || [ 0, -1, 0 ]) ], f = {
	            context: {
	                viewMatrix: function(t, e, n) {
	                    return u[n];
	                },
	                projMatrix: perspective(r, n, 1, .5, 1.1)
	            }
	        };
	        s && (f.framebuffer = s.faces ? function(t, e, n) {
	            return s.faces[n];
	        } : s);
	        return o(f)(6, (t, e, n) => {
	            const r = {
	                color: i,
	                depth: 1
	            };
	            s && (r.framebuffer = s.faces ? s.faces[n] : s), o.clear(r), a(h), l && l();
	        }), s;
	    };
	}();

	var Ed = {
	    vertices: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1 ],
	    textures: [ 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0 ],
	    indices: [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23 ]
	}, Od = "#define SHADER_NAME CUBE_MAP\nattribute vec3 aPosition;\nvarying vec3 vWorldPos;\nuniform mat4 projMatrix;\nuniform mat4 viewMatrix;\nvoid main() {\n  vWorldPos = aPosition;\n  gl_Position = projMatrix * viewMatrix * vec4(vWorldPos, 1.);\n}", Rd = "precision highp float;\n#define PI 3.1415926\nvarying vec3 vWorldPos;\nuniform sampler2D equirectangularMap;\nconst vec2 c = vec2(.1591, .3183);\nvec2 d(vec3 e) {\n  vec2 f = vec2(atan(e.y, e.x), asin(e.z));\n  f *= c;\n  f += .5;\n  return f;\n}\nvec3 h(const in vec4 i, const in float j) {\n  return j * i.rgb * i.a;\n}\nvec4 k(const in vec3 i, const in float j) {\n  vec4 l;\n  vec3 m = i / j;\n  l.a = clamp(max(max(m.r, m.g), max(m.b, 1e-6)), .0, 1.);\n  l.a = ceil(l.a * 255.) / 255.;\n  l.rgb = m / l.a;\n  return l;\n}\nvoid main() {\n  vec2 f = d(normalize(vWorldPos));\n  vec4 i = texture2D(equirectangularMap, f);\n#ifdef INPUT_RGBM\ngl_FragColor = i;\n#else\ngl_FragColor = vec4(h(i, 7.), 1.);\n#endif\n}";

	/*!
	 * from claygl
	 * https://github.com/pissang/claygl/
	 * License: BSD-2-Clause
	 */
	function Id(t, e) {
	    var n = t[0], i = t[1], r = t[2];
	    return 0 === e ? 1 : 1 === e ? n : 2 === e ? i : 3 === e ? r : 4 === e ? n * r : 5 === e ? i * r : 6 === e ? n * i : 7 === e ? 3 * r * r - 1 : n * n - i * i;
	}

	var kd = {
	    px: [ 2, 1, 0, -1, -1, 1 ],
	    nx: [ 2, 1, 0, 1, -1, -1 ],
	    py: [ 0, 2, 1, 1, -1, -1 ],
	    ny: [ 0, 2, 1, 1, 1, 1 ],
	    pz: [ 0, 1, 2, -1, -1, -1 ],
	    nz: [ 0, 1, 2, 1, -1, 1 ]
	}, Dd = [ "px", "nx", "py", "ny", "pz", "nz" ];

	const Ld = Xt$1.compile(Le);

	function zd(t, e, n) {
	    const i = t({
	        frag: Ld,
	        vert: Od,
	        attributes: {
	            aPosition: Ed.vertices
	        },
	        uniforms: {
	            projMatrix: t.context("projMatrix"),
	            viewMatrix: t.context("viewMatrix"),
	            cubeMap: e,
	            environmentExposure: 1,
	            bias: 0,
	            size: n,
	            hsv: [ 0, 0, 0 ]
	        },
	        elements: Ed.indices
	    }), r = [], o = t.framebuffer(n);
	    return Ad(t, o, i, {
	        size: n
	    }, (function() {
	        const e = t.read();
	        r.push(new e.constructor(e));
	    })), i.destroy(), o.destroy(), r;
	}

	const Fd = new Int8Array([ -1, 1, 0, -1, -1, 0, 1, 1, 0, 1, -1, 0 ]), jd = new Int8Array([ 0, 1, 0, 0, 1, 1, 1, 0 ]);

	function Hd(t, e, n, i) {
	    e = e || 256;
	    const r = Nd(n = n || 1024, i = i || 256), o = t.texture({
	        data: r,
	        width: i,
	        height: n,
	        min: "nearest",
	        mag: "nearest"
	    }), s = t.buffer(Fd), a = t.buffer(jd), h = t.framebuffer({
	        radius: e,
	        colorType: "uint8",
	        colorFormat: "rgba",
	        min: "linear",
	        mag: "linear"
	    }), l = t({
	        frag: "precision mediump float;\nvarying vec2 vTexCoords;\nuniform sampler2D distributionMap;\nconst float c = 3.14159265359;\nvec4 d(float a, float b) {\n  a *= 65535.;\n  b *= 65535.;\n  vec4 rgba;\n  rgba[0] = mod(a, 255.);\n  rgba[1] = (a - rgba[0]) / 65280.0;\n  rgba[2] = mod(b, 255.);\n  rgba[3] = (b - rgba[2]) / 65280.0;\n  return rgba;\n}\nvec3 e(float f, vec3 h, float i) {\n  vec4 j = texture2D(distributionMap, vec2(i, f));\n  vec3 k = j.xyz;\n  float l = sign(j.w - .5);\n  float m = sign(j.w - clamp(l, .0, 1.) * 200.0 / 255. - .15);\n  k.x *= l;\n  k.y *= m;\n  vec3 n = abs(h.z) < .999 ? vec3(.0, .0, 1.) : vec3(1., .0, .0);\n  vec3 o = normalize(cross(n, h));\n  vec3 u = cross(h, o);\n  vec3 v = o * k.x + u * k.y + h * k.z;\n  return normalize(v);\n}\nfloat A(float B, float i) {\n  float a = i;\n  float C = (a * a) / 2.;\n  float D = B;\n  float E = B * (1. - C) + C;\n  return D / E;\n}\nfloat F(float B, float G, float i) {\n  float I = A(B, i);\n  float J = A(G, i);\n  return J * I;\n}\nvec2 K(float B, float i) {\n  vec3 L;\n  L.x = sqrt(1. - B * B);\n  L.y = .0;\n  L.z = B;\n  float M = .0;\n  float O = .0;\n  vec3 h = vec3(.0, .0, 1.);\n  const int P = 1024;\n  for(int Q = 0; Q < P; ++Q) {\n    vec3 k = e(float(Q) / float(P), h, i);\n    vec3 R = normalize(2. * dot(L, k) * k - L);\n    float G = max(R.z, .0);\n    float S = max(k.z, .0);\n    float T = max(dot(L, k), .0);\n    float B = max(dot(h, L), .0);\n    if(G > .0) {\n      float U = F(B, G, i);\n      float W = (U * T) / (S * B);\n      float X = pow(1. - T, 5.);\n      M += (1. - X) * W;\n      O += X * W;\n    }\n  }\n  M /= float(P);\n  O /= float(P);\n  return vec2(M, O);\n}\nvoid main() {\n  vec2 Y = K(vTexCoords.x, vTexCoords.y);\n  gl_FragColor = d(Y.x, Y.y);\n}",
	        vert: "attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoords;\nvoid main() {\n  vTexCoords = aTexCoord;\n  gl_Position = vec4(aPosition, 1.);\n}",
	        attributes: {
	            aPosition: {
	                buffer: s
	            },
	            aTexCoord: {
	                buffer: a
	            }
	        },
	        uniforms: {
	            distributionMap: o
	        },
	        framebuffer: h,
	        viewport: {
	            x: 0,
	            y: 0,
	            width: e,
	            height: e
	        },
	        count: Fd.length / 3,
	        primitive: "triangle strip"
	    });
	    return l(), l.destroy(), s.destroy(), a.destroy(), o.destroy(), h;
	}

	function Nd(t, e) {
	    const n = new Array(t * e * 4);
	    for (let i = 0; i < t; i++) {
	        const {x: r, y: o} = Bd(i, t);
	        for (let t = 0; t < e; t++) {
	            const s = t / e, a = s * s, h = 2 * Math.PI * r, l = Math.sqrt((1 - o) / (1 + (a * a - 1) * o)), c = Math.sqrt(1 - l * l), u = 4 * (i * e + t), f = c * Math.cos(h), d = c * Math.sin(h);
	            n[u] = Math.abs(255 * f), n[u + 1] = Math.abs(255 * d), n[u + 2] = 255 * l, n[u + 3] = (f > 0 ? 200 : 0) + (d > 0 ? 55 : 0);
	        }
	    }
	    return n;
	}

	function Bd(t, e) {
	    let n = (t << 16 | t >>> 16) >>> 0;
	    return n = ((1431655765 & n) << 1 | (2863311530 & n) >>> 1) >>> 0, n = ((858993459 & n) << 2 | (3435973836 & n) >>> 2) >>> 0, 
	    n = ((252645135 & n) << 4 | (4042322160 & n) >>> 4) >>> 0, n = (((16711935 & n) << 8 | (4278255360 & n) >>> 8) >>> 0) / 4294967296, 
	    {
	        x: t / e,
	        y: n
	    };
	}

	var Gd = Object.freeze({
	    __proto__: null,
	    createIBLMaps: function(t, e = {}) {
	        const i = e.envTexture, r = e.envCubeSize || 512, o = e.sampleSize || 1024, s = e.roughnessLevels || 256, a = e.prefilterCubeSize || 256;
	        let h;
	        if (Array.isArray(i)) {
	            const n = t.cube({
	                flipY: !0,
	                faces: i
	            });
	            h = function(t, e, n, i, r) {
	                const o = t({
	                    frag: i ? "#define ENC_RGBM 1\n" + Ld : Ld,
	                    vert: Od,
	                    attributes: {
	                        aPosition: Ed.vertices
	                    },
	                    uniforms: {
	                        hsv: [ 0, 0, 0 ],
	                        projMatrix: t.context("projMatrix"),
	                        viewMatrix: t.context("viewMatrix"),
	                        cubeMap: e,
	                        bias: 0,
	                        size: e.width,
	                        environmentExposure: 1,
	                        rgbmRange: r
	                    },
	                    elements: Ed.indices
	                }), s = t.cube({
	                    width: n,
	                    height: n,
	                    min: "linear",
	                    mag: "linear",
	                    format: "rgba"
	                }), a = t.framebufferCube({
	                    radius: n,
	                    color: s
	                });
	                return Ad(t, a, o, {
	                    size: n
	                }, null, [ [ 0, 0, -1 ], [ 0, 0, -1 ], [ 0, 0, 1 ], [ 0, 0, 1 ], [ 0, -1, 0 ], [ 0, -1, 0 ] ]), 
	                o.destroy(), a;
	            }(t, n, r, !0, e.rgbmRange), n.destroy();
	        } else h = function(t, e, n, i) {
	            n = n || 512;
	            const r = t({
	                frag: i ? "#define INPUT_RGBM 1\n" + Rd : Rd,
	                vert: Od,
	                attributes: {
	                    aPosition: Ed.vertices
	                },
	                uniforms: {
	                    projMatrix: t.context("projMatrix"),
	                    viewMatrix: t.context("viewMatrix"),
	                    equirectangularMap: e
	                },
	                elements: Ed.indices
	            }), o = t.cube({
	                width: n,
	                height: n,
	                min: "linear",
	                mag: "linear",
	                format: "rgba"
	            }), s = t.framebufferCube({
	                radius: n,
	                color: o
	            });
	            return Ad(t, s, r), r.destroy(), s;
	        }(t, i, r, !0);
	        const {prefilterMap: l, prefilterMipmap: c} = function(t, e, n, i, r, o) {
	            const s = function(t, e, n, i, r, o) {
	                const s = Nd(r = r || 1024, o = o || 256), a = t.texture({
	                    data: s,
	                    width: o,
	                    height: r,
	                    min: "nearest",
	                    mag: "nearest"
	                }), h = t({
	                    frag: "#define SHADER_NAME PBR_prefilter\nprecision highp float;\nvarying vec3 vWorldPos;\nuniform samplerCube environmentMap;\nuniform sampler2D distributionMap;\nuniform float roughness;\nuniform float resolution;\nuniform float rgbmRange;\nconst float c = 3.14159265359;\nfloat d(vec3 e, vec3 f, float h) {\n  float a = h * h;\n  float i = a * a;\n  float j = max(dot(e, f), .0);\n  float k = j * j;\n  float l = i;\n  float m = (k * (i - 1.) + 1.);\n  m = c * m * m;\n  return l / m;\n}\nvec3 n(float o, vec3 e, float h) {\n  vec4 u = texture2D(distributionMap, vec2(h, o));\n  vec3 f = u.xyz;\n  float v = sign(u.w - .5);\n  float A = sign(u.w - 200.0 / 255. * clamp(v, .0, 1.) - .15);\n  f.x *= v;\n  f.y *= A;\n  vec3 B = abs(e.z) < .999 ? vec3(.0, .0, 1.) : vec3(1., .0, .0);\n  vec3 C = normalize(cross(B, e));\n  vec3 D = cross(e, C);\n  vec3 E = C * f.x + D * f.y + e * f.z;\n  return normalize(E);\n}\nvec4 F(const in vec3 G, const in float I) {\n  if(I <= .0)\n    return vec4(G, 1.);\n  vec4 J;\n  vec3 K = G / I;\n  J.a = clamp(max(max(K.r, K.g), max(K.b, 1e-6)), .0, 1.);\n  J.a = ceil(J.a * 255.) / 255.;\n  J.rgb = K / J.a;\n  return J;\n}\nvec3 L(const in vec4 G, const in float I) {\n  if(I <= .0)\n    return G.rgb;\n  return I * G.rgb * G.a;\n}\nvoid main() {\n  vec3 e = normalize(vWorldPos);\n  vec3 M = e;\n  vec3 O = M;\n  const int P = 1024;\n  vec3 Q = vec3(.0);\n  float S = .0;\n  for(int T = 0; T < P; ++T) {\n    vec3 f = n(float(T) / float(P), e, roughness);\n    vec3 U = normalize(2. * dot(O, f) * f - O);\n    float W = max(dot(e, U), .0);\n    if(W > .0) {\n      Q += L(textureCube(environmentMap, U), rgbmRange).rgb * W;\n      S += W;\n    }\n  }\n  Q = Q / S;\n  gl_FragColor = F(Q, rgbmRange);\n}",
	                    vert: Od,
	                    attributes: {
	                        aPosition: Ed.vertices
	                    },
	                    uniforms: {
	                        projMatrix: t.context("projMatrix"),
	                        viewMatrix: t.context("viewMatrix"),
	                        environmentMap: e,
	                        distributionMap: a,
	                        roughness: t.prop("roughness"),
	                        resolution: i,
	                        rgbmRange: n || 7
	                    },
	                    elements: Ed.indices,
	                    viewport: {
	                        x: 0,
	                        y: 0,
	                        width: t.prop("size"),
	                        height: t.prop("size")
	                    }
	                });
	                let l = i;
	                const c = t.texture({
	                    radius: i,
	                    min: "linear",
	                    mag: "linear"
	                }), u = t.framebuffer({
	                    radius: i,
	                    color: c
	                }), f = Math.log(l) / Math.log(2), d = [];
	                for (let e = 0; e <= f; e++) {
	                    let n = 0;
	                    Ad(t, u, h, {
	                        roughness: e / (f - 1),
	                        size: l
	                    }, (function() {
	                        const e = t.read({
	                            framebuffer: u
	                        });
	                        d[n] || (d[n] = {
	                            mipmap: []
	                        }), d[n].mipmap.push(e), n++;
	                    })), l /= 2, u.resize(l);
	                }
	                return a.destroy(), u.destroy(), h.destroy(), d;
	            }(t, e, n, i, r, o);
	            return {
	                prefilterMap: t.cube({
	                    radius: i,
	                    min: "linear mipmap linear",
	                    mag: "linear",
	                    faces: s
	                }),
	                prefilterMipmap: s
	            };
	        }(t, h, e.rgbmRange, a, o, s);
	        let u;
	        if (!e.ignoreSH) {
	            const e = a;
	            u = function(t, e, i) {
	                for (var r = new Array(9), o = [], s = [], a = [], h = 0; h < 9; h++) {
	                    for (var l = [ 0, 0, 0 ], c = 0; c < Dd.length; c++) {
	                        for (var u = t[c], f = [ 0, 0, 0 ], d = 0, m = 0, g = kd[Dd[c]], p = 0; p < i; p++) for (var _ = 0; _ < e; _++) {
	                            o[0] = _ / (e - 1) * 2 - 1, o[1] = p / (i - 1) * 2 - 1, o[2] = -1, normalize$4(o, o), 
	                            a[0] = o[g[0]] * g[3], a[1] = o[g[1]] * g[4], a[2] = o[g[2]] * g[5], s[0] = u[m++] / 255, 
	                            s[1] = u[m++] / 255, s[2] = u[m++] / 255;
	                            var v = u[m++] / 255 * 7;
	                            s[0] *= v, s[1] *= v, s[2] *= v, scaleAndAdd$2(f, f, s, Id(a, h) * -o[2]), d += -o[2];
	                        }
	                        scaleAndAdd$2(l, l, f, 1 / d);
	                    }
	                    r[h] = scale$4(l, l, 1 / 6);
	                }
	                return r;
	            }(zd(t, l, e), e, e);
	            const i = [];
	            for (let t = 0; t < u.length; t++) i.push(...u[t]);
	            u = i;
	        }
	        const f = {
	            rgbmRange: e.rgbmRange,
	            envMap: h,
	            prefilterMap: l
	        };
	        return u && (f.sh = u), "array" === e.format && (f.envMap = {
	            width: h.width,
	            height: h.height,
	            faces: zd(t, h, r)
	        }, f.prefilterMap = {
	            width: l.width,
	            height: l.height,
	            faces: c
	        }, h.destroy(), l.destroy()), f;
	    },
	    generateDFGLUT: Hd
	});

	const Vd = {
	    uvScale: [ 1, 1 ],
	    uvOffset: [ 0, 0 ],
	    uvRotation: 0,
	    baseColorFactor: [ 1, 1, 1, 1 ],
	    emissiveFactor: [ 0, 0, 0 ],
	    baseColorIntensity: 1,
	    anisotropyDirection: 0,
	    anisotropyFactor: 0,
	    clearCoatFactor: 0,
	    clearCoatIor: 1.4,
	    clearCoatRoughnessFactor: .04,
	    clearCoatThickness: 5,
	    emitColorFactor: 1,
	    occlusionFactor: 1,
	    roughnessFactor: .4,
	    metallicFactor: 0,
	    normalMapFactor: 1,
	    specularF0: .5,
	    emitMultiplicative: 1,
	    normalMapFlipY: 0,
	    outputSRGB: 1,
	    baseColorTexture: null,
	    normalTexture: null,
	    occlusionTexture: null,
	    metallicRoughnessTexture: null,
	    emissiveTexture: null,
	    uvOrigin: [ 0, 0 ],
	    noiseTexture: null,
	    clearCoatTint: [ .006, .006, .006 ],
	    specularAAVariance: 20,
	    specularAAThreshold: 20,
	    hsv: [ 0, 0, 0 ],
	    contrast: 1,
	    bumpTexture: null,
	    bumpScale: .05,
	    bumpMinLayers: 5,
	    bumpMaxLayers: 20
	};

	class Ud extends tt$1 {
	    constructor(t) {
	        const e = g({}, Vd);
	        (t.metallicRoughnessTexture || t.metallicRoughnessTexture) && (e.roughnessFactor = 1, 
	        e.metallicFactor = 1), super(t, e);
	    }
	    appendDefines(t, e) {
	        super.appendDefines(t, e);
	        const n = this.uniforms;
	        n.GAMMA_CORRECT_INPUT && (t.GAMMA_CORRECT_INPUT = 1), e.data[e.desc.colorAttribute] && (t.HAS_COLOR = 1);
	        return e.data[e.desc.color0Attribute] && (t.HAS_COLOR0 = 1, t.COLOR0_SIZE = e.getColor0Size()), 
	        e.data[e.desc.tangentAttribute] ? t.HAS_TANGENT = 1 : e.data[e.desc.normalAttribute] && (t.HAS_NORMAL = 1), 
	        e.data[e.desc.uv0Attribute] ? (n.baseColorTexture && (t.HAS_ALBEDO_MAP = 1), n.metallicRoughnessTexture && (t.HAS_METALLICROUGHNESS_MAP = 1), 
	        n.occlusionTexture && (t.HAS_AO_MAP = 1), n.emissiveTexture && (t.HAS_EMISSIVE_MAP = 1), 
	        n.normalTexture && (t.HAS_NORMAL_MAP = 1), n.bumpTexture && (t.HAS_BUMP_MAP = 1), 
	        (t.HAS_ALBEDO_MAP || t.HAS_METALLICROUGHNESS_MAP || t.HAS_AO_MAP || t.HAS_EMISSIVE_MAP || t.HAS_NORMAL_MAP || t.HAS_BUMP_MAP) && (t.HAS_MAP = 1), 
	        n.noiseTexture && (t.HAS_RANDOM_TEX = 1), e.data[e.desc.tangentAttribute] ? t.HAS_TANGENT = 1 : e.data[e.desc.normalAttribute] && (t.HAS_NORMAL = 1), 
	        t) : t;
	    }
	}

	class Wd extends(ht$1(Ud)){}

	function Zd(t, e, n) {
	    if (n.ambientUpdate) {
	        const {iblTexes: i} = t;
	        if (i) {
	            const r = n.target;
	            qd(i), t.iblTexes = Jd(e, r);
	        } else {
	            t.iblTexes = Jd(e, n.target);
	        }
	    }
	}

	const Xd = [ 0, 0 ];

	function Jd(t, e) {
	    const n = e.getLightManager().getAmbientResource();
	    return n ? {
	        prefilterMap: t.cube({
	            width: n.prefilterMap.width,
	            height: n.prefilterMap.height,
	            faces: n.prefilterMap.faces,
	            min: "linear mipmap linear",
	            mag: "linear",
	            format: "rgba"
	        }),
	        sh: n.sh,
	        rgbmRange: n.rgbmRange
	    } : null;
	}

	function qd(t) {
	    for (const e in t) t[e].destroy && t[e].destroy(), delete t[e];
	}

	var Yd = Object.freeze({
	    __proto__: null,
	    loginIBLResOnCanvas: function(t, e, n) {
	        if (!t.dfgLUT && (t.dfgLUT = Hd(e), t.dfgLUT.mtkRefCount = 0, n)) {
	            const i = Zd.bind(this, t, e);
	            n.on("updatelights", i), t._iblResListener = i;
	        }
	        t.dfgLUT.mtkRefCount++;
	        const i = n.getLightManager();
	        return i && i.getAmbientResource() ? (t.iblTexes || (t.iblTexes = Jd(e, n)), {
	            dfgLUT: t.dfgLUT,
	            iblTexes: t.iblTexes
	        }) : {
	            dfgLUT: t.dfgLUT,
	            iblTexes: null
	        };
	    },
	    getIBLResOnCanvas: function(t) {
	        const {dfgLUT: e, iblTexes: n} = t;
	        return {
	            dfgLUT: e,
	            iblTexes: n
	        };
	    },
	    logoutIBLResOnCanvas: function(t, e) {
	        let n = !1;
	        if (t.dfgLUT && (t.dfgLUT.mtkRefCount--, t.dfgLUT.mtkRefCount <= 0)) {
	            if (n = !0, e) {
	                e.off("updatelights", t._iblResListener);
	            }
	            t.dfgLUT.destroy(), delete t.dfgLUT;
	        }
	        t.iblTexes && n && (qd(t.iblTexes), delete t.iblTexes);
	    },
	    getPBRUniforms: function(t, e, n, i, r) {
	        const o = t.viewMatrix, s = t.projMatrix, a = t.cameraPosition, h = t.getRenderer().canvas, l = function(t, e) {
	            const n = t.getLightManager(), i = n && n.getAmbientResource(), r = n && n.getAmbientLight() || {}, o = n && n.getDirectionalLight() || {};
	            let s;
	            if (i) {
	                const t = e.prefilterMap.width, n = Math.log(t) / Math.log(2);
	                s = {
	                    prefilterMap: e.prefilterMap,
	                    diffuseSPH: e.sh,
	                    prefilterMiplevel: [ n, n ],
	                    prefilterSize: [ t, t ],
	                    hdrHSV: r.hsv || [ 0, 0, 0 ]
	                };
	            } else s = {
	                ambientColor: r.color || [ .2, .2, .2 ]
	            };
	            return s.rgbmRange = i ? e.rgbmRange : 7, s.environmentExposure = _$2(r.exposure) ? r.exposure : 1, 
	            s.environmentOrientation = r.orientation || 0, s.light0_diffuse = [ ...o.color || [ 1, 1, 1 ], 1 ], 
	            s.light0_viewDirection = o.direction || [ 1, 1, -1 ], s;
	        }(t, e), c = g({
	            viewMatrix: o,
	            projMatrix: s,
	            projViewMatrix: t.projViewMatrix,
	            cameraPosition: a,
	            outSize: [ h.width, h.height ],
	            cameraNearFar: [ t.cameraNear, t.cameraFar ]
	        }, l);
	        return c.brdfLUT = n, i && i.renderUniforms && g(c, i.renderUniforms), c.halton = r || Xd, 
	        c;
	    },
	    createIBLTextures: Jd,
	    disposeIBLTextures: qd,
	    isSupported: function(t) {
	        return t.hasExtension("EXT_shader_texture_lod");
	    }
	});

	class Kd extends ie$1 {
	    constructor(t) {
	        super({
	            vert: "attribute vec3 aPosition;\nuniform mat4 lightProjViewModelMatrix;\nuniform mat4 positionMatrix;\n#include <line_extrusion_vert>\n#include <get_output>\nvarying vec4 vPosition;\nvoid main() {\n  mat4 c = getPositionMatrix();\n#ifdef IS_LINE_EXTRUSION\nvec3 d = getLineExtrudePosition(aPosition);\n  vec4 e = getPosition(d);\n#else\nvec4 e = getPosition(aPosition);\n#endif\ngl_Position = lightProjViewModelMatrix * c * e;\n  vPosition = gl_Position;\n}",
	            frag: "#define SHADER_NAME vsm_mapping\n#ifdef USE_VSM\n#extension GL_OES_standard_derivatives : enable\n#endif\nprecision highp float;\nvarying vec4 vPosition;\n#ifdef PACK_FLOAT\n#include <common_pack_float>\n#endif\nvoid main() {\n  \n#if defined(USE_VSM)\nfloat c = vPosition.z / vPosition.w;\n  c = c * .5 + .5;\n  float d = c;\n  float e = c * c;\n  float f = dFdx(c);\n  float h = dFdy(c);\n  e += .25 * (f * f + h * h);\n  gl_FragColor = vec4(d, e, c, .0);\n#endif\n#if defined(USE_ESM)\n#ifdef PACK_FLOAT\ngl_FragColor = common_encodeDepth(gl_FragCoord.z);\n#else\ngl_FragColor = vec4(gl_FragCoord.z, .0, .0, 1.);\n#endif\n#endif\n}",
	            uniforms: [ {
	                name: "lightProjViewModelMatrix",
	                type: "function",
	                fn: function(t, n) {
	                    return multiply$5([], n.lightProjViewMatrix, n.modelMatrix);
	                }
	            } ],
	            extraCommandProps: {},
	            defines: t
	        });
	    }
	    filter(t) {
	        return t.castShadow;
	    }
	}

	class Qd extends de {
	    constructor({blurOffset: t}) {
	        super({
	            vert: ce$1,
	            frag: "precision highp float;\nvarying vec2 vTexCoord;\nuniform sampler2D textureSource;\nuniform vec2 resolution;\n#include <common_pack_float>\nvoid main() {\n  float c = .0;\n  float d = .0;\n  for(int x = -BOXBLUR_OFFSET; x <= BOXBLUR_OFFSET; ++x)\n    for(int y = -BOXBLUR_OFFSET; y <= BOXBLUR_OFFSET; ++y) {\n      vec2 e = vTexCoord.st + vec2(float(x) / resolution.x, float(y) / resolution.y);\n      e = clamp(e, .0, 1.);\n      float f = common_decodeDepth(texture2D(textureSource, e));\n      float s = max(.0, sign(1. - f));\n      d += sign(f) * s;\n      c += f;\n    }\n  float h = c / max(1., d);\n  gl_FragColor = common_encodeDepth(h);\n}",
	            defines: {
	                BOXBLUR_OFFSET: t || 2
	            }
	        }), this._blurOffset = t || 2;
	    }
	    getMeshCommand(t, e) {
	        const n = "box_shadow_blur_" + this._blurOffset;
	        return this.commands[n] || (this.commands[n] = this.createREGLCommand(t, null, e.getElements())), 
	        this.commands[n];
	    }
	}

	let $d, tm;

	class em {
	    constructor(t, {width: e, height: n, blurOffset: i, defines: r}) {
	        this.renderer = t, this.width = e || 512, this.height = n || 512, this.blurOffset = u(i) ? 2 : i, 
	        this._init(r);
	    }
	    render(t, {cameraProjViewMatrix: e, lightDir: n, farPlane: i, cameraLookAt: r}) {
	        return {
	            lightProjViewMatrix: this._renderShadow(t, e, n, i, r),
	            shadowMap: this.blurTex || this.depthTex,
	            depthFBO: this.depthFBO,
	            blurFBO: this.blurFBO
	        };
	    }
	    resize(t, e) {
	        return this.depthTex && (this.depthTex.resize(t, e), this.depthFBO.resize(t, e)), 
	        this.blurFBO && (this.blurTex.resize(t, e), this.blurFBO.resize(t, e)), this;
	    }
	    _renderShadow(t, e, n, i, r) {
	        const o = this.renderer, s = $d(e);
	        if (i) for (let t = 4; t < 8; t++) s[t] = i[t - 4];
	        const a = tm(r, s, n);
	        return o.clear({
	            color: [ 1, 0, 0, 1 ],
	            depth: 1,
	            framebuffer: this.depthFBO
	        }), o.render(this.shadowMapShader, {
	            lightProjViewMatrix: a
	        }, t, this.depthFBO), this.blurFBO && (this.boxBlurShader || (this.boxBlurShader = new Qd({
	            blurOffset: this.blurOffset
	        })), o.clear({
	            color: [ 1, 0, 0, 1 ],
	            depth: 1,
	            framebuffer: this.blurFBO
	        }), o.render(this.boxBlurShader, {
	            resolution: [ this.depthTex.width, this.depthTex.height ],
	            textureSource: this.depthTex
	        }, null, this.blurFBO)), a;
	    }
	    _init(t) {
	        const e = this.renderer.regl, n = this.width, i = this.height;
	        this.depthTex = e.texture({
	            width: n,
	            height: i,
	            format: "rgb",
	            type: "uint8",
	            min: "nearest",
	            mag: "nearest"
	        }), this.shadowMapShader = new Kd(t), this.shadowMapShader.filter = t => t.castShadow, 
	        this.depthFBO = e.framebuffer({
	            color: this.depthTex
	        }), this.blurOffset <= 0 || (this.blurTex = e.texture({
	            width: n,
	            height: i,
	            format: "rgb",
	            type: "uint8",
	            min: "linear",
	            mag: "linear"
	        }), this.blurFBO = e.framebuffer({
	            color: this.blurTex
	        }));
	    }
	    dispose() {
	        this.depthTex && (this.depthTex.destroy(), this.depthFBO.destroy(), delete this.depthTex, 
	        delete this.depthFBO), this.blurTex && (this.blurTex.destroy(), this.blurFBO.destroy(), 
	        delete this.blurTex, delete this.blurFBO), this.shadowMapShader && (this.shadowMapShader.dispose(), 
	        delete this.shadowMapShader), this.boxBlurShader && (this.boxBlurShader.dispose(), 
	        delete this.boxBlurShader);
	    }
	}

	$d = function() {
	    const t = [ [ -1, -1, -1, 1 ], [ 1, -1, -1, 1 ], [ 1, 1, -1, 1 ], [ -1, 1, -1, 1 ], [ -1, -1, 1, 1 ], [ 1, -1, 1, 1 ], [ 1, 1, 1, 1 ], [ -1, 1, 1, 1 ] ], n = new Array(16);
	    return function(r) {
	        invert$2(n, r);
	        const o = [];
	        for (let e = 0; e < t.length; e++) {
	            const r = transformMat4$1([], t[e], n);
	            scale$3(r, r, 1 / r[3]), o.push(r);
	        }
	        return o;
	    };
	}(), tm = function() {
	    let t = new Array(4);
	    const r = new Array(3), o = [ 0, 0, 0, 0 ], s = [ 0, 1, 0 ], a = new Array(3);
	    let h = new Array(16), l = new Array(16), c = new Array(16);
	    const u = [ 1, 1, 1 ], f = [ 0, 0, 0 ];
	    return function(d, m, g) {
	        set$3(o, ...d, 1), scale$4(r, g, -1), h = lookAt(h, add$4(a, o, normalize$4(a, r)), o, s), 
	        transformMat4$1(t, m[0], h);
	        let p = t[2], _ = t[2], v = t[0], y = t[0], x = t[1], b = t[1];
	        for (let e = 1; e < 8; e++) t = transformMat4$1(t, m[e], h), t[2] > _ && (_ = t[2]), 
	        t[2] < p && (p = t[2]), t[0] > y && (y = t[0]), t[0] < v && (v = t[0]), t[1] > b && (b = t[1]), 
	        t[1] < x && (x = t[1]);
	        l = ortho(l, -1, 1, -1, 1, -_, -p);
	        const w = u[0] = 2 / (y - v), C = u[1] = -2 / (b - x);
	        f[0] = -.5 * (v + y) * w, f[1] = -.5 * (x + b) * C, identity$2(c), translate$1(c, c, f), 
	        scale$5(c, c, u);
	        const M = multiply$5(l, c, l);
	        return multiply$5(new Array(16), M, h);
	    };
	}();

	class nm extends ie$1 {
	    constructor(t) {
	        super({
	            vert: "#define SHADER_NAME SHADOW_DISPLAY\nattribute vec3 aPosition;\nuniform mat4 projMatrix;\nuniform mat4 modelViewMatrix;\nuniform vec2 halton;\nuniform vec2 globalTexSize;\nvarying vec4 vPosition;\n#include <vsm_shadow_vert>\nvoid main() {\n  vec4 c = vec4(aPosition, 1.);\n  vec4 d = modelViewMatrix * c;\n  mat4 e = projMatrix;\n  e[2].xy += halton.xy / globalTexSize.xy;\n  gl_Position = e * d;\n  vPosition = gl_Position;\n  shadow_computeShadowPars(c);\n}",
	            frag: "#define SHADER_NAME SHADOW_DISPLAY\nprecision mediump float;\nuniform vec3 color;\n#include <vsm_shadow_frag>\nvoid main() {\n  float c = shadow_computeShadow();\n  float d = 1. - c;\n  gl_FragColor = vec4(color * d, d);\n}",
	            uniforms: [ {
	                name: "modelViewMatrix",
	                type: "function",
	                fn: function(t, n) {
	                    const i = [];
	                    return multiply$5(i, n.viewMatrix, n.modelMatrix), i;
	                }
	            } ],
	            defines: t || {
	                USE_ESM: 1
	            },
	            extraCommandProps: {
	                depth: {
	                    enable: !0,
	                    mask: !1
	                },
	                viewport: {
	                    x: 0,
	                    y: 0,
	                    width: (t, e) => e.globalTexSize[0],
	                    height: (t, e) => e.globalTexSize[1]
	                }
	            }
	        });
	    }
	    getMeshCommand(t, e) {
	        return this.commands.shadow_display || (this.commands.shadow_display = this.createREGLCommand(t, null, e.getElements())), 
	        this.commands.shadow_display;
	    }
	}

	function im(t) {
	    return 256 * t[2] * 256 + 256 * t[1] + t[0];
	}

	const rm = new Uint8Array(4), om = new Float32Array(rm.buffer);

	let sm, am;

	const hm = "\n    vec3 unpack(highp float f) {\n        highp vec3 color;\n        color.b = floor(f / 65536.0);\n        color.g = floor((f - color.b * 65536.0) / 256.0);\n        color.r = f - floor(color.b * 65536.0) - floor(color.g * 256.0);\n        // now we have a vec3 with the 3 components in range [0..255]. Let's normalize it!\n        return color / 255.0;\n    }\n", lm = `\n    precision highp float;\n\n    varying float vPickingId;\n    varying float vFbo_picking_visible;\n\n    uniform float fbo_picking_meshId;\n\n    ${hm}\n\n    void main() {\n        if (vFbo_picking_visible == 0.0) {\n            discard;\n            return;\n        }\n        gl_FragColor = vec4(unpack(vPickingId), fbo_picking_meshId / 255.0);\n    }\n`, cm = `\n    precision highp float;\n\n    uniform int fbo_picking_meshId;\n    varying float vFbo_picking_visible;\n\n    ${hm}\n\n    void main() {\n        if (vFbo_picking_visible == 0.0) {\n            discard;\n            return;\n        }\n        gl_FragColor = vec4(unpack(float(fbo_picking_meshId)), 1.0);\n        // gl_FragColor = vec4(unpack(float(35)), 1.0);\n    }\n`, um = `\n    precision highp float;\n\n    varying float vPickingId;\n    varying float vFbo_picking_visible;\n\n    ${hm}\n\n    void main() {\n        if (vFbo_picking_visible == 0.0) {\n            discard;\n            return;\n        }\n        gl_FragColor = vec4(unpack(vPickingId), 1.0);\n    }\n`;

	class fm {
	    constructor(t, {vert: e, uniforms: n, defines: i, extraCommandProps: r}, o, s) {
	        this._renderer = t, this._fbo = o, this._map = s, this._clearFbo(o), this._vert = e, 
	        this._uniforms = n, this._defines = i, this._extraCommandProps = g({}, r), delete this._extraCommandProps.blend, 
	        delete this._extraCommandProps.stencil, this._currentMeshes = [], this._init();
	    }
	    _init() {
	        const t = [];
	        this._uniforms && t.push(...this._uniforms);
	        const e = {
	            ENABLE_PICKING: 1,
	            HAS_PICKING_ID: 1
	        };
	        if (this._defines) for (const t in this._defines) e[t] = this._defines[t];
	        const n = this._vert, i = this._extraCommandProps;
	        this._shader0 = new ie$1({
	            vert: n,
	            frag: lm,
	            uniforms: t,
	            defines: e,
	            extraCommandProps: i
	        }), this._shader2 = new ie$1({
	            vert: n,
	            frag: um,
	            uniforms: t,
	            defines: e,
	            extraCommandProps: i
	        });
	        const r = {
	            ENABLE_PICKING: 1,
	            HAS_PICKING_ID: 1
	        };
	        if (this._defines) for (const t in this._defines) r[t] = this._defines[t];
	        this._shader1 = new ie$1({
	            vert: n,
	            frag: cm,
	            uniforms: t,
	            defines: r,
	            extraCommandProps: i
	        }), this._depthShader = new ie$1({
	            vert: n,
	            frag: "\n    #ifdef GL_ES\n        precision highp float;\n    #endif\n    #if __VERSION__ == 100\n        #extension GL_EXT_frag_depth : enable\n    #endif\n    #include <gl2_frag>\n    #include <common_pack_float>\n    varying float vFbo_picking_viewZ;\n    uniform float logDepthBufFC;\n    varying float vFbo_picking_fragDepth;\n\n    const float PackUpscale = 256. / 255.;\n    const float UnpackDownscale = 255. / 256.;\n    const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\n    const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n    const float ShiftRight8 = 1. / 256.;\n    vec4 packDepthToRGBA(const in float v ) {\n        vec4 r = vec4(fract(v * PackFactors), v);\n        r.yzw -= r.xyz * ShiftRight8;\n        return r * PackUpscale;\n    }\n\n    void main() {\n        float fragDepth = vFbo_picking_fragDepth > 1.0 ? vFbo_picking_fragDepth : vFbo_picking_viewZ + 1.0;\n        #if __VERSION__ == 300\n            gl_FragDepthEXT = log2(fragDepth) * logDepthBufFC * 0.5;\n        #endif\n        vec4 depthColor = packDepthToRGBA(fragDepth - 1.0);\n        glFragColor = common_unpackFloat(dot(depthColor, UnpackFactors));\n        #if __VERSION__ == 100\n            gl_FragColor = glFragColor;\n        #endif\n    }\n",
	            uniforms: t,
	            defines: r,
	            extraCommandProps: i
	        }), this._depthShader.version = 300, this._scene = new yt$1, this._scene1 = new yt$1;
	    }
	    filter() {
	        return !0;
	    }
	    render(t, e, n = !1) {
	        if (!t || !t.length) return this;
	        const i = this._fbo;
	        n && this.clear(), t = t.filter(t => t && t.isValid()), this._scene.setMeshes(t);
	        const r = this._getShader(t, n);
	        r.filter = this.filter, this._currentShader && r !== this._currentShader && this.clear(), 
	        this._currentShader = r, t.forEach((t, e) => {
	            t.setUniform("fbo_picking_meshId", e + this._currentMeshes.length);
	        });
	        for (let e = 0; e < t.length; e++) this._currentMeshes.push(t[e]);
	        return this._renderer.render(r, e, this._scene, i), this;
	    }
	    pick(t, e, n, i, r = {}) {
	        const o = this._currentShader, s = this._currentMeshes;
	        if (!o || !s || !s.length) return {
	            pickingId: null,
	            meshId: null,
	            point: null
	        };
	        t = Math.round(t), e = Math.round(e);
	        const a = this._fbo;
	        if (t <= 2 || t >= a.width - 2 || e <= 2 || e >= a.height - 2) return {
	            pickingId: null,
	            meshId: null,
	            point: null
	        };
	        const {px: h, py: l, width: c, height: u} = this._getParams(t, e, n, a), f = new Uint8Array(4 * c * u), d = this._renderer.regl.read({
	            data: f,
	            x: h,
	            y: l,
	            framebuffer: a,
	            width: c,
	            height: u
	        }), m = [];
	        let g = [];
	        for (let t = 0; t < d.length; t += 4) {
	            const {pickingId: e, meshId: n} = this._packData(d.subarray(t, t + 4), o);
	            m.push(n), g.push(e);
	        }
	        const p = {}, _ = m.filter(t => null != t && !p[t] && (p[t] = 1, !0)).map(t => s[t]);
	        let v;
	        for (let t = 0; t < _.length; t++) if (_[t] && _[t].geometry) {
	            v = _[t];
	            break;
	        }
	        if (!v) return {
	            pickingId: null,
	            meshId: null,
	            point: null
	        };
	        const y = v.geometry.desc.pickingIdAttribute;
	        m.length && o === this._shader1 && (void 0 !== v.getUniform("uPickingId") || v.geometry.data[y]) && (g = this._getPickingId(h, l, c, u, f, _, i));
	        const x = [], b = [];
	        if (m.length && r.returnPoint) {
	            const {viewMatrix: n, projMatrix: o} = r, s = this._pickDepth(h, l, c, u, f, _, i);
	            for (let i = 0; i < s.length; i++) if (s[i] && null != m[i] && null != g[i]) {
	                const r = this._getWorldPos(t, e, s[i], n, o), a = this._convertPickPoint(r);
	                x.push(r), b.push(a);
	            } else x.push(null);
	        }
	        const w = [];
	        for (let t = 0; t <= n; t++) w.push(t), t > 0 && w.push(-t);
	        for (let t = 0; t < w.length; t++) for (let e = 0; e < w.length; e++) {
	            const i = (w[e] + n) * c + (w[t] + n);
	            if (null != m[i] && null != g[i]) return {
	                meshId: m[i],
	                pickingId: g[i],
	                point: x[i] || null,
	                coordinate: b[i] || null
	            };
	        }
	        return {
	            pickingId: null,
	            meshId: null,
	            point: null
	        };
	    }
	    _convertPickPoint(t) {
	        const e = this._map;
	        if (!e) return null;
	        const n = e.getGLRes();
	        if (!sm) {
	            const t = e.getCenter();
	            am = new t.constructor(0, 0, 0);
	            const n = e.coordToPoint(t);
	            sm = new n.constructor(0, 0);
	        }
	        sm.set(t[0], t[1]);
	        const i = e.pointAtResToCoord(sm, n, am), r = e.pointAtResToAltitude(t[2], n);
	        return [ i.x, i.y, r ];
	    }
	    clear() {
	        return this._fbo && this._clearFbo(this._fbo), this._currentMeshes = [], delete this._currentShader, 
	        this;
	    }
	    getMeshAt(t) {
	        return this._currentMeshes ? this._currentMeshes[t] : null;
	    }
	    getRenderedMeshes() {
	        return this._currentMeshes;
	    }
	    dispose() {
	        this.clear(), this._shader0 && this._shader0.dispose(), this._shader1 && this._shader1.dispose(), 
	        this._shader2 && this._shader2.dispose(), this._scene && this._scene.clear(), this._scene1 && this._scene1.clear();
	    }
	    _getWorldPos(t, n, i, r, o) {
	        const s = this._fbo, a = [], h = s.width / 2 || 1, l = s.height / 2 || 1, c = [ (t - h) / h, (l - n) / l, 0, 1 ], u = [ (t - h) / h, (l - n) / l, 1, 1 ], f = invert$2(a, o), d = [], m = [];
	        dm(d, c, f), dm(m, u, f);
	        const g = -d[2], p = (i - g) / (-m[2] - g), _ = multiply$5(a, o, r), y = invert$2(a, _), x = dm(c, c, y), b = dm(u, u, y);
	        return [ v$1(x[0], b[0], p), v$1(x[1], b[1], p), v$1(x[2], b[2], p) ];
	    }
	    _getPickingId(t, e, n, i, r, o, s) {
	        const a = this._renderer.regl, h = this._getFBO1();
	        this._clearFbo(h), this._scene1.setMeshes(o), this._renderer.render(this._shader2, s, this._scene1, h);
	        const l = a.read({
	            data: r,
	            x: t,
	            y: e,
	            framebuffer: h,
	            width: n,
	            height: i
	        }), c = [];
	        for (let t = 0; t < l.length; t += 4) c.push(im(l.subarray(t, t + 4)));
	        return c;
	    }
	    _pickDepth(t, e, n, i, r, o, s) {
	        const a = this._renderer.regl, h = this._getFBO1();
	        this._scene1.setMeshes(o), this._clearFbo(h), s.logDepthBufFC = 2 / (Math.log(this._map.cameraFar + 1) / Math.LN2), 
	        this._renderer.render(this._depthShader, s, this._scene1, h);
	        const l = a.read({
	            data: r,
	            x: t,
	            y: e,
	            framebuffer: h,
	            width: n,
	            height: i
	        }), c = [];
	        for (let t = 0; t < l.length; t += 4) c.push((u = l.subarray(t, t + 4), rm[0] = u[3], 
	        rm[1] = u[2], rm[2] = u[1], rm[3] = u[0], om[0]));
	        var u;
	        return c;
	    }
	    _packData(t, e) {
	        if (255 === t[0] && 255 === t[1] && 255 === t[2] && 255 === t[3]) return {
	            meshId: null,
	            pickingId: null
	        };
	        let n = null, i = null;
	        return e === this._shader1 ? i = im(t) : e === this._shader0 ? (i = t[3], n = im(t)) : (i = null, 
	        n = im(t)), {
	            meshId: i,
	            pickingId: n
	        };
	    }
	    _clearFbo(t) {
	        this._renderer.regl.clear({
	            color: [ 1, 1, 1, 1 ],
	            depth: 1,
	            stencil: 0,
	            framebuffer: t
	        });
	    }
	    _getShader(t, e) {
	        return e && t.length < 256 ? this._shader0 : this._shader1;
	    }
	    _getFBO1() {
	        const t = this._renderer.regl, e = this._fbo;
	        return this._fbo1 ? this._fbo1.width === e.width && this._fbo1.height === e.height || this._fbo1.resize(e.width, e.height) : this._fbo1 = t.framebuffer(e.width, e.height), 
	        this._fbo1;
	    }
	    _getParams(t, e, n, i) {
	        e = i.height - e;
	        let r = 2 * n + 1, o = 2 * n + 1;
	        const s = (t -= n) + r, a = (e -= n) + o;
	        return s > i.width && (r -= s - i.width), a > i.height && (o -= a - i.height), {
	            px: t = t < 0 ? 0 : t,
	            py: e = e < 0 ? 0 : e,
	            width: r,
	            height: o
	        };
	    }
	    getPickingVert() {
	        return this._vert;
	    }
	    getUniformDeclares() {
	        return this._uniforms;
	    }
	}

	function dm(t, e, n) {
	    const i = e[0], r = e[1], o = e[2], s = 1 / (n[3] * i + n[7] * r + n[11] * o + n[15]);
	    return t[0] = (n[0] * i + n[4] * r + n[8] * o + n[12]) * s, t[1] = (n[1] * i + n[5] * r + n[9] * o + n[13]) * s, 
	    t[2] = (n[2] * i + n[6] * r + n[10] * o + n[14]) * s, t;
	}

	const mm = t => t && t.geometry && void 0 === t.geometry.properties.shaderHash, gm = [], pm = [], _m = [ {
	    name: "modelViewMatrix",
	    type: "function",
	    fn: (t, n) => multiply$5(gm, n.viewMatrix, n.modelMatrix)
	}, {
	    name: "modelViewProjMatrix",
	    type: "function",
	    fn: (t, n) => {
	        const i = multiply$5(gm, n.viewMatrix, n.modelMatrix);
	        return multiply$5(gm, n.projMatrix, i);
	    }
	}, {
	    name: "modelMatrixInverse",
	    type: "function",
	    fn: (t, n) => invert$2(gm, n.modelMatrix)
	}, {
	    name: "projMatrixInverse",
	    type: "function",
	    fn: (t, n) => invert$2(gm, n.projMatrix)
	}, {
	    name: "modelViewMatrixInverse",
	    type: "function",
	    fn: (t, n) => (multiply$5(gm, n.viewMatrix, n.modelMatrix), invert$2(gm, gm))
	}, {
	    name: "modelViewProjMatrixInverse",
	    type: "function",
	    fn: (t, n) => {
	        const i = multiply$5(gm, n.viewMatrix, n.modelMatrix);
	        return multiply$5(gm, n.projMatrix, i), invert$2(gm, gm);
	    }
	}, {
	    name: "modelInverseTransposeMatrix",
	    type: "function",
	    fn: (t, e) => {
	        const n = fromMat4$1(pm, e.modelMatrix), i = transpose$1(n, n);
	        return invert$3(i, i);
	    }
	}, {
	    name: "modelViewInverseTransposeMatrix",
	    type: "function",
	    fn: (t, n) => {
	        const i = multiply$5(gm, n.viewMatrix, n.modelMatrix), o = fromMat4$1(pm, i), s = transpose$1(o, o);
	        return invert$3(s, s);
	    }
	} ], vm = {
	    LOCAL: "positionMatrix",
	    MODEL: "modelMatrix",
	    VIEW: "viewMatrix",
	    PROJECTION: "projMatrix",
	    MODELVIEW: "modelViewMatrix",
	    MODELVIEWPROJECTION: "modelViewProjMatrix",
	    MODELINVERSE: "modelMatrixInverse",
	    VIEWINVERSE: "viewMatrixInverse",
	    PROJECTIONINVERSE: "projMatrixInverse",
	    MODELVIEWINVERSE: "modelViewMatrixInverse",
	    MODELVIEWPROJECTIONINVERSE: "modelViewProjMatrixInverse",
	    MODELINVERSETRANSPOSE: "modelInverseTransposeMatrix",
	    MODELVIEWINVERSETRANSPOSE: "modelViewInverseTransposeMatrix",
	    VIEWPORT: "viewport",
	    JOINTMATRIX: "jointMatrix",
	    ALPHACUTOFF: "alphaCutoff"
	};

	class ym {
	    constructor(t, e, n) {
	        this._regl = t, this._khrShaders = {}, this._commandProps = e, this._resLoader = n;
	    }
	    getExcludeFilter() {
	        return mm;
	    }
	    forEachShader(t) {
	        for (const e in this._khrShaders) {
	            const n = this._khrShaders[e];
	            t(n.shader, n.filter, n.uniformSemantics);
	        }
	    }
	    createMesh(t, e, n, i) {
	        const r = e.extensions.KHR_techniques_webgl, o = e.materials[t.material].extensions.KHR_techniques_webgl, {technique: s, values: a} = o, h = r.techniques[s], l = r.programs[h.program], c = r.shaders[l.vertexShader], u = r.shaders[l.fragmentShader];
	        u.content = function(t) {
	            if (t && t.indexOf("precision") < 0) return "precision mediump float;\n" + t;
	            return t;
	        }(u.content);
	        const f = O$1(c.content) + "-" + O$1(u.content);
	        this._khrShaders[f] || (this._khrShaders[f] = this._createTechniqueShader(f, r, s, this._commandProps, i));
	        const {attributeSemantics: d} = this._khrShaders[f], m = this._createGeometry(t, d, n, f), p = g({}, a);
	        for (const t in a) if (h.uniforms[t] && 35678 === h.uniforms[t].type) {
	            p[t] = this._getTexture(e.textures[a[t].index]);
	        }
	        return {
	            geometry: m,
	            material: new tt$1(p)
	        };
	    }
	    _createGeometry(t, e, n, i) {
	        const r = t.attributes;
	        if (r.COLOR_0) {
	            const t = r.COLOR_0.array || r.COLOR_0;
	            if (t instanceof Float32Array) {
	                const e = new Uint8Array(t.length);
	                for (let n = 0; n < e.length; n++) e[n] = Math.round(255 * t[n]);
	                r.COLOR_0.array ? (r.COLOR_0.array = e, r.COLOR_0.componentType = 5121) : r.COLOR_0 = e;
	            }
	        }
	        const o = {};
	        for (const t in r) {
	            const n = Nt$1(this._regl, r[t], {
	                dimension: r[t].itemSize
	            }), i = e[t] || t;
	            o[i] = {
	                buffer: n
	            }, r[t].quantization && (o[i].quantization = r[t].quantization), i === e.POSITION && (o[i].array = r[t].array);
	        }
	        const s = new Q$1(o, t.indices.array ? t.indices.array : t.indices, 0, {
	            positionAttribute: e.POSITION,
	            normalAttribute: e.NORMAL,
	            uv0Attribute: e.TEXCOORD_0,
	            uv1Attribute: e.TEXCOORD_1,
	            color0Attribute: e.COLOR_0,
	            tangentAttribute: e.TANGENT,
	            textureCoordMatrixAttribute: e.TextureCoordMatrix,
	            primitive: void 0 === t.mode ? "triangles" : Pt$1(t.mode)
	        });
	        s.generateBuffers(this._regl, {
	            excludeElementsInVAO: n
	        }), s.properties.shaderHash = i;
	        const a = s.data[s.desc.positionAttribute];
	        return a && a.array && delete a.array, s;
	    }
	    _getTexture(t) {
	        const e = {
	            type: t.type ? Et$1(t.type) : "uint8",
	            format: t.format ? Rt$1(t.format) : "rgba",
	            flipY: !!t.flipY
	        }, n = t.image;
	        n.array ? e.data = n.array : n.mipmap && (e.mipmap = n.mipmap), e.width = n.width, 
	        e.height = n.height;
	        const i = t.sampler || t.texture.sampler;
	        return i && (i.magFilter && (e.mag = kt$1(i.magFilter)), i.minFilter && (e.min = Lt$1(i.minFilter)), 
	        i.wrapS && (e.wrapS = Ft$1(i.wrapS)), i.wrapT && (e.wrapT = Ft$1(i.wrapT))), new Vt$1(e, this._resLoader);
	    }
	    _createTechniqueShader(t, e, n, i, r) {
	        const {techniques: o, programs: s, shaders: a} = e, h = o[n], l = s[h.program], c = a[l.vertexShader].content, u = a[l.fragmentShader].content, f = {};
	        for (const t in h.uniforms) {
	            const e = h.uniforms[t];
	            e.semantic && (f[e.semantic] = t);
	        }
	        const d = _m.slice();
	        for (const t in f) {
	            d.push({
	                name: f[t],
	                type: "function",
	                fn: (e, n) => n[vm[t]]
	            });
	        }
	        const m = new ie$1({
	            vert: c,
	            frag: u,
	            uniforms: d,
	            extraCommandProps: i
	        });
	        r && (m.version = 300);
	        const g = {};
	        for (const t in h.attributes) {
	            g[h.attributes[t].semantic] = t;
	        }
	        return {
	            shader: m,
	            filter: e => e && e.geometry && e.geometry.properties.shaderHash === t,
	            uniformSemantics: f,
	            attributeSemantics: g
	        };
	    }
	    dispose() {
	        for (const t in this._khrShaders) {
	            const {shader: e} = this._khrShaders[t];
	            e.dispose();
	        }
	        this._khrShaders = {};
	    }
	}

	const xm = {
	    parseHDR: Tt$1
	}, bm = {
	    PBRHelper: Gd,
	    StandardMaterial: Ud,
	    StandardSpecularGlossinessMaterial: Wd,
	    StandardShader: class extends ie$1 {
	        constructor(t = {}) {
	            let n = t.extraCommandProps || {};
	            const i = t.uniforms;
	            n = g({}, n);
	            const o = t.defines || {}, s = [], a = [], h = [], l = [], c = [], u = [ {
	                name: "modelNormalMatrix",
	                type: "function",
	                fn: (t, e) => fromMat4$1(s, e.modelMatrix)
	            }, {
	                name: "modelViewNormalMatrix",
	                type: "function",
	                fn: (t, n) => {
	                    const i = multiply$5(a, n.viewMatrix, n.modelMatrix), o = invert$2(i, i), s = transpose(o, o);
	                    return fromMat4$1(h, s);
	                }
	            }, {
	                name: "modelViewMatrix",
	                type: "function",
	                fn: (t, n) => multiply$5(l, n.viewMatrix, n.modelMatrix)
	            }, {
	                name: "uEnvironmentTransform",
	                type: "function",
	                fn: (t, e) => fromRotation$2(c, Math.PI * (e.environmentOrientation || 0) / 180)
	            } ];
	            i && u.push(...i);
	            super({
	                vert: t.vert || "#include <gl2_vert>\n#define SHADER_NAME PBR\nprecision highp float;\nattribute vec3 aPosition;\n#if defined(HAS_MAP)\nattribute vec2 aTexCoord;\nuniform vec2 uvOrigin;\nuniform vec2 uvScale;\nuniform vec2 uvOffset;\nuniform float uvRotation;\n#ifdef HAS_I3S_UVREGION\nattribute vec4 uvRegion;\nvarying vec4 vUvRegion;\n#endif\n#endif\nvec3 c;\nvec3 d;\nvec4 e;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 positionMatrix;\nuniform mat4 projMatrix;\nuniform vec2 outSize;\nuniform vec2 halton;\nuniform mediump vec3 cameraPosition;\nuniform mat3 modelNormalMatrix;\n#ifdef HAS_SSR\nuniform mat3 modelViewNormalMatrix;\nvarying vec3 vViewNormal;\n#ifdef HAS_TANGENT\nvarying vec4 vViewTangent;\n#endif\n#endif\nvarying vec3 vModelNormal;\nvarying vec4 vViewVertex;\n#if defined(HAS_TANGENT)\nvarying vec4 vModelTangent;\nvarying vec3 vModelBiTangent;\n#endif\nvarying vec3 vModelVertex;\n#if defined(HAS_MAP)\nvarying vec2 vTexCoord;\n#endif\n#if defined(HAS_COLOR)\nattribute vec4 aColor;\nvarying vec4 vColor;\n#endif\n#include <highlight_vert>\n#if defined(HAS_COLOR0)\n#if COLOR0_SIZE == 3\nattribute vec3 aColor0;\nvarying vec3 vColor0;\n#else\nattribute vec4 aColor0;\nvarying vec4 vColor0;\n#endif\n#endif\n#include <line_extrusion_vert>\n#include <get_output>\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n#include <vsm_shadow_vert>\n#endif\n#include <heatmap_render_vert>\n#if defined(HAS_BUMP_MAP) && defined(HAS_TANGENT)\nvarying vec3 vTangentViewPos;\nvarying vec3 vTangentFragPos;\n#if __VERSION__ == 100\nmat3 f(in mat3 h) {\n  vec3 i = h[0];\n  vec3 j = h[1];\n  vec3 k = h[2];\n  return mat3(vec3(i.x, j.x, k.x), vec3(i.y, j.y, k.y), vec3(i.z, j.z, k.z));\n}\n#else\nmat3 f(in mat3 h) {\n  return transpose(h);\n}\n#endif\n#endif\nvoid l(const highp vec4 q, out highp vec3 m) {\n  m = vec3(.0, .0, 1.) + vec3(2., -2., -2.) * q.x * q.zwx + vec3(2., 2., -2.) * q.y * q.wzy;\n}\nvoid l(const highp vec4 q, out highp vec3 m, out highp vec3 t) {\n  l(q, m);\n  t = vec3(1., .0, .0) + vec3(-2., 2., -2.) * q.y * q.yxw + vec3(-2., 2., 2.) * q.z * q.zwx;\n}\nconst float o = .5;\nvec2 u(vec2 v, float A) {\n  return vec2(cos(A) * (v.x - o) + sin(A) * (v.y - o) + o, cos(A) * (v.y - o) - sin(A) * (v.x - o) + o);\n}\n#ifdef PICKING_MODE\n#include <fbo_picking_vert>\n#endif\nvoid main() {\n  mat4 B = getPositionMatrix();\n#ifdef IS_LINE_EXTRUSION\nvec3 C = getLineExtrudePosition(aPosition);\n  vec4 D = getPosition(C);\n#else\nvec4 D = getPosition(aPosition);\n#endif\nvModelVertex = (modelMatrix * D).xyz;\n  vec4 E = B * D;\n  vec4 F = modelViewMatrix * E;\n  vViewVertex = F;\n  mat4 G = projMatrix;\n  G[2].xy += halton.xy / outSize.xy;\n#ifdef HAS_MASK_EXTENT\ngl_Position = G * getMaskPosition(E, modelMatrix);\n#else\ngl_Position = G * F;\n#endif\n#ifdef PICKING_MODE\nfloat H = 1.;\n#if defined(HAS_COLOR)\nH *= aColor.a;\n#endif\n#if defined(HAS_COLOR0)\nH *= aColor0.a;\n#endif\nfbo_picking_setData(gl_Position.w, H != .0);\n#else\n#if defined(HAS_MAP)\nvec2 I = getTexcoord(aTexCoord);\n#ifdef HAS_RANDOM_TEX\nvec2 J = uvOrigin;\n  vec2 K = I * uvScale + uvOffset;\n  if(uvRotation != .0) {\n    J = u(J, uvRotation);\n    K = u(K, uvRotation);\n  }\n  vTexCoord = mod(J, 1.) + K;\n#else\nvec2 J = uvOrigin;\n  vec2 K = I * uvScale;\n  if(uvRotation != .0) {\n    J = u(J, uvRotation);\n    K = u(K, uvRotation);\n  }\n  vTexCoord = mod(J, 1.) + K + uvOffset;\n#endif\n#ifdef HAS_I3S_UVREGION\nvUvRegion = uvRegion / 65535.;\n#endif\n#endif\n#if defined(HAS_TANGENT) || defined(HAS_NORMAL)\nmat3 L = mat3(B);\n  mat3 M = modelNormalMatrix * L;\n#if defined(HAS_TANGENT)\nvec3 t;\n  l(aTangent, d, t);\n  vModelTangent = vec4(M * t, aTangent.w);\n#else\n#ifdef HAS_DECODE_NORMAL\nd = getNormal(aNormal);\n#else\nd = aNormal;\n#endif\n#endif\nvec3 N = d;\n  vModelNormal = M * N;\n#else\nd = vec3(.0);\n  vModelNormal = vec3(.0);\n#endif\n#if defined(HAS_TANGENT)\nvModelBiTangent = cross(vModelNormal, vModelTangent.xyz) * sign(aTangent.w);\n#endif\n#ifdef HAS_SSR\nmat3 O = modelViewNormalMatrix * L;\n  vViewNormal = O * d;\n#if defined(HAS_TANGENT)\nvec4 P = vec4(t, aTangent.w);\n  vViewTangent = vec4(O * P.xyz, P.w);\n#endif\n#endif\n#if defined(HAS_COLOR)\nvColor = aColor / 255.;\n#endif\nhighlight_setVarying();\n#if defined(HAS_COLOR0)\nvColor0 = aColor0 / 255.;\n#endif\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\nshadow_computeShadowPars(E);\n#endif\n#ifdef HAS_HEATMAP\nheatmap_compute(projMatrix * modelViewMatrix * B, D);\n#endif\n#if defined(HAS_BUMP_MAP) && defined(HAS_TANGENT)\nmat3 Q = f(mat3(vModelTangent.xyz, vModelBiTangent, vModelNormal));\n  vTangentViewPos = Q * cameraPosition;\n  vTangentFragPos = Q * vModelVertex;\n#endif\n#endif\n}",
	                frag: t.frag || "#if __VERSION__ == 100\n#if defined(GL_EXT_shader_texture_lod)\n#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod(tex, uv, lod) textureCubeLodEXT(tex, uv, lod)\n#else\n#define textureCubeLod(tex, uv, lod) textureCube(tex, uv, lod)\n#endif\n#if defined(GL_OES_standard_derivatives)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#else\n#define textureCubeLod(tex, uv, lod) textureLod(tex, uv, lod)\n#endif\n#define saturate(x)        clamp(x, 0.0, 1.0)\nprecision mediump float;\n#include <gl2_frag>\n#include <hsv_frag>\nuniform vec3 hsv;\nuniform float contrast;\nconst float c = .04;\nstruct MaterialUniforms {\n  vec2 roughnessMetalness;\n  vec3 albedo;\n  float alpha;\n  vec3 normal;\n  vec3 emit;\n  float ao;\n  vec3 specularColor;\n  float glossiness;\n} d;\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n#include <vsm_shadow_frag>\n#endif\nuniform vec3 cameraPosition;\n#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)\nuniform vec4 diffuseFactor;\nuniform vec3 specularFactor;\nuniform float glossinessFactor;\n#if defined(HAS_DIFFUSE_MAP)\nuniform sampler2D diffuseTexture;\n#endif\n#if defined(HAS_SPECULARGLOSSINESS_MAP)\nuniform sampler2D specularGlossinessTexture;\n#endif\n#endif\nuniform vec3 emissiveFactor;\nuniform vec4 baseColorFactor;\nuniform float baseColorIntensity;\nuniform float anisotropyDirection;\nuniform float anisotropyFactor;\nuniform float clearCoatFactor;\nuniform float clearCoatIor;\nuniform float clearCoatRoughnessFactor;\nuniform float clearCoatThickness;\nuniform float emitColorFactor;\nuniform float occlusionFactor;\nuniform float environmentExposure;\nuniform float roughnessFactor;\nuniform float metallicFactor;\nuniform float normalMapFactor;\nuniform float rgbmRange;\nuniform float specularF0;\nuniform int emitMultiplicative;\nuniform int normalMapFlipY;\nuniform int outputSRGB;\nuniform mat3 uEnvironmentTransform;\n#if defined(HAS_ALBEDO_MAP)\nuniform sampler2D baseColorTexture;\n#endif\n#if defined(HAS_METALLICROUGHNESS_MAP)\nuniform sampler2D metallicRoughnessTexture;\n#endif\n#if defined(HAS_EMISSIVE_MAP)\nuniform sampler2D emissiveTexture;\n#endif\n#if defined(HAS_AO_MAP)\nuniform sampler2D occlusionTexture;\n#endif\n#if defined(HAS_NORMAL_MAP) && defined(HAS_TANGENT)\nuniform sampler2D normalTexture;\n#endif\n#if defined(HAS_ALPHAMODE)\nuniform float alphaCutoff;\n#endif\n#ifdef HAS_RANDOM_TEX\nuniform highp vec2 uvOrigin;\nuniform highp float uvRotation;\nuniform sampler2D noiseTexture;\n#endif\nuniform sampler2D brdfLUT;\n#if defined(HAS_IBL_LIGHTING)\nuniform vec3 hdrHSV;\nuniform samplerCube prefilterMap;\nuniform vec3 diffuseSPH[9];\nuniform vec2 prefilterMiplevel;\nuniform vec2 prefilterSize;\n#else\nuniform vec3 ambientColor;\n#endif\nuniform vec2 cameraNearFar;\nuniform vec3 clearCoatTint;\nuniform vec3 light0_viewDirection;\nuniform vec4 light0_diffuse;\n#ifdef HAS_SSR\nvarying vec3 vViewNormal;\n#if defined(HAS_TANGENT)\nvarying vec4 vViewTangent;\n#endif\n#endif\nvarying vec3 vModelVertex;\nvarying vec4 vViewVertex;\n#if defined(HAS_MAP)\n#include <computeTexcoord_frag>\n#endif\nvarying vec3 vModelNormal;\n#if defined(HAS_TANGENT)\nvarying vec4 vModelTangent;\nvarying vec3 vModelBiTangent;\n#endif\n#if defined(HAS_COLOR0)\n#if COLOR0_SIZE == 3\nvarying vec3 vColor0;\n#else\nvarying vec4 vColor0;\n#endif\n#endif\n#if defined(HAS_COLOR)\nvarying vec4 vColor;\n#elif defined(IS_LINE_EXTRUSION)\nuniform vec4 lineColor;\n#else\nuniform vec4 polygonFill;\n#endif\n#ifdef HAS_INSTANCE_COLOR\nvarying vec4 vInstanceColor;\n#endif\n#ifdef IS_LINE_EXTRUSION\nuniform float lineOpacity;\n#else\nuniform float polygonOpacity;\n#endif\n#ifdef HAS_PATTERN\nuniform sampler2D linePatternFile;\nuniform vec2 atlasSize;\nuniform float flipY;\nuniform float currentTime;\n#ifdef HAS_PATTERN_ANIM\nvarying float vLinePatternAnimSpeed;\n#else\nuniform float linePatternAnimSpeed;\n#endif\n#ifdef HAS_PATTERN_GAP\nvarying float vLinePatternGap;\n#else\nuniform float linePatternGap;\n#endif\nuniform vec4 linePatternGapColor;\nuniform vec2 uvScale;\nvarying float vPatternHeight;\nvarying float vLinesofar;\nvarying vec4 vTexInfo;\nvarying float vNormalY;\nvec2 e(vec2 f) {\n  vec2 h = mod(f, 1.);\n  vec2 i = vTexInfo.xy;\n  vec2 j = vTexInfo.zw;\n  return (i + h * j) / atlasSize;\n}\n#endif\n#include <heatmap_render_frag>\n#include <snow_frag>\n#include <mask_frag>\n#ifdef HAS_RANDOM_TEX\nconst float k = .5;\nvec2 l(vec2 h, float m) {\n  return vec2(cos(m) * (h.x - k) + sin(m) * (h.y - k) + k, cos(m) * (h.y - k) - sin(m) * (h.x - k) + k);\n}\nfloat n(vec3 o) {\n  return o.x + o.y + o.z;\n}\n#endif\nvec4 u(sampler2D A, in vec2 h) {\n  \n#ifdef HAS_RANDOM_TEX\nhighp vec2 B = uvOrigin;\n  if(uvRotation != .0) {\n    B = l(B, uvRotation);\n  }\n  highp vec2 C = h + B - mod(B, 1.);\n  float D = texture2D(noiseTexture, .005 * C).x;\n  vec2 E = dFdx(C);\n  vec2 F = dFdx(C);\n  float G = D * 8.;\n  float H = fract(G);\n#if 1\nfloat I = floor(G);\n  float J = I + 1.;\n#else\nfloat I = floor(G + .5);\n  float J = floor(G);\n  H = min(H, 1. - H) * 2.;\n#endif\nvec2 K = sin(vec2(3., 7.) * I);\n  vec2 L = sin(vec2(3., 7.) * J);\n  float M = .5;\n  vec4 N = texture2DGradEXT(A, h + M * K, E, F);\n  vec4 O = texture2DGradEXT(A, h + M * L, E, F);\n  return mix(N, O, smoothstep(.2, .8, H - .1 * n(N.xyz - O.xyz)));\n#else\nreturn texture2D(A, h);\n#endif\n}\n#if defined(HAS_BUMP_MAP) && defined(HAS_TANGENT)\nuniform sampler2D bumpTexture;\nuniform float bumpScale;\nuniform float bumpMaxLayers;\nuniform float bumpMinLayers;\nvec2 P(vec2 h, vec3 Q) {\n  float R = mix(bumpMaxLayers, bumpMinLayers, abs(dot(vec3(.0, .0, 1.), Q)));\n  float S = 1. / R;\n  float T = .0;\n  vec2 U = Q.xy * bumpScale / (Q.z * R);\n  vec2 V = h;\n  float W = u(bumpTexture, V).r;\n  for(int X = 0; X < 30; X++) {\n    T += S;\n    V -= U;\n    W = u(bumpTexture, V).r;\n    if(W < T) {\n      break;\n    }\n  }\n  vec2 Y = V + U;\n  float Z = W - T;\n  float ba = u(bumpTexture, Y).r - T + S;\n  return mix(V, Y, Z / (Z - ba));\n}\nvarying vec3 vTangentViewPos;\nvarying vec3 vTangentFragPos;\n#endif\n#define SHADER_NAME PBR\nvec3 bb(const in vec3 bc) {\n  return vec3(bc.r < .0031308 ? bc.r * 12.92 : 1.055 * pow(bc.r, 1. / 2.4) - .055, bc.g < .0031308 ? bc.g * 12.92 : 1.055 * pow(bc.g, 1. / 2.4) - .055, bc.b < .0031308 ? bc.b * 12.92 : 1.055 * pow(bc.b, 1. / 2.4) - .055);\n}\nvec3 bd(const in vec3 bc) {\n  return vec3(bc.r < .04045 ? bc.r * (1. / 12.92) : pow((bc.r + .055) * (1. / 1.055), 2.4), bc.g < .04045 ? bc.g * (1. / 12.92) : pow((bc.g + .055) * (1. / 1.055), 2.4), bc.b < .04045 ? bc.b * (1. / 12.92) : pow((bc.b + .055) * (1. / 1.055), 2.4));\n}\nvec3 be(const in vec4 bc, const in float bf) {\n  if(bf <= .0)\n    return bc.rgb;\n  return bf * bc.rgb * bc.a;\n}\nvec3 bg() {\n  return d.albedo;\n}\nfloat bh() {\n  \n#if defined(HAS_ALPHAMODE)\nif(d.alpha >= alphaCutoff) {\n    return 1.;\n  } else {\n    return .0;\n  }\n#else\nreturn d.alpha;\n#endif\n}\nfloat bi() {\n  \n#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)\nvec3 bc = d.specularColor;\n  return max(max(bc.r, bc.g), bc.b);\n#else\nreturn d.roughnessMetalness.y;\n#endif\n}\nfloat bj() {\n  return specularF0;\n}\nfloat bk() {\n  \n#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)\nreturn 1. - d.glossiness;\n#else\nreturn d.roughnessMetalness.x;\n#endif\n}\nvec3 bl() {\n  return d.emit;\n}\nvec3 bm() {\n  return d.normal;\n}\nfloat bn() {\n  return clearCoatFactor;\n}\nfloat bo() {\n  return clearCoatRoughnessFactor;\n}\nfloat bp() {\n  return d.ao;\n}\nfloat bq(const in vec4 br) {\n  return br.r + br.g / 255.;\n}\nfloat bs(const in vec2 bt, const in float bu) {\n  vec3 bv = vec3(.06711056, .00583715, 52.9829189);\n  return fract(bv.z * fract(dot(bt.xy + bu * vec2(47., 17.) * .695, bv.xy))) * .5;\n}\nvec3 bw(const in float bx, in vec3 by, const in vec3 t, const in vec3 b, in vec3 bz) {\n  by.xy = bx * by.xy;\n  mat3 bA = mat3(t, b, bz);\n  return normalize(bA * by);\n}\nvoid bB(const in vec3 bC, const in vec3 by, const in vec3 bD, out float bE, out vec3 bF, out float bG) {\n  bE = 1.;\n  bF = -bD;\n  bG = dot(bF, by);\n}\nvec4 bH(const in vec3 by, const in vec3 bC, const in float bI) {\n  float bJ = clamp(dot(by, bC), 0., 1.);\n  float bK = bI * bI;\n  return vec4(bK, bK * bK, bJ, bJ * (1. - bK));\n}\nfloat bL(const vec4 bH, const float bM) {\n  float bN = bH.y;\n  float bO = (bM * bN - bM) * bM + 1.;\n  return bN / (3.141593 * bO * bO);\n}\nvec3 bP(const vec3 bQ, const float bR, const in float bS) {\n  float bT = pow(1. - bS, 5.);\n  return bR * bT + (1. - bT) * bQ;\n}\nfloat bP(const float bQ, const float bR, const in float bS) {\n  return bQ + (bR - bQ) * pow(1. - bS, 5.);\n}\nfloat bU(const vec4 bH, const float bV) {\n  float a = bH.x;\n  float bW = bV * (bH.w + a);\n  float bX = bH.z * (bV * (1. - a) + a);\n  return .5 / (bW + bX);\n}\nvec3 bY(const vec4 bH, const vec3 by, const vec3 bC, const vec3 bF, const vec3 bZ, const float bV, const float bR) {\n  vec3 ca = normalize(bC + bF);\n  float bM = clamp(dot(by, ca), 0., 1.);\n  float bS = clamp(dot(bF, ca), 0., 1.);\n  float cb = bL(bH, bM);\n  float cc = bU(bH, bV);\n  vec3 cd = bP(bZ, bR, bS);\n  return (cb * cc * 3.141593) * cd;\n}\nvoid ce(const in vec3 by, const in vec3 bC, const in float bV, const in vec4 bH, const in vec3 cf, const in vec3 bZ, const in float bE, const in vec3 cg, const in vec3 bF, const in float bR, out vec3 ch, out vec3 ci, out bool cj) {\n  cj = bV > .0;\n  if(cj == false) {\n    ci = ch = vec3(.0);\n    return;\n  }\n  vec3 ck = bE * bV * cg;\n  ci = ck * bY(bH, by, bC, bF, bZ, bV, bR);\n  ch = ck * cf;\n}\nfloat cl(float at, float ab, float cm, float cn, float co, float cp, float bJ, float bV) {\n  float cq = bV * length(vec3(at * cm, ab * cn, bJ));\n  float cr = bJ * length(vec3(at * co, ab * cp, bV));\n  return .5 / (cq + cr);\n}\nfloat cs(const float at, const float ab, const float ct, const float cu, const float bM) {\n  float bN = at * ab;\n  vec3 bO = vec3(ab * ct, at * cu, bN * bM);\n  float x = bN / dot(bO, bO);\n  return bN * (x * x) / 3.141593;\n}\nvec3 cv(const vec4 bH, const vec3 by, const vec3 bC, const vec3 bF, const vec3 bZ, const float bV, const float bR, const in vec3 cw, const in vec3 cx, const in float cy) {\n  vec3 ca = normalize(bC + bF);\n  float bM = clamp(dot(by, ca), 0., 1.);\n  float bJ = clamp(dot(by, bC), 0., 1.);\n  float bS = clamp(dot(bF, ca), 0., 1.);\n  float cm = dot(cw, bC);\n  float cn = dot(cx, bC);\n  float co = dot(cw, bF);\n  float cp = dot(cx, bF);\n  float ct = dot(cw, ca);\n  float cu = dot(cx, ca);\n  float cz = sqrt(1. - abs(cy) * .9);\n  if(cy > .0)\n    cz = 1. / cz;\n  float at = bH.x * cz;\n  float ab = bH.x / cz;\n  float cb = cs(at, ab, ct, cu, bM);\n  float cc = cl(at, ab, cm, cn, co, cp, bJ, bV);\n  vec3 cd = bP(bZ, bR, bS);\n  return (cb * cc * 3.141593) * cd;\n}\nvoid cA(const in vec3 by, const in vec3 bC, const in float bV, const in vec4 bH, const in vec3 cf, const in vec3 bZ, const in float bE, const in vec3 cg, const in vec3 bF, const in float bR, const in vec3 cw, const in vec3 cx, const in float cy, out vec3 ch, out vec3 ci, out bool cj) {\n  cj = bV > .0;\n  if(cj == false) {\n    ci = ch = vec3(.0);\n    return;\n  }\n  vec3 ck = bE * bV * cg;\n  ci = ck * cv(bH, by, bC, bF, bZ, bV, bR, cw, cx, cy);\n  ch = ck * cf;\n}\n#if defined(HAS_IBL_LIGHTING)\nvec3 cB(const in vec3 by) {\n  vec3 bz = uEnvironmentTransform * by;\n  float x = bz.x;\n  float y = bz.y;\n  float z = bz.z;\n  vec3 cC = (diffuseSPH[0] + diffuseSPH[1] * x + diffuseSPH[2] * y + diffuseSPH[3] * z + diffuseSPH[4] * z * x + diffuseSPH[5] * y * z + diffuseSPH[6] * y * x + diffuseSPH[7] * (3. * z * z - 1.) + diffuseSPH[8] * (x * x - y * y));\n  if(length(hdrHSV) > .0) {\n    cC = hsv_apply(cC, hdrHSV);\n  }\n  return max(cC, vec3(.0));\n}\nfloat cD(const in float cE) {\n  return cE;\n}\nvec3 cF(const in float cG, const in vec3 cH) {\n  vec3 cI = cH;\n  float cJ = prefilterMiplevel.x;\n  float cK = min(cJ, cD(cG) * prefilterMiplevel.y);\n  vec3 cL = be(textureCubeLod(prefilterMap, cI, cK), rgbmRange);\n  if(length(hdrHSV) > .0) {\n    return hsv_apply(cL, hdrHSV);\n  } else {\n    return cL;\n  }\n}\nvec3 cM(const in vec3 cN, const in vec3 cH, const in float cO) {\n  float cP = 1. - cO;\n  float cQ = cP * (sqrt(cP) + cO);\n  return mix(cN, cH, cQ);\n}\nvec3 cR(const in vec3 by, const in vec3 bC, const in float bI, const in vec3 cS) {\n  vec3 cH = reflect(-bC, by);\n  cH = cM(by, cH, bI);\n  vec3 cT = cF(bI, uEnvironmentTransform * cH);\n  float bx = clamp(1. + dot(cH, cS), .0, 1.);\n  cT *= bx * bx;\n  return cT;\n}\n#else\nvec3 cR(const in vec3 by, const in vec3 bC, const in float bI, const in vec3 cS) {\n  return ambientColor;\n}\n#endif\nvec3 cU(const in vec3 bZ, const in float bI, const in float bJ, const in float bR) {\n  vec4 rgba = texture2D(brdfLUT, vec2(bJ, bI));\n  float b = (rgba[3] * 65280.0 + rgba[2] * 255.);\n  float a = (rgba[1] * 65280.0 + rgba[0] * 255.);\n  const float cV = 1. / 65535.;\n  return (bZ * a + b * bR) * cV;\n}\nvec3 cW(const in vec3 by, const in vec3 bC, const in float bI, const in vec3 bZ, const in vec3 cS, const in float bR) {\n  float bJ = dot(by, bC);\n  return cR(by, bC, bI, cS) * cU(bZ, bI, bJ, bR);\n}\nvec3 cX(const float bJ, const float bV, const vec3 cY, const float bO) {\n  return exp(cY * -bO * ((bV + bJ) / max(bV * bJ, 1e-3)));\n}\nvec3 cZ(const in float bJ, const in float bV, const in float da) {\n  return mix(vec3(1.), cX(bJ, bV, clearCoatTint, clearCoatThickness), da);\n}\nvoid db(const in float dc, const in vec3 by, const in vec3 bC, const in float bG, const in vec4 bH, const in float bE, const in vec3 cg, const in vec3 bF, const in float da, out vec3 dd, out vec3 de) {\n  if(bG <= .0) {\n    dd = vec3(.0);\n    de = vec3(.0);\n    return;\n  }\n  float df = clamp(dot(by, -refract(bF, by, 1. / clearCoatIor)), 0., 1.);\n  vec3 dg = cZ(dc, df, da);\n  vec3 ca = normalize(bC + bF);\n  float bM = clamp(dot(by, ca), 0., 1.);\n  float bS = clamp(dot(bF, ca), 0., 1.);\n  float cb = bL(bH, bM);\n  float cc = bU(bH, df);\n  float cd = bP(c, 1., bS);\n  dd = (bE * bG * da * cb * cc * 3.141593 * cd) * cg;\n  de = (1. - cd * da) * dg;\n}\nfloat dh(const in int di, const in float dj, const in vec3 by, const in vec3 bC) {\n  if(di == 0)\n    return 1.;\n  float bO = dot(by, bC) + dj;\n  return clamp(bO * bO - 1. + dj, .0, 1.);\n}\nvec3 dk(const in vec3 by, const in vec3 bC, const in float bI, const in vec3 cw, const in vec3 cx, const in float cy) {\n  vec3 dl = cy >= .0 ? cx : cw;\n  vec3 dm = cross(dl, bC);\n  vec3 dn = cross(dm, dl);\n  float dp = abs(cy) * clamp(5. * bI, .0, 1.);\n  return normalize(mix(by, dn, dp));\n}\nvoid dq() {\n  \n#ifdef HAS_MAP\nvec2 h = computeTexCoord();\n#endif\n#if defined(HAS_BUMP_MAP) && defined(HAS_TANGENT)\nh = P(h, normalize(vTangentViewPos - vTangentFragPos));\n#endif\nd.albedo = baseColorIntensity * baseColorFactor.rgb;\n  d.alpha = baseColorFactor.a;\n#if defined(HAS_PATTERN)\nfloat dr = vLinesofar;\n  vec2 j = vTexInfo.zw;\n#ifdef HAS_PATTERN_GAP\nfloat ds = vLinePatternGap;\n#else\nfloat ds = linePatternGap;\n#endif\n#ifdef HAS_PATTERN_ANIM\nfloat dt = vLinePatternAnimSpeed;\n#else\nfloat dt = linePatternAnimSpeed;\n#endif\nfloat du = ceil(j.x * vPatternHeight / j.y);\n  float dv = du * (1. + ds);\n  dr += mod(currentTime * -dt * .2, dv);\n  float dw = mod(dr / dv, 1.);\n  float dx = mod(flipY * vNormalY, 1.);\n  vec2 h = e(vec2(dw * (1. + ds) * uvScale[0], dx * uvScale[1]));\n  vec4 dy = texture2D(linePatternFile, h);\n  float dz = clamp(sign(1. / (1. + ds) - dw) + .000001, .0, 1.);\n  dy = mix(linePatternGapColor, dy, dz);\n#ifdef IS_SQUARE_TUBE\nfloat o = clamp(sign(abs(vNormalY) - .999999), .0, 1.);\n  dy = mix(dy, vec4(1.), o);\n#endif\nd.albedo *= dy.rgb;\n  d.alpha *= dy.a;\n#endif\n#if defined(HAS_ALBEDO_MAP)\nvec4 dA = u(baseColorTexture, h);\n  d.albedo *= bd(dA.rgb);\n  d.alpha *= dA.a;\n#endif\n#if defined(HAS_COLOR0)\nd.albedo *= vColor0.rgb;\n#if COLOR0_SIZE == 4\nd.alpha *= vColor0.a;\n#endif\n#endif\n#if defined(HAS_COLOR)\nd.albedo *= vColor.rgb;\n  d.alpha *= vColor.a;\n#elif defined(IS_LINE_EXTRUSION)\nd.albedo *= lineColor.rgb;\n  d.alpha *= lineColor.a;\n#else\nd.albedo *= polygonFill.rgb;\n  d.alpha *= polygonFill.a;\n#endif\n#if defined(HAS_INSTANCE_COLOR)\nd.albedo *= vInstanceColor.rgb;\n  d.alpha *= vInstanceColor.a;\n#endif\n#if defined(IS_LINE_EXTRUSION)\nd.alpha *= lineOpacity;\n#else\nd.alpha *= polygonOpacity;\n#endif\n#if defined(HAS_METALLICROUGHNESS_MAP)\nd.roughnessMetalness = u(metallicRoughnessTexture, h).gb * vec2(roughnessFactor, metallicFactor);\n#else\nd.roughnessMetalness = vec2(roughnessFactor, metallicFactor);\n#endif\nd.emit = emissiveFactor;\n#if defined(HAS_EMISSIVE_MAP)\nif(emitMultiplicative == 1) {\n    d.emit *= bd(u(emissiveTexture, h).rgb);\n  } else {\n    d.emit += bd(u(emissiveTexture, h).rgb);\n  }\n#endif\nd.emit *= emitColorFactor;\n#if defined(HAS_AO_MAP)\nd.ao = u(occlusionTexture, h).r;\n#else\nd.ao = 1.;\n#endif\nd.ao *= occlusionFactor;\n#if defined(HAS_NORMAL_MAP) && defined(HAS_TANGENT)\nvec3 dB = u(normalTexture, h).xyz * 2. - 1.;\n  dB.y = normalMapFlipY == 1 ? -dB.y : dB.y;\n  d.normal = dB;\n#else\nd.normal = normalize(vModelNormal);\n#endif\n#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)\nd.albedo *= diffuseFactor.rgb;\n  d.alpha *= diffuseFactor.a;\n#if defined(HAS_DIFFUSE_MAP)\nvec4 cf = u(diffuseTexture, h);\n  d.albedo *= bd(cf.rgb);\n  d.alpha *= cf.a;\n#endif\nd.specularColor = specularFactor;\n  d.glossiness = glossinessFactor;\n#if defined(HAS_SPECULARGLOSSINESS_MAP)\nvec4 dC = u(specularGlossinessTexture, h);\n  d.specularColor *= bd(dC.rgb);\n  d.glossiness *= dC.a;\n#endif\n#endif\n}\nvec3 dD(const vec3 x) {\n  const float a = 2.51;\n  const float b = .03;\n  const float dE = 2.43;\n  const float bO = .59;\n  const float dF = .14;\n  return (x * (a * x + b)) / (x * (dE * x + bO) + dF);\n}\nvec3 dG(vec3 bc) {\n  bc = dD(bc);\n  return bc = pow(bc, vec3(1. / 2.2));\n}\nuniform float specularAAVariance;\nuniform float specularAAThreshold;\nfloat dH(float bI, const vec3 dI) {\n  \n#if defined(GL_OES_standard_derivatives) || __VERSION__ == 300\nvec3 dJ = dFdx(dI);\n  vec3 dK = dFdy(dI);\n  float dL = specularAAVariance * (dot(dJ, dJ) + dot(dK, dK));\n  float dM = min(2. * dL, specularAAThreshold);\n  float dN = saturate(bI * bI + dM);\n  return sqrt(dN);\n#else\nreturn bI;\n#endif\n}\n#ifdef HAS_SSR\nuniform sampler2D TextureDepth;\nuniform highp vec2 outSize;\nuniform float ssrFactor;\nuniform float ssrQuality;\nuniform sampler2D TextureReflected;\nuniform highp mat4 projMatrix;\nuniform mat4 invProjMatrix;\nuniform vec4 outputFovInfo[2];\nuniform mat4 reprojViewProjMatrix;\nvec3 dO(const in mat4 dP, const in vec3 dQ) {\n  vec4 dR = dP * vec4(dQ, 1.);\n  return vec3(.5 + .5 * dR.xy / dR.w, dR.w);\n}\nvec3 dS(const in float dT, const in vec2 h) {\n  return texture2D(TextureReflected, h).rgb;\n}\nfloat dU(float dV) {\n  highp mat4 dP = projMatrix;\n  highp float z = dV * 2. - 1.;\n  return -dP[3].z / (z + dP[2].z);\n}\nfloat dW(const vec2 h) {\n  float dV = bq(texture2D(TextureDepth, h));\n  return dV;\n}\nvec3 dX(const in float bu, const in vec3 dY, const in vec3 dZ, const in vec3 ea, const in vec3 bC, const in float eb) {\n  vec2 ec;\n  ec.x = bs(gl_FragCoord.yx, bu);\n  ec.y = fract(ec.x * 52.9829189);\n  ec.y = mix(ec.y, 1., .7);\n  float ed = 2. * 3.14159 * ec.x;\n  float ee = pow(max(ec.y, .000001), eb / (2. - eb));\n  float ef = sqrt(1. - ee * ee);\n  vec3 eg = vec3(ef * cos(ed), ef * sin(ed), ee);\n  eg = eg.x * dY + eg.y * dZ + eg.z * ea;\n  return normalize((2. * dot(bC, eg)) * eg - bC);\n}\nfloat eh(const in float bu) {\n  return (bs(gl_FragCoord.xy, bu) - .5);\n}\nvec3 ei(const in vec3 ej, const in float ek, const in vec3 el) {\n  vec3 em = dO(projMatrix, vViewVertex.xyz + el * ek);\n  em.z = 1. / em.z;\n  em -= ej;\n  float en = min(1., .99 * (1. - ej.x) / max(1e-5, em.x));\n  float eo = min(1., .99 * (1. - ej.y) / max(1e-5, em.y));\n  float ep = min(1., .99 * ej.x / max(1e-5, -em.x));\n  float eq = min(1., .99 * ej.y / max(1e-5, -em.y));\n  return em * min(en, eo) * min(ep, eq);\n}\nfloat er(const in vec3 ej, const in vec3 em, inout float es, inout float et) {\n  float eu = (et + es) * .5;\n  vec3 ev = ej + em * eu;\n  float z = dW(ev.xy);\n  float dV = dU(z);\n  float ew = -1. / ev.z;\n  es = dV > ew ? es : eu;\n  et = dV > ew ? eu : et;\n  return eu;\n}\nvec4 ex(const in vec3 ej, const in float ek, in float ey, const in vec3 el, const in float bI, const in float bu) {\n  int ez = 20;\n  float eA = 1. / float(ez);\n  ey *= eA;\n  vec3 em = ei(ej, ek, el);\n  float eB = eA;\n  vec3 eC = vec3(.0, eB, 1.);\n  vec3 ev;\n  float z, dV, ew, eD, eE, eF;\n  bool eG;\n  float eH = 1.;\n  float eu;\n  for(int X = 0; X < ez; X++) {\n    ev = ej + em * eC.y;\n    z = dW(ev.xy);\n    dV = dU(z);\n    ew = -1. / ev.z;\n    float eI = clamp(sign(.999 - z), .0, 1.);\n    eD = eI * (ew - dV);\n    eD *= clamp(sign(abs(eD) - ek * eA * eA), .0, 1.);\n    eG = abs(eD + ey) < ey;\n    eE = clamp(eC.x / (eC.x - eD), .0, 1.);\n    eF = eG ? eC.y + eE * eA - eA : 1.;\n    eC.z = min(eC.z, eF);\n    eC.x = eD;\n    if(eG) {\n      float es = eC.y - eA;\n      float et = eC.y;\n      eu = er(ej, em, es, et);\n      eu = er(ej, em, es, et);\n      eu = er(ej, em, es, et);\n      eH = eu;\n      break;\n    }\n    eC.y += eA;\n  }\n  return vec4(ej + em * eH, 1. - eH);\n}\nvec4 eJ(in vec4 eK, const in float eL, const in vec3 eM, const in vec3 eN, const in float bI) {\n  vec4 eO = mix(outputFovInfo[0], outputFovInfo[1], eK.x);\n  eK.xyz = vec3(mix(eO.xy, eO.zw, eK.y), 1.) * -1. / eK.z;\n  eK.xyz = (reprojViewProjMatrix * vec4(eK.xyz, 1.)).xyw;\n  eK.xy /= eK.z;\n  float eP = clamp(6. - 6. * max(abs(eK.x), abs(eK.y)), .0, 1.);\n  eK.xy = .5 + .5 * eK.xy;\n  vec3 eQ = eN * dS(bI * (1. - eK.w), eK.xy);\n  return vec4(mix(eM, eQ, eL * eP), 1.);\n}\nvec3 ssr(const in vec3 eM, const in vec3 eN, const in float bI, const in vec3 by, const in vec3 bC) {\n  float eR = .0;\n  vec4 cC = vec4(.0);\n  float eb = bI * bI;\n  eb = eb * eb;\n  vec3 eS = abs(by.z) < .999 ? vec3(.0, .0, 1.) : vec3(1., .0, .0);\n  vec3 dY = normalize(cross(eS, by));\n  vec3 dZ = cross(by, dY);\n  float eL = ssrFactor * clamp(-4. * dot(bC, by) + 3.8, .0, 1.);\n  eL *= clamp(4.7 - bI * 5., .0, 1.);\n  vec3 ej = dO(projMatrix, vViewVertex.xyz);\n  ej.z = 1. / ej.z;\n  vec3 el = dX(eR, dY, dZ, by, bC, eb);\n  float ek = mix(cameraNearFar.y + vViewVertex.z, -vViewVertex.z - cameraNearFar.x, el.z * .5 + .5);\n  float ey = .5 * ek;\n  vec4 eK;\n  if(dot(el, by) > .001 && eL > .0) {\n    eK = ex(ej, ek, ey, el, bI, eR);\n    if(eK.w > .0)\n      cC += eJ(eK, eL, eM, eN, bI);\n    \n  }\n  return cC.w > .0 ? cC.rgb / cC.w : eM;\n}\n#endif\n#include <highlight_frag>\nvoid main() {\n  dq();\n  vec3 bC = normalize(cameraPosition - vModelVertex.xyz);\n#if defined(HAS_DOUBLE_SIDE)\nvec3 cS = gl_FrontFacing ? normalize(vModelNormal) : -normalize(vModelNormal);\n#else\nvec3 cS = normalize(vModelNormal);\n#endif\n#if defined(HAS_TANGENT)\nvec4 eT;\n  eT = vModelTangent;\n#if defined(HAS_DOUBLE_SIDE)\neT.xyz = gl_FrontFacing ? normalize(eT.xyz) : -normalize(eT.xyz);\n#else\neT.xyz = normalize(eT.xyz);\n#endif\nvec3 eU = normalize(vModelBiTangent);\n#endif\nfloat bQ = .08 * bj();\n  float eV = bi();\n  vec3 eW = bg();\n#if defined(SHADING_MODEL_SPECULAR_GLOSSINESS)\nvec3 eX = d.specularColor;\n#else\nvec3 eX = mix(vec3(bQ), eW, eV);\n#endif\neW *= 1. - eV;\n  float eY = clamp(50.0 * eX.g, .0, 1.);\n  float eZ = bk();\n  if(specularAAVariance > .0) {\n    eZ = dH(eZ, cS);\n  }\n  vec3 fa = bl();\n  vec3 fb = bm();\n  vec3 fc = vec3(fb);\n#if defined(HAS_TANGENT) && defined(HAS_NORMAL_MAP)\nfc = bw(normalMapFactor, fc, eT.xyz, eU, cS);\n#endif\nfloat fd = bn();\n  float fe = bo();\n  if(specularAAVariance > .0) {\n    fe = dH(fe, cS);\n  }\n  vec3 ff = cS;\n#if defined(HAS_TANGENT)\nfloat cy;\n  vec3 cw;\n  vec3 cx;\n  if(anisotropyFactor > .0) {\n    cy = anisotropyFactor;\n    eT.xyz = normalize(eT.xyz - fc * dot(eT.xyz, fc));\n    eU = normalize(cross(fc, eT.xyz)) * eT.w;\n    cw = normalize(mix(eT.xyz, eU, anisotropyDirection));\n    cx = normalize(mix(eU, -eT.xyz, anisotropyDirection));\n  }\n#endif\nvec3 cf = vec3(.0);\n  vec3 bZ = vec3(.0);\n  vec3 fg;\n#if defined(HAS_TANGENT)\nif(anisotropyFactor > .0) {\n    fg = dk(fc, bC, eZ, cw, cx, cy);\n  } else {\n    fg = fc;\n  }\n#else\nfg = fc;\n#endif\n#if defined(HAS_IBL_LIGHTING)\ncf = eW * cB(fc) * .5;\n#else\ncf = eW * ambientColor;\n#endif\nbZ = cW(fg, bC, eZ, eX, cS, eY);\n  float dc;\n  if(clearCoatFactor > .0) {\n    dc = clamp(dot(ff, -refract(bC, ff, 1. / clearCoatIor)), 0., 1.);\n    float fh = fd * bP(c, 1., dc);\n    vec3 fi = cZ(dc, dc, fd);\n    bZ = mix(bZ * fi, cR(ff, bC, fe, cS), fh);\n    cf *= fi * (1. - fh);\n  }\n  float fj = 1.;\n  float fk = bp();\n  cf *= environmentExposure * fk;\n#ifdef HAS_IBL_LIGHTING\nfj = dh(1, fk, fc, bC);\n#endif\n#ifdef HAS_SSR\nvec3 fl = normalize(gl_FrontFacing ? vViewNormal : -vViewNormal);\n  vec3 fm = fl;\n#if defined(HAS_TANGENT) && defined(HAS_NORMAL_MAP)\nvec4 fn;\n  fn = vViewTangent;\n  fn = gl_FrontFacing ? fn : -fn;\n  fn.xyz = normalize(fn.xyz);\n  vec3 fo = normalize(cross(fl, fn.xyz)) * fn.w;\n  fm = bw(normalMapFactor, fb, fn.xyz, fo, fl);\n#endif\nbZ = ssr(bZ, eX * fj, eZ, fm, -normalize(vViewVertex.xyz));\n#endif\nbZ *= environmentExposure * fj;\n  float bE, bG;\n  vec3 bF;\n  bool cj;\n  vec3 fp;\n  vec3 fq;\n  vec4 fr = bH(fc, bC, max(.045, eZ));\n  vec3 fs = vModelNormal;\n  bB(bC, fc, light0_viewDirection, bE, bF, bG);\n#if defined(HAS_TANGENT)\nif(anisotropyFactor > .0) {\n    cA(fc, bC, bG, fr, eW, eX, bE, light0_diffuse.rgb, bF, eY, cw, cx, cy, fq, fp, cj);\n  } else {\n    ce(fc, bC, bG, fr, eW, eX, bE, light0_diffuse.rgb, bF, eY, fq, fp, cj);\n  }\n#else\nce(fc, bC, bG, fr, eW, eX, bE, light0_diffuse.rgb, bF, eY, fq, fp, cj);\n#endif\nif(clearCoatFactor > .0) {\n    vec3 ft;\n    vec3 fu;\n    vec4 fv = bH(ff, bC, fe);\n    db(dc, ff, bC, dot(ff, bF), fv, bE, light0_diffuse.rgb, bF, fd, ft, fu);\n    fq *= fu;\n    fp = ft + fp * fu;\n  }\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\nfloat fw = shadow_computeShadow();\n  fq = shadow_blend(fq, fw).rgb;\n  fp = shadow_blend(fp, fw).rgb;\n#endif\nvec3 fx = vec3(bZ);\n  vec3 fy = vec3(cf);\n  cf += fq;\n  bZ += fp;\n  cf += fa;\n  vec3 fz = bZ + cf;\n  if(outputSRGB == 1)\n    fz = bb(fz);\n  glFragColor = vec4(fz, bh());\n#ifdef HAS_HEATMAP\nglFragColor = heatmap_getColor(glFragColor);\n#endif\n#ifdef HAS_SNOW\nglFragColor.rgb = snow(glFragColor, bm(), 1.);\n#endif\nif(contrast != 1.) {\n    glFragColor = contrastMatrix(contrast) * glFragColor;\n  }\n  if(length(hsv) > .0) {\n    glFragColor = hsv_apply(glFragColor, hsv);\n  }\n#ifdef OUTPUT_NORMAL\nglFragColor = vec4(cS, 1.);\n#endif\nglFragColor = highlight_blendColor(glFragColor);\n#ifdef HAS_MASK_EXTENT\nglFragColor = setMask(glFragColor);\n#endif\n#if __VERSION__ == 100\ngl_FragColor = glFragColor;\n#endif\n}",
	                uniforms: u,
	                extraCommandProps: n,
	                defines: o
	            }), this.version = 300;
	        }
	        getGeometryDefines(t) {
	            const e = {};
	            return t.data[t.desc.tangentAttribute] ? e.HAS_TANGENT = 1 : t.data[t.desc.normalAttribute] && (e.HAS_NORMAL = 1), 
	            t.data[t.desc.colorAttribute] && (e.HAS_COLOR = 1), t.data[t.desc.color0Attribute] && (e.HAS_COLOR0 = 1, 
	            e.COLOR0_SIZE = t.getColor0Size()), e;
	        }
	    },
	    StandardDepthShader: class extends ie$1 {
	        constructor(t = {}) {
	            const n = [];
	            super({
	                vert: "#define SHADER_NAME depth_vert\nprecision highp float;\nattribute vec3 aPosition;\n#include <line_extrusion_vert>\nuniform mat4 modelViewMatrix;\nuniform mat4 positionMatrix;\nuniform mat4 projMatrix;\nuniform vec2 outSize;\nuniform vec2 halton;\n#include <get_output>\nvoid main() {\n  mat4 c = getPositionMatrix();\n#ifdef IS_LINE_EXTRUSION\nvec4 d = getPosition(getLineExtrudePosition(aPosition));\n#else\nvec4 d = getPosition(aPosition);\n#endif\nvec4 e = modelViewMatrix * c * d;\n  mat4 f = projMatrix;\n  f[2].xy += halton.xy / outSize.xy;\n  gl_Position = f * e;\n}",
	                frag: "#define SHADER_NAME depth_frag\nprecision highp float;\nvoid main() {\n  gl_FragColor = vec4(1., .0, .0, 1.);\n}",
	                uniforms: [ {
	                    name: "modelViewMatrix",
	                    type: "function",
	                    fn: (t, i) => multiply$5(n, i.viewMatrix, i.modelMatrix)
	                } ],
	                extraCommandProps: t.extraCommandProps,
	                defines: t.defines
	            });
	        }
	    },
	    PBRUtils: Yd
	};

	var reshadergl = /*#__PURE__*/Object.freeze({
		__proto__: null,
		AbstractTexture: F$1,
		BloomPass: Oe,
		BoundingBox: W$1,
		BoxBlurShader: ge,
		Constants: z$1,
		CopyShader: He,
		DeferredRenderer: B$1,
		ExtentPass: rd,
		FBORayPicking: fm,
		FogPass: Be,
		FogShader: Ge,
		FxaaShader: me,
		GLTFHelper: xd,
		GLTFManager: Pd,
		Geometry: Q$1,
		HDR: xm,
		HeatmapDisplayShader: Fe,
		HeatmapShader: ke,
		InstancedMesh: dt$1,
		Jitter: Ae,
		KHRTechniquesWebglManager: ym,
		Material: tt$1,
		Mesh: ft$1,
		MeshShader: ie$1,
		PhongMaterial: rt$1,
		PhongShader: ae$1,
		PhongSpecularGlossinessMaterial: lt$1,
		Plane: Wt$1,
		PointLineShader: he$1,
		PostProcessShader: be,
		QuadShader: de,
		REGLHelper: Gt$1,
		RainRipplesPass: qe,
		Renderer: N$1,
		ResourceLoader: gt$1,
		Scene: yt$1,
		Shader: ee$1,
		ShaderLib: Xt$1,
		ShadowDisplayShader: nm,
		ShadowMapShader: Kd,
		ShadowPass: em,
		SkyboxShader: ze,
		SsaoPass: xe,
		SsrPass: Ie,
		TaaPass: Me,
		Texture2D: Vt$1,
		TextureCube: Ut$1,
		ToonMaterial: st$1,
		ToonShader: le$1,
		Util: k$1,
		WaterShader: je,
		WireFrameMaterial: nt$1,
		WireframeShader: re$1,
		earcut: $f,
		pbr: bm
	});

	var isArray = Array.isArray;
	var keyList = Object.keys;
	var hasProp = Object.prototype.hasOwnProperty;

	var fastDeepEqual = function equal(a, b) {
	  if (a === b) return true;

	  if (a && b && typeof a == 'object' && typeof b == 'object') {
	    var arrA = isArray(a)
	      , arrB = isArray(b)
	      , i
	      , length
	      , key;

	    if (arrA && arrB) {
	      length = a.length;
	      if (length != b.length) return false;
	      for (i = length; i-- !== 0;)
	        if (!equal(a[i], b[i])) return false;
	      return true;
	    }

	    if (arrA != arrB) return false;

	    var dateA = a instanceof Date
	      , dateB = b instanceof Date;
	    if (dateA != dateB) return false;
	    if (dateA && dateB) return a.getTime() == b.getTime();

	    var regexpA = a instanceof RegExp
	      , regexpB = b instanceof RegExp;
	    if (regexpA != regexpB) return false;
	    if (regexpA && regexpB) return a.toString() == b.toString();

	    var keys = keyList(a);
	    length = keys.length;

	    if (length !== keyList(b).length)
	      return false;

	    for (i = length; i-- !== 0;)
	      if (!hasProp.call(b, keys[i])) return false;

	    for (i = length; i-- !== 0;) {
	      key = keys[i];
	      if (!equal(a[key], b[key])) return false;
	    }

	    return true;
	  }

	  return a!==a && b!==b;
	};

	/*!
	 * @maptalks/fusiongl v0.5.2
	 * LICENSE : UNLICENSED
	 * (c) 2016-2023 maptalks.com
	 */
	function _$1(E){for(let _=1;_<arguments.length;_++){const t=arguments[_];for(const _ in t)E[_]=t[_];}return E}function t(E,...t){for(let R=0;R<t.length;R++)_$1(E,t[R]);}class R$1{constructor(E){this.context=E,this.COLOR_ATTACHMENT0_WEBGL=36064,this.COLOR_ATTACHMENT1_WEBGL=36065,this.COLOR_ATTACHMENT2_WEBGL=36066,this.COLOR_ATTACHMENT3_WEBGL=36067,this.COLOR_ATTACHMENT4_WEBGL=36068,this.COLOR_ATTACHMENT5_WEBGL=36069,this.COLOR_ATTACHMENT6_WEBGL=36070,this.COLOR_ATTACHMENT7_WEBGL=36071,this.COLOR_ATTACHMENT8_WEBGL=36072,this.COLOR_ATTACHMENT9_WEBGL=36073,this.COLOR_ATTACHMENT10_WEBGL=577040,this.COLOR_ATTACHMENT11_WEBGL=577041,this.COLOR_ATTACHMENT12_WEBGL=577042,this.COLOR_ATTACHMENT13_WEBGL=577043,this.COLOR_ATTACHMENT14_WEBGL=577044,this.COLOR_ATTACHMENT15_WEBGL=577045,this.DRAW_BUFFER0_WEBGL=34853,this.DRAW_BUFFER1_WEBGL=34854,this.DRAW_BUFFER2_WEBGL=34855,this.DRAW_BUFFER3_WEBGL=34856,this.DRAW_BUFFER4_WEBGL=34857,this.DRAW_BUFFER5_WEBGL=34858,this.DRAW_BUFFER6_WEBGL=34859,this.DRAW_BUFFER7_WEBGL=34860,this.DRAW_BUFFER8_WEBGL=34861,this.DRAW_BUFFER9_WEBGL=34862,this.DRAW_BUFFER10_WEBGL=34863,this.DRAW_BUFFER11_WEBGL=34864,this.DRAW_BUFFER12_WEBGL=34865,this.DRAW_BUFFER13_WEBGL=34866,this.DRAW_BUFFER14_WEBGL=34867,this.DRAW_BUFFER15_WEBGL=34868,this.MAX_COLOR_ATTACHMENTS_WEBGL=36063,this.MAX_DRAW_BUFFERS_WEBGL=2178;}drawBuffersWEBGL(){return this.context.drawBuffers.apply(this.context,arguments)}}class T$1{constructor(E){this.context=E,this.VERTEX_ARRAY_BINDING_OES=34229;}createVertexArrayOES(){return this.context.createVertexArray()}deleteVertexArrayOES(){return this.context.deleteVertexArray.apply(this.context,arguments)}isVertexArrayOES(){return this.context.isVertexArray.apply(this.context,arguments)}bindVertexArrayOES(){return this.context.bindVertexArray.apply(this.context,arguments)}}class A$1{constructor(E){this.context=E,this.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE=35070;}drawArraysInstancedANGLE(){return this.context.drawArraysInstanced.apply(this.context,arguments)}drawElementsInstancedANGLE(){return this.context.drawElementsInstanced.apply(this.context,arguments)}vertexAttribDivisorANGLE(){return this.context.vertexAttribDivisor.apply(this.context,arguments)}}const s={webgl_depth_texture:{UNSIGNED_INT_24_8_WEBGL:34042},oes_element_index_uint:{},oes_texture_float:{},oes_texture_half_float:{HALF_FLOAT_OES:36193},ext_color_buffer_float:{},oes_standard_derivatives:{},ext_frag_depth:{},ext_blend_minmax:{MIN_EXT:32775,MAX_EXT:32776},ext_shader_texture_lod:{}},e$1={has(E,_){const t=E._,R=E.t;return !(!t&&!R.getExtension(_))&&(_=_.toLowerCase(),t&&s[_]||"webgl_draw_buffers"===_||"oes_vertex_array_object"===_||"angle_instanced_arrays"===_)},mock(E,_){return _=_.toLowerCase(),s[_]?E._?("oes_texture_float"!==_&&"oes_texture_half_float"!==_||E.t.getExtension("EXT_color_buffer_float"),s[_]):this.t.getExtension(_):"webgl_draw_buffers"===_?new R$1(E):"oes_vertex_array_object"===_?new T$1(E):"angle_instanced_arrays"===_?new A$1(E):null},getInternalFormat:(E,_,t)=>6402===_?33190:34041===_?35056:36193===t&&_===E.RGBA?34842:36193===t&&_===E.RGB?34843:t===E.FLOAT&&_===E.RGBA?34836:t===E.FLOAT&&_===E.RGB?34837:_,getTextureType:(E,_)=>36193===_?E.HALF_FLOAT:_};let r=1;class i{constructor(E){this.uid=r++,this.states=function(E){return {scissor:[0,0,E.canvas.width,E.canvas.height],viewport:[0,0,E.canvas.width,E.canvas.height],blendColor:[0,0,0,0],blendEquationSeparate:[E.FUNC_ADD,E.FUNC_ADD],blendFuncSeparate:[E.ONE,E.ZERO,E.ONE,E.ZERO],clearColor:[0,0,0,0],clearDepth:[1],clearStencil:[0],colorMask:[!0,!0,!0,!0],cullFace:[E.BACK],depthFunc:[E.LESS],depthMask:[!0],depthRange:[0,1],capabilities:{3042:!1,2884:!1,2929:!1,3024:!1,32823:!1,32926:!1,32928:!1,3089:!1,2960:!1},frontFace:[E.CCW],hint:{33170:[E.DONT_CARE],35723:[E.DONT_CARE]},lineWidth:[1],pixelStorei:{3333:[4],3317:[4],37440:[!1],37441:[!1],37443:[E.BROWSER_DEFAULT_WEBGL]},polygonOffset:[0,0],sampleCoverage:[1,!1],stencilFuncSeparate:{1028:[E.ALWAYS,0,4294967295],1029:[E.ALWAYS,0,4294967295]},stencilMaskSeparate:{1028:[4294967295],1029:[4294967295]},stencilOpSeparate:{1028:[E.KEEP,E.KEEP,E.KEEP],1029:[E.KEEP,E.KEEP,E.KEEP]},program:null,framebuffer:{36160:null,36008:null,36009:null},renderbuffer:{36161:null},textures:{active:-1,units:function(){const _=[],t=E.getParameter(E.MAX_COMBINED_TEXTURE_IMAGE_UNITS);for(let E=0;E<t;E++)_.push({3553:null,34067:null});return _[-1]={3553:null,34067:null},_}()},attributes:{},arrayBuffer:null,elementArrayBuffer:null}}(E),this.t=E,this.t._fusiongl_drawCalls=0,this._="undefined"!=typeof WebGL2RenderingContext&&this.t instanceof WebGL2RenderingContext,this.R=E.getParameter(E.MAX_VERTEX_ATTRIBS);}get canvas(){return this.t.canvas}get drawingBufferWidth(){return this.t.drawingBufferWidth}get drawingBufferHeight(){return this.t.drawingBufferHeight}get gl(){return this.t}get buffersOES(){return this.T||(this.T=this.t.getExtension("WEBGL_draw_buffers")),this.T}get vaoOES(){return this.A||(this.A=this.t.getExtension("OES_vertex_array_object")),this.A}get angleOES(){return this.s||(this.s=this.t.getExtension("ANGLE_instanced_arrays")),this.s}attachShader(E,_){return this.t.attachShader(E,_)}shaderSource(E,_){return this.t.shaderSource(E,_)}compileShader(E){return this.t.compileShader(E)}createShader(E){return this.t.createShader(E)}createProgram(){return this.t.createProgram()}deleteProgram(E){return this.states.program===E&&(this.states.program=null),this.t.deleteProgram(E)}deleteShader(E){return this.t.deleteShader(E)}detachShader(E,_){return this.t.detachShader(E,_)}getAttachedShaders(E){return this.t.getAttachedShaders(E)}linkProgram(E){return this.t.linkProgram(E)}getShaderParameter(E,_){return this.t.getShaderParameter(E,_)}getShaderPrecisionFormat(E,_){return this.t.getShaderPrecisionFormat(E,_)}getShaderInfoLog(E){return this.t.getShaderInfoLog(E)}getShaderSource(E){return this.t.getShaderSource(E)}getProgramInfoLog(E){return this.t.getProgramInfoLog(E)}getProgramParameter(E,_){return this.t.getProgramParameter(E,_)}getError(){return this.t.getError()}getContextAttributes(){return this.t.getContextAttributes()}getExtension(E){return e$1.has(this,E)?e$1.mock(this,E):this.t.getExtension(E)}getSupportedExtensions(){return this.t.getSupportedExtensions()}getParameter(E){return this.t.getParameter(E)}isEnabled(E){return this.t.isEnabled(E)}isProgram(E){return this.t.isProgram(E)}isShader(E){return this.t.isShader(E)}validateProgram(E){return this.t.validateProgram(E)}clear(E){return this.i(),this.t.clear(E)}drawArrays(E,_,t){return this.i(),this.N(),this.t.drawArrays(E,_,t)}drawElements(E,_,t,R){return this.i(),this.N(),this.t.drawElements(E,_,t,R)}drawBuffers(E){return this.i(),this.N(),this._?this.t.drawBuffers(E):this.buffersOES.drawBuffersWEBGL(E)}N(){this.t._fusiongl_drawCalls++;}resetDrawCalls(){this.t._fusiongl_drawCalls=0;}getDrawCalls(){return this.t._fusiongl_drawCalls}I(){const E=this.t,_=E.getParameter(E.CURRENT_PROGRAM),t=E.getProgramParameter(_,E.ACTIVE_ATTRIBUTES),R=[];for(let _=0;_<t;_++)R.push(E.getVertexAttrib(_,E.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING));this.h={buffers:R,elements:E.getParameter(E.ELEMENT_ARRAY_BUFFER_BINDING),framebuffer:E.getParameter(E.FRAMEBUFFER_BINDING)},window.DEBUGGING&&(console.log(this.uid,this.h),console.log(this.uid,this.states.attributes),console.log(this.states.attributes[0].buffer===this.h.buffers[0]),console.log(this.states.attributes[1].buffer===this.h.buffers[1]),console.log(this.states.attributes[2].buffer===this.h.buffers[2]));}finish(){return this.t.finish()}flush(){return this.i(),this.t.flush()}commit(){return this.i(),this.t.commit()}isContextLost(){return this.t.isContextLost()}}t(i.prototype,{DEPTH_BUFFER_BIT:256,STENCIL_BUFFER_BIT:1024,COLOR_BUFFER_BIT:16384,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,ZERO:0,ONE:1,SRC_COLOR:768,ONE_MINUS_SRC_COLOR:769,SRC_ALPHA:770,ONE_MINUS_SRC_ALPHA:771,DST_ALPHA:772,ONE_MINUS_DST_ALPHA:773,DST_COLOR:774,ONE_MINUS_DST_COLOR:775,SRC_ALPHA_SATURATE:776,CONSTANT_COLOR:32769,ONE_MINUS_CONSTANT_COLOR:32770,CONSTANT_ALPHA:32771,ONE_MINUS_CONSTANT_ALPHA:32772,FUNC_ADD:32774,FUNC_SUBSTRACT:32778,FUNC_REVERSE_SUBTRACT:32779,BLEND_EQUATION:32777,BLEND_EQUATION_RGB:32777,BLEND_EQUATION_ALPHA:34877,BLEND_DST_RGB:32968,BLEND_SRC_RGB:32969,BLEND_DST_ALPHA:32970,BLEND_SRC_ALPHA:32971,BLEND_COLOR:32773,ARRAY_BUFFER_BINDING:34964,ELEMENT_ARRAY_BUFFER_BINDING:34965,LINE_WIDTH:2849,ALIASED_POINT_SIZE_RANGE:33901,ALIASED_LINE_WIDTH_RANGE:33902,CULL_FACE_MODE:2885,FRONT_FACE:2886,DEPTH_RANGE:2928,DEPTH_WRITEMASK:2930,DEPTH_CLEAR_VALUE:2931,DEPTH_FUNC:2932,STENCIL_CLEAR_VALUE:2961,STENCIL_FUNC:2962,STENCIL_FAIL:2964,STENCIL_PASS_DEPTH_FAIL:2965,STENCIL_PASS_DEPTH_PASS:2966,STENCIL_REF:2967,STENCIL_VALUE_MASK:2963,STENCIL_WRITEMASK:2968,STENCIL_BACK_FUNC:34816,STENCIL_BACK_FAIL:34817,STENCIL_BACK_PASS_DEPTH_FAIL:34818,STENCIL_BACK_PASS_DEPTH_PASS:34819,STENCIL_BACK_REF:36003,STENCIL_BACK_VALUE_MASK:36004,STENCIL_BACK_WRITEMASK:36005,VIEWPORT:2978,SCISSOR_BOX:3088,COLOR_CLEAR_VALUE:3106,COLOR_WRITEMASK:3107,UNPACK_ALIGNMENT:3317,PACK_ALIGNMENT:3333,MAX_TEXTURE_SIZE:3379,MAX_VIEWPORT_DIMS:3386,SUBPIXEL_BITS:3408,RED_BITS:3410,GREEN_BITS:3411,BLUE_BITS:3412,ALPHA_BITS:3413,DEPTH_BITS:3414,STENCIL_BITS:3415,POLYGON_OFFSET_UNITS:10752,POLYGON_OFFSET_FACTOR:32824,TEXTURE_BINDING_2D:32873,SAMPLE_BUFFERS:32936,SAMPLES:32937,SAMPLE_COVERAGE_VALUE:32938,SAMPLE_COVERAGE_INVERT:32939,COMPRESSED_TEXTURE_FORMATS:34467,VENDOR:7936,RENDERER:7937,VERSION:7938,IMPLEMENTATION_COLOR_READ_TYPE:35738,IMPLEMENTATION_COLOR_READ_FORMAT:35739,BROWSER_DEFAULT_WEBGL:37444,STATIC_DRAW:35044,STREAM_DRAW:35040,DYNAMIC_DRAW:35048,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,BUFFER_SIZE:34660,BUFFER_USAGE:34661,CURRENT_VERTEX_ATTRIB:34342,VERTEX_ATTRIB_ARRAY_ENABLED:34338,VERTEX_ATTRIB_ARRAY_SIZE:34339,VERTEX_ATTRIB_ARRAY_STRIDE:34340,VERTEX_ATTRIB_ARRAY_TYPE:34341,VERTEX_ATTRIB_ARRAY_NORMALIZED:34922,VERTEX_ATTRIB_ARRAY_POINTER:34373,VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:34975,CULL_FACE:2884,FRONT:1028,BACK:1029,FRONT_AND_BACK:1032,BLEND:3042,DEPTH_TEST:2929,DITHER:3024,POLYGON_OFFSET_FILL:32823,SAMPLE_ALPHA_TO_COVERAGE:32926,SAMPLE_COVERAGE:32928,SCISSOR_TEST:3089,STENCIL_TEST:2960,NO_ERROR:0,INVALID_ENUM:1280,INVALID_VALUE:1281,INVALID_OPERATION:1282,OUT_OF_MEMORY:1285,CONTEXT_LOST_WEBGL:37442,CW:2304,CCW:2305,DONT_CARE:4352,FASTEST:4353,NICEST:4354,GENERATE_MIPMAP_HINT:33170,BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,INT:5124,UNSIGNED_INT:5125,FLOAT:5126,DEPTH_COMPONENT:6402,ALPHA:6406,RGB:6407,RGBA:6408,LUMINANCE:6409,LUMINANCE_ALPHA:6410,UNSIGNED_SHORT_4_4_4_4:32819,UNSIGNED_SHORT_5_5_5_1:32820,UNSIGNED_SHORT_5_6_5:33635,FRAGMENT_SHADER:35632,VERTEX_SHADER:35633,COMPILE_STATUS:35713,DELETE_STATUS:35712,LINK_STATUS:35714,VALIDATE_STATUS:35715,ATTACHED_SHADERS:35717,ACTIVE_ATTRIBUTES:35721,ACTIVE_UNIFORMS:35718,MAX_VERTEX_ATTRIBS:34921,MAX_VERTEX_UNIFORM_VECTORS:36347,MAX_VARYING_VECTORS:36348,MAX_COMBINED_TEXTURE_IMAGE_UNITS:35661,MAX_VERTEX_TEXTURE_IMAGE_UNITS:35660,MAX_TEXTURE_IMAGE_UNITS:34930,MAX_FRAGMENT_UNIFORM_VECTORS:36349,SHADER_TYPE:35663,SHADING_LANGUAGE_VERSION:35724,CURRENT_PROGRAM:35725,NEVER:512,ALWAYS:519,LESS:513,EQUAL:514,LEQUAL:515,GREATER:516,GEQUAL:518,NOTEQUAL:517,KEEP:7680,REPLACE:7681,INCR:7682,DECR:7683,INVERT:5386,INCR_WRAP:34055,DECR_WRAP:34056,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,TEXTURE_MAG_FILTER:10240,TEXTURE_MIN_FILTER:10241,TEXTURE_WRAP_S:10242,TEXTURE_WRAP_T:10243,TEXTURE_2D:3553,TEXTURE:5890,TEXTURE_CUBE_MAP:34067,TEXTURE_BINDING_CUBE_MAP:34068,TEXTURE_CUBE_MAP_POSITIVE_X:34069,TEXTURE_CUBE_MAP_NEGATIVE_X:34070,TEXTURE_CUBE_MAP_POSITIVE_Y:34071,TEXTURE_CUBE_MAP_NEGATIVE_Y:34072,TEXTURE_CUBE_MAP_POSITIVE_Z:34073,TEXTURE_CUBE_MAP_NEGATIVE_Z:34074,MAX_CUBE_MAP_TEXTURE_SIZE:34076,TEXTURE0:33984,TEXTURE1:33985,TEXTURE2:33986,TEXTURE3:33987,TEXTURE4:33988,TEXTURE5:33989,TEXTURE6:33990,TEXTURE7:33991,TEXTURE8:33992,TEXTURE9:33993,TEXTURE10:33994,TEXTURE11:33995,TEXTURE12:33996,TEXTURE13:33997,TEXTURE14:33998,TEXTURE15:33999,TEXTURE16:34e3,ACTIVE_TEXTURE:34016,REPEAT:10497,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,TEXTURE_WIDTH:4096,TEXTURE_HEIGHT:4097,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,INT_VEC2:35667,INT_VEC3:35668,INT_VEC4:35669,BOOL:35670,BOOL_VEC2:35671,BOOL_VEC3:35672,BOOL_VEC4:35673,FLOAT_MAT2:35674,FLOAT_MAT3:35675,FLOAT_MAT4:35676,SAMPLER_2D:35678,SAMPLER_CUBE:35680,LOW_FLOAT:36336,MEDIUM_FLOAT:36337,HIGH_FLOAT:36338,LOW_INT:36339,MEDIUM_INT:36340,HIGH_INT:36341,FRAMEBUFFER:36160,RENDERBUFFER:36161,RGBA4:32854,RGB5_A1:32855,RGB565:36194,DEPTH_COMPONENT16:33189,STENCIL_INDEX:6401,STENCIL_INDEX8:36168,DEPTH_STENCIL:34041,RENDERBUFFER_WIDTH:36162,RENDERBUFFER_HEIGHT:36163,RENDERBUFFER_INTERNAL_FORMAT:36164,RENDERBUFFER_RED_SIZE:36176,RENDERBUFFER_GREEN_SIZE:36177,RENDERBUFFER_BLUE_SIZE:36178,RENDERBUFFER_ALPHA_SIZE:36179,RENDERBUFFER_DEPTH_SIZE:36180,RENDERBUFFER_STENCIL_SIZE:36181,FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:36048,FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:36049,FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:36050,FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:36051,COLOR_ATTACHMENT0:36064,DEPTH_ATTACHMENT:36096,STENCIL_ATTACHMENT:36128,DEPTH_STENCIL_ATTACHMENT:33306,NONE:0,FRAMEBUFFER_COMPLETE:36053,FRAMEBUFFER_INCOMPLETE_ATTACHMENT:36054,FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:36055,FRAMEBUFFER_INCOMPLETE_DIMENSIONS:36057,FRAMEBUFFER_UNSUPPORTED:36061,FRAMEBUFFER_BINDING:36006,RENDERBUFFER_BINDING:36007,MAX_RENDERBUFFER_SIZE:34024,INVALID_FRAMEBUFFER_OPERATION:1286,UNPACK_FLIP_Y_WEBGL:37440,UNPACK_PREMULTIPLY_ALPHA_WEBGL:37441,UNPACK_COLORSPACE_CONVERSION_WEBGL:37443,READ_BUFFER:3074,UNPACK_ROW_LENGTH:3314,UNPACK_SKIP_ROWS:3315,UNPACK_SKIP_PIXELS:3316,PACK_ROW_LENGTH:3330,PACK_SKIP_ROWS:3331,PACK_SKIP_PIXELS:3332,UNPACK_SKIP_IMAGES:32877,UNPACK_IMAGE_HEIGHT:32878,MAX_3D_TEXTURE_SIZE:32883,MAX_ELEMENTS_VERTICES:33e3,MAX_ELEMENTS_INDICES:33001,MAX_TEXTURE_LOD_BIAS:34045,MAX_FRAGMENT_UNIFORM_COMPONENTS:35657,MAX_VERTEX_UNIFORM_COMPONENTS:35658,MAX_ARRAY_TEXTURE_LAYERS:35071,MIN_PROGRAM_TEXEL_OFFSET:35076,MAX_PROGRAM_TEXEL_OFFSET:35077,MAX_VARYING_COMPONENTS:35659,FRAGMENT_SHADER_DERIVATIVE_HINT:35723,RASTERIZER_DISCARD:35977,VERTEX_ARRAY_BINDING:34229,MAX_VERTEX_OUTPUT_COMPONENTS:37154,MAX_FRAGMENT_INPUT_COMPONENTS:37157,MAX_SERVER_WAIT_TIMEOUT:37137,MAX_ELEMENT_INDEX:36203,RED:6403,RGB8:32849,RGBA8:32856,RGB10_A2:32857,TEXTURE_3D:32879,TEXTURE_WRAP_R:32882,TEXTURE_MIN_LOD:33082,TEXTURE_MAX_LOD:33083,TEXTURE_BASE_LEVEL:33084,TEXTURE_MAX_LEVEL:33085,TEXTURE_COMPARE_MODE:34892,TEXTURE_COMPARE_FUNC:34893,SRGB:35904,SRGB8:35905,SRGB8_ALPHA8:35907,COMPARE_REF_TO_TEXTURE:34894,RGBA32F:34836,RGB32F:34837,RGBA16F:34842,RGB16F:34843,TEXTURE_2D_ARRAY:35866,TEXTURE_BINDING_2D_ARRAY:35869,R11F_G11F_B10F:35898,RGB9_E5:35901,RGBA32UI:36208,RGB32UI:36209,RGBA16UI:36214,RGB16UI:36215,RGBA8UI:36220,RGB8UI:36221,RGBA32I:36226,RGB32I:36227,RGBA16I:36232,RGB16I:36233,RGBA8I:36238,RGB8I:36239,RED_INTEGER:36244,RGB_INTEGER:36248,RGBA_INTEGER:36249,R8:33321,RG8:33323,R16F:33325,R32F:33326,RG16F:33327,RG32F:33328,R8I:33329,R8UI:33330,R16I:33331,R16UI:33332,R32I:33333,R32UI:33334,RG8I:33335,RG8UI:33336,RG16I:33337,RG16UI:33338,RG32I:33339,RG32UI:33340,R8_SNORM:36756,RG8_SNORM:36757,RGB8_SNORM:36758,RGBA8_SNORM:36759,RGB10_A2UI:36975,TEXTURE_IMMUTABLE_FORMAT:37167,TEXTURE_IMMUTABLE_LEVELS:33503,UNSIGNED_INT_2_10_10_10_REV:33640,UNSIGNED_INT_10F_11F_11F_REV:35899,UNSIGNED_INT_5_9_9_9_REV:35902,FLOAT_32_UNSIGNED_INT_24_8_REV:36269,UNSIGNED_INT_24_8:34042,HALF_FLOAT:5131,RG:33319,RG_INTEGER:33320,INT_2_10_10_10_REV:36255,CURRENT_QUERY:34917,QUERY_RESULT:34918,QUERY_RESULT_AVAILABLE:34919,ANY_SAMPLES_PASSED:35887,ANY_SAMPLES_PASSED_CONSERVATIVE:36202,MAX_DRAW_BUFFERS:34852,DRAW_BUFFER0:34853,DRAW_BUFFER1:34854,DRAW_BUFFER2:34855,DRAW_BUFFER3:34856,DRAW_BUFFER4:34857,DRAW_BUFFER5:34858,DRAW_BUFFER6:34859,DRAW_BUFFER7:34860,DRAW_BUFFER8:34861,DRAW_BUFFER9:34862,DRAW_BUFFER10:34863,DRAW_BUFFER11:34864,DRAW_BUFFER12:34865,DRAW_BUFFER13:34866,DRAW_BUFFER14:34867,DRAW_BUFFER15:34868,MAX_COLOR_ATTACHMENTS:36063,COLOR_ATTACHMENT1:36065,COLOR_ATTACHMENT2:36066,COLOR_ATTACHMENT3:36067,COLOR_ATTACHMENT4:36068,COLOR_ATTACHMENT5:36069,COLOR_ATTACHMENT6:36070,COLOR_ATTACHMENT7:36071,COLOR_ATTACHMENT8:36072,COLOR_ATTACHMENT9:36073,COLOR_ATTACHMENT10:36074,COLOR_ATTACHMENT11:36075,COLOR_ATTACHMENT12:36076,COLOR_ATTACHMENT13:36077,COLOR_ATTACHMENT14:36078,COLOR_ATTACHMENT15:36079,SAMPLER_3D:35679,SAMPLER_2D_SHADOW:35682,SAMPLER_2D_ARRAY:36289,SAMPLER_2D_ARRAY_SHADOW:36292,SAMPLER_CUBE_SHADOW:36293,INT_SAMPLER_2D:36298,INT_SAMPLER_3D:36299,INT_SAMPLER_CUBE:36300,INT_SAMPLER_2D_ARRAY:36303,UNSIGNED_INT_SAMPLER_2D:36306,UNSIGNED_INT_SAMPLER_3D:36307,UNSIGNED_INT_SAMPLER_CUBE:36308,UNSIGNED_INT_SAMPLER_2D_ARRAY:36311,MAX_SAMPLES:36183,SAMPLER_BINDING:35097,PIXEL_PACK_BUFFER:35051,PIXEL_UNPACK_BUFFER:35052,PIXEL_PACK_BUFFER_BINDING:35053,PIXEL_UNPACK_BUFFER_BINDING:35055,COPY_READ_BUFFER:36662,COPY_WRITE_BUFFER:36663,COPY_READ_BUFFER_BINDING:36662,COPY_WRITE_BUFFER_BINDING:36663,FLOAT_MAT2x3:35685,FLOAT_MAT2x4:35686,FLOAT_MAT3x2:35687,FLOAT_MAT3x4:35688,FLOAT_MAT4x2:35689,FLOAT_MAT4x3:35690,UNSIGNED_INT_VEC2:36294,UNSIGNED_INT_VEC3:36295,UNSIGNED_INT_VEC4:36296,UNSIGNED_NORMALIZED:35863,SIGNED_NORMALIZED:36764,VERTEX_ATTRIB_ARRAY_INTEGER:35069,VERTEX_ATTRIB_ARRAY_DIVISOR:35070,TRANSFORM_FEEDBACK_BUFFER_MODE:35967,MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS:35968,TRANSFORM_FEEDBACK_VARYINGS:35971,TRANSFORM_FEEDBACK_BUFFER_START:35972,TRANSFORM_FEEDBACK_BUFFER_SIZE:35973,TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN:35976,MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS:35978,MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS:35979,INTERLEAVED_ATTRIBS:35980,SEPARATE_ATTRIBS:35981,TRANSFORM_FEEDBACK_BUFFER:35982,TRANSFORM_FEEDBACK_BUFFER_BINDING:35983,TRANSFORM_FEEDBACK:36386,TRANSFORM_FEEDBACK_PAUSED:36387,TRANSFORM_FEEDBACK_ACTIVE:36388,TRANSFORM_FEEDBACK_BINDING:36389,FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:33296,FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:33297,FRAMEBUFFER_ATTACHMENT_RED_SIZE:33298,FRAMEBUFFER_ATTACHMENT_GREEN_SIZE:33299,FRAMEBUFFER_ATTACHMENT_BLUE_SIZE:33300,FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE:33301,FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE:33302,FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:33303,FRAMEBUFFER_DEFAULT:33304,DEPTH24_STENCIL8:35056,DRAW_FRAMEBUFFER_BINDING:36006,READ_FRAMEBUFFER_BINDING:36010,RENDERBUFFER_SAMPLES:36011,FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:36052,FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:36182,UNIFORM_BUFFER:35345,UNIFORM_BUFFER_BINDING:35368,UNIFORM_BUFFER_START:35369,UNIFORM_BUFFER_SIZE:35370,MAX_VERTEX_UNIFORM_BLOCKS:35371,MAX_FRAGMENT_UNIFORM_BLOCKS:35373,MAX_COMBINED_UNIFORM_BLOCKS:35374,MAX_UNIFORM_BUFFER_BINDINGS:35375,MAX_UNIFORM_BLOCK_SIZE:35376,MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:35377,MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:35379,UNIFORM_BUFFER_OFFSET_ALIGNMENT:35380,ACTIVE_UNIFORM_BLOCKS:35382,UNIFORM_TYPE:35383,UNIFORM_SIZE:35384,UNIFORM_BLOCK_INDEX:35386,UNIFORM_OFFSET:35387,UNIFORM_ARRAY_STRIDE:35388,UNIFORM_MATRIX_STRIDE:35389,UNIFORM_IS_ROW_MAJOR:35390,UNIFORM_BLOCK_BINDING:35391,UNIFORM_BLOCK_DATA_SIZE:35392,UNIFORM_BLOCK_ACTIVE_UNIFORMS:35394,UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES:35395,UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER:35396,UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER:35398,OBJECT_TYPE:37138,SYNC_CONDITION:37139,SYNC_STATUS:37140,SYNC_FLAGS:37141,SYNC_FENCE:37142,SYNC_GPU_COMMANDS_COMPLETE:37143,UNSIGNALED:37144,SIGNALED:37145,ALREADY_SIGNALED:37146,TIMEOUT_EXPIRED:37147,CONDITION_SATISFIED:37148,WAIT_FAILED:37149,SYNC_FLUSH_COMMANDS_BIT:1,COLOR:6144,DEPTH:6145,STENCIL:6146,MIN:32775,MAX:32776,DEPTH_COMPONENT24:33190,STREAM_READ:35041,STREAM_COPY:35042,STATIC_READ:35045,STATIC_COPY:35046,DYNAMIC_READ:35049,DYNAMIC_COPY:35050,DEPTH_COMPONENT32F:36012,DEPTH32F_STENCIL8:36013,INVALID_INDEX:4294967295,TIMEOUT_IGNORED:-1,MAX_CLIENT_WAIT_TIMEOUT_WEBGL:37447,VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE:35070,UNMASKED_VENDOR_WEBGL:37445,UNMASKED_RENDERER_WEBGL:37446,MAX_TEXTURE_MAX_ANISOTROPY_EXT:34047,TEXTURE_MAX_ANISOTROPY_EXT:34046,COMPRESSED_RGB_S3TC_DXT1_EXT:33776,COMPRESSED_RGBA_S3TC_DXT1_EXT:33777,COMPRESSED_RGBA_S3TC_DXT3_EXT:33778,COMPRESSED_RGBA_S3TC_DXT5_EXT:33779,COMPRESSED_R11_EAC:37488,COMPRESSED_SIGNED_R11_EAC:37489,COMPRESSED_RG11_EAC:37490,COMPRESSED_SIGNED_RG11_EAC:37491,COMPRESSED_RGB8_ETC2:37492,COMPRESSED_RGBA8_ETC2_EAC:37493,COMPRESSED_SRGB8_ETC2:37494,COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:37495,COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:37496,COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:37497,COMPRESSED_RGB_PVRTC_4BPPV1_IMG:35840,COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:35842,COMPRESSED_RGB_PVRTC_2BPPV1_IMG:35841,COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:35843,COMPRESSED_RGB_ETC1_WEBGL:36196,COMPRESSED_RGB_ATC_WEBGL:35986,COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:35986,COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:34798,UNSIGNED_INT_24_8_WEBGL:34042,HALF_FLOAT_OES:36193,RGBA32F_EXT:34836,RGB32F_EXT:34837,FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT:33297,UNSIGNED_NORMALIZED_EXT:35863,MIN_EXT:32775,MAX_EXT:32776,SRGB_EXT:35904,SRGB_ALPHA_EXT:35906,SRGB8_ALPHA8_EXT:35907,FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT:33296,FRAGMENT_SHADER_DERIVATIVE_HINT_OES:35723,COLOR_ATTACHMENT0_WEBGL:36064,COLOR_ATTACHMENT1_WEBGL:36065,COLOR_ATTACHMENT2_WEBGL:36066,COLOR_ATTACHMENT3_WEBGL:36067,COLOR_ATTACHMENT4_WEBGL:36068,COLOR_ATTACHMENT5_WEBGL:36069,COLOR_ATTACHMENT6_WEBGL:36070,COLOR_ATTACHMENT7_WEBGL:36071,COLOR_ATTACHMENT8_WEBGL:36072,COLOR_ATTACHMENT9_WEBGL:36073,COLOR_ATTACHMENT10_WEBGL:36074,COLOR_ATTACHMENT11_WEBGL:36075,COLOR_ATTACHMENT12_WEBGL:36076,COLOR_ATTACHMENT13_WEBGL:36077,COLOR_ATTACHMENT14_WEBGL:36078,COLOR_ATTACHMENT15_WEBGL:36079,DRAW_BUFFER0_WEBGL:34853,DRAW_BUFFER1_WEBGL:34854,DRAW_BUFFER2_WEBGL:34855,DRAW_BUFFER3_WEBGL:34856,DRAW_BUFFER4_WEBGL:34857,DRAW_BUFFER5_WEBGL:34858,DRAW_BUFFER6_WEBGL:34859,DRAW_BUFFER7_WEBGL:34860,DRAW_BUFFER8_WEBGL:34861,DRAW_BUFFER9_WEBGL:34862,DRAW_BUFFER10_WEBGL:34863,DRAW_BUFFER11_WEBGL:34864,DRAW_BUFFER12_WEBGL:34865,DRAW_BUFFER13_WEBGL:34866,DRAW_BUFFER14_WEBGL:34867,DRAW_BUFFER15_WEBGL:34868,MAX_COLOR_ATTACHMENTS_WEBGL:36063,MAX_DRAW_BUFFERS_WEBGL:34852,VERTEX_ARRAY_BINDING_OES:34229,QUERY_COUNTER_BITS_EXT:34916,CURRENT_QUERY_EXT:34917,QUERY_RESULT_EXT:34918,QUERY_RESULT_AVAILABLE_EXT:34919,TIME_ELAPSED_EXT:35007,TIMESTAMP_EXT:36392,GPU_DISJOINT_EXT:36795}),t(i.prototype,{bufferData(...E){return this.i(),this.t.bufferData(...E)},bufferSubData(...E){return this.i(),this.t.bufferSubData(...E)},createBuffer(){return this.t.createBuffer()},deleteBuffer(E){const _=this.states;_.arrayBuffer===E?_.arrayBuffer=null:_.elementArrayBuffer===E&&(_.elementArrayBuffer=null);const t=_.attributes;for(const _ in t)t[_].buffer===E&&(t[_].buffer=null);return this.t.deleteBuffer(E)},getBufferParameter(E,_){return this.i(),this.t.getBufferParameter(E,_)},isBuffer(E){return this.t.isBuffer(E)}}),t(i.prototype,{checkFramebufferStatus(E){return this.t.checkFramebufferStatus(E)},createFramebuffer(){return this.t.createFramebuffer()},deleteFramebuffer(E){const _=this.states.framebuffer;for(const t in _)_[t]===E&&(_[t]=null);return this.t.deleteFramebuffer(E)},framebufferRenderbuffer(E,_,t,R){return this.i(),this.t.framebufferRenderbuffer(E,_,t,R)},framebufferTexture2D(E,_,t,R,T){return this.i(),this.t.framebufferTexture2D(E,_,t,R,T)},getFramebufferAttachmentParameter(E,_,t){return this.i(),this.t.getFramebufferAttachmentParameter(E,_,t)},isFramebuffer(E){return this.t.isFramebuffer(E)},readPixels(E,_,t,R,T,A,s){return this.i(),this.t.readPixels(E,_,t,R,T,A,s)},blitFramebuffer(E,_,t,R,T,A,s,e,r,i){return this.i(),this.t.blitFramebuffer(E,_,t,R,T,A,s,e,r,i)}}),t(i.prototype,{createRenderbuffer(){return this.t.createRenderbuffer()},deleteRenderbuffer(E){const _=this.states.renderbuffer;for(const t in _)_[t]===E&&(_[t]=null);return this.t.deleteRenderbuffer(E)},getRenderbufferParameter(E,_){return this.i(),this.t.getRenderbufferParameter(E,_)},isRenderbuffer(E){return this.t.isRenderbuffer(E)},renderbufferStorage(E,_,t,R){return this.i(),this.t.renderbufferStorage(E,_,t,R)},renderbufferStorageMultisample(E,_,t,R,T){return this.i(),this.t.renderbufferStorageMultisample(E,_,t,R,T)}});t(i.prototype,{scissor(E,_,t,R){this.i();const T=this.states.scissor;T[0]===E&&T[1]===_&&T[2]===t&&T[3]===R||(T[0]=E,T[1]=_,T[2]=t,T[3]=R,this.t.scissor(E,_,t,R));},viewport(E,_,t,R){this.i();const T=this.states.viewport;T[0]===E&&T[1]===_&&T[2]===t&&T[3]===R||(T[0]=E,T[1]=_,T[2]=t,T[3]=R,this.t.viewport(E,_,t,R));},blendColor(E,_,t,R){this.i();const T=this.states.blendColor;T[0]===E&&T[1]===_&&T[2]===t&&T[3]===R||(T[0]=E,T[1]=_,T[2]=t,T[3]=R,this.t.blendColor(E,_,t,R));},blendEquation(E){this.i();const _=this.states.blendEquationSeparate;_[0]===E&&_[1]===E||(_[0]=E,_[1]=E,this.t.blendEquation(E));},blendEquationSeparate(E,_){this.i();const t=this.states.blendEquationSeparate;t[0]===E&&t[1]===_||(t[0]=E,t[1]=_,this.t.blendEquationSeparate(E,_));},blendFunc(E,_){this.i();const t=this.states.blendFuncSeparate;t[0]===E&&t[2]===E&&t[1]===_&&t[3]===_||(t[0]=E,t[1]=_,t[2]=E,t[3]=_,this.t.blendFunc(E,_));},blendFuncSeparate(E,_,t,R){this.i();const T=this.states.blendFuncSeparate;T[0]===E&&T[1]===_&&T[2]===t&&T[3]===R||(T[0]=E,T[1]=_,T[2]=t,T[3]=R,this.t.blendFuncSeparate(E,_,t,R));},clearColor(E,_,t,R){this.i();const T=this.states.clearColor;T[0]===E&&T[1]===_&&T[2]===t&&T[3]===R||(T[0]=E,T[1]=_,T[2]=t,T[3]=R,this.t.clearColor(E,_,t,R));},clearDepth(E){this.i();const _=this.states.clearDepth;_[0]!==E&&(_[0]=E,this.t.clearDepth(E));},clearStencil(E){this.i();const _=this.states.clearStencil;_[0]!==E&&(_[0]=E,this.t.clearStencil(E));},colorMask(E,_,t,R){this.i();const T=this.states.colorMask;T[0]===E&&T[1]===_&&T[2]===t&&T[3]===R||(T[0]=E,T[1]=_,T[2]=t,T[3]=R,this.t.colorMask(E,_,t,R));},cullFace(E){this.i();const _=this.states.cullFace;_[0]!==E&&(_[0]=E,this.t.cullFace(E));},depthFunc(E){this.i();const _=this.states.depthFunc;_[0]!==E&&(_[0]=E,this.t.depthFunc(E));},depthMask(E){this.i();const _=this.states.depthMask;_[0]!==E&&(_[0]=E,this.t.depthMask(E));},depthRange(E,_){this.i();const t=this.states.depthRange;t[0]===E&&t[1]===_||(t[0]=E,t[1]=_,this.t.depthRange(E,_));},disable(E){this.i();const _=this.states.capabilities;_[E]&&(_[E]=!1,this.t.disable(E));},enable(E){this.i();const _=this.states.capabilities;_[E]||(_[E]=!0,this.t.enable(E));},frontFace(E){this.i();const _=this.states.frontFace;_[0]!==E&&(_[0]=E,this.t.frontFace(E));},hint(E,_){this.i();const t=this.states.hint;t[E][0]!==_&&(t[E][0]=_,this.t.hint(E,_));},lineWidth(E){this.i();const _=this.states.lineWidth;_[0]!==E&&(_[0]=E,this.t.lineWidth(E));},pixelStorei(E,_){this.i();const t=this.states.pixelStorei;t[E]!==_&&(t[E]&&(t[E][0]=_),this.t.pixelStorei(E,_));},polygonOffset(E,_){this.i();const t=this.states.polygonOffset;t[0]===E&&t[1]===_||(t[0]=E,t[1]=_,this.t.polygonOffset(E,_));},sampleCoverage(E,_){this.i();const t=this.states.sampleCoverage;t[0]===E&&t[1]===_||(t[0]=E,t[1]=_,this.t.sampleCoverage(E,_));},stencilFunc(E,_,t){this.i();const R=this.states.stencilFuncSeparate,T=this.t;R[T.FRONT][0]===E&&R[T.FRONT][1]===_&&R[T.FRONT][2]===t&&R[T.BACK][0]===E&&R[T.BACK][1]===_&&R[T.BACK][2]===t||(R[T.FRONT][0]=R[T.BACK][0]=E,R[T.FRONT][1]=R[T.BACK][1]=_,R[T.FRONT][2]=R[T.BACK][2]=t,this.t.stencilFunc(E,_,t));},stencilFuncSeparate(E,_,t,R){if(this.i(),E===this.t.FRONT_AND_BACK)return void this.stencilFunc(_,t,R);const T=this.states.stencilFuncSeparate;T[E][0]===_&&T[E][1]===t&&T[E][2]===R||(T[E][0]=_,T[E][1]=t,T[E][2]=R,this.t.stencilFuncSeparate(E,_,t,R));},stencilMask(E){this.i();const _=this.t,t=this.states.stencilMaskSeparate;t[_.FRONT][0]===E&&t[_.BACK][0]===E||(t[_.FRONT][0]=E,t[_.BACK][0]=E,this.t.stencilMask(E));},stencilMaskSeparate(E,_){if(this.i(),E===this.t.FRONT_AND_BACK)return void this.stencilMask(_);const t=this.states.stencilMaskSeparate;t[E][0]!==_&&(t[E][0]=_,this.t.stencilMaskSeparate(E,_));},stencilOp(E,_,t){this.i();const R=this.states.stencilOpSeparate,T=this.t;R[T.FRONT][0]===E&&R[T.FRONT][1]===_&&R[T.FRONT][2]===t&&R[T.BACK][0]===E&&R[T.BACK][1]===_&&R[T.BACK][2]===t||(R[T.FRONT][0]=R[T.BACK][0]=E,R[T.FRONT][1]=R[T.BACK][1]=_,R[T.FRONT][2]=R[T.BACK][2]=t,this.t.stencilOp(E,_,t));},stencilOpSeparate(E,_,t,R){if(this.i(),E===this.t.FRONT_AND_BACK)return void this.stencilOp(_,t,R);const T=this.states.stencilOpSeparate;T[E][0]===_&&T[E][1]===t&&T[E][2]===R||(T[E][0]=_,T[E][1]=t,T[E][2]=R,this.t.stencilOpSeparate(E,_,t,R));},bindFramebuffer(E,_){this.i();const t=this.states.framebuffer;t[E]!==_&&(t[E]=_,this.t.bindFramebuffer(E,_));},bindRenderbuffer(E,_){this.i();const t=this.states.renderbuffer;t[E]!==_&&(t[E]=_,this.t.bindRenderbuffer(E,_));},bindTexture(E,_){this.i();const t=this.states.textures,R=-1!==t.active?t.active-33984:-1;t.units[R][E]=_,this.t.bindTexture(E,_);},activeTexture(E){this.i();const _=this.t,t=this.states.textures,R=t.active;t.active=E,this.activeUnit!==E&&(_.activeTexture(E),this.activeUnit=E),-1===R&&(t.units[E-33984][_.TEXTURE_2D]=t.units[-1][_.TEXTURE_2D],t.units[E-33984][_.TEXTURE_CUBE_MAP]=t.units[-1][_.TEXTURE_CUBE_MAP],t.units[-1][_.TEXTURE_2D]=null,t.units[-1][_.TEXTURE_CUBE_MAP]=null);},useProgram(E){this.i();const _=this.states;_.program!==E&&(_.program=E,this.t.useProgram(E));},bindBuffer(E,_){this.i();const t=this.t,R=this.states;E===t.ELEMENT_ARRAY_BUFFER?R.elementArrayBuffer=_:R.arrayBuffer=_,t.bindBuffer(E,_);},bindVertexArray(E){this.i();const _=this.t,t=this.states;t.vao!==E&&(t.vao=E,this._?_.bindVertexArray(E):this.vaoOES.bindVertexArrayOES(E));},vertexAttribPointer(E,_,t,R,T,A){this.i(),this.states.attributes[E]||(this.states.attributes[E]={enable:!0});const s=this.states.attributes[E];return s.buffer=this.states.arrayBuffer,s.args?(s.args[0]=E,s.args[1]=_,s.args[2]=t,s.args[3]=R,s.args[4]=T,s.args[5]=A):s.args=[E,_,t,R,T,A],this.t.vertexAttribPointer(E,_,t,R,T,A)},vertexAttribDivisor(E,_){return this.i(),this.states.attributes[E].divisor=_,this._?this.t.vertexAttribDivisor(E,_):this.angleOES.vertexAttribDivisorANGLE(E,_)}},{i(){const E=this.t;if(E.S&&E.S!==this){const _=E.S;this.O(_.states),E.S=this;}E.S=this;},O(_){if(!_)return;delete this.activeUnit;const t=this.states,R=this.t;for(const T in t)if("capabilities"!==T&&"textures"!==T&&"attributes"!==T&&"arrayBuffer"!==T&&"elementArrayBuffer"!==T&&"vao"!==T)if("program"===T)t.program!==_.program&&R.useProgram(t.program);else if("framebuffer"===T)for(const E in t[T])t[T][E]!==_[T][E]&&R.bindFramebuffer(+E,t[T][E]);else if("renderbuffer"===T)for(const E in t[T])t[T][E]!==_[T][E]&&R.bindRenderbuffer(+E,t[T][E]);else if(!fastDeepEqual(t[T],_[T]))if(Array.isArray(_[T]))R[T](...t[T]);else if(_[T])for(const A in t[T])fastDeepEqual(t[T][A],_[T][A])||R[T](+A,...t[T][A]);for(const E in t.capabilities)t.capabilities[E]!==_.capabilities[E]&&R[t.capabilities[E]?"enable":"disable"](+E);const T=t.textures,A=_.textures,s=T.units,e=A.units,r=T.active-R.TEXTURE0;for(let E=0;E<s.length;E++)E===r||s[E][R.TEXTURE_2D]===e[E][R.TEXTURE_2D]&&s[E][R.TEXTURE_CUBE_MAP]===e[E][R.TEXTURE_CUBE_MAP]||(R.activeTexture(R.TEXTURE0+E),R.bindTexture(R.TEXTURE_2D,s[E][R.TEXTURE_2D]),R.bindTexture(R.TEXTURE_CUBE_MAP,s[E][R.TEXTURE_CUBE_MAP]));if(T.active>-1){const E=s[r];E[R.TEXTURE_2D]===e[r][R.TEXTURE_2D]&&E[R.TEXTURE_CUBE_MAP]===e[r][R.TEXTURE_CUBE_MAP]||(R.activeTexture(T.active),R.bindTexture(R.TEXTURE_2D,E[R.TEXTURE_2D]),R.bindTexture(R.TEXTURE_CUBE_MAP,E[R.TEXTURE_CUBE_MAP]));}this._?R.bindVertexArray(null):this.A&&this.A.bindVertexArrayOES(null);const i=this.R,N=t.attributes;for(let E=0;E<i;E++){const _=N[E];_?(_.buffer&&(R.bindBuffer(R.ARRAY_BUFFER,_.buffer),R.vertexAttribPointer(..._.args),void 0!==_.divisor&&(this._?R.vertexAttribDivisor(E,_.divisor):this.angleOES.vertexAttribDivisorANGLE(E,_.divisor))),_.enable?R.enableVertexAttribArray(E):R.disableVertexAttribArray(E)):R.disableVertexAttribArray(E);}R.bindBuffer(R.ARRAY_BUFFER,t.arrayBuffer),R.bindBuffer(R.ELEMENT_ARRAY_BUFFER,t.elementArrayBuffer);const I=t.vao;I&&(this._?R.bindVertexArray(I||null):this.A&&this.A.bindVertexArrayOES(I||null));}}),t(i.prototype,{compressedTexImage2D(E,_,t,R,T,A,s){return this.i(),this.t.compressedTexImage2D(E,_,t,R,T,A,s)},copyTexImage2D(E,_,t,R,T,A,s,e){return this.i(),this.t.copyTexImage2D(E,_,t,R,T,A,s,e)},copyTexSubImage2D(E,_,t,R,T,A,s,e){return this.i(),this.t.copyTexSubImage2D(E,_,t,R,T,A,s,e)},createTexture(){return this.t.createTexture()},deleteTexture(E){const _=this.states.textures.units;for(let t=0;t<_.length;t++)for(const R in _[t])_[t][R]===E&&(_[t][R]=null);return this.t.deleteTexture(E)},generateMipmap(E){return this.i(),this.t.generateMipmap(E)},getTexParameter(E,_){return this.i(),this.t.getTexParameter(E,_)},isTexture(E){return this.t.isTexture(E)},texImage2D(...E){if(this.i(),this._){const _=E[E.length-2],t=e$1.getInternalFormat(this.t,E[2],_);t!==E[2]&&(E[2]=t);const R=e$1.getTextureType(this.t,_);R!==_&&(E[E.length-2]=R);}return this.t.texImage2D(...E)},texSubImage2D(E){if(this.i(),this._){const _=E[E.length-2],t=e$1.getTextureType(this.t,_);t!==_&&(E[E.length-2]=t);}return this.t.texSubImage2D(...E)},texParameterf(E,_,t){return this.i(),this.t.texParameterf(E,_,t)},texParameteri(E,_,t){return this.i(),this.t.texParameteri(E,_,t)}}),t(i.prototype,{bindAttribLocation(E,_,t){return this.t.bindAttribLocation(E,_,t)},enableVertexAttribArray(E){return this.i(),this.states.attributes[E]||(this.states.attributes[E]={}),this.states.attributes[E].enable=!0,this.t.enableVertexAttribArray(E)},disableVertexAttribArray(E){return this.i(),this.states.attributes[E]||(this.states.attributes[E]={}),this.states.attributes[E].enable=!1,this.t.disableVertexAttribArray(E)},getActiveAttrib(E,_){return this.t.getActiveAttrib(E,_)},getActiveUniform(E,_){return this.t.getActiveUniform(E,_)},getAttribLocation(E,_){return this.t.getAttribLocation(E,_)},getUniformLocation(E,_){return this.t.getUniformLocation(E,_)},getVertexAttrib(E,_){return this.i(),this.t.getVertexAttrib(E,_)},getVertexAttribOffset(E,_){return this.i(),this.t.getVertexAttribOffset(E,_)},uniformMatrix2fv(E,_,t){return this.i(),this.t.uniformMatrix2fv(E,_,t)},uniformMatrix3fv(E,_,t){return this.i(),this.t.uniformMatrix3fv(E,_,t)},uniformMatrix4fv(E,_,t){return this.i(),this.t.uniformMatrix4fv(E,_,t)},uniform1f(E,_){return this.i(),this.t.uniform1f(E,_)},uniform1fv(E,_){return this.i(),this.t.uniform1fv(E,_)},uniform1i(E,_){return this.i(),this.t.uniform1i(E,_)},uniform1iv(E,_){return this.i(),this.t.uniform1iv(E,_)},uniform2f(E,_,t){return this.i(),this.t.uniform2f(E,_,t)},uniform2fv(E,_){return this.i(),this.t.uniform2fv(E,_)},uniform2i(E,_,t){return this.i(),this.t.uniform2i(E,_,t)},uniform2iv(E,_){return this.i(),this.t.uniform2iv(E,_)},uniform3f(E,_,t,R){return this.i(),this.t.uniform3f(E,_,t,R)},uniform3fv(E,_){return this.i(),this.t.uniform3fv(E,_)},uniform3i(E,_,t,R){return this.i(),this.t.uniform3i(E,_,t,R)},uniform3iv(E,_){return this.i(),this.t.uniform3iv(E,_)},uniform4f(E,_,t,R,T){return this.i(),this.t.uniform4f(E,_,t,R,T)},uniform4fv(E,_){return this.i(),this.t.uniform4fv(E,_)},uniform4i(E,_,t,R,T){return this.i(),this.t.uniform4i(E,_,t,R,T)},uniform4iv(E,_){return this.i(),this.t.uniform4iv(E,_)},vertexAttrib1f(E,_){return this.i(),this.t.vertexAttrib1f(E,_)},vertexAttrib2f(E,_,t){return this.i(),this.t.vertexAttrib2f(E,_,t)},vertexAttrib3f(E,_,t,R){return this.i(),this.t.vertexAttrib3f(E,_,t,R)},vertexAttrib4f(E,_,t,R,T){return this.i(),this.t.vertexAttrib4f(E,_,t,R,T)},vertexAttrib1fv(E,_){return this.i(),this.t.vertexAttrib1fv(E,_)},vertexAttrib2fv(E,_){return this.i(),this.t.vertexAttrib2fv(E,_)},vertexAttrib3fv(E,_){return this.i(),this.t.vertexAttrib3fv(E,_)},vertexAttrib4fv(E,_){return this.i(),this.t.vertexAttrib4fv(E,_)}}),t(i.prototype,{createVertexArray(){return this._?this.t.createVertexArray():this.vaoOES.createVertexArrayOES()},deleteVertexArray(E){const _=this.states;return _.vao===E&&(_.vao=null),this._?this.t.deleteVertexArray(E):this.vaoOES.deleteVertexArrayOES(E)},isVertexArray(E){return this._?this.t.isVertexArray(E):this.vaoOES.isVertexArrayOES(E)}}),t(i.prototype,{drawArraysInstanced(E,_,t,R){return this.i(),this.N(),this._?this.t.drawArraysInstanced(E,_,t,R):this.angleOES.drawArraysInstancedANGLE(E,_,t,R)},drawElementsInstanced(E,_,t,R,T){return this.i(),this.N(),this._?this.t.drawElementsInstanced(E,_,t,R,T):this.angleOES.drawElementsInstancedANGLE(E,_,t,R,T)}});

	var m = {
	    exports: {}
	}, v = {
	    "aliceblue": [ 240, 248, 255 ],
	    "antiquewhite": [ 250, 235, 215 ],
	    "aqua": [ 0, 255, 255 ],
	    "aquamarine": [ 127, 255, 212 ],
	    "azure": [ 240, 255, 255 ],
	    "beige": [ 245, 245, 220 ],
	    "bisque": [ 255, 228, 196 ],
	    "black": [ 0, 0, 0 ],
	    "blanchedalmond": [ 255, 235, 205 ],
	    "blue": [ 0, 0, 255 ],
	    "blueviolet": [ 138, 43, 226 ],
	    "brown": [ 165, 42, 42 ],
	    "burlywood": [ 222, 184, 135 ],
	    "cadetblue": [ 95, 158, 160 ],
	    "chartreuse": [ 127, 255, 0 ],
	    "chocolate": [ 210, 105, 30 ],
	    "coral": [ 255, 127, 80 ],
	    "cornflowerblue": [ 100, 149, 237 ],
	    "cornsilk": [ 255, 248, 220 ],
	    "crimson": [ 220, 20, 60 ],
	    "cyan": [ 0, 255, 255 ],
	    "darkblue": [ 0, 0, 139 ],
	    "darkcyan": [ 0, 139, 139 ],
	    "darkgoldenrod": [ 184, 134, 11 ],
	    "darkgray": [ 169, 169, 169 ],
	    "darkgreen": [ 0, 100, 0 ],
	    "darkgrey": [ 169, 169, 169 ],
	    "darkkhaki": [ 189, 183, 107 ],
	    "darkmagenta": [ 139, 0, 139 ],
	    "darkolivegreen": [ 85, 107, 47 ],
	    "darkorange": [ 255, 140, 0 ],
	    "darkorchid": [ 153, 50, 204 ],
	    "darkred": [ 139, 0, 0 ],
	    "darksalmon": [ 233, 150, 122 ],
	    "darkseagreen": [ 143, 188, 143 ],
	    "darkslateblue": [ 72, 61, 139 ],
	    "darkslategray": [ 47, 79, 79 ],
	    "darkslategrey": [ 47, 79, 79 ],
	    "darkturquoise": [ 0, 206, 209 ],
	    "darkviolet": [ 148, 0, 211 ],
	    "deeppink": [ 255, 20, 147 ],
	    "deepskyblue": [ 0, 191, 255 ],
	    "dimgray": [ 105, 105, 105 ],
	    "dimgrey": [ 105, 105, 105 ],
	    "dodgerblue": [ 30, 144, 255 ],
	    "firebrick": [ 178, 34, 34 ],
	    "floralwhite": [ 255, 250, 240 ],
	    "forestgreen": [ 34, 139, 34 ],
	    "fuchsia": [ 255, 0, 255 ],
	    "gainsboro": [ 220, 220, 220 ],
	    "ghostwhite": [ 248, 248, 255 ],
	    "gold": [ 255, 215, 0 ],
	    "goldenrod": [ 218, 165, 32 ],
	    "gray": [ 128, 128, 128 ],
	    "green": [ 0, 128, 0 ],
	    "greenyellow": [ 173, 255, 47 ],
	    "grey": [ 128, 128, 128 ],
	    "honeydew": [ 240, 255, 240 ],
	    "hotpink": [ 255, 105, 180 ],
	    "indianred": [ 205, 92, 92 ],
	    "indigo": [ 75, 0, 130 ],
	    "ivory": [ 255, 255, 240 ],
	    "khaki": [ 240, 230, 140 ],
	    "lavender": [ 230, 230, 250 ],
	    "lavenderblush": [ 255, 240, 245 ],
	    "lawngreen": [ 124, 252, 0 ],
	    "lemonchiffon": [ 255, 250, 205 ],
	    "lightblue": [ 173, 216, 230 ],
	    "lightcoral": [ 240, 128, 128 ],
	    "lightcyan": [ 224, 255, 255 ],
	    "lightgoldenrodyellow": [ 250, 250, 210 ],
	    "lightgray": [ 211, 211, 211 ],
	    "lightgreen": [ 144, 238, 144 ],
	    "lightgrey": [ 211, 211, 211 ],
	    "lightpink": [ 255, 182, 193 ],
	    "lightsalmon": [ 255, 160, 122 ],
	    "lightseagreen": [ 32, 178, 170 ],
	    "lightskyblue": [ 135, 206, 250 ],
	    "lightslategray": [ 119, 136, 153 ],
	    "lightslategrey": [ 119, 136, 153 ],
	    "lightsteelblue": [ 176, 196, 222 ],
	    "lightyellow": [ 255, 255, 224 ],
	    "lime": [ 0, 255, 0 ],
	    "limegreen": [ 50, 205, 50 ],
	    "linen": [ 250, 240, 230 ],
	    "magenta": [ 255, 0, 255 ],
	    "maroon": [ 128, 0, 0 ],
	    "mediumaquamarine": [ 102, 205, 170 ],
	    "mediumblue": [ 0, 0, 205 ],
	    "mediumorchid": [ 186, 85, 211 ],
	    "mediumpurple": [ 147, 112, 219 ],
	    "mediumseagreen": [ 60, 179, 113 ],
	    "mediumslateblue": [ 123, 104, 238 ],
	    "mediumspringgreen": [ 0, 250, 154 ],
	    "mediumturquoise": [ 72, 209, 204 ],
	    "mediumvioletred": [ 199, 21, 133 ],
	    "midnightblue": [ 25, 25, 112 ],
	    "mintcream": [ 245, 255, 250 ],
	    "mistyrose": [ 255, 228, 225 ],
	    "moccasin": [ 255, 228, 181 ],
	    "navajowhite": [ 255, 222, 173 ],
	    "navy": [ 0, 0, 128 ],
	    "oldlace": [ 253, 245, 230 ],
	    "olive": [ 128, 128, 0 ],
	    "olivedrab": [ 107, 142, 35 ],
	    "orange": [ 255, 165, 0 ],
	    "orangered": [ 255, 69, 0 ],
	    "orchid": [ 218, 112, 214 ],
	    "palegoldenrod": [ 238, 232, 170 ],
	    "palegreen": [ 152, 251, 152 ],
	    "paleturquoise": [ 175, 238, 238 ],
	    "palevioletred": [ 219, 112, 147 ],
	    "papayawhip": [ 255, 239, 213 ],
	    "peachpuff": [ 255, 218, 185 ],
	    "peru": [ 205, 133, 63 ],
	    "pink": [ 255, 192, 203 ],
	    "plum": [ 221, 160, 221 ],
	    "powderblue": [ 176, 224, 230 ],
	    "purple": [ 128, 0, 128 ],
	    "rebeccapurple": [ 102, 51, 153 ],
	    "red": [ 255, 0, 0 ],
	    "rosybrown": [ 188, 143, 143 ],
	    "royalblue": [ 65, 105, 225 ],
	    "saddlebrown": [ 139, 69, 19 ],
	    "salmon": [ 250, 128, 114 ],
	    "sandybrown": [ 244, 164, 96 ],
	    "seagreen": [ 46, 139, 87 ],
	    "seashell": [ 255, 245, 238 ],
	    "sienna": [ 160, 82, 45 ],
	    "silver": [ 192, 192, 192 ],
	    "skyblue": [ 135, 206, 235 ],
	    "slateblue": [ 106, 90, 205 ],
	    "slategray": [ 112, 128, 144 ],
	    "slategrey": [ 112, 128, 144 ],
	    "snow": [ 255, 250, 250 ],
	    "springgreen": [ 0, 255, 127 ],
	    "steelblue": [ 70, 130, 180 ],
	    "tan": [ 210, 180, 140 ],
	    "teal": [ 0, 128, 128 ],
	    "thistle": [ 216, 191, 216 ],
	    "tomato": [ 255, 99, 71 ],
	    "turquoise": [ 64, 224, 208 ],
	    "violet": [ 238, 130, 238 ],
	    "wheat": [ 245, 222, 179 ],
	    "white": [ 255, 255, 255 ],
	    "whitesmoke": [ 245, 245, 245 ],
	    "yellow": [ 255, 255, 0 ],
	    "yellowgreen": [ 154, 205, 50 ]
	}, w = {
	    exports: {}
	}, b = function(t) {
	    return !(!t || "string" == typeof t) && (t instanceof Array || Array.isArray(t) || t.length >= 0 && (t.splice instanceof Function || Object.getOwnPropertyDescriptor(t, t.length - 1) && "String" !== t.constructor.name));
	}, _ = Array.prototype.concat, M = Array.prototype.slice, y = w.exports = function(t) {
	    for (var i = [], e = 0, s = t.length; e < s; e++) {
	        var n = t[e];
	        b(n) ? i = _.call(i, M.call(n)) : i.push(n);
	    }
	    return i;
	};

	y.wrap = function(t) {
	    return function() {
	        return t(y(arguments));
	    };
	};

	var x = v, C = w.exports, S = Object.hasOwnProperty, T = Object.create(null);

	for (var O in x) S.call(x, O) && (T[x[O]] = O);

	var k = m.exports = {
	    to: {},
	    get: {}
	};

	function A(t, i, e) {
	    return Math.min(Math.max(i, t), e);
	}

	function E(t) {
	    var i = Math.round(t).toString(16).toUpperCase();
	    return i.length < 2 ? "0" + i : i;
	}

	k.get = function(t) {
	    var i, e;
	    switch (t.substring(0, 3).toLowerCase()) {
	      case "hsl":
	        i = k.get.hsl(t), e = "hsl";
	        break;

	      case "hwb":
	        i = k.get.hwb(t), e = "hwb";
	        break;

	      default:
	        i = k.get.rgb(t), e = "rgb";
	    }
	    return i ? {
	        model: e,
	        value: i
	    } : null;
	}, k.get.rgb = function(t) {
	    if (!t) return null;
	    var i, e, s, n = [ 0, 0, 0, 1 ];
	    if (i = t.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)) {
	        for (s = i[2], i = i[1], e = 0; e < 3; e++) {
	            var r = 2 * e;
	            n[e] = parseInt(i.slice(r, r + 2), 16);
	        }
	        s && (n[3] = parseInt(s, 16) / 255);
	    } else if (i = t.match(/^#([a-f0-9]{3,4})$/i)) {
	        for (s = (i = i[1])[3], e = 0; e < 3; e++) n[e] = parseInt(i[e] + i[e], 16);
	        s && (n[3] = parseInt(s + s, 16) / 255);
	    } else if (i = t.match(/^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)) {
	        for (e = 0; e < 3; e++) n[e] = parseInt(i[e + 1], 0);
	        i[4] && (i[5] ? n[3] = .01 * parseFloat(i[4]) : n[3] = parseFloat(i[4]));
	    } else {
	        if (!(i = t.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/))) return (i = t.match(/^(\w+)$/)) ? "transparent" === i[1] ? [ 0, 0, 0, 0 ] : S.call(x, i[1]) ? ((n = x[i[1]])[3] = 1, 
	        n) : null : null;
	        for (e = 0; e < 3; e++) n[e] = Math.round(2.55 * parseFloat(i[e + 1]));
	        i[4] && (i[5] ? n[3] = .01 * parseFloat(i[4]) : n[3] = parseFloat(i[4]));
	    }
	    for (e = 0; e < 3; e++) n[e] = A(n[e], 0, 255);
	    return n[3] = A(n[3], 0, 1), n;
	}, k.get.hsl = function(t) {
	    if (!t) return null;
	    var i = t.match(/^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);
	    if (i) {
	        var e = parseFloat(i[4]);
	        return [ (parseFloat(i[1]) % 360 + 360) % 360, A(parseFloat(i[2]), 0, 100), A(parseFloat(i[3]), 0, 100), A(isNaN(e) ? 1 : e, 0, 1) ];
	    }
	    return null;
	}, k.get.hwb = function(t) {
	    if (!t) return null;
	    var i = t.match(/^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/);
	    if (i) {
	        var e = parseFloat(i[4]);
	        return [ (parseFloat(i[1]) % 360 + 360) % 360, A(parseFloat(i[2]), 0, 100), A(parseFloat(i[3]), 0, 100), A(isNaN(e) ? 1 : e, 0, 1) ];
	    }
	    return null;
	}, k.to.hex = function() {
	    var t = C(arguments);
	    return "#" + E(t[0]) + E(t[1]) + E(t[2]) + (t[3] < 1 ? E(Math.round(255 * t[3])) : "");
	}, k.to.rgb = function() {
	    var t = C(arguments);
	    return t.length < 4 || 1 === t[3] ? "rgb(" + Math.round(t[0]) + ", " + Math.round(t[1]) + ", " + Math.round(t[2]) + ")" : "rgba(" + Math.round(t[0]) + ", " + Math.round(t[1]) + ", " + Math.round(t[2]) + ", " + t[3] + ")";
	}, k.to.rgb.percent = function() {
	    var t = C(arguments), i = Math.round(t[0] / 255 * 100), e = Math.round(t[1] / 255 * 100), s = Math.round(t[2] / 255 * 100);
	    return t.length < 4 || 1 === t[3] ? "rgb(" + i + "%, " + e + "%, " + s + "%)" : "rgba(" + i + "%, " + e + "%, " + s + "%, " + t[3] + ")";
	}, k.to.hsl = function() {
	    var t = C(arguments);
	    return t.length < 4 || 1 === t[3] ? "hsl(" + t[0] + ", " + t[1] + "%, " + t[2] + "%)" : "hsla(" + t[0] + ", " + t[1] + "%, " + t[2] + "%, " + t[3] + ")";
	}, k.to.hwb = function() {
	    var t = C(arguments), i = "";
	    return t.length >= 4 && 1 !== t[3] && (i = ", " + t[3]), "hwb(" + t[0] + ", " + t[1] + "%, " + t[2] + "%" + i + ")";
	}, k.to.keyword = function(t) {
	    return T[t.slice(0, 3)];
	};

	var L = {
	    exports: {}
	}, I = v, F = {};

	for (var R in I) I.hasOwnProperty(R) && (F[I[R]] = R);

	var P = L.exports = {
	    rgb: {
	        channels: 3,
	        labels: "rgb"
	    },
	    hsl: {
	        channels: 3,
	        labels: "hsl"
	    },
	    hsv: {
	        channels: 3,
	        labels: "hsv"
	    },
	    hwb: {
	        channels: 3,
	        labels: "hwb"
	    },
	    cmyk: {
	        channels: 4,
	        labels: "cmyk"
	    },
	    xyz: {
	        channels: 3,
	        labels: "xyz"
	    },
	    lab: {
	        channels: 3,
	        labels: "lab"
	    },
	    lch: {
	        channels: 3,
	        labels: "lch"
	    },
	    hex: {
	        channels: 1,
	        labels: [ "hex" ]
	    },
	    keyword: {
	        channels: 1,
	        labels: [ "keyword" ]
	    },
	    ansi16: {
	        channels: 1,
	        labels: [ "ansi16" ]
	    },
	    ansi256: {
	        channels: 1,
	        labels: [ "ansi256" ]
	    },
	    hcg: {
	        channels: 3,
	        labels: [ "h", "c", "g" ]
	    },
	    apple: {
	        channels: 3,
	        labels: [ "r16", "g16", "b16" ]
	    },
	    gray: {
	        channels: 1,
	        labels: [ "gray" ]
	    }
	};

	for (var H in P) if (P.hasOwnProperty(H)) {
	    if (!("channels" in P[H])) throw new Error("missing channels property: " + H);
	    if (!("labels" in P[H])) throw new Error("missing channel labels property: " + H);
	    if (P[H].labels.length !== P[H].channels) throw new Error("channel and label counts mismatch: " + H);
	    var D = P[H].channels, N = P[H].labels;
	    delete P[H].channels, delete P[H].labels, Object.defineProperty(P[H], "channels", {
	        value: D
	    }), Object.defineProperty(P[H], "labels", {
	        value: N
	    });
	}

	P.rgb.hsl = function(t) {
	    var i, e, s = t[0] / 255, n = t[1] / 255, r = t[2] / 255, h = Math.min(s, n, r), o = Math.max(s, n, r), a = o - h;
	    return o === h ? i = 0 : s === o ? i = (n - r) / a : n === o ? i = 2 + (r - s) / a : r === o && (i = 4 + (s - n) / a), 
	    (i = Math.min(60 * i, 360)) < 0 && (i += 360), e = (h + o) / 2, [ i, 100 * (o === h ? 0 : e <= .5 ? a / (o + h) : a / (2 - o - h)), 100 * e ];
	}, P.rgb.hsv = function(t) {
	    var i, e, s, n, r, h = t[0] / 255, o = t[1] / 255, a = t[2] / 255, l = Math.max(h, o, a), c = l - Math.min(h, o, a), u = function(t) {
	        return (l - t) / 6 / c + .5;
	    };
	    return 0 === c ? n = r = 0 : (r = c / l, i = u(h), e = u(o), s = u(a), h === l ? n = s - e : o === l ? n = 1 / 3 + i - s : a === l && (n = 2 / 3 + e - i), 
	    n < 0 ? n += 1 : n > 1 && (n -= 1)), [ 360 * n, 100 * r, 100 * l ];
	}, P.rgb.hwb = function(t) {
	    var i = t[0], e = t[1], s = t[2];
	    return [ P.rgb.hsl(t)[0], 100 * (1 / 255 * Math.min(i, Math.min(e, s))), 100 * (s = 1 - 1 / 255 * Math.max(i, Math.max(e, s))) ];
	}, P.rgb.cmyk = function(t) {
	    var i, e = t[0] / 255, s = t[1] / 255, n = t[2] / 255;
	    return [ 100 * ((1 - e - (i = Math.min(1 - e, 1 - s, 1 - n))) / (1 - i) || 0), 100 * ((1 - s - i) / (1 - i) || 0), 100 * ((1 - n - i) / (1 - i) || 0), 100 * i ];
	}, P.rgb.keyword = function(t) {
	    var i = F[t];
	    if (i) return i;
	    var e, s, n, r = 1 / 0;
	    for (var h in I) if (I.hasOwnProperty(h)) {
	        var o = I[h], a = (s = t, n = o, Math.pow(s[0] - n[0], 2) + Math.pow(s[1] - n[1], 2) + Math.pow(s[2] - n[2], 2));
	        a < r && (r = a, e = h);
	    }
	    return e;
	}, P.keyword.rgb = function(t) {
	    return I[t];
	}, P.rgb.xyz = function(t) {
	    var i = t[0] / 255, e = t[1] / 255, s = t[2] / 255;
	    return [ 100 * (.4124 * (i = i > .04045 ? Math.pow((i + .055) / 1.055, 2.4) : i / 12.92) + .3576 * (e = e > .04045 ? Math.pow((e + .055) / 1.055, 2.4) : e / 12.92) + .1805 * (s = s > .04045 ? Math.pow((s + .055) / 1.055, 2.4) : s / 12.92)), 100 * (.2126 * i + .7152 * e + .0722 * s), 100 * (.0193 * i + .1192 * e + .9505 * s) ];
	}, P.rgb.lab = function(t) {
	    var i = P.rgb.xyz(t), e = i[0], s = i[1], n = i[2];
	    return s /= 100, n /= 108.883, e = (e /= 95.047) > .008856 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, 
	    [ 116 * (s = s > .008856 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116) - 16, 500 * (e - s), 200 * (s - (n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116)) ];
	}, P.hsl.rgb = function(t) {
	    var i, e, s, n, r, h = t[0] / 360, o = t[1] / 100, a = t[2] / 100;
	    if (0 === o) return [ r = 255 * a, r, r ];
	    i = 2 * a - (e = a < .5 ? a * (1 + o) : a + o - a * o), n = [ 0, 0, 0 ];
	    for (var l = 0; l < 3; l++) (s = h + 1 / 3 * -(l - 1)) < 0 && s++, s > 1 && s--, 
	    r = 6 * s < 1 ? i + 6 * (e - i) * s : 2 * s < 1 ? e : 3 * s < 2 ? i + (e - i) * (2 / 3 - s) * 6 : i, 
	    n[l] = 255 * r;
	    return n;
	}, P.hsl.hsv = function(t) {
	    var i = t[0], e = t[1] / 100, s = t[2] / 100, n = e, r = Math.max(s, .01);
	    return e *= (s *= 2) <= 1 ? s : 2 - s, n *= r <= 1 ? r : 2 - r, [ i, 100 * (0 === s ? 2 * n / (r + n) : 2 * e / (s + e)), 100 * ((s + e) / 2) ];
	}, P.hsv.rgb = function(t) {
	    var i = t[0] / 60, e = t[1] / 100, s = t[2] / 100, n = Math.floor(i) % 6, r = i - Math.floor(i), h = 255 * s * (1 - e), o = 255 * s * (1 - e * r), a = 255 * s * (1 - e * (1 - r));
	    switch (s *= 255, n) {
	      case 0:
	        return [ s, a, h ];

	      case 1:
	        return [ o, s, h ];

	      case 2:
	        return [ h, s, a ];

	      case 3:
	        return [ h, o, s ];

	      case 4:
	        return [ a, h, s ];

	      case 5:
	        return [ s, h, o ];
	    }
	}, P.hsv.hsl = function(t) {
	    var i, e, s, n = t[0], r = t[1] / 100, h = t[2] / 100, o = Math.max(h, .01);
	    return s = (2 - r) * h, e = r * o, [ n, 100 * (e = (e /= (i = (2 - r) * o) <= 1 ? i : 2 - i) || 0), 100 * (s /= 2) ];
	}, P.hwb.rgb = function(t) {
	    var i, e, s, n, r, h, o, a = t[0] / 360, l = t[1] / 100, c = t[2] / 100, u = l + c;
	    switch (u > 1 && (l /= u, c /= u), s = 6 * a - (i = Math.floor(6 * a)), 0 != (1 & i) && (s = 1 - s), 
	    n = l + s * ((e = 1 - c) - l), i) {
	      default:
	      case 6:
	      case 0:
	        r = e, h = n, o = l;
	        break;

	      case 1:
	        r = n, h = e, o = l;
	        break;

	      case 2:
	        r = l, h = e, o = n;
	        break;

	      case 3:
	        r = l, h = n, o = e;
	        break;

	      case 4:
	        r = n, h = l, o = e;
	        break;

	      case 5:
	        r = e, h = l, o = n;
	    }
	    return [ 255 * r, 255 * h, 255 * o ];
	}, P.cmyk.rgb = function(t) {
	    var i = t[0] / 100, e = t[1] / 100, s = t[2] / 100, n = t[3] / 100;
	    return [ 255 * (1 - Math.min(1, i * (1 - n) + n)), 255 * (1 - Math.min(1, e * (1 - n) + n)), 255 * (1 - Math.min(1, s * (1 - n) + n)) ];
	}, P.xyz.rgb = function(t) {
	    var i, e, s, n = t[0] / 100, r = t[1] / 100, h = t[2] / 100;
	    return e = -.9689 * n + 1.8758 * r + .0415 * h, s = .0557 * n + -.204 * r + 1.057 * h, 
	    i = (i = 3.2406 * n + -1.5372 * r + -.4986 * h) > .0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - .055 : 12.92 * i, 
	    e = e > .0031308 ? 1.055 * Math.pow(e, 1 / 2.4) - .055 : 12.92 * e, s = s > .0031308 ? 1.055 * Math.pow(s, 1 / 2.4) - .055 : 12.92 * s, 
	    [ 255 * (i = Math.min(Math.max(0, i), 1)), 255 * (e = Math.min(Math.max(0, e), 1)), 255 * (s = Math.min(Math.max(0, s), 1)) ];
	}, P.xyz.lab = function(t) {
	    var i = t[0], e = t[1], s = t[2];
	    return e /= 100, s /= 108.883, i = (i /= 95.047) > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, 
	    [ 116 * (e = e > .008856 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116) - 16, 500 * (i - e), 200 * (e - (s = s > .008856 ? Math.pow(s, 1 / 3) : 7.787 * s + 16 / 116)) ];
	}, P.lab.xyz = function(t) {
	    var i, e, s, n = t[0];
	    i = t[1] / 500 + (e = (n + 16) / 116), s = e - t[2] / 200;
	    var r = Math.pow(e, 3), h = Math.pow(i, 3), o = Math.pow(s, 3);
	    return e = r > .008856 ? r : (e - 16 / 116) / 7.787, i = h > .008856 ? h : (i - 16 / 116) / 7.787, 
	    s = o > .008856 ? o : (s - 16 / 116) / 7.787, [ i *= 95.047, e *= 100, s *= 108.883 ];
	}, P.lab.lch = function(t) {
	    var i, e = t[0], s = t[1], n = t[2];
	    return (i = 360 * Math.atan2(n, s) / 2 / Math.PI) < 0 && (i += 360), [ e, Math.sqrt(s * s + n * n), i ];
	}, P.lch.lab = function(t) {
	    var i, e = t[0], s = t[1];
	    return i = t[2] / 360 * 2 * Math.PI, [ e, s * Math.cos(i), s * Math.sin(i) ];
	}, P.rgb.ansi16 = function(t) {
	    var i = t[0], e = t[1], s = t[2], n = 1 in arguments ? arguments[1] : P.rgb.hsv(t)[2];
	    if (0 === (n = Math.round(n / 50))) return 30;
	    var r = 30 + (Math.round(s / 255) << 2 | Math.round(e / 255) << 1 | Math.round(i / 255));
	    return 2 === n && (r += 60), r;
	}, P.hsv.ansi16 = function(t) {
	    return P.rgb.ansi16(P.hsv.rgb(t), t[2]);
	}, P.rgb.ansi256 = function(t) {
	    var i = t[0], e = t[1], s = t[2];
	    return i === e && e === s ? i < 8 ? 16 : i > 248 ? 231 : Math.round((i - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(i / 255 * 5) + 6 * Math.round(e / 255 * 5) + Math.round(s / 255 * 5);
	}, P.ansi16.rgb = function(t) {
	    var i = t % 10;
	    if (0 === i || 7 === i) return t > 50 && (i += 3.5), [ i = i / 10.5 * 255, i, i ];
	    var e = .5 * (1 + ~~(t > 50));
	    return [ (1 & i) * e * 255, (i >> 1 & 1) * e * 255, (i >> 2 & 1) * e * 255 ];
	}, P.ansi256.rgb = function(t) {
	    if (t >= 232) {
	        var i = 10 * (t - 232) + 8;
	        return [ i, i, i ];
	    }
	    var e;
	    return t -= 16, [ Math.floor(t / 36) / 5 * 255, Math.floor((e = t % 36) / 6) / 5 * 255, e % 6 / 5 * 255 ];
	}, P.rgb.hex = function(t) {
	    var i = (((255 & Math.round(t[0])) << 16) + ((255 & Math.round(t[1])) << 8) + (255 & Math.round(t[2]))).toString(16).toUpperCase();
	    return "000000".substring(i.length) + i;
	}, P.hex.rgb = function(t) {
	    var i = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	    if (!i) return [ 0, 0, 0 ];
	    var e = i[0];
	    3 === i[0].length && (e = e.split("").map((function(t) {
	        return t + t;
	    })).join(""));
	    var s = parseInt(e, 16);
	    return [ s >> 16 & 255, s >> 8 & 255, 255 & s ];
	}, P.rgb.hcg = function(t) {
	    var i, e = t[0] / 255, s = t[1] / 255, n = t[2] / 255, r = Math.max(Math.max(e, s), n), h = Math.min(Math.min(e, s), n), o = r - h;
	    return i = o <= 0 ? 0 : r === e ? (s - n) / o % 6 : r === s ? 2 + (n - e) / o : 4 + (e - s) / o + 4, 
	    i /= 6, [ 360 * (i %= 1), 100 * o, 100 * (o < 1 ? h / (1 - o) : 0) ];
	}, P.hsl.hcg = function(t) {
	    var i = t[1] / 100, e = t[2] / 100, s = 1, n = 0;
	    return (s = e < .5 ? 2 * i * e : 2 * i * (1 - e)) < 1 && (n = (e - .5 * s) / (1 - s)), 
	    [ t[0], 100 * s, 100 * n ];
	}, P.hsv.hcg = function(t) {
	    var i = t[1] / 100, e = t[2] / 100, s = i * e, n = 0;
	    return s < 1 && (n = (e - s) / (1 - s)), [ t[0], 100 * s, 100 * n ];
	}, P.hcg.rgb = function(t) {
	    var i = t[0] / 360, e = t[1] / 100, s = t[2] / 100;
	    if (0 === e) return [ 255 * s, 255 * s, 255 * s ];
	    var n, r = [ 0, 0, 0 ], h = i % 1 * 6, o = h % 1, a = 1 - o;
	    switch (Math.floor(h)) {
	      case 0:
	        r[0] = 1, r[1] = o, r[2] = 0;
	        break;

	      case 1:
	        r[0] = a, r[1] = 1, r[2] = 0;
	        break;

	      case 2:
	        r[0] = 0, r[1] = 1, r[2] = o;
	        break;

	      case 3:
	        r[0] = 0, r[1] = a, r[2] = 1;
	        break;

	      case 4:
	        r[0] = o, r[1] = 0, r[2] = 1;
	        break;

	      default:
	        r[0] = 1, r[1] = 0, r[2] = a;
	    }
	    return n = (1 - e) * s, [ 255 * (e * r[0] + n), 255 * (e * r[1] + n), 255 * (e * r[2] + n) ];
	}, P.hcg.hsv = function(t) {
	    var i = t[1] / 100, e = i + t[2] / 100 * (1 - i), s = 0;
	    return e > 0 && (s = i / e), [ t[0], 100 * s, 100 * e ];
	}, P.hcg.hsl = function(t) {
	    var i = t[1] / 100, e = t[2] / 100 * (1 - i) + .5 * i, s = 0;
	    return e > 0 && e < .5 ? s = i / (2 * e) : e >= .5 && e < 1 && (s = i / (2 * (1 - e))), 
	    [ t[0], 100 * s, 100 * e ];
	}, P.hcg.hwb = function(t) {
	    var i = t[1] / 100, e = i + t[2] / 100 * (1 - i);
	    return [ t[0], 100 * (e - i), 100 * (1 - e) ];
	}, P.hwb.hcg = function(t) {
	    var i = t[1] / 100, e = 1 - t[2] / 100, s = e - i, n = 0;
	    return s < 1 && (n = (e - s) / (1 - s)), [ t[0], 100 * s, 100 * n ];
	}, P.apple.rgb = function(t) {
	    return [ t[0] / 65535 * 255, t[1] / 65535 * 255, t[2] / 65535 * 255 ];
	}, P.rgb.apple = function(t) {
	    return [ t[0] / 255 * 65535, t[1] / 255 * 65535, t[2] / 255 * 65535 ];
	}, P.gray.rgb = function(t) {
	    return [ t[0] / 100 * 255, t[0] / 100 * 255, t[0] / 100 * 255 ];
	}, P.gray.hsl = P.gray.hsv = function(t) {
	    return [ 0, 0, t[0] ];
	}, P.gray.hwb = function(t) {
	    return [ 0, 100, t[0] ];
	}, P.gray.cmyk = function(t) {
	    return [ 0, 0, 0, t[0] ];
	}, P.gray.lab = function(t) {
	    return [ t[0], 0, 0 ];
	}, P.gray.hex = function(t) {
	    var i = 255 & Math.round(t[0] / 100 * 255), e = ((i << 16) + (i << 8) + i).toString(16).toUpperCase();
	    return "000000".substring(e.length) + e;
	}, P.rgb.gray = function(t) {
	    return [ (t[0] + t[1] + t[2]) / 3 / 255 * 100 ];
	};

	var G = L.exports;

	function j(t) {
	    var i = function() {
	        for (var t = {}, i = Object.keys(G), e = i.length, s = 0; s < e; s++) t[i[s]] = {
	            distance: -1,
	            parent: null
	        };
	        return t;
	    }(), e = [ t ];
	    for (i[t].distance = 0; e.length; ) for (var s = e.pop(), n = Object.keys(G[s]), r = n.length, h = 0; h < r; h++) {
	        var o = n[h], a = i[o];
	        -1 === a.distance && (a.distance = i[s].distance + 1, a.parent = s, e.unshift(o));
	    }
	    return i;
	}

	function B(t, i) {
	    return function(e) {
	        return i(t(e));
	    };
	}

	function V(t, i) {
	    for (var e = [ i[t].parent, t ], s = G[i[t].parent][t], n = i[t].parent; i[n].parent; ) e.unshift(i[n].parent), 
	    s = B(G[i[n].parent][n], s), n = i[n].parent;
	    return s.conversion = e, s;
	}

	var U = L.exports, z = function(t) {
	    for (var i = j(t), e = {}, s = Object.keys(i), n = s.length, r = 0; r < n; r++) {
	        var h = s[r];
	        null !== i[h].parent && (e[h] = V(h, i));
	    }
	    return e;
	}, W = {};

	Object.keys(U).forEach((function(t) {
	    W[t] = {}, Object.defineProperty(W[t], "channels", {
	        value: U[t].channels
	    }), Object.defineProperty(W[t], "labels", {
	        value: U[t].labels
	    });
	    var i = z(t);
	    Object.keys(i).forEach((function(e) {
	        var s = i[e];
	        W[t][e] = function(t) {
	            var i = function(i) {
	                if (null == i) return i;
	                arguments.length > 1 && (i = Array.prototype.slice.call(arguments));
	                var e = t(i);
	                if ("object" == typeof e) for (var s = e.length, n = 0; n < s; n++) e[n] = Math.round(e[n]);
	                return e;
	            };
	            return "conversion" in t && (i.conversion = t.conversion), i;
	        }(s), W[t][e].raw = function(t) {
	            var i = function(i) {
	                return null == i ? i : (arguments.length > 1 && (i = Array.prototype.slice.call(arguments)), 
	                t(i));
	            };
	            return "conversion" in t && (i.conversion = t.conversion), i;
	        }(s);
	    }));
	}));

	var q = W, $ = m.exports, X = q, Y = [].slice, J = [ "keyword", "gray", "hex" ], K = {};

	Object.keys(X).forEach((function(t) {
	    K[Y.call(X[t].labels).sort().join("")] = t;
	}));

	var Z = {};

	function Q(t, i) {
	    if (!(this instanceof Q)) return new Q(t, i);
	    if (i && i in J && (i = null), i && !(i in X)) throw new Error("Unknown model: " + i);
	    var e, s;
	    if (null == t) this.model = "rgb", this.color = [ 0, 0, 0 ], this.valpha = 1; else if (t instanceof Q) this.model = t.model, 
	    this.color = t.color.slice(), this.valpha = t.valpha; else if ("string" == typeof t) {
	        var n = $.get(t);
	        if (null === n) throw new Error("Unable to parse color from string: " + t);
	        this.model = n.model, s = X[this.model].channels, this.color = n.value.slice(0, s), 
	        this.valpha = "number" == typeof n.value[s] ? n.value[s] : 1;
	    } else if (t.length) {
	        this.model = i || "rgb", s = X[this.model].channels;
	        var r = Y.call(t, 0, s);
	        this.color = st(r, s), this.valpha = "number" == typeof t[s] ? t[s] : 1;
	    } else if ("number" == typeof t) t &= 16777215, this.model = "rgb", this.color = [ t >> 16 & 255, t >> 8 & 255, 255 & t ], 
	    this.valpha = 1; else {
	        this.valpha = 1;
	        var h = Object.keys(t);
	        "alpha" in t && (h.splice(h.indexOf("alpha"), 1), this.valpha = "number" == typeof t.alpha ? t.alpha : 0);
	        var o = h.sort().join("");
	        if (!(o in K)) throw new Error("Unable to parse color from object: " + JSON.stringify(t));
	        this.model = K[o];
	        var a = X[this.model].labels, l = [];
	        for (e = 0; e < a.length; e++) l.push(t[a[e]]);
	        this.color = st(l);
	    }
	    if (Z[this.model]) for (s = X[this.model].channels, e = 0; e < s; e++) {
	        var c = Z[this.model][e];
	        c && (this.color[e] = c(this.color[e]));
	    }
	    this.valpha = Math.max(0, Math.min(1, this.valpha)), Object.freeze && Object.freeze(this);
	}

	function tt(t, i, e) {
	    return (t = Array.isArray(t) ? t : [ t ]).forEach((function(t) {
	        (Z[t] || (Z[t] = []))[i] = e;
	    })), t = t[0], function(s) {
	        var n;
	        return arguments.length ? (e && (s = e(s)), (n = this[t]()).color[i] = s, n) : (n = this[t]().color[i], 
	        e && (n = e(n)), n);
	    };
	}

	function it(t) {
	    return function(i) {
	        return Math.max(0, Math.min(t, i));
	    };
	}

	function et(t) {
	    return Array.isArray(t) ? t : [ t ];
	}

	function st(t, i) {
	    for (var e = 0; e < i; e++) "number" != typeof t[e] && (t[e] = 0);
	    return t;
	}

	Q.prototype = {
	    toString: function() {
	        return this.string();
	    },
	    toJSON: function() {
	        return this[this.model]();
	    },
	    string: function(t) {
	        var i = this.model in $.to ? this : this.rgb(), e = 1 === (i = i.round("number" == typeof t ? t : 1)).valpha ? i.color : i.color.concat(this.valpha);
	        return $.to[i.model](e);
	    },
	    percentString: function(t) {
	        var i = this.rgb().round("number" == typeof t ? t : 1), e = 1 === i.valpha ? i.color : i.color.concat(this.valpha);
	        return $.to.rgb.percent(e);
	    },
	    array: function() {
	        return 1 === this.valpha ? this.color.slice() : this.color.concat(this.valpha);
	    },
	    object: function() {
	        for (var t = {}, i = X[this.model].channels, e = X[this.model].labels, s = 0; s < i; s++) t[e[s]] = this.color[s];
	        return 1 !== this.valpha && (t.alpha = this.valpha), t;
	    },
	    unitArray: function() {
	        var t = this.rgb().color;
	        return t[0] /= 255, t[1] /= 255, t[2] /= 255, 1 !== this.valpha && t.push(this.valpha), 
	        t;
	    },
	    unitObject: function() {
	        var t = this.rgb().object();
	        return t.r /= 255, t.g /= 255, t.b /= 255, 1 !== this.valpha && (t.alpha = this.valpha), 
	        t;
	    },
	    round: function(t) {
	        return t = Math.max(t || 0, 0), new Q(this.color.map(function(t) {
	            return function(i) {
	                return function(t, i) {
	                    return Number(t.toFixed(i));
	                }(i, t);
	            };
	        }(t)).concat(this.valpha), this.model);
	    },
	    alpha: function(t) {
	        return arguments.length ? new Q(this.color.concat(Math.max(0, Math.min(1, t))), this.model) : this.valpha;
	    },
	    red: tt("rgb", 0, it(255)),
	    green: tt("rgb", 1, it(255)),
	    blue: tt("rgb", 2, it(255)),
	    hue: tt([ "hsl", "hsv", "hsl", "hwb", "hcg" ], 0, (function(t) {
	        return (t % 360 + 360) % 360;
	    })),
	    saturationl: tt("hsl", 1, it(100)),
	    lightness: tt("hsl", 2, it(100)),
	    saturationv: tt("hsv", 1, it(100)),
	    value: tt("hsv", 2, it(100)),
	    chroma: tt("hcg", 1, it(100)),
	    gray: tt("hcg", 2, it(100)),
	    white: tt("hwb", 1, it(100)),
	    wblack: tt("hwb", 2, it(100)),
	    cyan: tt("cmyk", 0, it(100)),
	    magenta: tt("cmyk", 1, it(100)),
	    yellow: tt("cmyk", 2, it(100)),
	    black: tt("cmyk", 3, it(100)),
	    x: tt("xyz", 0, it(100)),
	    y: tt("xyz", 1, it(100)),
	    z: tt("xyz", 2, it(100)),
	    l: tt("lab", 0, it(100)),
	    a: tt("lab", 1),
	    b: tt("lab", 2),
	    keyword: function(t) {
	        return arguments.length ? new Q(t) : X[this.model].keyword(this.color);
	    },
	    hex: function(t) {
	        return arguments.length ? new Q(t) : $.to.hex(this.rgb().round().color);
	    },
	    rgbNumber: function() {
	        var t = this.rgb().color;
	        return (255 & t[0]) << 16 | (255 & t[1]) << 8 | 255 & t[2];
	    },
	    luminosity: function() {
	        for (var t = this.rgb().color, i = [], e = 0; e < t.length; e++) {
	            var s = t[e] / 255;
	            i[e] = s <= .03928 ? s / 12.92 : Math.pow((s + .055) / 1.055, 2.4);
	        }
	        return .2126 * i[0] + .7152 * i[1] + .0722 * i[2];
	    },
	    contrast: function(t) {
	        var i = this.luminosity(), e = t.luminosity();
	        return i > e ? (i + .05) / (e + .05) : (e + .05) / (i + .05);
	    },
	    level: function(t) {
	        var i = this.contrast(t);
	        return i >= 7.1 ? "AAA" : i >= 4.5 ? "AA" : "";
	    },
	    isDark: function() {
	        var t = this.rgb().color;
	        return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 < 128;
	    },
	    isLight: function() {
	        return !this.isDark();
	    },
	    negate: function() {
	        for (var t = this.rgb(), i = 0; i < 3; i++) t.color[i] = 255 - t.color[i];
	        return t;
	    },
	    lighten: function(t) {
	        var i = this.hsl();
	        return i.color[2] += i.color[2] * t, i;
	    },
	    darken: function(t) {
	        var i = this.hsl();
	        return i.color[2] -= i.color[2] * t, i;
	    },
	    saturate: function(t) {
	        var i = this.hsl();
	        return i.color[1] += i.color[1] * t, i;
	    },
	    desaturate: function(t) {
	        var i = this.hsl();
	        return i.color[1] -= i.color[1] * t, i;
	    },
	    whiten: function(t) {
	        var i = this.hwb();
	        return i.color[1] += i.color[1] * t, i;
	    },
	    blacken: function(t) {
	        var i = this.hwb();
	        return i.color[2] += i.color[2] * t, i;
	    },
	    grayscale: function() {
	        var t = this.rgb().color, i = .3 * t[0] + .59 * t[1] + .11 * t[2];
	        return Q.rgb(i, i, i);
	    },
	    fade: function(t) {
	        return this.alpha(this.valpha - this.valpha * t);
	    },
	    opaquer: function(t) {
	        return this.alpha(this.valpha + this.valpha * t);
	    },
	    rotate: function(t) {
	        var i = this.hsl(), e = i.color[0];
	        return e = (e = (e + t) % 360) < 0 ? 360 + e : e, i.color[0] = e, i;
	    },
	    mix: function(t, i) {
	        if (!t || !t.rgb) throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof t);
	        var e = t.rgb(), s = this.rgb(), n = void 0 === i ? .5 : i, r = 2 * n - 1, h = e.alpha() - s.alpha(), o = ((r * h == -1 ? r : (r + h) / (1 + r * h)) + 1) / 2, a = 1 - o;
	        return Q.rgb(o * e.red() + a * s.red(), o * e.green() + a * s.green(), o * e.blue() + a * s.blue(), e.alpha() * n + s.alpha() * (1 - n));
	    }
	}, Object.keys(X).forEach((function(t) {
	    if (-1 === J.indexOf(t)) {
	        var i = X[t].channels;
	        Q.prototype[t] = function() {
	            if (this.model === t) return new Q(this);
	            if (arguments.length) return new Q(arguments, t);
	            var e = "number" == typeof arguments[i] ? i : this.valpha;
	            return new Q(et(X[this.model][t].raw(this.color)).concat(e), t);
	        }, Q[t] = function(e) {
	            return "number" == typeof e && (e = st(Y.call(arguments), i)), new Q(e, t);
	        };
	    }
	}));

	var nt = Q;

	const rt = "function" == typeof Object.assign;

	function ht(t) {
	    if (rt) Object.assign.apply(Object, arguments); else for (let i = 1; i < arguments.length; i++) {
	        const e = arguments[i];
	        for (const i in e) t[i] = e[i];
	    }
	    return t;
	}

	function ot(t) {
	    return null == t;
	}

	const at = [];

	function lt(t, i) {
	    const e = i._get2DExtentAtRes(i.getGLRes()), s = e.getWidth(), n = e.getHeight(), r = t;
	    return identity$2(r), translate$1(r, r, i.cameraLookAt), scale$5(r, r, set$4(at, s, n, 1)), 
	    r;
	}

	function ct(t) {
	    for (let i = 1; i < arguments.length; i++) {
	        const e = arguments[i];
	        if (e) for (let i = 0, s = e.length; i < s; i++) t.push(e[i]);
	    }
	    return t.length;
	}

	const ut = {};

	function ft(t, i) {
	    if (!Array.isArray(i)) {
	        const t = i;
	        i = ut[t] = ut[t] || nt(i).array();
	    }
	    for (let e = 0; e < i.length; e++) t[e] = i[e];
	    return 3 === i.length && (t[3] = 1), t;
	}

	function dt(t, i) {
	    if (Array.isArray(i)) for (let e = 0; e < i.length; e++) t[e] = 255 * i[e]; else {
	        const e = i;
	        i = ut[e] = ut[e] || nt(i).array();
	        for (let e = 0; e < i.length; e++) t[e] = i[e];
	    }
	    return 3 === t.length && t.push(255), t;
	}

	const pt = [ 0, 0 ], gt = [ 0, 0, 0 ];

	let mt;

	class vt {
	    static getUniformDeclares() {
	        const t = [], i = [];
	        return i.push({
	            name: "shadow_lightProjViewModelMatrix",
	            type: "function",
	            fn: function(i, e) {
	                const s = e.shadow_lightProjViewMatrix, n = e.modelMatrix;
	                return multiply$5(t, s, n);
	            }
	        }), i.push("shadow_shadowMap", "shadow_opacity", "esm_shadow_threshold", "shadow_color", "shadow_nearFar"), 
	        i;
	    }
	    constructor(t, i, e) {
	        this.renderer = new N$1(t), this.sceneConfig = i, this.t = .3, this.i = e, 
	        this.s();
	    }
	    resize() {
	        const t = this.canvas;
	        t.width = this.i.getRenderer().canvas.width, t.height = this.i.getRenderer().canvas.height;
	    }
	    s() {
	        const t = this.sceneConfig.shadow || {};
	        let i = 512;
	        const e = t.quality;
	        "high" === e ? i = 2048 : "medium" === e && (i = 1024);
	        const s = this.getDefines();
	        this.h = new em(this.renderer, {
	            width: i,
	            height: i,
	            blurOffset: t.blurOffset,
	            defines: s
	        }), this.o = new nm(s), this.u();
	    }
	    getDefines() {
	        return {
	            "HAS_SHADOWING": 1,
	            "PACK_FLOAT": 1,
	            "USE_ESM": 1
	        };
	    }
	    render(t, i, e, s, n, r, a, l, c, u) {
	        this.p();
	        const f = this.i.getMap();
	        let d, p;
	        if (u || this.m(f, a, !!t)) {
	            this.v = this.v || [], this._ = this._ || [];
	            const s = multiply$5(this.v, i, e), n = normalize$4(this._, r);
	            mt || (mt = f.getContainerExtent());
	            let l = f.height;
	            f.getPitch() > 62 && (l = f._getVisualHeight(62));
	            const c = mt.set(0, f.height - l, f.width, f.height).convertTo(t => f._containerPointToPointAtRes(t, f.getGLRes())).toArray();
	            t && a.addMesh(this.M);
	            const u = c.map(t => [ t.x, t.y, 0, 1 ]), {lightProjViewMatrix: g, shadowMap: m, blurFBO: v} = this.h.render(a, {
	                cameraProjViewMatrix: s,
	                lightDir: n,
	                farPlane: u,
	                cameraLookAt: f.cameraLookAt
	            });
	            d = this.C = g, p = this.S = m, this.T = v, this.O = a.getMeshes().reduce((t, i) => (i.castShadow && (t[i.uuid] = {
	                v0: i.version,
	                v1: i.geometry.version
	            }), t), {}), this.k = {
	                count: a.getMeshes().length - +!!t,
	                displayShadow: !!t
	            }, this.A = !0;
	        } else d = this.C, p = this.S, this.A = !1;
	        this.L = i, this.I = e, t && a.getMeshes().length && this.displayShadow(s, n, l, c);
	        return {
	            "shadow_lightProjViewMatrix": d,
	            "shadow_shadowMap": p,
	            "shadow_opacity": n,
	            "shadow_color": s,
	            "esm_shadow_threshold": this.t
	        };
	    }
	    displayShadow(t, i, e, s) {
	        const n = this.C, r = this.M, o = this.F || [], a = this.i.getRenderer().canvas, l = this.R = this.R || [];
	        l[0] = a.width, l[1] = a.height, this.renderer.render(this.o, {
	            "halton": e || pt,
	            "globalTexSize": l,
	            "projMatrix": this.L,
	            "viewMatrix": this.I,
	            "shadow_lightProjViewModelMatrix": multiply$5(o, n, r.localTransform),
	            "shadow_shadowMap": this.S,
	            "esm_shadow_threshold": this.t,
	            "shadow_opacity": i,
	            "color": t || gt
	        }, this.P, s);
	    }
	    dispose() {
	        this.h.dispose(), this.o.dispose(), this.M && (this.M.geometry.dispose(), this.M.dispose()), 
	        delete this.renderer;
	    }
	    isUpdated() {
	        return !1 !== this.A;
	    }
	    m(t, i, e) {
	        if (!this.O) return !0;
	        const s = this.k;
	        if (i.getMeshes().length !== s.count || e !== s.displayShadow) return !0;
	        const n = i.getMeshes();
	        for (let t = 0; t < n.length; t++) {
	            const i = this.O[n[t].uuid];
	            if (n[t].castShadow && (n[t].hasSkinAnimation() || !i || i.v0 !== n[t].version || i.v1 !== n[t].geometry.version)) return !0;
	        }
	        return !1;
	    }
	    u() {
	        const t = new Wt$1;
	        t.generateBuffers(this.renderer.regl), this.M = new ft$1(t), this.P = new yt$1([ this.M ]);
	    }
	    p() {
	        const t = this.i.getMap(), i = lt(this.M.localTransform, t);
	        this.M.setLocalTransform(i);
	    }
	}

	const {createIBLTextures: wt, disposeIBLTextures: bt, getPBRUniforms: _t} = bm.PBRUtils, Mt = [ 0, 0 ], yt = [ 1, 1 ];

	class xt {
	    static getGroundTransform(t, i) {
	        return lt(t, i);
	    }
	    constructor(t, i) {
	        this.H = t, this.renderer = new N$1(t), this.i = i, this.D = new gt$1, 
	        this.N = this.G.bind(this), this.s();
	    }
	    needToRedraw() {
	        const t = this.j();
	        return t && (t[0] || t[1]);
	    }
	    getMap() {
	        return this.i && this.i.getMap();
	    }
	    getSymbol() {
	        const t = this.i.getGroundConfig();
	        return t && t.symbol;
	    }
	    isEnable() {
	        const t = this.i.getGroundConfig();
	        return t && t.enable;
	    }
	    paint(t) {
	        if (!this.isEnable()) return !1;
	        const i = this.B();
	        if (this.V(t) && i === this.U) return !1;
	        const e = this.W(t);
	        e && this.M.setDefines(e), this.M.material !== this.material && this.M.setMaterial(this.material);
	        const s = this.i.getGroundConfig();
	        (s && s.symbol).ssr ? this.M.ssr = 1 : this.M.ssr = 0, this.p();
	        const n = this.q(t);
	        n.offsetFactor = t.offsetFactor, n.offsetUnits = t.offsetUnits;
	        const r = t && t.renderTarget && t.renderTarget.fbo;
	        return i === this.U ? (this.renderer.render(i, n, this.P, r), this.i.getRenderer().setCanvasUpdated(), 
	        !0) : (i.filter = t.sceneFilter, this.renderer.render(i, n, this.P, r), this.i.getRenderer().setCanvasUpdated(), 
	        !0);
	    }
	    V(t) {
	        return !(!this.i.getRenderer().isEnableSSR || !this.i.getRenderer().isEnableSSR()) && !(!t || !t.ssr);
	    }
	    update() {
	        const t = this.i.getGroundConfig();
	        if (!t) return;
	        const i = t && t.symbol;
	        if (i) {
	            this.$ = this.X(i.polygonFill || [ 1, 1, 1, 1 ]), this.Y = void 0 === i.polygonOpacity ? 1 : i.polygonOpacity;
	            const t = i.polygonPatternFile;
	            if (t) {
	                if (!this.J || this.J._pattern_src !== t) {
	                    const i = new Image;
	                    i.onload = () => {
	                        this.J && this.J.destroy(), this.J = this.K(i), this.J._pattern_src = t;
	                    }, i.src = t;
	                }
	            } else this.J && (this.J.destroy(), delete this.J);
	        } else this.$ = [ 1, 1, 1, 1 ], this.Y = 1, this.J && (this.J.destroy(), delete this.J);
	        this.Z();
	    }
	    setToRedraw() {
	        const t = this.i.getRenderer();
	        t && t.setToRedraw();
	    }
	    dispose() {
	        this.material && (this.material.dispose(), delete this.material), this.M && (this.M.geometry.dispose(), 
	        this.M.material && this.M.material.dispose(), this.M.dispose(), delete this.M), 
	        this.J && (this.J.destroy(), delete this.J), this.U && (this.U.dispose(), delete this.U), 
	        this.tt && (this.tt.dispose(), delete this.tt), this.it(), this.et && (this.et.destroy(), 
	        delete this.et);
	        const t = this.getMap();
	        t && t.off("updatelights", this.st, this);
	    }
	    B() {
	        const t = this.i.getGroundConfig();
	        if (!t || !t.renderPlugin) return this.U;
	        const i = t.renderPlugin.type;
	        if ("lit" === i) return this.tt;
	        if ("fill" === i) return this.U;
	        throw new Error("unsupported render plugin of " + i + " for layer ground");
	    }
	    q(t) {
	        const i = this.nt(t);
	        i.polygonFill = this.$, i.polygonOpacity = this.Y;
	        return this.B() === this.U && this.J && (i.polygonPatternFile = this.J), i;
	    }
	    nt(t) {
	        let i;
	        if ("lit" === this.i.getGroundConfig().renderPlugin.type) this.rt || (this.rt = wt(this.H, this.getMap())), 
	        this.et || (this.et = bm.PBRHelper.generateDFGLUT(this.H)), i = _t(this.getMap(), this.rt, this.et, t && t.ssr, t && t.jitter); else {
	            i = {
	                projViewMatrix: this.getMap().projViewMatrix
	            };
	        }
	        return this.ht(i, t), i;
	    }
	    ht(t, i) {
	        const e = i && i.includes;
	        if (e) for (const s in e) e[s] && i[s].renderUniforms && ht(t, i[s].renderUniforms);
	    }
	    it() {
	        this.rt && (bt(this.rt), delete this.rt);
	    }
	    s() {
	        this.getMap().on("updatelights", this.st, this);
	        const t = this.ot(), i = vt.getUniformDeclares(), e = [];
	        i.push({
	            name: "projViewModelMatrix",
	            type: "function",
	            fn: function(t, i) {
	                return multiply$5(e, i.projViewMatrix, i.modelMatrix);
	            }
	        }), this.U = new ie$1({
	            vert: "attribute vec3 aPosition;\nuniform mat4 projViewModelMatrix;\nuniform mat4 modelMatrix;\n#ifdef HAS_PATTERN\n    attribute vec2 aTexCoord;\n    uniform vec2 uvScale;\n    uniform vec2 uvOffset;\n    varying vec2 vTexCoord;\n#endif\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n    #include <vsm_shadow_vert>\n#endif\nvoid main () {\n    #ifdef HAS_PATTERN\n        vTexCoord = aTexCoord * uvScale + uvOffset;\n    #endif\n    vec3 position = vec3(aPosition);\n    gl_Position = projViewModelMatrix * vec4(position, 1.0);\n    #if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n        shadow_computeShadowPars(vec4(position, 1.0));\n    #endif\n}",
	            frag: "precision mediump float;\n#if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n    #include <vsm_shadow_frag>\n#endif\n#ifdef HAS_PATTERN\n    uniform sampler2D polygonPatternFile;\n    varying vec2 vTexCoord;\n#endif\nuniform vec4 polygonFill;\nuniform float polygonOpacity;\nvoid main() {\n    #ifdef HAS_PATTERN\n        vec4 color = texture2D(polygonPatternFile, vTexCoord);\n    #else\n        vec4 color = polygonFill;\n    #endif\n    gl_FragColor = color * polygonOpacity;\n    #if defined(HAS_SHADOWING) && !defined(HAS_BLOOM)\n        float shadowCoeff = shadow_computeShadow();\n        gl_FragColor.rgb = shadow_blend(gl_FragColor.rgb, shadowCoeff);\n    #endif\n}",
	            uniforms: i,
	            extraCommandProps: t
	        });
	        const s = vt.getUniformDeclares();
	        s.push(...Ie.getUniformDeclares()), this.tt = new bm.StandardShader({
	            uniforms: s,
	            extraCommandProps: t
	        }), this.u(), this.update();
	    }
	    ot() {
	        const t = [ 0, 1 ], i = this.i.getRenderer().canvas;
	        return {
	            viewport: {
	                x: 0,
	                y: 0,
	                width: () => i.width,
	                height: () => i.height
	            },
	            depth: {
	                enable: !0,
	                mask: () => {
	                    const t = this.i.getGroundConfig();
	                    return t.depth || void 0 === t.depth;
	                },
	                range: () => {
	                    const i = this.i.getGroundConfig(), e = i && i.renderPlugin.sceneConfig;
	                    return e && e.depthRange || t;
	                },
	                func: "<="
	            },
	            blend: {
	                enable: !0,
	                func: {
	                    src: "src alpha",
	                    dst: "one minus src alpha"
	                },
	                equation: "add"
	            },
	            polygonOffset: {
	                enable: !0,
	                offset: {
	                    factor: (t, i) => i.offsetFactor,
	                    units: (t, i) => i.offsetUnits
	                }
	            }
	        };
	    }
	    lt() {
	        const t = this.getMap().getLightManager();
	        return !!(t && t.getAmbientResource());
	    }
	    u() {
	        const t = new Wt$1;
	        t.data.aTexCoord = new Uint8Array([ 0, 1, 1, 1, 0, 0, 1, 0 ]), t.createTangent(), 
	        t.generateBuffers(this.renderer.regl), this.M = new ft$1(t, null, {
	            castShadow: !1
	        });
	        const i = this.tt.getGeometryDefines(t);
	        this.M.setDefines(i), this.P = new yt$1([ this.M ]);
	    }
	    p() {
	        const t = this.getMap(), i = xt.getGroundTransform(this.M.localTransform, t);
	        this.M.setLocalTransform(i);
	        const e = t._get2DExtentAtRes(t.getGLRes()), s = e.getWidth(), n = e.getHeight(), r = t.cameraLookAt, h = r[0] - s, o = r[1] + n;
	        let a = this.material && this.material.get("uvOffset") || Mt;
	        a[0] = a[0] || 0, a[1] = a[1] || 0;
	        const l = this.j(), c = this.material && this.material.get("noiseTexture"), u = l && (l[0] || l[1]);
	        if (u) {
	            a = [ a[0], a[1] ];
	            const t = performance.now(), i = c ? 5e4 : 1e3, e = c ? 256 : 1;
	            l[0] && (a[0] = t * l[0] % i / i * e), l[1] && (a[1] = t * l[1] % i / i * e);
	        }
	        const f = this.material && this.material.get("uvScale") || yt, d = .5 / f[0], p = .5 / f[1], g = e.getWidth() / d * 2, m = e.getHeight() / p * 2;
	        if (this.M.setUniform("uvScale", [ g, -m ]), u && c) {
	            const t = [ h - (l[0] ? a[0] : 0), o + (l[1] ? a[1] : 0) ], i = t[0] / d % 1, e = t[1] / p % 1, s = [ t[0] / d - i, t[1] / p - e ];
	            this.M.setUniform("uvOffset", [ i + (l[0] ? 0 : a[0]), e + (l[1] ? 0 : a[1]) ]), 
	            this.M.setUniform("uvOrigin", s);
	        } else {
	            const t = h / d % 1, i = o / p % 1, e = [ h / d - t, o / p - i ];
	            this.M.setUniform("uvOffset", [ t + a[0], i + a[1] ]), this.M.setUniform("uvOrigin", e);
	        }
	    }
	    W(t) {
	        let i = !1;
	        const e = this.M.defines, s = this.i.ct && this.i.ct(), n = this.i.getGroundConfig();
	        function r(t, s) {
	            t ? e[s] || (e[s] = 1, i = !0) : e[s] && (delete e[s], i = !0);
	        }
	        r(this.lt(), "HAS_IBL_LIGHTING");
	        r(t && t.ssr && n && n.symbol && n.symbol.ssr, "HAS_SSR");
	        const h = t && s && s.shadow && s.shadow.enable;
	        r(h, "HAS_SHADOWING"), r(h, "USE_ESM");
	        r(!!this.J, "HAS_PATTERN");
	        return r(t && t.ssao, "HAS_SSAO"), i ? e : null;
	    }
	    Z() {
	        const t = this.getSymbol() && this.getSymbol().material;
	        if (!t) return;
	        const i = {};
	        let e = !1;
	        for (const r in t) if (s = t, n = r, Object.prototype.hasOwnProperty.call(s, n)) if (r.indexOf("Texture") > 0) {
	            let s = t[r];
	            if (!s) continue;
	            s = "string" == typeof s ? {
	                url: s,
	                wrap: "repeat"
	            } : s, s.flipY = !0, s.min = "linear", s.mag = "linear", s.flipY = !0, i[r] = new Vt$1(s, this.D), 
	            e = !0;
	        } else i[r] = t[r];
	        var s, n;
	        this.material ? (this.ut = new bm.StandardMaterial(i), this.ut.isReady() ? this.G() : this.ut.once("complete", this.N)) : (this.material = new bm.StandardMaterial(i), 
	        this.material.once("complete", this.N, this)), e || this.G();
	    }
	    G() {
	        this.ut && (this.material.dispose(), this.material = this.ut, delete this.ut), this.setToRedraw(!0);
	    }
	    K(t) {
	        const i = this.H, e = {
	            width: t.width,
	            height: t.height,
	            data: t,
	            mag: "linear",
	            min: "linear",
	            flipY: !1,
	            wrap: "repeat"
	        };
	        return i.texture(e);
	    }
	    st(t) {
	        if (t.ambientUpdate) {
	            this.it();
	            const t = this.getMap();
	            t && (this.rt = wt(this.H, t));
	        }
	        this.setToRedraw();
	    }
	    X(t) {
	        return ft([], t);
	    }
	    j() {
	        return this.material && this.material.get("uvOffsetAnim");
	    }
	    getRenderMeshes() {
	        return this.P.getMeshes();
	    }
	}

	const {createIBLTextures: Ct, disposeIBLTextures: St} = bm.PBRUtils, Tt = [ 0, 0, 0 ], Ot = [], kt = [];

	class At {
	    constructor(t, i) {
	        this.ft = 4, this.H = t, this.renderer = new N$1(t), this.i = i, this.s(), 
	        this.dt();
	    }
	    paint(t) {
	        if (!this.isEnable() || !this.pt) return;
	        const i = this.q(t), e = t && t.renderTarget && t.renderTarget.fbo;
	        this.renderer.render(this.gt, i, null, e);
	    }
	    update() {
	        const t = this.getMap();
	        if (!t || !this.isEnable()) return;
	        const i = t.getLightManager(), e = i && i.getAmbientResource();
	        e !== this.pt && this.rt && (St(this.rt), delete this.rt), this.pt = e, this.dt();
	    }
	    dispose() {
	        this.gt.dispose(), St(this.rt), delete this.gt, delete this.rt, delete this.pt;
	    }
	    getMap() {
	        return this.i.getMap();
	    }
	    dt() {
	        if (!this.pt) return;
	        const t = this.i.ct();
	        this.gt.setMode(1, 0, t.environment && t.environment.mode ? 1 : 0);
	    }
	    isEnable() {
	        const t = this.i.ct();
	        return this.lt() && t && t.environment && t.environment.enable;
	    }
	    lt() {
	        const t = this.getMap().getLightManager();
	        return !!(t && t.getAmbientResource());
	    }
	    q() {
	        const t = this.getMap(), i = this.getMap().getLightManager().getAmbientLight();
	        let e = this.rt;
	        e || (e = this.rt = Ct(this.H, t));
	        const s = this.i.getRenderer().canvas, n = this.i.ct().environment || {}, r = n.level || 0, h = e.prefilterMap.width, l = this.vt = this.vt || [], c = i && i.hsv || Tt, u = n.brightness || 0;
	        return copy$4(Ot, c), u && (Ot[2] += u), kt[0] = s.width, kt[1] = s.height, {
	            "rgbmRange": e.rgbmRange,
	            "cubeMap": e.prefilterMap,
	            "bias": r,
	            "size": h / Math.pow(2, Math.max(0, r - 1)),
	            "environmentExposure": (f = i.exposure, "number" != typeof f || isNaN(f) ? 1 : i.exposure),
	            "diffuseSPH": e.sh,
	            "viewMatrix": t.viewMatrix,
	            "projMatrix": t.projMatrix,
	            "resolution": kt,
	            "hsv": Ot,
	            "transformMatrix": fromRotation$2(l, Math.PI / 180 * -i.orientation || 0)
	        };
	        var f;
	    }
	    s() {
	        const t = this.getMap();
	        if (t.on("updatelights", this.update, this), this.gt = new ze, t.options.lights) {
	            const t = this.getMap().getLightManager().getAmbientResource();
	            this.pt = t;
	        }
	    }
	}

	const Et = [], Lt = [ .03, .03, .03 ], It = [], Ft = [], Rt = [], Pt = [ 1, 1, 1 ], Ht = [ -1200, -1200, 0 ], Dt = [ 1200, 1200, 1e3 ], Nt = {
	    min: [],
	    max: []
	}, Gt = fromRotationTranslation$1([], fromEuler([], 90, 0, 0), [ 0, 0, 0 ]);

	class jt {
	    constructor(t, i) {
	        this.H = t, this.renderer = new N$1(t), this.i = i, this.wt = new Bt, this.s();
	    }
	    getMap() {
	        return this.i && this.i.getMap();
	    }
	    s() {
	        const t = this.i.getRenderer().canvas, i = {
	            x: 0,
	            y: 0,
	            width: () => t.width,
	            height: () => t.height
	        };
	        this.gt = new ie$1({
	            vert: "attribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\nuniform mat4 projMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 positionMatrix;\nuniform vec3 cameraPosition;\nuniform float top;\nuniform float bottom;\nuniform float time;\nvarying vec2 vTexCoord;\n#include <get_output>\nfloat angle(float x, float y){\n    return atan(y, x);\n}\nvec2 getFoot(vec2 camera, vec2 normal, vec2 pos) {\n    vec2 position = vec2(0.0, 0.0);\n    float distanceLen = distance(pos, normal);\n    float a = angle(camera.x - normal.x, camera.y - normal.y);\n    pos.x > normal.x ? a -= 0.785 : a += 0.785;\n    position.x = cos(a) * distanceLen;\n    position.y = sin(a) * distanceLen;\n    return position + normal;\n    return position;\n}\nvoid main()\n{\n    vec4 localPosition = getPosition(aPosition);\n    mat4 localPositionMatrix = getPositionMatrix();\n    vec2 foot = getFoot(vec2(cameraPosition.x, cameraPosition.z), vec2(aNormal.x, aNormal.z), vec2(localPosition.x, localPosition.z));\n    float height = top - bottom;\n    float y = aNormal.y - bottom - height * time;\n    y = y + (y < 0.0 ? height : 0.0);\n    float ratio = (1.0 - y / height) * (1.0 - y / height);\n    y = height * (1.0 - ratio);\n    y += bottom;\n    y += aPosition.y - aNormal.y;\n    localPosition = vec4( foot.x, y, foot.y , 1.0);\n    gl_Position = projMatrix * modelViewMatrix * localPositionMatrix * localPosition;\n    vTexCoord = aTexCoord;\n}",
	            frag: "precision mediump float;\nvarying vec2 vTexCoord;\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D rainMap;\nvoid main() {\n    vec4 rainColor = texture2D(rainMap, vTexCoord);\n    vec4 diffuseColor = vec4(diffuse, opacity);\n    diffuseColor *= rainColor;\n    gl_FragColor = diffuseColor;\n}",
	            uniforms: [ {
	                name: "modelViewMatrix",
	                type: "function",
	                fn: function(t, i) {
	                    return multiply$5(Et, i.viewMatrix, i.modelMatrix);
	                }
	            } ],
	            extraCommandProps: {
	                viewport: i,
	                depth: {
	                    enable: !0,
	                    mask: !1,
	                    func: "less",
	                    range: [ 0, 1 ]
	                },
	                blend: {
	                    enable: !0,
	                    func: {
	                        src: "src alpha",
	                        dst: "one minus src alpha"
	                    },
	                    equation: "add"
	                }
	            }
	        }), this.bt();
	    }
	    bt() {
	        const t = this.H.texture({
	            width: 2,
	            height: 2
	        });
	        if (this._t = this.Mt(), !this._t) return;
	        this.yt = new yt$1(this._t);
	        const i = this.xt();
	        i.rainTexture ? this.Ct(i.rainTexture).then(t => {
	            this._t.material.set("rainMap", t);
	        }) : (this._t.material.set("rainMap", t), console.warn("should set rain texture."));
	    }
	    Mt() {
	        const t = this.getMap(), i = this.xt();
	        if (!i) return;
	        this.St = t.getZoom();
	        const e = this.Tt(), s = this.Ot = i.density, n = this.kt = i.rainWidth || 1, r = this.At = i.rainHeight || 1, h = [], o = [], a = [], l = [];
	        for (let t = 0; t < s; t++) {
	            const i = {};
	            i.x = Math.random() * (e.max[0] - e.min[0]) + e.min[0], i.y = Math.random() * (e.max[2] - e.min[2]) + e.min[2], 
	            i.z = Math.random() * (e.max[1] - e.min[1]) + e.min[1];
	            const s = (e.max[2] - e.min[2]) / 37.5 * r, c = s / 3 * n;
	            h.push(i.x + c, i.y + s, i.z, i.x - c, i.y + s, i.z, i.x - c, i.y, i.z, i.x + c, i.y, i.z), 
	            o.push(i.x, i.y - s / 2, i.z, i.x, i.y - s / 2, i.z, i.x, i.y - s / 2, i.z, i.x, i.y - s / 2, i.z), 
	            a.push(1, 1, 0, 1, 0, 0, 1, 0), l.push(4 * t + 0, 4 * t + 1, 4 * t + 2, 4 * t + 0, 4 * t + 2, 4 * t + 3);
	        }
	        const c = {};
	        c.POSITION = h, c.NORMAL = o, c.TEXCOORD_0 = a;
	        const u = new Q$1(c, l, 0, {
	            primitive: "triangles",
	            positionAttribute: "POSITION",
	            normalAttribute: "NORMAL",
	            uv0Attribute: "TEXCOORD_0"
	        });
	        u.generateBuffers(this.renderer.regl);
	        const f = new tt$1({
	            rainMap: this.H.texture({
	                width: 2,
	                height: 2
	            }),
	            diffuse: i.color || [ 1, 1, 1 ],
	            opacity: i.opacity || 1
	        }), p = new ft$1(u, f);
	        return p.setUniform("top", e.max[2]), p.setUniform("bottom", e.min[2]), this.Et(p), 
	        p.transparent = !0, p;
	    }
	    Ct(t) {
	        const i = new Image;
	        return i.src = this.Lt = t, new Promise((t, e) => {
	            i.onload = () => {
	                const e = this.H.texture({
	                    mag: "linear",
	                    min: "linear mipmap nearest",
	                    wrapS: "clamp",
	                    wrapT: "clamp",
	                    data: i
	                });
	                t(e);
	            }, i.onerror = t => {
	                e(t);
	            };
	        });
	    }
	    paint(t) {
	        if (!this.yt) return;
	        const i = this.xt(), e = {}, s = this.getMap();
	        e.projMatrix = s.projMatrix, e.viewMatrix = s.viewMatrix, e.cameraPosition = s.cameraPosition;
	        const n = i.speed || 1, r = this.wt.getElapsedTime() / (2 / n) % 1;
	        e.time = r, this._t.material.set("diffuse", i.color || Pt), this._t.material.set("opacity", i.opacity || 1), 
	        this.Et(this._t);
	        const h = t && t.renderTarget && t.renderTarget.fbo;
	        this.renderer.render(this.gt, e, this.yt, h), this.i.getRenderer().setCanvasUpdated();
	    }
	    Et(t) {
	        const i = this.getMap(), e = i.coordinateToPointAtRes(i.getCenter(), i.getGLRes());
	        let s = i.getGLScale() / i.getGLScale(this.St);
	        const n = set$4(Ft, s, s, s), r = multiply$4(n, Lt, n), a = identity$2(Rt), c = this.xt(), u = i.getBearing();
	        fromRotationTranslationScale(a, fromEuler(It, c.windDirectionX || 0, c.windDirectionY || 0, 90 - u), [ e.x, e.y, 0 ], r), 
	        multiply$5(a, a, Gt), t.setLocalTransform(a);
	    }
	    setToRedraw() {
	        const t = this.i.getRenderer();
	        t && t.setToRedraw();
	    }
	    update() {
	        const t = this.xt();
	        if (t) {
	            if (this._t || this.bt(), t.density !== this.Ot || t.rainWidth !== this.kt || t.rainHeight !== this.At) {
	                const t = this._t.material.get("rainMap");
	                this._t.geometry.dispose(), this._t.dispose(), this.yt.clear(), this._t = this.Mt(), 
	                this._t.material.set("rainMap", t), this.yt.setMeshes(this._t);
	            }
	            t.rainTexture !== this.Lt && this.Ct().then(t => {
	                this._t.material.set("rainMap", t);
	            });
	        }
	    }
	    dispose() {
	        this._t && (this._t.geometry.dispose(), this._t.material && this._t.material.dispose(), 
	        this._t.dispose(), delete this._t), this.gt && (this.gt.dispose(), delete this.gt);
	    }
	    isEnable() {
	        const t = this.xt();
	        return t && t.enable;
	    }
	    xt() {
	        const t = this.i.getWeatherConfig();
	        return t && t.rain;
	    }
	    Tt() {
	        const t = 16.685648411389433 - this.getMap().getZoom();
	        return scale$4(Nt.min, Ht, Math.pow(2, t)), scale$4(Nt.max, Dt, Math.pow(2, t)), 
	        Nt;
	    }
	}

	class Bt {
	    constructor(t) {
	        this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, 
	        this.running = !1;
	    }
	    start() {
	        this.startTime = ("undefined" == typeof performance ? Date : performance).now(), 
	        this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
	    }
	    stop() {
	        this.getElapsedTime(), this.running = !1, this.autoStart = !1;
	    }
	    getElapsedTime() {
	        return this.getDelta(), this.elapsedTime;
	    }
	    getDelta() {
	        let t = 0;
	        if (this.autoStart && !this.running) return this.start(), 0;
	        if (this.running) {
	            let i = ("undefined" == typeof performance ? Date : performance).now();
	            t = (i - this.oldTime) / 1e3, this.oldTime = i, this.elapsedTime += t;
	        }
	    }
	}

	const Vt = [], Ut = [ .03, .03, .03 ], zt = [], Wt = [], qt = [], $t = fromRotationTranslation$1([], fromEuler([], 90, 0, 0), [ 0, 0, 0 ]);

	class Xt {
	    constructor(t, i) {
	        this.H = t, this.i = i, this.s();
	    }
	    s() {
	        const t = this.i.getRenderer().canvas, i = {
	            x: 0,
	            y: 0,
	            width: () => t.width,
	            height: () => t.height
	        };
	        this.gt = new ie$1({
	            vert: "#include <gl2_vert>\nattribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nuniform mat4 projMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 positionMatrix;\n#include <get_output>\nvoid main()\n{\n    mat4 localPositionMatrix = getPositionMatrix();\n    vec4 localPosition = getPosition(aPosition);\n    gl_Position = projMatrix * modelViewMatrix * localPositionMatrix * localPosition;\n    vTexCoord = aTexCoord;\n}",
	            frag: "#if __VERSION__ == 100\n  #ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n  #endif\n#endif\nprecision mediump float;\n#include <gl2_frag>\nprecision mediump float;\nuniform sampler2D perlinTexture;\nvarying vec2 vTexCoord;\nfloat lerp(float a, float b, float w) {\n    return a + w * (b - a);\n}\nvoid main() {\n    float snowIntense = texture2D(perlinTexture, vTexCoord).r;\n    vec3 fixedC = vec3(1.0, 1.0, 1.0);\n    float r = lerp(0.5, fixedC.x, snowIntense);\n    float g = lerp(0.5, fixedC.y, snowIntense);\n    float b = lerp(0.5, fixedC.z, snowIntense);\n    glFragColor = vec4(r, g, b, 1.0);\n    #if __VERSION__ == 100\n        gl_FragColor = glFragColor;\n    #endif\n}",
	            uniforms: [ {
	                name: "modelViewMatrix",
	                type: "function",
	                fn: function(t, i) {
	                    return multiply$5(Vt, i.viewMatrix, i.modelMatrix);
	                }
	            } ],
	            extraCommandProps: {
	                viewport: i
	            }
	        }), this.gt.version = 300, this.yt = new yt$1, this.It = this.Ft(), this.yt.setMeshes(this.It), 
	        this.renderer = new N$1(this.H);
	        const e = this.Rt();
	        e && (e.snowGroundTexture ? this.Pt(e.snowGroundTexture) : (this.Ht = this.H.texture({
	            width: 2,
	            height: 2
	        }), console.warn("should set snow ground texture.")));
	    }
	    render(t) {
	        this.Ht && this.It.material.set("perlinTexture", this.Ht);
	        const i = this.i.getMap();
	        this.Dt(i);
	        const e = {
	            projMatrix: i.projMatrix,
	            viewMatrix: i.viewMatrix,
	            cameraPosition: i.cameraPosition
	        }, s = t && t.renderTarget && t.renderTarget.fbo;
	        this.renderer.render(this.gt, e, this.yt, s), this.i.getRenderer().setCanvasUpdated();
	    }
	    Dt(t) {
	        const i = t.coordinateToPointAtRes(t.getCenter(), t.getGLRes());
	        let e = t.getGLScale() / t.getGLScale(this.St);
	        const s = set$4(Wt, e, e, e), n = multiply$4(s, Ut, s), r = identity$2(qt);
	        fromRotationTranslationScale(r, fromEuler(zt, 0, 0, 0), [ i.x, i.y, .005 ], n), 
	        multiply$5(r, r, $t), this.It.setLocalTransform(r);
	    }
	    Pt(t) {
	        const i = new Image;
	        i.onload = () => {
	            this.Ht = this.H.texture({
	                mag: "linear",
	                min: "linear mipmap nearest",
	                wrapS: "repeat",
	                wrapT: "repeat",
	                data: i
	            });
	        }, i.onerror = t => {
	            console.log(t);
	        }, i.src = this.Nt = t;
	    }
	    Ft() {
	        const t = this.i.getMap();
	        this.St = t.getZoom();
	        const i = 16e3 * Math.pow(2, 16.685648411389433 - this.St), e = [ -i, 0, -i, i, 0, -i, -i, 0, i, i, 0, i ], s = {};
	        s.POSITION = e, s.NORMAL = [ 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0 ], s.TEXCOORD_0 = [ 0, 0, 1, 0, 0, 1, 1, 1 ];
	        const n = new Q$1(s, [ 3, 1, 0, 0, 2, 3 ], 0, {
	            positionAttribute: "POSITION",
	            normalAttribute: "NORMAL",
	            uv0Attribute: "TEXCOORD_0"
	        });
	        n.generateBuffers(this.H);
	        const r = new tt$1({
	            perlinTexture: this.H.texture({
	                with: 2,
	                height: 2
	            })
	        });
	        return new ft$1(n, r);
	    }
	    getMeshes() {
	        return this.It;
	    }
	    dispose() {
	        this.It && (this.It.geometry.dispose(), this.It.material && this.It.material.dispose(), 
	        this.It.dispose(), delete this.It), this.gt && (this.gt.dispose(), delete this.gt);
	    }
	    update() {
	        const t = this.Rt();
	        t && t.snowGroundTexture === !this.Nt && this.Pt(t.snowGroundTexture);
	    }
	    isEnable() {
	        const t = this.xt();
	        return t && t.enable;
	    }
	    Rt() {
	        const t = this.i.getWeatherConfig();
	        return t && t.snow;
	    }
	}

	const Yt = [];

	class Jt {
	    constructor(t, i, e) {
	        this.H = t, this.i = i, this.Gt = e, this.s();
	    }
	    s() {
	        this.renderer = new N$1(this.H);
	        const t = this.i.getRenderer(), i = this.jt = {
	            x: 0,
	            y: 0,
	            width: () => t.canvas ? t.canvas.width : 1,
	            height: () => t.canvas ? t.canvas.height : 1
	        };
	        this.Bt = i.width, this.Vt = i.height, this.Ut = this.H.framebuffer({
	            color: this.H.texture({
	                width: t.canvas ? t.canvas.width : 1,
	                height: t.canvas ? t.canvas.height : 1,
	                wrap: "clamp",
	                mag: "linear",
	                min: "linear"
	            }),
	            depth: !0
	        }), this.EMPTY_TEXTURE = this.H.texture({
	            with: 2,
	            height: 2
	        }), this.zt = new jt(this.H, this.i), this.Wt = new qe(this.H, i), 
	        this.qt = new Xt(this.H, this.i), this.$t = new Be(this.H, i), this.Xt = new Ge, 
	        this.Xt.version = 300;
	    }
	    getMap() {
	        return this.i && this.i.getMap();
	    }
	    renderScene(t) {
	        this.renderSnowMask(t), this.renderRain(t);
	    }
	    renderRain(t) {
	        this.isEnableRain() && this.zt.paint(t);
	    }
	    renderSnowMask(t) {
	        if (!this.isEnableSnow()) return;
	        const i = this.getMap();
	        this.qt.render(t, i);
	    }
	    paint(t, i) {
	        if (!i || !i.length) return t;
	        this.Yt();
	        const e = this.i.getWeatherConfig(), s = {};
	        if (this.isEnableRain() ? (s.ripplesMap = this.Jt(), this.Xt.shaderDefines.HAS_RAIN = 1) : delete this.Xt.shaderDefines.HAS_RAIN, 
	        this.isEnableSnow() ? (this.Xt.shaderDefines.HAS_SNOW = 1, i.forEach(t => {
	            t.defines.HAS_SNOW = 1;
	        })) : (delete this.Xt.shaderDefines.HAS_SNOW, i.forEach(t => {
	            delete t.defines.HAS_SNOW;
	        })), this.isEnableFog()) {
	            const t = e.fog;
	            s.fogColor = t.color || [ .9, .9, .9 ], this.Xt.shaderDefines.HAS_FOG = 1;
	        } else delete this.Xt.shaderDefines.HAS_FOG;
	        return this.Xt.setDefines(this.Xt.shaderDefines), s.mixFactorMap = this.Kt(i) || this.EMPTY_TEXTURE, 
	        s.sceneMap = t, s.time = this.Zt() / 1e3, s.resolution = set(Yt, this.Ut.width, this.Ut.height), 
	        this.renderer.render(this.Xt, s, null, this.Ut), this.Ut;
	    }
	    Kt(t) {
	        const i = {}, e = this.getMap(), s = e.getZoom(), n = Math.pow(2, 16.685648411389433 - s), r = this.i.getWeatherConfig().fog;
	        if (!r) return;
	        const h = r.start || .1, o = r.end || 100;
	        i.projMatrix = e.projMatrix, i.viewMatrix = e.viewMatrix, i.cameraPosition = e.cameraPosition, 
	        i.fogDist = [ h * n, o * n ];
	        return this.$t.render(t, i);
	    }
	    Jt() {
	        const t = this.getMap(), i = this.i.getWeatherConfig(), e = i.rain.rippleRadius || 24, s = {};
	        s.projMatrix = t.projMatrix, s.viewMatrix = t.viewMatrix, s.time = this.Zt() / 1e3, 
	        s.rippleRadius = e, s.density = i.rain.density || 2e3;
	        return this.Wt.render(t, s);
	    }
	    Zt() {
	        if (!this.i) return 0;
	        return this.i.getRenderer().getFrameTime();
	    }
	    isEnable() {
	        const t = this.i.getWeatherConfig();
	        return t && t.enable;
	    }
	    isEnableRain() {
	        const t = this.i.getWeatherConfig();
	        return t && t.enable && t.rain && t.rain.enable;
	    }
	    isEnableFog() {
	        const t = this.i.getWeatherConfig();
	        return t && t.enable && t.fog && t.fog.enable;
	    }
	    isEnableSnow() {
	        const t = this.i.getWeatherConfig();
	        return t && t.enable && t.snow && t.snow.enable;
	    }
	    Qt() {
	        return this.isEnableRain() || this.isEnableFog() || this.isEnableSnow();
	    }
	    update() {
	        this.isEnableRain() && (this.zt = this.zt || new jt(this.H, this.i), this.zt.update()), 
	        this.isEnableSnow() && (this.qt = this.qt || new Xt(this.H, this.i), this.qt.update());
	    }
	    getShadowMeshes() {
	        return this.qt.getMeshes();
	    }
	    Yt() {
	        const t = this.Bt(), i = this.Vt();
	        !this.Ut || this.Ut.width === t && this.Ut.height === i || this.Ut.resize(t, i);
	    }
	    dispose() {
	        this.Ut && this.Ut.destroy(), this.Xt && (this.Xt.dispose(), delete this.Xt), this.zt && (this.zt.dispose(), 
	        delete this.zt), this.qt && (this.qt.dispose(), delete this.qt);
	    }
	}

	const Kt = [], Zt = t => !!t.bloom, Qt = t => !!t.ssr;

	class ti {
	    constructor(t, i, e) {
	        this.H = t, this.i = i, this.ti = new N$1(t), this.ii = new me, 
	        this.ei = new Me(this.ti, e), this.si = new He, this.ni = new Ie(this.H);
	    }
	    setContextIncludes() {}
	    bloom(t, i, e, s, n, r, h) {
	        this.ri || (this.ri = new Oe(this.H));
	        const o = this.i.getRenderer().hi(this.oi);
	        return this.ri.render(t, o, s, n, r, i, e, h);
	    }
	    drawBloom(t) {
	        const i = this.i.getRenderer(), e = this.H, s = this.oi;
	        if (s) {
	            const {width: i, height: n} = t;
	            s.width === i && s.height === n || s.resize(i, n), e.clear({
	                color: [ 0, 0, 0, 0 ],
	                framebuffer: s
	            });
	        } else {
	            const i = this.ai(t);
	            this.oi = e.framebuffer(i);
	        }
	        const n = i.getFrameTime(), r = i.getFrameEvent(), h = i.getFrameContext(), o = h.renderMode, a = h.sceneFilter, l = h.renderTarget;
	        h.renderMode = "default", h.sceneFilter = Zt, h.renderTarget = {
	            fbo: this.oi,
	            getFramebuffer: ii,
	            getDepthTexture: ei
	        };
	        const c = i.glCtx;
	        return c.resetDrawCalls(), r ? i.forEachRenderer(t => {
	            i.clearStencil(t, s), t.drawOnInteracting(r, n, h);
	        }) : i.forEachRenderer(t => {
	            i.clearStencil(t, s), t.draw(n, h);
	        }), h.renderMode = o, h.sceneFilter = a, h.renderTarget = l, c.getDrawCalls();
	    }
	    genSsrMipmap(t, i) {
	        const e = this.i.getMap().projViewMatrix;
	        this.ni.genMipMap(t, i, e);
	    }
	    getPrevSsrProjViewMatrix() {
	        return this.ni && this.ni.getPrevProjViewMatrix();
	    }
	    drawSSR(t, i, e) {
	        e && this.ni.copyDepthTex(t);
	        const s = this.i.getRenderer(), n = s.getFrameTime(), r = s.getFrameEvent(), h = s.getFrameContext();
	        h.ssr = this.getSSRContext();
	        const o = h.renderMode, a = h.sceneFilter;
	        h.renderMode = "default", h.sceneFilter = Qt, h.renderTarget.fbo = i;
	        const l = s.glCtx;
	        let c = !1;
	        r ? s.forEachRenderer(t => {
	            s.clearStencil(t, i), c || (l.resetDrawCalls(), c = !0), t.drawOnInteracting(r, n, h);
	        }) : s.forEachRenderer(t => {
	            s.clearStencil(t, i), c || (l.resetDrawCalls(), c = !0), t.draw(n, h);
	        });
	        const u = s.drawGround();
	        return delete h.ssr, h.renderMode = o, h.sceneFilter = a, this.li = l.getDrawCalls() > 0, 
	        u;
	    }
	    getSSRUniforms() {
	        const t = this.i.ct(), i = t && t.postProcess, e = this.i.getMap();
	        return this.ni.getSSRUniforms(e, i.ssr.factor, i.ssr.quality);
	    }
	    getSSRContext() {
	        const t = this.i.ct(), i = t && t.postProcess, e = this.i.getMap(), s = this.ni.getSSRUniforms(e, i.ssr.factor, i.ssr.quality);
	        if (!s) return null;
	        return {
	            renderUniforms: s,
	            defines: {
	                "HAS_SSR": 1
	            }
	        };
	    }
	    taa(t, i, {projMatrix: e, needClear: s}) {
	        const n = this.ei;
	        return {
	            outputTex: n.render(t, i, e, s),
	            redraw: n.needToRedraw()
	        };
	    }
	    isTaaNeedRedraw() {
	        return this.ei.needToRedraw();
	    }
	    ssao(t, i, e) {
	        return this.ci || (this.ci = new xe(this.ti), this.i.getRenderer().setToRedraw()), 
	        this.ci.render({
	            projMatrix: e.projMatrix,
	            cameraNear: e.cameraNear,
	            cameraFar: e.cameraFar,
	            bias: e.ssaoBias,
	            radius: e.ssaoRadius,
	            intensity: e.ssaoIntensity,
	            quality: .6
	        }, t, i);
	    }
	    fxaa(t, i, e, s, n, r, h, o, a, l, u, f, d, p, g, m) {
	        !t || t.width === i.fbo && t.height === i.height || t.resize(i.width, i.height);
	        const v = {};
	        n ? v.HAS_TAA_TEX = 1 : delete v.HAS_TAA_TEX, r ? v.HAS_FXAA_TEX = 1 : delete v.HAS_FXAA_TEX, 
	        f ? v.HAS_OUTLINE_TEX = 1 : delete v.HAS_OUTLINE_TEX, e ? v.HAS_NOAA_TEX = 1 : delete v.HAS_NOAA_TEX, 
	        s ? v.HAS_POINT_TEX = 1 : delete v.HAS_POINT_TEX, this.ii.setDefines(v), this.ti.render(this.ii, {
	            textureSource: i,
	            noAaTextureSource: e,
	            pointTextureSource: s,
	            taaTextureSource: n,
	            fxaaTextureSource: r,
	            resolution: set(Kt, i.width, i.height),
	            enableFXAA: h,
	            enableToneMapping: o,
	            enableSharpen: a,
	            pixelRatio: l,
	            sharpFactor: u,
	            textureOutline: f,
	            highlightFactor: d,
	            outlineFactor: p,
	            outlineWidth: g,
	            outlineColor: m
	        }, null, t);
	    }
	    renderFBOToScreen(t, i, e, s) {
	        this.ui || (this.ui = []), this.ui[0] = t.width, this.ui[1] = t.height;
	        const n = this.i.getRenderer();
	        this.ti.render(this.si, {
	            texture: t.color && n.hi(t) || t,
	            size: this.ui,
	            enableSharpen: +!!i,
	            sharpFactor: e,
	            pixelRatio: s
	        });
	    }
	    postprocess(t, i, e) {
	        this.fi || (this.fi = new be);
	        const s = this.i.getRenderer(), n = e || s.hi(t);
	        return i.resolution = set(Kt, n.width, n.height), i.textureSource = n, i.timeGrain = performance.now(), 
	        this.ti.render(this.fi, i), this.di;
	    }
	    dispose() {
	        this.oi && (this.oi.destroy(), delete this.oi), this.ei && (this.ei.dispose(), delete this.ei), 
	        this.ci && (this.ci.dispose(), delete this.ci), this.ri && (this.ri.dispose(), delete this.ri), 
	        this.fi && (this.fi.dispose(), delete this.fi), this.ii && (this.ii.dispose(), delete this.ii), 
	        this.si && (this.si.dispose(), delete this.si);
	    }
	    ai(t, i) {
	        const {width: e, height: s} = this.i.getRenderer().canvas, n = this.H;
	        let r;
	        r = this.i.getRenderer().pi() ? n.renderbuffer({
	            width: e,
	            height: s,
	            samples: this.i.options.multiSamples,
	            format: "rgba8"
	        }) : n.texture({
	            min: "nearest",
	            mag: "nearest",
	            format: i || "rgba",
	            width: e,
	            height: s
	        });
	        const h = {
	            width: e,
	            height: s,
	            colors: [ r ]
	        };
	        return t && (h.depthStencil = t), h;
	    }
	}

	function ii(t) {
	    return t._framebuffer.framebuffer;
	}

	function ei(t) {
	    return t.depthStencil._texture.texture;
	}

	class si extends de {
	    constructor(t) {
	        super({
	            vert: "#if __VERSION__ == 300\n\t#define attribute in\n\t#define varying out\n#endif\nattribute vec2 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main()\n{\n  gl_Position = vec4(aPosition, 0., 1.);\n  vTexCoord = aTexCoord;\n}",
	            frag: "#if __VERSION__ == 100\n  #ifdef GL_OES_standard_derivatives\n    #extension GL_OES_standard_derivatives : enable\n  #endif\n#endif\nprecision mediump float;\n#include <gl2_frag>\nvarying vec2 vTexCoord;\n#ifdef HAS_FLOODANALYSE\n    uniform vec3 flood_waterColor;\n    uniform float flood_waterOpacity;\n    uniform sampler2D floodMap;\n#endif\n#ifdef HAS_SKYLINE\n    uniform sampler2D skylineMap;\n#endif\n#ifdef HAS_VIEWSHED\n    uniform vec4 viewshed_visibleColor;\n    uniform vec4 viewshed_invisibleColor;\n    uniform sampler2D viewshedMap;\n#endif\n#ifdef HAS_INSIGHT\n    uniform vec4 insight_visibleColor;\n    uniform vec4 insight_invisibleColor;\n    uniform sampler2D insightMap;\n#endif\n#ifdef HAS_CUT\n    uniform sampler2D meshesMap;\n    uniform sampler2D invisibleMap;\n#endif\n#ifdef HAS_EXCAVATE\n    uniform sampler2D excavateMap;\n#endif\n#ifdef HAS_CROSSCUT\n    uniform sampler2D crosscutMap;\n    uniform vec4 cutLineColor;\n#endif\n#ifdef HAS_HEIGHTLIMIT\n    uniform vec3 limitColor;\n    uniform sampler2D heightLimitMap;\n#endif\nuniform sampler2D sceneMap;\nvoid main() {\n    vec4 sceneColor = texture2D(sceneMap, vTexCoord);\n    glFragColor = sceneColor;\n    #ifdef HAS_VIEWSHED\n        vec4 viewshedColor = texture2D(viewshedMap, vTexCoord);\n        if (viewshedColor.r > 0.99) {\n            glFragColor = vec4(mix(viewshed_invisibleColor.rgb, sceneColor.rgb, viewshed_invisibleColor.a), sceneColor.a);\n        } else if (viewshedColor.g > 0.99) {\n            glFragColor = vec4(mix(viewshed_visibleColor.rgb, sceneColor.rgb, viewshed_visibleColor.a), sceneColor.a);\n        } else if (viewshedColor.a < 0.01) {\n            glFragColor = vec4(viewshedColor.rgb, 1.0);\n        }\n    #endif\n    #ifdef HAS_FLOODANALYSE\n        vec4 floodColor = texture2D(floodMap, vTexCoord);\n        if (floodColor.r > 0.0) {\n            glFragColor = vec4(mix(flood_waterColor, glFragColor.rgb, flood_waterOpacity), glFragColor.a);\n        }\n    #endif\n    #ifdef HAS_SKYLINE\n        vec4 skylineColor = texture2D(skylineMap, vTexCoord);\n        if (skylineColor.r > 0.0 || skylineColor.g > 0.0 || skylineColor.b > 0.0) {\n            glFragColor = skylineColor;\n        }\n    #endif\n    #ifdef HAS_INSIGHT\n        vec4 insightColor = texture2D(insightMap, vTexCoord);\n        if (insightColor.g > 0.0) {\n            glFragColor = insight_visibleColor;\n        } else if (insightColor.r > 0.0) {\n            glFragColor = insight_invisibleColor;\n        }\n    #endif\n    #ifdef HAS_CUT\n        vec4 cutColor = texture2D(invisibleMap, vTexCoord);\n        vec4 meshesMapColor = texture2D(meshesMap, vTexCoord);\n        if (cutColor.r == 1.0 && cutColor.g == 0.0 && cutColor.b == 0.0) {\n            glFragColor = meshesMapColor;\n        } else if (cutColor.r == 0.0 && cutColor.g == 1.0 && cutColor.b == 0.0) {\n            glFragColor = meshesMapColor;\n        } else if (cutColor.r == 0.0 && cutColor.g == 0.0 && cutColor.b == 1.0) {\n          glFragColor = sceneColor;\n        }\n    #endif\n    #ifdef HAS_EXCAVATE\n        vec4 excavateColor = texture2D(excavateMap, vTexCoord);\n        if (excavateColor.r == 1.0 && excavateColor.g == 0.0 && excavateColor.b == 0.0) {\n          glFragColor = sceneColor;\n        }  else {\n          glFragColor = excavateColor;\n        }\n    #endif\n    #ifdef HAS_CROSSCUT\n        vec4 crosscutColor = texture2D(crosscutMap, vTexCoord);\n        if (crosscutColor.r > 0.0) {\n            glFragColor = vec4(mix(cutLineColor.rgb, glFragColor.rgb, 0.99), glFragColor.a);\n        }\n    #endif\n    #ifdef HAS_HEIGHTLIMIT\n        vec4 heightLimitColor = texture2D(heightLimitMap, vTexCoord);\n        if (heightLimitColor.r > 0.0) {\n            glFragColor = vec4(mix(limitColor, glFragColor.rgb, 0.6), glFragColor.a);\n        }\n    #endif\n    #if __VERSION__ == 100\n        gl_FragColor = glFragColor;\n    #endif\n}",
	            extraCommandProps: {
	                viewport: t,
	                cull: {
	                    enable: !0
	                },
	                blend: {
	                    enable: !0,
	                    func: {
	                        srcRGB: "src alpha",
	                        srcAlpha: 1,
	                        dstRGB: "one minus src alpha",
	                        dstAlpha: "one minus src alpha"
	                    },
	                    equation: "add"
	                }
	            }
	        });
	    }
	}

	class ni {
	    constructor(t, i, e) {
	        this.H = t, this.i = i, this.Gt = e, this.s();
	    }
	    s() {
	        this.renderer = new N$1(this.H);
	        const t = this.i.getRenderer(), i = this.jt = {
	            x: 0,
	            y: 0,
	            width: () => t.canvas ? t.canvas.width : 1,
	            height: () => t.canvas ? t.canvas.height : 1
	        };
	        this.Ut = this.H.framebuffer({
	            color: this.H.texture({
	                width: t.canvas ? t.canvas.width : 1,
	                height: t.canvas ? t.canvas.height : 1,
	                wrap: "clamp",
	                mag: "linear",
	                min: "linear"
	            }),
	            depth: !0
	        }), this.gt = new si(i);
	    }
	    getMap() {
	        return this.i && this.i.getMap();
	    }
	    paint(t, i) {
	        if (!i && i.length) return t;
	        this.Yt();
	        const e = {}, s = this.i.gi;
	        if (!this.mi()) return t;
	        delete this.gt.shaderDefines.HAS_FLOODANALYSE, delete this.gt.shaderDefines.HAS_VIEWSHED, 
	        delete this.gt.shaderDefines.HAS_SKYLINE, delete this.gt.shaderDefines.HAS_INSIGHT, 
	        delete this.gt.shaderDefines.HAS_CUT, delete this.gt.shaderDefines.HAS_EXCAVATE, 
	        delete this.gt.shaderDefines.HAS_CROSSCUT, delete this.gt.shaderDefines.HAS_HEIGHTLIMIT;
	        for (let t = 0; t < s.length; t++) {
	            const n = s[t];
	            if (!n.isEnable()) continue;
	            const r = n.getDefines();
	            ht(this.gt.shaderDefines, r);
	            const h = this.getMap(), o = h.width, a = h.height, l = this.vi(i, n.getExcludeLayers()), c = n.renderAnalysis(l, o, a);
	            c && ht(e, c);
	        }
	        return e.sceneMap = t, this.gt.setDefines(this.gt.shaderDefines), this.renderer.render(this.gt, e, null, this.Ut), 
	        this.Ut;
	    }
	    vi(t, i) {
	        let e = [];
	        for (let s = 0; s < t.length; s++) {
	            const n = t[s].getRenderer();
	            if (n && n.getAnalysisMeshes) {
	                const r = n.getAnalysisMeshes();
	                r.forEach(e => {
	                    e.setUniform("useAnalysis", 1), i.indexOf(t[s].getId()) > -1 && e.setUniform("useAnalysis", 0);
	                }), e = e.concat(r);
	            }
	        }
	        return e;
	    }
	    Yt() {
	        const t = t$1.Util.isFunction(this.jt.width.data) ? this.jt.width.data() : this.jt.width, e = t$1.Util.isFunction(this.jt.height.data) ? this.jt.height.data() : this.jt.height;
	        !this.Ut || this.Ut.width === t && this.Ut.height === e || this.Ut.resize(t, e);
	    }
	    mi() {
	        const t = this.i && this.i.gi;
	        if (!t) return !1;
	        for (let i = 0; i < t.length; i++) if (t[i].isEnable()) return !0;
	        return !1;
	    }
	}

	const ri = [ 0, 0, 0, 0 ], hi = [ 0, 0 ], oi = t => !t.bloom && !t.ssr, ai = t => !t.bloom, li = t => !t.ssr;

	class ci extends t__namespace.renderer.CanvasRenderer {
	    setToRedraw() {
	        this.setRetireFrames(), super.setToRedraw();
	    }
	    onAdd() {
	        super.onAdd(), this.prepareCanvas();
	    }
	    updateSceneConfig() {
	        this.wi && this.wi.update(), this.bi && this.bi.update(), this._i && this._i.update(), 
	        this.setToRedraw();
	    }
	    render(...t) {
	        this.getMap() && this.layer.isVisible() && (this.forEachRenderer(t => {
	            t._replacedDrawFn || (t.draw = this.Mi(t.draw), t.drawOnInteracting = this.yi(t.drawOnInteracting), 
	            t.setToRedraw = this.xi(t.setToRedraw), t._replacedDrawFn = !0);
	        }), this.prepareRender(), this.prepareCanvas(), this.layer.Ci(), this._toRedraw = !1, 
	        this.Si("render", t), this.Ti(), this.Oi());
	    }
	    prepareCanvas() {
	        super.prepareCanvas(), this.forEachRenderer(t => {
	            t.prepareCanvas();
	        });
	    }
	    drawOnInteracting(...t) {
	        this.getMap() && this.layer.isVisible() && (this.layer.Ci(), this._toRedraw = !1, 
	        this.Si("drawOnInteracting", t), this.Ti(), this.Oi());
	    }
	    Si(t, i) {
	        this.ki = "default";
	        const e = this.hasRenderTarget(), s = this.Ai(i);
	        if (e && (this.Ei.renderTarget = this.Li()), this.bi.paint(s), this.drawGround(!0), 
	        !e) return void this.Ii("default", null, t, i, !0);
	        const n = this.glCtx, r = this.layer.ct(), h = r && r.postProcess, o = this.isSSROn(), a = this.isEnableTAA(), l = s.jitter;
	        if (s.jitter = hi, n.resetDrawCalls(), this.Ii(a ? "fxaaBeforeTaa" : "fxaa", this.Fi, t, i), 
	        this.Ri = n.getDrawCalls(), o && this.Pi.drawSSR(this.Hi(), this.Fi), a) {
	            const e = this.getMap(), r = this.Pi.isTaaNeedRedraw() || this.Di || e.getRenderer().isViewChanged();
	            s.jitter = r ? l : this.Ni.getAverage(), s.onlyUpdateDepthInTaa = !r;
	            let o = this.Gi;
	            if (o) o.width === this.Fi.width && o.height === this.Fi.height || o.resize(this.Fi.width, this.Fi.height); else {
	                const t = this.regl, i = this.ai(h, this.ji);
	                o = this.Gi = t.framebuffer(i);
	            }
	            n.resetDrawCalls(), this.Ii("taa", o, t, i), this.Bi = n.getDrawCalls(), delete s.onlyUpdateDepthInTaa, 
	            s.jitter = hi;
	            let a = this.Vi;
	            if (a) a.width === this.Fi.width && a.height === this.Fi.height || a.resize(this.Fi.width, this.Fi.height); else {
	                const t = this.regl, i = this.ai(h, this.ji);
	                a = this.Vi = t.framebuffer(i);
	            }
	            n.resetDrawCalls(), this.Ii("fxaaAfterTaa", this.Vi, t, i), this.Ui = n.getDrawCalls();
	        } else this.Gi && (this.Gi.destroy(), this.Vi.destroy(), delete this.Gi, delete this.Vi, 
	        delete this.Ui);
	        h.bloom && h.bloom.enable && (this.zi = this.Pi.drawBloom(this.ji)), 2 === o && this.Pi.drawSSR(this.Hi(), this.Fi, !0), 
	        n.resetDrawCalls(), this.Ii("noAa", this.Wi, t, i), this.qi = n.getDrawCalls(), 
	        n.resetDrawCalls(), this.Ii("point", this.$i, t, i, !0), this._i.renderScene(s), 
	        this.Xi = n.getDrawCalls();
	    }
	    Ii(t, i, e, s, n) {
	        this.ki = t;
	        const r = this.Ai(s);
	        r.renderMode = this.ki, r.renderTarget && (r.renderTarget.fbo = i), n && (r.isFinalRender = !0), 
	        this.forEachRenderer((n, r) => {
	            r.isVisible() && ("default" === t || !n.supportRenderMode && ("fxaa" === t || "fxaaAfterTaa" === t) || n.supportRenderMode && n.supportRenderMode(t)) && (this.clearStencil(n, i), 
	            n[e].apply(n, s));
	        });
	    }
	    Ai(t) {
	        let i = t[0];
	        return ui(i) || (i = t[1]), i !== this.Yi && (this.forEachRenderer((t, i) => {
	            i.isVisible() && t.needRetireFrames && t.needRetireFrames() && this.setRetireFrames();
	        }), this.Ei = this.Ji(i), this.Yi = i, this.Ki = ui(t[0]) ? null : t[0]), this.Ei;
	    }
	    Ti() {
	        if (!this.isEnableOutline()) return;
	        const t = this.Zi(), i = this.glCtx;
	        i.resetDrawCalls(), this.forEachRenderer((i, e) => {
	            e.isVisible() && i.drawOutline && i.drawOutline(t);
	        }), this.Qi = i.getDrawCalls();
	    }
	    Zi() {
	        const {width: t, height: i} = this.canvas;
	        let e = this.te;
	        if (e) t === e.width && i === e.height || e.resize(t, i); else {
	            const s = this.regl.texture({
	                width: t,
	                height: i,
	                format: "rgba4"
	            });
	            e = this.te = this.regl.framebuffer({
	                width: t,
	                height: i,
	                colors: [ s ],
	                depth: !1,
	                stencil: !1
	            });
	        }
	        return e;
	    }
	    hi(t) {
	        if (this.pi()) {
	            const i = this.ie(t);
	            return i.width !== t.width || i.height !== t.height ? i.resize(t.width, t.height) : this.regl.clear({
	                color: [ 0, 0, 0, 0 ],
	                fbo: i
	            }), i.blit(t), i.color[0];
	        }
	        return t.color[0];
	    }
	    Hi() {
	        if (this.ji.subimage) return this.ji;
	        const {width: t, height: i} = this.ji;
	        if (!this.ee) {
	            const e = this.regl, s = {
	                depthStencil: e.texture({
	                    min: "nearest",
	                    mag: "nearest",
	                    mipmap: !1,
	                    type: "depth stencil",
	                    width: t,
	                    height: i,
	                    format: "depth stencil"
	                }),
	                colors: [ e.renderbuffer({
	                    width: t,
	                    height: i,
	                    format: "rgba4"
	                }) ],
	                colorFormat: "rgba4",
	                width: t,
	                height: i
	            };
	            this.ee = e.framebuffer(s);
	        }
	        return this.ee.width === t && this.ee.height === i || this.ee.resize(t, i), this.regl.clear({
	            color: [ 0, 0, 0, 0 ],
	            depth: 1,
	            fbo: this.ee
	        }), this.ee.blit(this.Fi, 256, "nearest"), this.ee.depthStencil;
	    }
	    ie(t) {
	        if (this.se || (this.se = []), !t.ne) {
	            const i = this.re(!0, t.width, t.height), e = this.regl.framebuffer(i);
	            this.se.push(e), t.ne = e;
	        }
	        return t.ne;
	    }
	    pi() {
	        return 0 === this.regl.limits.version.indexOf("WebGL 2.0") && this.layer.options.antialias;
	    }
	    hasRenderTarget() {
	        const t = this.layer.ct(), i = t && t.postProcess;
	        return !(!i || !i.enable);
	    }
	    testIfNeedRedraw() {
	        if (this._toRedraw) return this._toRedraw = !1, !0;
	        if (this.getMap().isInteracting() && (this.wi && this.wi.isEnable() || this.bi && this.bi.isEnable())) return !0;
	        if (this._i && this._i.isEnable()) return !0;
	        const t = this.layer.he;
	        if (t) {
	            const i = t.getRenderer();
	            if (i && i.testIfNeedRedraw()) return this.oe = !0, !0;
	        }
	        const i = this.ae();
	        for (const t of i) {
	            const i = t.getRenderer();
	            if (i && i.testIfNeedRedraw()) return this.oe = !0, !0;
	        }
	        return !1;
	    }
	    isRenderComplete() {
	        const t = this.ae();
	        for (const i of t) {
	            const t = i.getRenderer();
	            if (t && !t.isRenderComplete()) return !1;
	        }
	        return !0;
	    }
	    mustRenderOnInteracting() {
	        const t = this.ae();
	        for (const i of t) {
	            const t = i.getRenderer();
	            if (t && t.mustRenderOnInteracting()) return !0;
	        }
	        return !1;
	    }
	    isCanvasUpdated() {
	        if (super.isCanvasUpdated()) return !0;
	        const t = this.ae();
	        for (const i of t) {
	            const t = i.getRenderer();
	            if (t && t.isCanvasUpdated()) return !0;
	        }
	        return !1;
	    }
	    isBlank() {
	        if (this.wi && this.wi.isEnable()) return !1;
	        if (this.bi && this.bi.isEnable()) return !1;
	        const t = this.ae();
	        for (const i of t) {
	            const t = i.getRenderer();
	            if (t && !t.isBlank()) return !1;
	        }
	        return !0;
	    }
	    createContext() {
	        const t = this.layer, i$1 = t.options.glOptions || {
	            alpha: !0,
	            depth: !0,
	            stencil: !0
	        };
	        i$1.preserveDrawingBuffer = !0, i$1.antialias = !!t.options.antialias, this.glOptions = i$1;
	        const e = this.gl = this.le(this.canvas, i$1);
	        this.ce(e), e.wrap = () => new i(this.gl), this.glCtx = e.wrap(), this.canvas.gl = this.gl, 
	        this.reglGL = e.wrap(), this.regl = p$2({
	            gl: this.reglGL,
	            attributes: i$1,
	            extensions: t.options.extensions,
	            optionalExtensions: t.options.optionalExtensions
	        }), this.gl.regl = this.regl, this.ue = [ 0, 0 ], this.wi = new xt(this.regl, this.layer), 
	        this.bi = new At(this.regl, this.layer);
	        const s = this.layer.getWeatherConfig();
	        this._i = new Jt(this.regl, t, s), this.fe = new ni(this.regl, t);
	        const n = this.layer.ct() || {}, r = n && n.postProcess, h = r && r.antialias && r.antialias.jitterRatio || .2;
	        this.Ni = new Ae(h), this.Pi = new ti(this.regl, this.layer, this.Ni), this.h = new vt(this.regl, n, this.layer);
	    }
	    ce() {
	        const t = this.layer, i = this.gl, e = t.options.extensions;
	        e && e.forEach(t => {
	            i.getExtension(t);
	        });
	        const s = t.options.optionalExtensions;
	        s && s.forEach(t => {
	            i.getExtension(t);
	        }), this.gl.clearColor(0, 0, 0, 0);
	    }
	    clearCanvas() {
	        super.clearCanvas(), this.de();
	    }
	    de() {
	        const t = this.regl;
	        this.Fi && (t.clear({
	            color: ri,
	            depth: 1,
	            stencil: 255,
	            framebuffer: this.Fi
	        }), t.clear({
	            color: ri,
	            framebuffer: this.Wi
	        }), t.clear({
	            color: ri,
	            framebuffer: this.$i
	        }), this.Gi && this.Bi && t.clear({
	            color: ri,
	            framebuffer: this.Gi
	        }), this.Vi && this.Ui && t.clear({
	            color: ri,
	            framebuffer: this.Vi
	        })), this.te && t.clear({
	            color: ri,
	            framebuffer: this.te
	        }), t.clear({
	            color: ri,
	            depth: 1,
	            stencil: 255
	        });
	    }
	    resizeCanvas() {
	        const t = this.canvas.width, i = this.canvas.height;
	        !this.Fi || this.Fi.width === t && this.Fi.height === i || (super.resizeCanvas(), 
	        this.Fi.resize(t, i), this.Wi.resize(t, i), this.$i.resize(t, i), this.Gi && this.Gi.resize(t, i), 
	        this.Vi && this.Vi.resize(t, i), this.de(), this.forEachRenderer(t => {
	            t.canvas && t.resizeCanvas();
	        }));
	    }
	    getCanvasImage() {
	        return this.forEachRenderer(t => {
	            t.getCanvasImage();
	        }), super.getCanvasImage();
	    }
	    ae() {
	        return this.layer.getLayers();
	    }
	    forEachRenderer(t) {
	        const i = this.ae();
	        for (const e of i) {
	            if (!e.isVisible() || !e.options.beneathTerrain) continue;
	            const i = e.getRenderer();
	            i && t(i, e);
	        }
	        const e = this.layer.he;
	        if (e) {
	            const i = e.getRenderer();
	            i && t(i, e);
	        }
	        for (const e of i) {
	            if (!e.isVisible() || e.options.beneathTerrain) continue;
	            const i = e.getRenderer();
	            i && t(i, e);
	        }
	    }
	    le(t, i) {
	        const e = this.layer.options.onlyWebGL1 ? [ "webgl", "experimental-webgl" ] : [ "webgl2", "webgl", "experimental-webgl" ];
	        let s = null;
	        for (let n = 0; n < e.length; ++n) {
	            try {
	                s = t.getContext(e[n], i);
	            } catch (t) {}
	            if (s) break;
	        }
	        return s;
	    }
	    clearStencil(t, i) {
	        const e = {
	            stencil: t.getStencilValue ? t.getStencilValue() : 255
	        };
	        i && (e.framebuffer = i), this.regl.clear(e);
	    }
	    onRemove() {
	        this.canvas.pickingFBO && this.canvas.pickingFBO.destroy && this.canvas.pickingFBO.destroy(), 
	        this.pe(), this.wi && (this.wi.dispose(), delete this.wi), this.bi && (this.bi.dispose(), 
	        delete this.bi), this.h && (this.h.dispose(), delete this.h), this.Pi && (this.Pi.dispose(), 
	        delete this.Pi), this.te && (this.te.destroy(), delete this.te), this._i && (this._i.dispose(), 
	        delete this._i), super.onRemove();
	    }
	    pe() {
	        if (this.Fi && (this.Fi.destroy(), this.Wi.destroy(), this.$i.destroy(), this.Gi && (this.Gi.destroy(), 
	        delete this.Gi), this.Vi && (this.Vi.destroy(), delete this.Vi), delete this.Fi, 
	        delete this.Wi, delete this.$i, this.ge && (this.ge.destroy(), delete this.ge), 
	        this.ee && (this.ee.destroy(), delete this.ee), this.se)) {
	            for (let t = 0; t < this.se.length; t++) this.se[t] && this.se[t].destroy();
	            delete this.se;
	        }
	    }
	    setRetireFrames() {
	        this.Di = !0;
	    }
	    getFrameTime() {
	        return this.Yi;
	    }
	    getFrameEvent() {
	        return this.Ki;
	    }
	    getFrameContext() {
	        return this.Ei;
	    }
	    drawGround(t) {
	        const i = this.layer.getGroundConfig();
	        if (!i || !i.enable) return !1;
	        if (!this.wi) return !1;
	        const e = this.getFrameContext(), s = e.jitter;
	        let n;
	        e.jitter = hi, e.offsetFactor = 2, e.offsetUnits = 2, t && (n = e.sceneFilter, delete e.sceneFilter);
	        const r = this.wi.paint(e);
	        return this.wi.needToRedraw() && this.setToRedraw(), n && (e.sceneFilter = n), e.jitter = s, 
	        r;
	    }
	    Mi(t) {
	        const i = this;
	        return function(e, s) {
	            return (s = s || i.Ei) && s.renderTarget && (s.renderTarget.getFramebuffer = fi, 
	            s.renderTarget.getDepthTexture = di), t.call(this, e, s);
	        };
	    }
	    yi(t) {
	        const i = this;
	        return function(e, s, n) {
	            return (n = n || i.Ei) && n.renderTarget && (n.renderTarget.getFramebuffer = fi, 
	            n.renderTarget.getDepthTexture = di), t.call(this, e, s, n);
	        };
	    }
	    xi(t) {
	        return function(...i) {
	            return t.apply(this, i);
	        };
	    }
	    isEnableSSR() {
	        const t = this.layer.ct(), i = t && t.postProcess;
	        return i && i.enable && i.ssr && i.ssr.enable;
	    }
	    isSSROn() {
	        const t = this.isEnableSSR(), i = this.getMap();
	        if (!t || i.getPitch() <= -.001) return 0;
	        const e = i.projViewMatrix, s = this.Pi.getPrevSsrProjViewMatrix();
	        return s && exactEquals$5(s, e) ? 1 : 2;
	    }
	    isEnableTAA() {
	        return !1;
	    }
	    isEnableSSAO() {
	        const t = this.layer.ct(), i = t && t.postProcess;
	        return i && i.enable && i.ssao && i.ssao.enable;
	    }
	    isEnableOutline() {
	        const t = this.layer.ct(), i = t && t.postProcess;
	        return i && i.enable && i.outline && i.outline.enable;
	    }
	    isEnableWeather() {
	        const t = this.layer.ct(), i = t && t.weather;
	        return i && i.enable;
	    }
	    me() {
	        const t = this.layer.getMap();
	        if (!this.k) {
	            this.k = {
	                center: t.getCenter(),
	                bearing: t.getBearing(),
	                pitch: t.getPitch(),
	                res: t.getResolution()
	            };
	            let i = !1;
	            if (t.options.lights) {
	                const e = t.getLightManager().getDirectionalLight().direction;
	                this.k.lightDirection = copy$4([], e), i = !0;
	            }
	            return {
	                viewChanged: !0,
	                lightDirectionChanged: i
	            };
	        }
	        const i = t.getResolution() / this.k.res, e = t.coordToContainerPoint(this.k.center), s = this.layer.options.viewMoveThreshold, n = e._sub(t.width / 2, t.height / 2).mag() > s || i < .95 || i > 1.05;
	        let r = !1;
	        if (t.options.lights) {
	            const i = t.getLightManager().getDirectionalLight().direction;
	            r = !equals$4(this.k.lightDirection, i), r && (this.k.lightDirection = copy$4([], i));
	        }
	        return n && (this.k.center = t.getCenter(), this.k.bearing = t.getBearing(), this.k.pitch = t.getPitch(), 
	        this.k.res = t.getResolution()), {
	            viewChanged: n,
	            lightDirectionChanged: r
	        };
	    }
	    Ji(t) {
	        const i = this.layer.ct(), e = i && i.postProcess, s = i && i.weather, n = {
	            timestamp: t,
	            renderMode: this.ki || "default",
	            includes: {},
	            states: this.me(),
	            testSceneFilter: t => !n.sceneFilter || n.sceneFilter(t),
	            isFinalRender: !1,
	            weather: {
	                fog: s && s.fog
	            }
	        }, r = e && e.antialias && e.antialias.jitterRatio || .2, h = this.Ni;
	        h.setRatio(r);
	        const o = this.isSSROn();
	        let a;
	        if (e && e.enable) {
	            if (this.isEnableTAA()) {
	                (this.getMap().isInteracting() || this.Di) && h.reset(), h.getJitter(this.ue), h.frame();
	            } else set(this.ue, 0, 0);
	            n.jitter = this.ue;
	            const t = e.bloom && e.bloom.enable;
	            t && o ? (n.bloom = 1, n.sceneFilter = oi) : t ? (n.bloom = 1, n.sceneFilter = ai) : o && (n.sceneFilter = li), 
	            a = this.Li(), a && (n.renderTarget = a);
	        } else this.pe();
	        return "noAa" !== this.ki && (this.ve = this.we(n), this.ve && (n.includes.shadow = 1), 
	        this.be = this._e(n)), this.ve && (n.shadow = this.ve, n.includes.shadow = 1), n.states.includesChanged = this.be, 
	        e && e.enable && this.Pi && this.Pi.setContextIncludes(n), n;
	    }
	    Me(t) {
	        const i = this.ae().filter(t => t.isVisible());
	        return this.fe.paint(t, i);
	    }
	    _e(t) {
	        let i = !1;
	        const e = Object.keys(t.includes), s = this.ye;
	        if (s) {
	            const t = e.filter(t => -1 === s.indexOf(t)).concat(s.filter(t => -1 === e.indexOf(t)));
	            t.length && (i = t.reduce((t, i) => (t[i] = 1, t), {}));
	        }
	        return this.ye = e, i;
	    }
	    we(t) {
	        const i = this.layer.ct();
	        if (!i || !i.shadow || !i.shadow.enable) return this.h && (this.h.dispose(), delete this.h), 
	        null;
	        this.h || (this.h = new vt(this.regl, this.layer.ct() || {}, this.layer));
	        const e = {
	            config: i.shadow,
	            defines: this.h.getDefines(),
	            uniformDeclares: vt.getUniformDeclares()
	        };
	        return e.renderUniforms = this.xe(t), e;
	    }
	    xe(t) {
	        const i = t.renderTarget && t.renderTarget.fbo, e = this.layer.ct(), s = [];
	        let n = t.states.lightDirectionChanged || t.states.viewChanged;
	        this.forEachRenderer((t, i) => {
	            if (!t.getShadowMeshes || !i.isVisible()) return;
	            const e = t.getShadowMeshes();
	            if (Array.isArray(e)) for (let t = 0; t < e.length; t++) e[t].needUpdateShadow && (n = !0), 
	            e[t].needUpdateShadow = !1, s.push(e[t]);
	        }), this.Ce || (this.Ce = new yt$1), this.Ce.setMeshes(s);
	        const r = this.getMap(), h = e.shadow, o = r.getLightManager().getDirectionalLight().direction, a = !e.ground || !e.ground.enable;
	        return this.h.render(a, r.projMatrix, r.viewMatrix, h.color, h.opacity, o, this.Ce, this.ue, i, n);
	    }
	    Se(t) {
	        let i = [];
	        if (this.forEachRenderer((t, e) => {
	            if (!t.getShadowMeshes || !e.isVisible()) return;
	            const s = t.getShadowMeshes();
	            i = i.concat(s);
	        }), this.wi) {
	            const t = this.wi.getRenderMeshes();
	            i = i.concat(t);
	        }
	        const e = this.layer.getWeatherConfig();
	        return this._i.paint(t, i, e);
	    }
	    Li() {
	        const t = this.layer.ct(), i = t && t.postProcess;
	        if (!this.Fi) {
	            const t = this.regl;
	            let e = this.ji;
	            (!e || !e._texture || e._texture.refCount <= 0) && (e = null);
	            const s = this.ai(i, e);
	            this.ji = s.depth || s.depthStencil, this.Fi = t.framebuffer(s);
	            const n = this.ai(i, this.ji);
	            this.Wi = t.framebuffer(n);
	            const r = this.ai(i, this.ji);
	            this.$i = t.framebuffer(r), this.de();
	        }
	        return {
	            fbo: this.Fi
	        };
	    }
	    re(t, i, e) {
	        i = i || this.canvas.width, e = e || this.canvas.height;
	        const s = this.regl, n = this.pi();
	        let r;
	        if (!t && n) r = s.renderbuffer({
	            width: i,
	            height: e,
	            samples: this.layer.options.multiSamples,
	            format: "rgba8"
	        }); else {
	            const t = "uint8";
	            r = s.texture({
	                min: "nearest",
	                mag: "nearest",
	                type: t,
	                width: i,
	                height: e
	            });
	        }
	        return {
	            width: i,
	            height: e,
	            colors: [ r ],
	            colorFormat: n ? "rgba8" : "rgba"
	        };
	    }
	    ai(t, i) {
	        const {width: e, height: s} = this.canvas, n = this.regl, r = this.re(), h = this.pi(), o = n.hasExtension("WEBGL_depth_texture");
	        if (h) {
	            const t = i || n.renderbuffer({
	                width: e,
	                height: s,
	                format: "depth24 stencil8",
	                samples: this.layer.options.multiSamples
	            });
	            r.depthStencil = t;
	        } else if (o) {
	            const t = i || n.texture({
	                min: "nearest",
	                mag: "nearest",
	                mipmap: !1,
	                type: "depth stencil",
	                width: e,
	                height: s,
	                format: "depth stencil"
	            });
	            r.depthStencil = t;
	        } else {
	            const t = i || n.renderbuffer({
	                width: e,
	                height: s,
	                format: "depth stencil"
	            });
	            r.depthStencil = t;
	        }
	        return r;
	    }
	    Oi() {
	        if (!this.Fi) return void (this.Di = !1);
	        const t = this.layer.ct(), i = t && t.postProcess;
	        if (!i || !i.enable) return;
	        this.layer.fire("postprocessstart");
	        const e = this.layer.getMap();
	        let s;
	        if (this.isEnableTAA()) {
	            const t = this.Di || e.getRenderer().isViewChanged();
	            t && this.layer.fire("taastart");
	            const {outputTex: i, redraw: n} = this.Pi.taa(this.hi(this.Gi), this.Hi(), {
	                projMatrix: e.projMatrix,
	                needClear: t
	            });
	            s = i, n ? this.setToRedraw() : this.layer.fire("taaend"), this.Di = !1;
	        }
	        let n = i.sharpen && i.sharpen.factor;
	        n || 0 === n || (n = .2);
	        let r = 0, h = .2, o = .3, a = 1, l = [ 1, 1, 0 ];
	        i.outline && (r = +!!i.outline.enable, h = pi(i.outline, "highlightFactor", h), 
	        o = pi(i.outline, "outlineFactor", o), a = pi(i.outline, "outlineWidth", a), l = pi(i.outline, "outlineColor", l));
	        const c = this.isEnableSSAO(), u = i.ssr && i.ssr.enable, f = i.bloom && i.bloom.enable, d = f && this.zi, p = +!(!i.antialias || !i.antialias.enable), g = this.fe.mi(), m = this._i.Qt(), v = c || f || u || g || m;
	        let w = this.ge;
	        if (v) {
	            if (!w) {
	                const t = this.re();
	                this.pi() && (t.depthStencil = this.regl.renderbuffer({
	                    width: this.canvas.width,
	                    height: this.canvas.height,
	                    samples: this.layer.options.multiSamples,
	                    format: "depth24 stencil8"
	                })), w = this.ge = this.regl.framebuffer(t);
	            }
	            const {width: t, height: i} = this.canvas;
	            w.width === t && w.height === i || w.resize(t, i);
	        } else w = null, this.ge && (this.ge.destroy(), delete this.ge);
	        let b = this.hi(this.Fi);
	        const _ = this.qi && this.hi(this.Wi), M = this.Xi && this.hi(this.$i);
	        if (this.Pi.fxaa(w, b, !d && _, !d && M, s, this.Ui && this.Vi && this.hi(this.Vi), p, +!(!i.toneMapping || !i.toneMapping.enable), +!(v || !i.sharpen || !i.sharpen.enable), e.getDevicePixelRatio(), n, r && this.Qi > 0 && this.Zi(), h, o, a, l), 
	        w && (b = this.hi(w)), c && (this.Ui || this.Bi || this.Ri) && (b = this.Pi.ssao(b, this.Hi(), {
	            projMatrix: e.projMatrix,
	            cameraNear: e.cameraNear,
	            cameraFar: e.cameraFar,
	            ssaoBias: i.ssao && i.ssao.bias || 10,
	            ssaoRadius: i.ssao && i.ssao.radius || 100,
	            ssaoIntensity: i.ssao && i.ssao.intensity || .5
	        })), f && this.zi) {
	            const t = i.bloom, e = +t.threshold || 0, s = pi(t, "factor", 1), n = pi(t, "radius", 1);
	            b = this.Pi.bloom(b, _, M, e, s, n, p);
	        }
	        if (u && (this.Pi.genSsrMipmap(b, this.Hi()), this.oe)) {
	            const t = this.Di;
	            this.setToRedraw(), this.Di = t, this.oe = !1;
	        }
	        this.fe && (b = this.Me(b)), this.isEnableWeather() && (b = this.Se(b)), v && this.Pi.renderFBOToScreen(b, +!(!i.sharpen || !i.sharpen.enable), n, e.getDevicePixelRatio()), 
	        this.layer.fire("postprocessend");
	    }
	}

	function ui(t) {
	    return "number" == typeof t && !isNaN(t);
	}

	function fi(t) {
	    return t._framebuffer.framebuffer;
	}

	function di(t) {
	    return t.depthStencil._texture.texture;
	}

	function pi(t, i, e) {
	    return null == t[i] ? e : t[i];
	}

	class gi extends t__namespace.worker.Actor {
	    constructor(t) {
	        super("@maptalks/terrain"), this.mapId = t;
	    }
	    checkUrl(i) {
	        return i && t__namespace.Util.isString(i) ? t__namespace.Util.getAbsoluteURL(i) : i;
	    }
	    fetchTerrain(t, i, e) {
	        t = this.checkUrl(t);
	        const s = {
	            actorId: this.actorId,
	            mapId: this.mapId,
	            command: "fetchTerrain",
	            params: {
	                url: t,
	                origin: location.origin,
	                terrainWidth: i.terrainWidth,
	                type: i.type,
	                accessToken: i.accessToken,
	                error: i.error,
	                maxAvailable: i.maxAvailable
	            }
	        };
	        this.send(s, null, (t, i) => {
	            t ? e(t) : e(t, i);
	        });
	    }
	    abortTerrain(t, i) {
	        const e = {
	            actorId: this.actorId,
	            mapId: this.mapId,
	            command: "abortTerrain",
	            params: {
	                url: t
	            }
	        };
	        this.broadcast(e, null, i);
	    }
	    addLayer(t, i, e) {
	        const s = {
	            actorId: this.actorId,
	            mapId: this.mapId,
	            layerId: t,
	            command: "addLayer",
	            params: {}
	        };
	        this.broadcast(s, null, e);
	    }
	    createTerrainMesh(t, i) {
	        const e = {
	            actorId: this.actorId,
	            command: "createTerrainMesh",
	            params: t
	        };
	        this.send(e, [ t.terrainHeights.data.buffer ], (t, e) => {
	            t ? i(t) : i(t, e);
	        });
	    }
	    removeLayer(t, i, e) {
	        const s = {
	            mapId: this.mapId,
	            layerId: t,
	            command: "removeLayer"
	        };
	        this.broadcast(s, null, e);
	    }
	}

	const mi = [];

	function vi(t, i, e, s, n, r, h) {
	    if ((s -= h) <= 0) return mi;
	    let o = t.options.tileSize;
	    Array.isArray(o) && (o = o[0]);
	    const a = t._getTileOffset(s), l = n[0] - a[0], c = a[1] - n[1];
	    let u, f;
	    if (l || c) {
	        const i = t._getTileConfig();
	        u = i.tileSystem.scale.x, f = i.tileSystem.scale.x;
	    }
	    let d = 0, p = 0, g = r /= Math.pow(2, h), m = r;
	    if (l < 0 ? g += u * Math.ceil(-l / o - 1e-7) : l > 0 && (d -= u * Math.ceil(l / o - 1e-7)), 
	    c > 0 ? p -= f * Math.ceil(c / o - 1e-7) : c < 0 && (m += f * Math.ceil(-c / o - 1e-7)), 
	    0 === d && 0 === p && g <= 1 && m <= 1) {
	        const n = Math.floor(i * r), h = Math.floor(e * r);
	        return [ {
	            x: n,
	            y: h,
	            z: s,
	            offset: a,
	            id: t._getTileId(n, h, s)
	        } ];
	    }
	    let v = [];
	    for (let n = d; n < g; n++) for (let h = p; h < m; h++) {
	        const o = i * r + n, l = e * r + h;
	        v.push({
	            x: o,
	            y: l,
	            z: s,
	            offset: a,
	            id: t._getTileId(o, l, s)
	        });
	    }
	    return v;
	}

	function wi(t, i, e, s, n) {
	    const r = t.getRenderer().tileCache, h = Math.floor(i / 2), o = Math.floor(e / 2), a = s - 1, l = t._getTileId(h, o, a), c = r.get(l);
	    return !c && n <= 0 ? wi(t, h, o, a, n + 1) : c;
	}

	function bi(t, i, e, s) {
	    let n = t / e * s / i;
	    return n < 1 ? (n = 1 / n, n = 1 / Math.round(n)) : n = Math.round(n), n;
	}

	function _i(t, i, e) {
	    const s = t.getResolution(i), n = i - Math.log(e / s) * Math.LOG2E;
	    return {
	        zoom: n,
	        res: t.getResolution(n)
	    };
	}

	const Mi = [], yi = new t__namespace.Point(0, 0), xi = new t__namespace.Point(0, 0), Ci = new t__namespace.PointExtent(0, 0, 0, 0), Si = new t__namespace.Point(0, 0), Ti = [], Oi = new t__namespace.Point(20, 20);

	class ki extends t__namespace.renderer.TileLayerCanvasRenderer {
	    constructor(...t) {
	        super(...t), this.yt = new yt$1;
	    }
	    isDrawable() {
	        return !0;
	    }
	    consumeTile(t, i) {
	        if (t && t.mesh && !t.terrainMesh) {
	            t.terrainMesh = this.Te(i, t.mesh), i.minAltitude = t.data.min, i.maxAltitude = t.data.max;
	            const e = this.layer.tileInfoCache;
	            if (e && i.parentNodeId) {
	                const t = e.get(i.parentNodeId);
	                t && (void 0 === t.minAltitude && (t.minAltitude = i.minAltitude), void 0 === t.maxAltitude && (t.maxAltitude = i.maxAltitude));
	            }
	        }
	        super.consumeTile(t, i);
	        const e = this.getMap();
	        if (e.updateCenterAltitude && void 0 === e.centerAltitude && i.z === this.getCurrentTileZoom()) {
	            const t = e._getPrjCenter(), s = e._prjToPointAtRes(t, i.res, Si);
	            i.extent2d.contains(s) && e.updateCenterAltitude();
	        }
	    }
	    draw(t, i) {
	        this.yt.clear(), super.draw(t, i), this.Oe(i);
	    }
	    drawOnInteracting(t, i, e) {
	        this.draw(i, e);
	    }
	    drawTile(t, i) {
	        const e = this.getMap();
	        if (!t || !e || !i) return;
	        let s = this.getTileOpacity(i);
	        s *= this.layer.options.opacity || 1;
	        const n = i.terrainMesh;
	        if (n) {
	            n.setUniform("opacity", s);
	            const i = this.layer.getSkinCount();
	            if (n.properties.skinCount !== i) {
	                const t = n.defines();
	                t.SKIN_COUNT = i, n.properties.skinCount = i, n.defines = t;
	            }
	            const e = this.getCurrentTileZoom(), r = e + this.layer.options.backZoomOffset, h = !0 === this.drawingTiles && t.z > r && t.z <= e;
	            n.setUniform("depthMask", h), this.yt.addMesh(n);
	        }
	    }
	    _drawTiles(t, i, e) {
	        const s = this.layer.getSkinCount();
	        for (let n = 0; n < s; n++) {
	            for (let i = 0; i < t.length; i++) this.ke(n, t[i].info, t[i].image);
	            for (let t = 0; t < i.length; t++) this.ke(n, i[t].info, i[t].image);
	            for (let t = 0; t < e.length; t++) this.ke(n, e[t].info, e[t].image);
	        }
	        return super._drawTiles(...arguments);
	    }
	    ke(t, i, e) {
	        const s = this.getMap();
	        if (!i || !s || !e) return;
	        const n = e.terrainMesh;
	        if (n) {
	            const s = this.layer.getSkinLayer(t);
	            this.renderSkin(s, i, e, t);
	            const r = this.Ae(), h = n.getUniform("skins"), o = e.skins;
	            for (let t = 0; t < o.length; t++) h[t] = o[t] || r;
	        }
	    }
	    renderSkin(t, i, e, s) {
	        const n = t.getRenderer();
	        if (!n) return;
	        e.skins || (e.skins = []), e.skinImages || (e.skinImages = []), e.skinStatus || (e.skinStatus = []), 
	        e.skinTileIds || (e.skinTileIds = []);
	        const r = e.skinStatus[s], h = n.needToRefreshTerrainTile && n.needToRefreshTerrainTile();
	        if (!h && r) return;
	        const o = t.getSpatialReference(), {x: a, y: l, z: c, res: u, offset: f} = i, p = this.layer.getTileSize().width;
	        let g = p, m = p;
	        const {res: v, zoom: w} = _i(o, c, u), b = bi(v, t.getTileSize().width, u, g);
	        let _ = e.skinTileIds[s];
	        _ || (_ = e.skinTileIds[s] = function(t, i, e, s, n, r, h) {
	            const o = {};
	            for (let a = 0; a < h; a++) o[a + ""] = vi(t, i, e, s, n, r, a);
	            return o;
	        }(t, a, l, w, f, b, Ai));
	        const M = _[0];
	        let y = !0;
	        const x = [];
	        let C;
	        for (let i = 0; i < M.length; i++) {
	            const e = M[i].id, s = n.tileCache.get(e);
	            s ? x.push(s) : (y = !1, C || (C = wi(t, M[i].x, M[i].y, M[i].z, this.layer.options.backZoomOffset)));
	        }
	        let S, T = e.skinImages[s];
	        if (T || (k$1.isPowerOfTwo(g) || (g = k$1.floorPowerOfTwo(g)), k$1.isPowerOfTwo(m) || (g = k$1.floorPowerOfTwo(m)), 
	        T = n.createTerrainTexture(g, m), e.skinImages[s] = T), n.renderTerrainSkin(this.regl, this.layer, i, T, x, C), 
	        t.fire("renderterrainskin", {
	            tile: i,
	            skinTiles: x
	        }), T instanceof HTMLCanvasElement) {
	            const t = document.getElementById("terrain_skin_debug");
	            t && (t.width = g, t.height = m, t.getContext("2d").drawImage(T, 0, 0));
	        }
	        if (T.destroy) S = T; else {
	            const t = {
	                data: T,
	                width: g,
	                height: m,
	                flipY: !0
	            };
	            S = e.skins[s], S ? S(t) : S = this.regl.texture(t);
	        }
	        e.skins[s] = S, y && (e.skinStatus[s] = 1, h || (e.skinTileIds = [], e.skinImages[s] = null));
	    }
	    Oe(t) {
	        const i = this.q(), e = this.yt.getMeshes().sort(Ii);
	        this.yt.setMeshes(e), this.renderer.render(this.gt, i, this.yt, this.getRenderFBO(t)), 
	        e.length && !Object.keys(this.tilesLoading).length && this.layer.fire("terrainreadyandrender");
	    }
	    Te(t, i) {
	        const {positions: e, texcoords: s, triangles: n} = i, r = this.Ee(100) / 100;
	        for (let t = 2; t < e.length; t += 3) e[t] *= r;
	        const a = new Q$1({
	            POSITION: e,
	            TEXCOORD_0: s
	        }, n, 0, {
	            primitive: "triangles",
	            positionAttribute: "POSITION",
	            uv0Attribute: "TEXCOORD_0"
	        });
	        a.generateBuffers(this.regl);
	        const l = this.layer.getSkinCount(), c = new ft$1(a);
	        c.setDefines({
	            "SKIN_COUNT": l
	        });
	        const u = this.layer.getSpatialReference().getMaxZoom();
	        c.setUniform("level", u - t.z), c.properties.skinCount = l, c.properties.z = t.z;
	        const f = [], p = this.Ae();
	        for (let t = 0; t < l; t++) f[t] = p;
	        c.setUniform("skins", f);
	        const g = this.getMap(), m = this.layer.options.tileSize, v = m + 1, w = t.res / g.getGLRes();
	        let b = (m + 2) / v;
	        const {extent2d: _, offset: M} = t;
	        set$4(Mi, (_.xmin - M[0]) * w, (t.extent2d.ymax - M[1]) * w, 0);
	        const y = identity$2([]);
	        return translate$1(y, y, Mi), set$4(Ti, w * b, w * b, 1), scale$5(y, y, Ti), c.localTransform = y, 
	        c;
	    }
	    Le(t) {
	        const i = this.layer.options.maxAvailableZoom;
	        let e, s = t.z;
	        for (;s > i && t; ) e = this._findParentTile(t), s = (t = e && e.info) && t.z;
	        return e;
	    }
	    Ie(t, i) {
	        const {image: e, info: s} = t, n = e.data, r = n.width, {extent2d: h, res: o} = s, {extent2d: a, res: l} = i, c = h.getWidth(), u = h.getHeight();
	        let f = (a.xmin * l / o - h.xmin) / c * r, d = (h.ymax - a.ymax * l / o) / u * r;
	        const p = (a.xmax * l / o - h.xmin) / c * r, g = Math.ceil(p - f);
	        f = Math.floor(f), d = Math.floor(d);
	        const m = new Float32Array(g * g);
	        let v = 1 / 0, w = -1 / 0;
	        for (let t = 0; t < g; t++) for (let i = 0; i < g; i++) {
	            const e = n.data[t + f + (d + i) * r];
	            m[t + i * g] = e, e < v && (v = e), e > w && (w = e);
	        }
	        return {
	            width: g,
	            height: g,
	            data: m,
	            min: v,
	            max: w
	        };
	    }
	    loadTile(i) {
	        const e = this.layer.options.maxAvailableZoom, s = this.layer.getSpatialReference().getResolution(i.z);
	        if (e && i.z > e) {
	            const e = this.Le(i);
	            if (e) {
	                const n = this.Ie(e, i), r = {};
	                return this.workerConn.createTerrainMesh({
	                    terrainHeights: n,
	                    terrainWidth: this.layer.options.tileSize + 1,
	                    error: s
	                }, (e, s) => {
	                    if (e) {
	                        if (e.canceled) return;
	                        return console.warn(e), void this.onTileError(r, i);
	                    }
	                    t__namespace.Util.extend(r, s), this.consumeTile(r, i), this.setToRedraw();
	                }), r;
	            }
	        }
	        const n = i.url, r = {}, h = {
	            terrainWidth: this.layer.options.tileSize + 1,
	            type: this.layer.options.type,
	            accessToken: this.layer.options.accessToken,
	            error: s,
	            maxAvailable: e === i.z
	        };
	        return this.workerConn.fetchTerrain(n, h, (e, s) => {
	            if (e) {
	                if (e.canceled) return;
	                return console.warn(e), void this.onTileError(r, i);
	            }
	            t__namespace.Util.extend(r, s), this.consumeTile(r, i), this.setToRedraw();
	        }), r;
	    }
	    deleteTile(t) {
	        if (!t || !t.image) return;
	        const {image: i} = t, e = i.skins;
	        if (e && e.length) for (let t = 0; t < e.length; t++) e[t] && e[t].destroy && e[t].destroy();
	        i.terrainMesh && (i.terrainMesh.geometry.dispose(), i.terrainMesh.dispose()), delete i.skins, 
	        delete i.skinStatus, delete i.skinTileIds, delete i.terrainMesh, delete i.mesh;
	    }
	    abortTileLoading(t, i) {
	        i && i.url && this.workerConn && this.workerConn.abortTerrain(i.url), super.abortTileLoading(t, i);
	    }
	    Fe(t, i, e, s, n) {
	        const r = this.Re(i.x, i.y, n, this.layer.options.backZoomOffset);
	        if (r && r.image && r.image.data) {
	            const i = r.info.extent2d, n = r.info.res / s, h = e.x - i.xmin * n, o = i.ymax * n - e.y, a = this.Pe(r.image.data, h / (i.getWidth() * n), o / (i.getHeight() * n));
	            t[0] = a, t[1] = 1;
	        } else t[0] = null, t[1] = 0;
	        return t;
	    }
	    Re(t, i, e, s) {
	        const n = this.layer._getTileId(t, i, e);
	        let r = this.tilesInView[n] || this.tileCache.get(n);
	        return !r && s <= 0 ? this.Re(Math.floor(t / 2), Math.floor(i / 2), e - 1, s + 1) : r;
	    }
	    Pe(t, i, e) {
	        const {width: s, height: n, data: r} = t, h = Math.floor(s * i);
	        return r[Math.floor(n * e) * s + h];
	    }
	    Ee(t) {
	        const i = this.layer.getMap();
	        if (!i) return null;
	        return i.altitudeToPoint(t, i.getGLRes());
	    }
	    He(t, i, e) {
	        t || (t = {
	            tiles: {},
	            dirty: !0,
	            complete: !1
	        });
	        const s = this.layer, n = this.getCurrentTileZoom(), r = s.getSpatialReference().getResolution(n), {xmin: h, ymin: o, xmax: a, ymax: l} = i, c = s._getTileConfig();
	        yi.set(h, o).De(e);
	        const u = c._getTileNum(yi, e, !0);
	        xi.set(a, l).De(e);
	        const f = c._getTileNum(xi, e, !0), d = Math.min(u.x, f.x), p = Math.max(u.x, f.x), g = Math.min(u.y, f.y), m = Math.max(u.y, f.y), v = e / r;
	        yi.set(h, o).De(v), xi.set(a, l).De(v);
	        const w = Ci.set(yi.x, yi.y, xi.x, xi.y), b = (s.options.tileSize || 256) + 1;
	        w.Ne(w.getWidth() / b), t.array = t.array || new Float32Array(b * b);
	        const _ = t.tiles;
	        t.complete = !0, t.array.fill(0);
	        for (let i = d; i <= p; i++) for (let e = g; e <= m; e++) {
	            const s = this.layer._getTileId(i, e, n);
	            if (_[s]) continue;
	            const r = this.tileCache.get(s);
	            r ? (this.Ge(t.array, r, w, b), t.dirty = !0, _[s] = 1) : (t.dirty = t.dirty || void 0 !== t.tiles[s], 
	            t.tiles[s] && delete t.tiles[s], t.complete = !1);
	        }
	        return t;
	    }
	    Ge(t, i, e, s) {
	        const n = i.info.extent2d, r = n.intersection(e), {xmin: h, ymin: o, xmax: a, ymax: l} = r, {data: c} = i.image, u = c.width, f = e.getWidth() / s, d = Math.floor((h - e.xmin) / f), p = Math.floor((o - e.ymin) / f), g = Math.floor((a - e.xmin) / f) - d, m = Math.floor((l - e.ymin) / f) - p, v = n.getWidth() / u, w = Math.floor((h - n.xmin) / v), b = Math.floor((o - n.ymin) / v), _ = Math.floor(f / v);
	        for (let i = 0; i <= g; i++) for (let e = 0; e <= m; e++) {
	            const n = i + d + (p + e) * s;
	            let r = 0;
	            for (let t = 0; t < _; t++) for (let s = 0; s < _; s++) {
	                const n = (w + Math.floor(i * _)) * u + t + b + Math.floor(e * _) + s;
	                r += c.data[n];
	            }
	            t[n] = r / Math.max(_, 1);
	        }
	        return t;
	    }
	    onAdd() {
	        super.onAdd(), this.prepareWorker();
	    }
	    onRemove() {
	        this.workerConn && (this.workerConn.removeLayer(this.layer.getId(), t => {
	            if (t) throw t;
	        }), this.workerConn.remove(), delete this.workerConn), this.gt && (this.gt.dispose(), 
	        delete this.gt), this.je && this.je.destroy(), super.onRemove();
	    }
	    prepareWorker() {
	        const t = this.layer.getMap();
	        this.workerConn || (this.workerConn = new gi(t.id));
	        const i = this.workerConn;
	        if (!i.isActive()) return;
	        const e = this.layer.options || {}, s = this.layer.getId();
	        i.addLayer(s, e, t => {
	            if (t) throw t;
	            this.layer && (this.ready = !0, this.setToRedraw(), this.layer.fire("workerready"));
	        });
	    }
	    createContext() {
	        this.canvas.gl && this.canvas.gl.wrap ? (this.gl = this.canvas.gl.wrap(), this.regl = this.canvas.gl.regl) : this.Be(), 
	        this.je = this.regl.texture(2, 2), this.Ve = new gt$1(this.je), this.renderer = new N$1(this.regl), 
	        this.Ue();
	    }
	    Be() {
	        const t = this.layer, i = t.options.glOptions || {
	            alpha: !0,
	            depth: !0,
	            antialias: this.layer.options.antialias
	        };
	        i.preserveDrawingBuffer = !0, i.stencil = !0, this.glOptions = i, this.gl = this.gl || this.le(this.canvas, i), 
	        this.regl = regl.exports.createREGL({
	            gl: this.gl,
	            attributes: i,
	            extensions: [ "OES_element_index_uint" ],
	            optionalExtensions: t.options.glExtensions
	        });
	    }
	    le(t, i) {
	        const e = [ "webgl", "experimental-webgl" ];
	        let s = null;
	        for (let n = 0; n < e.length; ++n) {
	            try {
	                s = t.getContext(e[n], i);
	            } catch (t) {}
	            if (s) break;
	        }
	        return s;
	    }
	    resizeCanvas(t) {
	        this.canvas && super.resizeCanvas(t);
	    }
	    clearCanvas() {
	        this.canvas && super.clearCanvas();
	    }
	    Ae() {
	        return this.je;
	    }
	    Ue() {
	        const t = this.layer.getMap();
	        this.ze = {
	            "projViewMatrix": t.projViewMatrix
	        };
	        const i = this.layer.getSkinCount(), e = [], s = {
	            viewport: {
	                x: 0,
	                y: 0,
	                width: () => this.canvas ? this.canvas.width : 1,
	                height: () => this.canvas ? this.canvas.height : 1
	            },
	            stencil: {
	                enable: !1,
	                func: {
	                    cmp: () => "<=",
	                    ref: (t, i) => i.level
	                },
	                op: {
	                    fail: "keep",
	                    zfail: "keep",
	                    zpass: "replace"
	                }
	            },
	            cull: {
	                enable: !0,
	                face: "back"
	            },
	            depth: {
	                enable: !0,
	                mask: (t, i) => this.layer.options.depthMask && i.depthMask,
	                func: this.layer.options.depthFunc || "<="
	            },
	            blend: {
	                enable: !0,
	                func: {
	                    src: this.layer.options.blendSrc,
	                    dst: this.layer.options.blendDst
	                },
	                equation: "add"
	            }
	        };
	        this.gt = new ie$1({
	            vert: "#define SHADER_NAME TERRAIN_SKIN\nattribute vec3 aPosition;\nattribute vec2 aTexCoord;\nuniform mat4 projViewModelMatrix;\nvarying vec2 vUv;\nvoid main() {\n    gl_Position = projViewModelMatrix * vec4(aPosition, 1.0);\n    vUv = aTexCoord;\n}",
	            frag: "#define SHADER_NAME TERRAIN_SKIN\nprecision mediump float;\nuniform sampler2D skins[SKIN_COUNT];\nuniform float opacity;\nvarying vec2 vUv;\nvec4 blend(vec4 src, vec4 dst) {\n    return vec4(src.rgb * src.a + dst.rgb * (1.0 - src.a), src.a + (1.0 - src.a) * dst.a);\n}\nvoid main() {\n    vec2 uv = vec2(vUv);\n    uv.y = 1.0 - uv.y;\n    vec4 color = vec4(0.0);\n    for (int i = 0; i < SKIN_COUNT; i++) {\n        color = blend(texture2D(skins[i], uv), color);\n    }\n    gl_FragColor = color * opacity;\n}",
	            uniforms: [ {
	                name: "projViewModelMatrix",
	                type: "function",
	                fn: function(t, i) {
	                    return multiply$5(e, i.projViewMatrix, i.modelMatrix);
	                }
	            }, {
	                name: "skins",
	                type: "array",
	                length: i,
	                fn: (t, i) => i.skinTextures
	            } ],
	            extraCommandProps: s
	        });
	    }
	    getRenderFBO(t) {
	        return t && t.renderTarget && t.renderTarget.fbo;
	    }
	    q() {
	        return {
	            projViewMatrix: this.getMap().projViewMatrix
	        };
	    }
	}

	const Ai = 4;

	function Ei(t, i, e, s, n, r) {
	    const h = s.info.res / n, {info: o, image: a} = s, l = o.offset, c = a.width * h, u = a.height * h, f = o.extent2d.xmin * h, d = o.extent2d.ymax * h, p = f - i.xmin, g = i.ymax - d, m = e[0] - l[0], v = l[1] - e[1];
	    if (t.drawImage(a, p + m, g + v, c, u), r) {
	        const {x: i, y: e, z: n} = s.info;
	        Li(t, `${i}/${e}/${n}`, "yellow", 1, p + m, g + v, c, u, -18);
	    }
	}

	function Li(t, i, e, s, n, r, h, o, a = 0) {
	    t.font = "20px monospace", t.fillStyle = e, Oi.y = o - 30, t.globalAlpha = 1, t.fillText(i, Oi.x + n, Oi.y + r + a), 
	    t.globalAlpha = .6, t.strokeStyle = e, t.lineWidth = s, t.beginPath(), t.moveTo(n, r), 
	    t.lineTo(n + h, r), t.lineTo(n + h, r + o), t.lineTo(n, r + o), t.lineTo(n, r), 
	    t.stroke(), t.globalAlpha = 1;
	}

	function Ii(t, i) {
	    const e = +t.getUniform("depthMask"), s = +i.getUniform("depthMask");
	    if (e !== s) return e - s;
	    return t.getUniform("level") - i.getUniform("level");
	}

	t__namespace.renderer.TileLayerCanvasRenderer.include({
	    renderTerrainSkin(t, i, e, s, n, r) {
	        const {res: h, extent2d: o, offset: a} = e, l = i.options.debug, c = i.options.debugOutline, u = s.getContext("2d");
	        r && Ei(u, o, a, r, h, l);
	        for (let t = 0; t < n.length; t++) Ei(u, o, a, n[t], h, l);
	        if (l) {
	            const t = e.x + "/" + e.y + "/" + e.z, {width: i, height: s} = u.canvas;
	            Li(u, t, c, 6, 0, 0, i, s);
	        }
	    },
	    createTerrainTexture(t, i) {
	        const e = document.createElement("canvas");
	        return e.width = t, e.height = i, e;
	    }
	});

	const Fi = new t__namespace.Coordinate(0, 0), Ri = new t__namespace.Point(0, 0), Pi = [], Hi = [], Di = {
	    tileGrids: [],
	    count: 0
	}, Ni = "01", Gi = "1";

	class ji extends t__namespace.TileLayer {
	    getTileUrl(t, i, e) {
	        let s = super.getTileUrl(t, i, e);
	        const n = this.options.type;
	        if ("cesium" === n) {
	            i = (1 << (e -= 1)) - i - 1;
	        }
	        return "mapbox" === n ? this.options.requireSkuToken && (this.We || (this.We = this.qe()), 
	        s.indexOf("?") > -1 ? s += "&sku=" + this.We : s += "?sku=" + this.We) : "cesium" === n && (s += "?extensions=octvertexnormals-watermask-metadata&v=1.2.0"), 
	        s;
	    }
	    _getTileZoom(t) {
	        const i = this.options.maxAvailableZoom;
	        this.options.maxAvailableZoom = null;
	        const e = super._getTileZoom(t);
	        return this.options.maxAvailableZoom = i, e;
	    }
	    qe() {
	        let t = "";
	        for (let i = 0; i < 10; i++) t += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
	        return [ Gi, Ni, t ].join("");
	    }
	    setSkinLayers(t) {
	        this.$e = t;
	        const i = this.getRenderer();
	        i && i.setToRedraw();
	    }
	    getSkinTiles(i) {
	        const e = this.getRenderer();
	        if (!e) return Di;
	        const s = e.getTileGridsInCurrentFrame().tileGrids[0];
	        if (!s) return Di;
	        const n = i.getId(), r = this._getTileConfig().tileSystem.scale, h = i.getTileSize().width, o = s.tiles;
	        if (!o.length) return Di;
	        const a = i.getSpatialReference(), l = o[0].extent2d.getWidth(), c = r.x, u = r.y, f = [], d = new Set;
	        for (let e = 0; e < o.length; e++) {
	            const s = o[e], {res: r} = s, {res: p, zoom: g} = _i(a, s.z, r), m = p / r, v = bi(p, h, r, l), {extent2d: w, offset: b} = s, _ = v * s.x, M = v * s.y;
	            if (s.skinTileIds || (s.skinTileIds = {}), !s.skinTileIds[n]) {
	                const e = new Set, r = [], o = vi(i, s.x, s.y, g, b, v, 0);
	                for (let s = 0; s < o.length; s++) {
	                    let n = o[s];
	                    if (e.has(n.id)) continue;
	                    n.idx = n.x, n.idy = n.y, n.res = p, n.url = i.getTileUrl(n.x, n.y, n.z + i.options.zoomOffset);
	                    const a = c * (n.x - _) * h, l = u * (n.y - M) * h, f = w.xmin * m + a, d = w.ymax * m + l;
	                    n.extent2d = new t__namespace.PointExtent(f, d - h, f + h, d), e.add(n.id), r.push(n);
	                }
	                s.skinTileIds[n] = r;
	            }
	            const y = s.skinTileIds[n];
	            for (let t = 0; t < y.length; t++) d.has(y[t].id) || (f.push(y[t]), d.add(y[t].id));
	        }
	        return {
	            tileGrids: [ {
	                extent: s.extent,
	                tiles: f,
	                count: f.length
	            } ],
	            count: f.length
	        };
	    }
	    getSkinLayer(t) {
	        return this.getSkinLayers()[t];
	    }
	    getSkinLayers() {
	        return this.$e || Pi;
	    }
	    getSkinCount() {
	        return this.$e && this.$e.length || 0;
	    }
	    queryTerrainByProjCoord(t) {
	        const i = this.getRenderer();
	        if (!i) return 0;
	        const e = this.getMap(), s = this.getSpatialReference(), n = i.getCurrentTileZoom(), r = s.getResolution(n), h = this.options.repeatWorld, o = this._getTileConfig().getTileIndex(t, r, h), a = e._prjToPointAtRes(t, r, Ri);
	        return i.Fe(Hi, o, a, r, n);
	    }
	    queryTerrain(t) {
	        if (!this.getRenderer()) return 0;
	        const i = this.getMap().getProjection().project(t, Fi);
	        return this.queryTerrainByProjCoord(i);
	    }
	    queryTileAltitude(t, i, e) {
	        const s = this.getRenderer();
	        return s ? s.He(t, i, e) : null;
	    }
	    queryTileMesh(t, i) {
	        const e = this.getRenderer();
	        e && e.Xe(t, i);
	    }
	}

	ji.include({
	    "_getTileId": (t, i, e) => {
	        const s = Math.sqrt(Math.pow(4, e));
	        return "" + ((0 === e ? 0 : Math.pow(4, e - 1)) + t * s + i);
	    }
	}), ji.mergeOptions({
	    "forceRenderOnMoving": !0,
	    "forceRenderOnZooming": !0,
	    "forceRenderOnRotating": !0,
	    "opacity": 1,
	    "renderer": "gl",
	    "pyramidMode": 1,
	    "tileSize": 512,
	    "terrainWidth": 65,
	    "backZoomOffset": 0,
	    "depthMask": !0,
	    "blendSrc": "one",
	    "blendDst": "one minus src alpha",
	    "requireSkuToken": !0
	}), ji.registerJSONType("TerrainLayer"), ji.registerRenderer("gl", ki);

	const Bi = () => {};

	class Vi extends t__namespace.Layer {
	    static fromJSON(i) {
	        if (!i || "GroupGLLayer" !== i.type) return null;
	        const e = i.layers.map(i => t__namespace.Layer.fromJSON(i));
	        return new Vi(i.id, e, i.options);
	    }
	    constructor(t, i, e) {
	        super(t, e), this.layers = i || [], this.layers.forEach(t => {
	            if (t.getMap()) throw new Error(`layer(${t.getId()} is already added on map`);
	        }), this.Ye(), this.sortLayersByZIndex(), this.Je = {};
	    }
	    sortLayersByZIndex() {
	        if (this.layers && this.layers.length) {
	            for (let t = 0, i = this.layers.length; t < i; t++) this.layers[t].__group_gl_order = t;
	            this.layers.sort(zi);
	        }
	    }
	    setSceneConfig(t) {
	        this.options.sceneConfig = t;
	        const i = this.getRenderer();
	        return i && i.updateSceneConfig(), this;
	    }
	    getSceneConfig() {
	        return JSON.parse(JSON.stringify(this.options.sceneConfig || {}));
	    }
	    ct() {
	        return this.options.sceneConfig;
	    }
	    getGroundConfig() {
	        const t = this.ct();
	        return t ? t.ground : null;
	    }
	    getWeatherConfig() {
	        const t = this.ct();
	        return t && t.weather;
	    }
	    addLayer(t, i) {
	        if (t.getMap()) throw new Error(`layer(${t.getId()}) is already added on map`);
	        if ("gl" !== t.options.renderer) throw new Error(`layer(${t.getId()})'s renderer is canvas, not supported to be added to GroupGLLayer`);
	        void 0 === i ? this.layers.push(t) : this.layers.splice(i, 0, t), this.Ye(), this.sortLayersByZIndex();
	        const e = this.getRenderer();
	        return e ? (this.Ke(t), e.setToRedraw(), this) : this;
	    }
	    removeLayer(i) {
	        t__namespace.Util.isString(i) && (i = this.getChildLayer(i));
	        const e = this.layers.indexOf(i);
	        if (e < 0) return this;
	        i._doRemove(), this.Ze(i), delete this.Je[i.getId()], this.layers.splice(e, 1);
	        const s = this.getRenderer();
	        return s ? (s.setToRedraw(), this) : this;
	    }
	    Ci() {
	        let t = 0;
	        for (let i = 0; i < this.layers.length; i++) this.layers[i].setPolygonOffset && this.layers[i].getPolygonOffsetCount && (t += this.layers[i].getPolygonOffsetCount());
	        let i = 0;
	        for (let e = 0; e < this.layers.length; e++) this.layers[e].setPolygonOffset && this.layers[e].getPolygonOffsetCount && (this.layers[e].setPolygonOffset(i, t), 
	        i += this.layers[e].getPolygonOffsetCount());
	    }
	    getLayers() {
	        return this.layers;
	    }
	    toJSON() {
	        const t = [];
	        if (this.layers) for (let i = 0; i < this.layers.length; i++) {
	            const e = this.layers[i];
	            e && (e && e.toJSON && t.push(e.toJSON()));
	        }
	        return {
	            "type": this.getJSONType(),
	            "id": this.getId(),
	            "layers": t,
	            "options": this.config()
	        };
	    }
	    onLoadEnd() {
	        this.layers.forEach(t => {
	            this.Ke(t);
	        }), this.options.terrain && this.Qe(), super.onLoadEnd();
	    }
	    Ke(t) {
	        const i = this.getMap();
	        this.Je[t.getId()] = t, t._canvas = this.getRenderer().canvas, t._bindMap(i), t.once("renderercreate", this.ts, this), 
	        t.once("remove", t => {
	            this.removeLayer(t.target);
	        }), t.load(), this.es(t);
	    }
	    onRemove() {
	        this.ss(), this.layers.forEach(t => {
	            this.ns(t), t._doRemove(), this.Ze(t);
	        }), this.Je = {}, this.clearAnalysis(), super.onRemove();
	    }
	    getChildLayer(t) {
	        return this.Je[t] || null;
	    }
	    getLayer(t) {
	        return this.getChildLayer(t);
	    }
	    es(t) {
	        t.on("show hide", this.rs, this), t.on("idchange", this.hs, this);
	    }
	    Ze(t) {
	        t.off("show hide", this.rs, this), t.off("idchange", this.hs, this);
	    }
	    rs() {
	        const t = this.getRenderer();
	        t && t.setToRedraw();
	    }
	    hs(t) {
	        const i = t.new, e = t.old, s = this.getLayer(e);
	        delete this.Je[e], this.Je[i] = s;
	    }
	    ts(t) {
	        t.renderer.clearCanvas = Ui;
	    }
	    Ye() {
	        const t = {};
	        this.layers.forEach(i => {
	            const e = i.getId();
	            if (t[e]) throw new Error(`Duplicate child layer id (${e}) in the GroupGLLayer (${this.getId()})`);
	            t[e] = 1;
	        });
	    }
	    addAnalysis(t) {
	        this.gi = this.gi || [], this.gi.push(t);
	        const i = this.getRenderer();
	        i && i.setToRedraw();
	    }
	    removeAnalysis(t) {
	        if (this.gi) {
	            const i = this.gi.indexOf(t);
	            i > -1 && (this.gi.splice(i, 1), t.remove());
	        }
	        const i = this.getRenderer();
	        i && i.setToRedraw();
	    }
	    clearAnalysis() {
	        this.gi && (this.gi.forEach(t => {
	            t.remove();
	        }), this.gi = []);
	        const t = this.getRenderer();
	        t && t.setToRedraw();
	    }
	    identify(i, e = {}) {
	        const s = this.getMap(), n = this.getRenderer();
	        if (!s || !n) return [];
	        const r = s.coordToContainerPoint(new t__namespace.Coordinate(i));
	        return this.identifyAtPoint(r, e);
	    }
	    identifyAtPoint(t, i = {}) {
	        const e = i.includeInternals, s = this.getLayers(), n = i && i.childLayers || s, r = this.getMap();
	        if (!r) return [];
	        const h = ot(i.count) ? 1 : i.count;
	        let a = [];
	        for (let r = n.length - 1; r >= 0; r--) {
	            const h = n[r];
	            if (s.indexOf(h) < 0 || !h.identifyAtPoint) continue;
	            const o = h.options.geometryEvents;
	            if (e && (void 0 === o || !1 === o || 0 === o)) continue;
	            let l = h.identifyAtPoint(t, i);
	            if (!l || !l.length) continue;
	            if (i.filter && (l = l.filter(t => i.filter(t))), !l.length) continue;
	            const c = h.getId();
	            for (let t = 0; t < l.length; t++) l[t] && (l[t].layer = c);
	            a.push(...l);
	        }
	        if (i.orderByCamera) {
	            const t = r.cameraPosition;
	            a.sort((i, e) => e.point ? i.point ? dist$2(i.point, t) - dist$2(e.point, t) : 1 : -1);
	        }
	        return h && (a = a.slice(0, h)), a;
	    }
	    getTerrain() {
	        return this.options.terrain;
	    }
	    setTerrain(t) {
	        return t === this.options.terrain ? this : (this.options.terrain = t, this.getRenderer() ? (this.Qe(), 
	        this) : this);
	    }
	    Qe() {
	        const t = this.getRenderer();
	        t && t.setToRedraw();
	        const i = this.options.terrain;
	        if (this.he) {
	            const t = this.he.options;
	            if (i && t.urlTemplate === i.urlTemplate && t.spatialReference === i.spatialReference) {
	                for (const t in i) "urlTemplate" !== t && "spatialReference" !== t && this.he.config(t, i[t]);
	                return this;
	            }
	            this.os(), this.ss();
	        }
	        if (!i) return this;
	        this.he = new ji("__terrain_in_group", i), this.as(), this.he.on("tileload", this.ls, this), 
	        this.Ke(this.he), this.fire("terrainlayercreated");
	    }
	    queryTerrain(t) {
	        return this.he ? this.he.queryTerrain(t) : 0;
	    }
	    queryTerrainByProjCoord(t) {
	        return this.he ? this.he.queryTerrainByProjCoord(t) : 0;
	    }
	    as() {
	        this.cs || (this.cs = {});
	        const t = this.layers, i = [];
	        for (let e = 0; e < t.length; e++) {
	            if (!t[e]) continue;
	            const s = t[e], n = s.getRenderer();
	            n.renderTerrainSkin && (this.cs[s.getId()] = s.options.background, s.options.background = !1, 
	            s.getTiles = () => this.he.getSkinTiles(s), s.isTerrainSkin = 1, n.drawTileOnTerrain ? n.drawTile = (...t) => n.drawTileOnTerrain(...t) : n.drawTile = Bi, 
	            i.push(t[e])), n.setTerrainHelper && n.setTerrainHelper(this.he);
	        }
	        this.he.setSkinLayers(i);
	    }
	    ns(t) {
	        if (!t.isTerrainSkin) return;
	        const i = t.getRenderer();
	        if (i && delete i.drawTile, delete t.getTiles, delete t.isTerrainSkin, this.cs) {
	            const i = this.cs[t.getId()];
	            void 0 !== i ? t.options.background = i : delete t.options.background, delete this.cs[t.getId()];
	        }
	    }
	    os() {
	        const t = this.layers;
	        for (let i = 0; i < t.length; i++) t[i] && this.ns(t[i]);
	        delete this.cs;
	    }
	    ls() {
	        const t = this.getRenderer();
	        t && t.setToRedraw();
	    }
	    ss() {
	        if (this.he) {
	            const t = this.he;
	            t.off("tileload", this.ls, this), this.Ze(t), this.he._doRemove(), delete this.he, 
	            this.fire("terrainlayerremoved");
	        }
	    }
	    getTerrainLayer() {
	        return this.he;
	    }
	    _bindMap(...t) {
	        if (this.options.single) {
	            const i = t[0].getLayers();
	            for (let t = 0; t < i.length; t++) if (i[t] instanceof Vi) throw new Error("Only one GroupGLLayer is allowed in a map instance. Set options.single to false if you want to add two or more GroupGLLayers.");
	        }
	        return super._bindMap(...t);
	    }
	}

	function Ui() {}

	function zi(t, i) {
	    const e = t.getZIndex() - i.getZIndex();
	    return 0 === e ? t.__group_gl_order - i.__group_gl_order : e;
	}

	Vi.mergeOptions({
	    renderer: "gl",
	    antialias: !0,
	    extensions: [],
	    single: !0,
	    onlyWebGL1: !1,
	    optionalExtensions: [ "ANGLE_instanced_arrays", "OES_element_index_uint", "OES_standard_derivatives", "OES_vertex_array_object", "OES_texture_half_float", "OES_texture_half_float_linear", "OES_texture_float", "OES_texture_float_linear", "WEBGL_depth_texture", "EXT_shader_texture_lod", "EXT_frag_depth", "WEBGL_compressed_texture_astc", "WEBGL_compressed_texture_etc", "WEBGL_compressed_texture_etc1", "WEBGL_compressed_texture_pvrtc", "WEBGL_compressed_texture_s3tc", "WEBGL_compressed_texture_s3tc_srgb" ],
	    forceRenderOnZooming: !0,
	    forceRenderOnMoving: !0,
	    forceRenderOnRotating: !0,
	    viewMoveThreshold: 100,
	    geometryEvents: !0,
	    multiSamples: 4
	}), Vi.registerJSONType("GroupGLLayer"), Vi.registerRenderer("gl", ci), Vi.registerRenderer("canvas", null);

	class Wi {
	    constructor(t) {
	        this.us = t, this.D = new gt$1, this.onHDRLoaded = this.fs.bind(this), 
	        this.onHDRError = this.ds.bind(this);
	    }
	    getDirectionalLight() {
	        return this.Gt && this.Gt.directional || {};
	    }
	    getAmbientLight() {
	        return this.Gt && this.Gt.ambient || {};
	    }
	    getAmbientResource() {
	        return this.ps;
	    }
	    setConfig(t) {
	        const i = this.Gt;
	        this.Gt = JSON.parse(JSON.stringify(t));
	        let e = !1;
	        if (t && t.ambient && t.ambient.resource) {
	            if (!(i && i.ambient && function(t, i) {
	                if (!t.resource) return !1;
	                if (t.resource.url !== i.resource.url) return !1;
	                return !0;
	            }(i.ambient, t.ambient))) return void this.gs();
	            this.ps && (t.ambient.prefilterCubeSize !== i.ambient && i.ambient.prefilterCubeSize && this.fs(), 
	            e = !0, t.ambient.resource.sh && (this.ps.sh = t.ambient.resource.sh));
	        } else this.ms(), e = i && i.ambient && i.ambient.resource;
	        this.us.fire("updatelights", {
	            ambientUpdate: e
	        });
	    }
	    vs(t) {
	        const i = t.getLayers();
	        for (let t = 0; t < i.length; t++) {
	            const e = i[t] && i[t].getRenderer();
	            if (e && e.regl) return e.regl;
	        }
	        const e = document.createElement("canvas"), s = p$2({
	            canvas: e,
	            attributes: {
	                depth: !1,
	                stencil: !1,
	                alpha: !1
	            }
	        });
	        return s.ws = !0, s;
	    }
	    gs() {
	        const t = this.Gt.ambient.resource, i = t && t.url;
	        if (!i) return;
	        const e = [];
	        let s = 0, n = 0;
	        const r = () => {
	            n++, n >= s && this.bs(e);
	        }, h = function() {
	            throw new Error(`skybox image with url(${this.src}) failed to load, please check the image's url.`);
	        };
	        if (i.top) {
	            const {front: t, back: n, right: o, left: a, top: l, bottom: c} = i, u = [ t, n, o, a, l, c ];
	            s = u.length;
	            for (let t = 0; t < s; t++) {
	                const i = new Image;
	                i.onload = r, i.onerror = h, i.src = u[t], e[t] = i;
	            }
	        } else {
	            const i = {
	                url: t.url,
	                arrayBuffer: !0,
	                hdr: !0,
	                flipY: !0
	            };
	            this._s = new Vt$1(i, this.D), this._s.once("complete", this.onHDRLoaded), 
	            this._s.once("error", this.onHDRError);
	        }
	    }
	    dispose() {
	        this.ms();
	    }
	    fs() {
	        this._s && (this.ps = this.Ms(this._s), this.us.fire("updatelights", {
	            "ambientUpdate": !0
	        }));
	    }
	    ds() {
	        this.us.fire("hdrerror");
	    }
	    bs(t) {
	        this.ps = this.Ms(t), this.us.fire("updatelights", {
	            "ambientUpdate": !0
	        });
	    }
	    Ms(t) {
	        const i = this.Gt.ambient.resource, e = i.prefilterCubeSize || 256, s = this.vs(this.us), n = bm.PBRHelper.createIBLMaps(s, {
	            envTexture: Array.isArray(t) ? t : t.getREGLTexture(s),
	            rgbmRange: Array.isArray(t) ? 9 : t.rgbmRange,
	            ignoreSH: !!i.sh,
	            envCubeSize: e,
	            prefilterCubeSize: e,
	            format: "array"
	        });
	        if (i.sh && (n.sh = i.sh, Array.isArray(n.sh[0]))) {
	            const t = n.sh, i = [];
	            for (let e = 0; e < t.length; e++) i.push(...t[e]);
	            n.sh = i;
	        }
	        return s.ws && (delete this._s, s.destroy()), n;
	    }
	    ms() {
	        this._s && (this._s.dispose(), delete this._s), delete this.ps;
	    }
	}

	let qi, $i, Xi, Yi;

	t$1.Map.include({
	    setLights(t) {
	        return this.options.lights = t, this.ys(), this;
	    },
	    getLights() {
	        return this.options.lights;
	    },
	    ys() {
	        this.xs || (this.xs = new Wi(this)), this.xs.setConfig(this.getLights());
	    },
	    getLightManager() {
	        return this.xs ? this.xs : (this.Cs || (this.Cs = !0, console.warn("map's light config is not set, use map.setLights(config) to set lights.")), 
	        null);
	    }
	}), t$1.Map.addOnLoadHook((function() {
	    this.options.lights && this.ys();
	}));

	const Ji = {
	    color: [ 0, 0, 0, 0 ]
	}, Ki = {
	    enable: !0
	};

	t$1.Map.include({
	    setPostProcessConfig(t) {
	        return this.options.postProcessConfig = t, this;
	    },
	    getPostProcessConfig() {
	        return this.options.postProcessConfig;
	    }
	});

	const Zi = t$1.renderer.MapCanvasRenderer.prototype.drawLayerCanvas;

	t$1.renderer.MapCanvasRenderer.prototype.drawLayerCanvas = function() {
	    const t = Zi.apply(this, arguments);
	    return t && te(this, this.canvas), t;
	};

	const Qi = t$1.renderer.MapCanvasRenderer.prototype.renderFrame;

	function te(t, i) {
	    const e = t.map.getPostProcessConfig();
	    if (!e || !e.enable) return;
	    var s, n;
	    qi || (s = i.width, n = i.height, qi = document.createElement("canvas", s, n), $i = p$2({
	        canvas: qi,
	        attributes: {
	            depth: !1,
	            stencil: !1,
	            alpha: !0,
	            antialias: !1,
	            premultipliedAlpha: !1
	        }
	    }), Xi = $i.texture({
	        mag: "linear",
	        min: "linear",
	        mipmap: !1,
	        flipY: !0,
	        width: s,
	        height: n
	    }), Yi = $i.texture()), qi.width === i.width && qi.height === i.height || (qi.width = i.width, 
	    qi.height = i.height), $i.clear(Ji);
	    const r = e.filmicGrain || Ki;
	    void 0 === r.enable && (r.enable = !0);
	    const h = e.vignette || Ki;
	    void 0 === h.enable && (h.enable = !0);
	    const o = e.colorLUT || Ki;
	    void 0 === o.enable && (o.enable = !0), t.Ss || (t.Ss = {});
	    const a = t.Ss;
	    if (o.enable) {
	        const i = o.lut;
	        if (!a.lutTexture || a.lutTexture.url !== i) {
	            const e = new Image;
	            e.onload = function() {
	                const s = {
	                    data: e,
	                    min: "linear",
	                    mag: "linear"
	                }, n = a.lutTexture ? a.lutTexture.texture(s) : $i.texture(s);
	                a.lutTexture = {
	                    url: i,
	                    texture: n
	                }, t.setLayerCanvasUpdated();
	            }, e.src = i;
	        }
	    }
	    const l = {
	        "enableGrain": +!!r.enable,
	        "grainFactor": void 0 === r.factor ? .15 : r.factor,
	        "timeGrain": performance.now(),
	        "enableVignette": +!!h.enable,
	        "lensRadius": h.lensRadius || [ .8, .25 ],
	        "frameMod": 1,
	        "enableLut": +!!o.enable,
	        "lookupTable": a.lutTexture ? a.lutTexture.texture : Yi
	    };
	    (void 0).postprocess(l, Xi({
	        width: qi.width,
	        height: qi.height,
	        data: i,
	        flipY: !0,
	        mag: "linear",
	        min: "linear",
	        mipmap: !1
	    })), r.enable && t.setLayerCanvasUpdated(), t.context.drawImage(qi, 0, 0, qi.width, qi.height);
	}

	t$1.renderer.MapCanvasRenderer.prototype.renderFrame = function() {
	    const t = Qi.apply(this, arguments), i = this.map.getPostProcessConfig(), e = i && i.filmicGrain;
	    return !e || void 0 !== e.enable && !0 !== e.enable || this.setLayerCanvasUpdated(), 
	    t;
	};

	const ie = [];

	function ee(t) {
	    if (!t.properties.showOnlyTimestamp) return;
	    delete t.properties.showOnlyTimestamp;
	    const i = t.properties.oldElementsBeforeHighlight;
	    i && t.geometry.elements !== i && (t.geometry.elements.destroy(), t.geometry.setElements(i));
	}

	function se(t) {
	    if (!t.properties.highlightTimestamp) return;
	    const i = t.defines;
	    delete i.HAS_HIGHLIGHT_COLOR, delete i.HAS_HIGHLIGHT_OPACITY, t.setDefines(i), delete t.properties.highlightTimestamp;
	    const e = t.properties.oldElementsBeforeHighlight;
	    e && t.geometry.elements !== e && (t.geometry.elements.destroy(), t.geometry.setElements(t.properties.oldElementsBeforeHighlight), 
	    delete t.properties.hasInvisible), ne(t);
	}

	function ne(t) {
	    if (!t) return;
	    const {hlBloomMesh: i} = t.properties;
	    if (i) {
	        const e = i.geometry;
	        e.elements && e.elements.destroy && e.elements.destroy(), i.dispose(), delete t.properties.hlBloomMesh;
	    }
	}

	var re = Object.freeze({
	    __proto__: null,
	    clearShowOnly: ee,
	    showOnly: function(t, i, e, s, n) {
	        const {showOnlyTimestamp: r} = i.properties;
	        if (!e) return void (r && ee(i));
	        if (s === r) return;
	        i.properties.showOnlyTimestamp = s;
	        const h = e.keys(), o = [];
	        for (const t of h) {
	            if (!n.has(t)) continue;
	            const i = n.get(t);
	            i && ct(o, i);
	        }
	        i.properties.oldElementsBeforeHighlight || (i.properties.oldElementsBeforeHighlight = i.geometry.elements), 
	        i.geometry.elements !== i.properties.oldElementsBeforeHighlight && i.geometry.elements.destroy && i.geometry.elements.destroy();
	        const a = {
	            data: o,
	            primitive: i.geometry.getPrimitive()
	        };
	        i.geometry.setElements(t.elements(a)), i.geometry.generateBuffers(t);
	    },
	    clearHighlight: se,
	    highlightMesh: function(t, i, e, s, n) {
	        const {highlightTimestamp: r} = i.properties;
	        if (!e) return void (r && se(i));
	        if (s === r) return;
	        const o = i.geometry.getVertexCount();
	        let {aHighlightColor: a, aHighlightOpacity: l} = i.geometry.properties;
	        a && a.fill(0), l && l.fill(255);
	        let c = !1, f = !1;
	        const p = e.keys();
	        let g = null, m = null;
	        for (const t of p) if (n.has(t)) {
	            let i, {color: s, opacity: r, bloom: h, visible: d} = e.get(t);
	            s && (c || (a || (a = new Uint8Array(4 * o)), c = !0), i = dt(ie, s)), r = ot(r) ? 1 : r, 
	            r < 1 && (f || (l || (l = new Uint8Array(o), l.fill(255)), f = !0)), !1 === d && (m || (m = new Set), 
	            m.add(t));
	            const p = n.get(t);
	            if (p) for (let t = 0; t < p.length; t++) {
	                const e = p[t];
	                i && set$3(a.subarray(4 * e, 4 * e + 4), ...i), r < 1 && (l[e] = 255 * r), h && (g || (g = []), 
	                g.push(e));
	            }
	        }
	        const v = i.defines;
	        if (c ? (i.geometry.data.aHighlightColor ? i.geometry.updateData("aHighlightColor", a) : (i.geometry.data.aHighlightColor = a, 
	        i.geometry.generateBuffers(t)), i.geometry.properties.aHighlightColor = a, v.HAS_HIGHLIGHT_COLOR = 1) : v.HAS_HIGHLIGHT_COLOR && (i.geometry.updateData("aHighlightColor", a), 
	        delete v.HAS_HIGHLIGHT_COLOR), f ? (i.geometry.data.aHighlightOpacity ? i.geometry.updateData("aHighlightOpacity", l) : (i.geometry.data.aHighlightOpacity = l, 
	        i.geometry.generateBuffers(t)), i.geometry.properties.aHighlightOpacity = l, v.HAS_HIGHLIGHT_OPACITY = 1) : v.HAS_HIGHLIGHT_OPACITY && (i.geometry.updateData("aHighlightOpacity", l), 
	        delete v.HAS_HIGHLIGHT_OPACITY), m && m.size > 0) {
	            let e = [];
	            n.forEach((t, i) => {
	                m.has(i) || ct(e, t);
	            }), i.properties.hasInvisible = !0, i.properties.oldElementsBeforeHighlight || (i.properties.oldElementsBeforeHighlight = i.geometry.elements);
	            const s = {
	                data: e,
	                primitive: i.geometry.getPrimitive()
	            };
	            i.geometry.elements !== i.properties.oldElementsBeforeHighlight && i.geometry.elements.destroy && i.geometry.elements.destroy(), 
	            e = t.elements(s), i.geometry.setElements(e), i.geometry.generateBuffers(t);
	        } else i.properties.hasInvisible && (i.geometry.elements && i.geometry.elements.destroy && i.geometry.elements.destroy(), 
	        i.geometry.setElements(i.properties.oldElementsBeforeHighlight), delete i.properties.hasInvisible);
	        i.setDefines(v), i.properties.highlightTimestamp = s;
	        let w = i.properties.hlBloomMesh;
	        if (g && g.length) {
	            if (w) {
	                const t = copy$5(w.localTransform, i.localTransform), e = copy$5(w.positionMatrix, i.positionMatrix);
	                w.setLocalTransform(t), w.setPositionMatrix(e), i.properties.hlBloomMesh.geometry.setElements(g);
	            } else {
	                const e = new Q$1(i.geometry.data, g, 0, i.geometry.desc);
	                e.generateBuffers(t);
	                const s = i.material;
	                w = new ft$1(e, s, i.config);
	                const n = i.uniforms;
	                for (const t in n) Object.defineProperty(w.uniforms, t, {
	                    enumerable: !0,
	                    get: function() {
	                        return i.getUniform(t);
	                    }
	                });
	                const r = ht({}, i.defines);
	                r.HAS_BLOOM = 1;
	                const o = copy$5([], i.localTransform), a = copy$5([], i.positionMatrix);
	                w.setLocalTransform(o), w.setPositionMatrix(a), ht(w.properties, i.properties), 
	                ht(e.properties, i.geometry.properties), w.setDefines(r), w.bloom = 1;
	            }
	            i.properties.hlBloomMesh = w;
	        } else w && ne(i);
	    },
	    deleteHighlightBloomMesh: ne
	});

	const he = [ 0, 0, 0, 0 ];

	class oe {
	    constructor(t, i, e, s, n, r) {
	        this.renderer = new N$1(t), this.sceneConfig = i, this.i = e, this.Ts = s, 
	        this.Os = n, this.ks = r || {
	            factor: 0,
	            units: 0
	        }, this.s(), this.As = [];
	    }
	    render(t, i, e) {
	        this.Es();
	        const s = this.i.getMap();
	        this.renderer.regl.clear({
	            color: he,
	            depth: 1,
	            stencil: 255,
	            framebuffer: this.Ls
	        }), this.renderer.render(this.Is, i, t, this.Ls);
	        const n = this.i.getRenderer().canvas;
	        this.As[0] = n.width, this.As[1] = n.height;
	        const r = ht({
	            colorRamp: this.Fs,
	            inputTexture: this.Ls,
	            projViewMatrix: s.projViewMatrix,
	            textureOutputSize: this.As
	        }, i);
	        this.p(), this.renderer.render(this.Rs, r, this.P, e);
	    }
	    dispose() {
	        this.Is && (this.Is.dispose(), delete this.Is), this.Rs && (this.Rs.dispose(), delete this.Rs), 
	        this.M && (this.M.geometry.dispose(), this.M.dispose(), delete this.M, delete this.P), 
	        this.Ls && (this.Ls.destroy(), delete this.Ls);
	    }
	    Ps() {
	        const t = this.Ts;
	        let i = this.Hs, e = this.Ds;
	        e ? e.clearRect(0, 0, 256, 1) : (i = this.Hs = document.createElement("canvas"), 
	        i.width = 256, i.height = 1, e = this.Ds = i.getContext("2d"));
	        const s = e.createLinearGradient(0, 0, 256, 1);
	        for (let i = 0; i < t.length; i++) s.addColorStop(t[i][0], t[i][1]);
	        e.fillStyle = s, e.fillRect(0, 0, 256, 1), this.Fs && this.Fs.destroy();
	        const n = this.renderer.regl;
	        this.Fs = n.texture({
	            width: 256,
	            height: 1,
	            data: i,
	            min: "linear",
	            mag: "linear",
	            premultiplyAlpha: !0
	        });
	    }
	    Es() {
	        const t = this.i.getRenderer().canvas, i = Math.ceil(t.width / 4), e = Math.ceil(t.height / 4), s = this.Ls;
	        s.width === i && s.height === e || s.resize(i, e);
	    }
	    s() {
	        this.Ps(), this.Ns(), this.Gs(), this.u();
	    }
	    u() {
	        const t = new Wt$1;
	        t.generateBuffers(this.renderer.regl), this.M = new ft$1(t), this.P = new yt$1([ this.M ]);
	    }
	    p() {
	        const t = this.i.getMap(), i = xt.getGroundTransform(this.M.localTransform, t);
	        this.M.setLocalTransform(i);
	    }
	    Gs() {
	        const t = this.i.getRenderer().canvas, i = this.renderer.regl, e = i.hasExtension("OES_texture_half_float") ? "half float" : "float", s = Math.ceil(t.width / 4), n = Math.ceil(t.height / 4), r = i.texture({
	            width: s,
	            height: n,
	            type: e,
	            min: "linear",
	            mag: "linear",
	            format: "rgba"
	        });
	        this.Ls = i.framebuffer({
	            width: s,
	            height: n,
	            color: [ r ]
	        });
	    }
	    Ns() {
	        const t = this.i.getRenderer().canvas, i = this.sceneConfig.depthRange, e = {
	            viewport: {
	                x: 0,
	                y: 0,
	                width: () => t ? Math.ceil(t.width / 4) : 1,
	                height: () => t ? Math.ceil(t.height / 4) : 1
	            },
	            depth: {
	                enable: !0,
	                func: "always"
	            }
	        };
	        this.Os && (e.stencil = this.Os), this.Is = new ke({
	            extraCommandProps: e
	        }), this.Rs = new Fe({
	            x: 0,
	            y: 0,
	            width: () => t ? t.width : 1,
	            height: () => t ? t.height : 1
	        }, {
	            extraCommandProps: {
	                stencil: {
	                    enable: !1
	                },
	                depth: {
	                    enable: !0,
	                    range: i || [ 0, 1 ],
	                    func: "<="
	                },
	                polygonOffset: {
	                    enable: !0,
	                    offset: this.ks
	                },
	                scissor: {
	                    enable: !1
	                }
	            }
	        });
	    }
	}

	const ae = {
	    "clip-inside": .1,
	    "clip-outside": .2,
	    "flat-inside": .3,
	    "flat-outside": .4,
	    "color": .5
	};

	function le(t) {
	    return class extends t {
	        setMask(t) {
	            if (!t) return void this.js();
	            const i = this.getRenderer(), e = this.getMap(), s = [];
	            let h = 1 / 0, o = 1 / 0, a = -1 / 0, l = -1 / 0, c = -1 / 0, u = 1 / 0;
	            for (let i = 0; i < t.length; i++) {
	                const n = t[i], r = n.polygons;
	                for (let t = 0; t < r.length; t++) {
	                    const i = r[t], f = i.getCoordinates()[0].map(t => ce(e, t)), d = i.getSymbol(), {polygonFill: p, polygonOpacity: g} = d, m = ft([], p);
	                    m[3] = g || .6;
	                    const v = {
	                        maskColor: m,
	                        position: f,
	                        maskMode: this.Bs(n.mode),
	                        flatHeight: this.Vs(n.flatHeight) || 0,
	                        heightRange: n.heightRange ? [ this.Vs(n.heightRange[0]), this.Vs(n.heightRange[1]) ] : [ 0, 0 ]
	                    };
	                    s.push(v);
	                    const w = i.getExtent();
	                    w.xmin < h && (h = w.xmin), w.ymin < o && (o = w.ymin), w.xmax > a && (a = w.xmax), 
	                    w.ymax > l && (l = w.ymax), v.heightRange[0] < u && (u = v.heightRange[0]), v.heightRange[1] > c && (c = v.heightRange[1]), 
	                    v.flatHeight < u && (u = v.flatHeight), v.flatHeight > c && (c = v.flatHeight);
	                }
	            }
	            const {ratio: f, minHeight: d} = this.Us(s, u, c), p = new t$1.Extent(h, o, a, l), {projViewMatrix: g, mapExtent: m} = this.zs(p), v = ce(e, new t$1.Coordinate(m.xmin, m.ymin)), w = ce(e, new t$1.Coordinate(m.xmax, m.ymax)), b = [ v[0], v[1], w[0], w[1] ];
	            i ? i.setMask(s, b, g, f, d) : this.once("renderercreate", t => {
	                t.renderer.setMask(s, b, g, f, d);
	            });
	        }
	        js() {
	            const t = this.getRenderer();
	            t ? t.clearMask() : this.once("renderercreate", t => {
	                t.renderer.clearMask();
	            });
	        }
	        Us(t, i, e) {
	            const s = i, n = e, r = Math.abs(n - s);
	            if (0 === r) return {
	                ratio: 1,
	                minHeight: 0
	            };
	            const h = Math.pow(r, -1);
	            for (let i = 0; i < t.length; i++) t[i].flatHeight = (t[i].flatHeight - s) * h, 
	            t[i].heightRange[0] = (t[i].heightRange[0] - s) * h, t[i].heightRange[1] = (t[i].heightRange[1] - s) * h;
	            return {
	                ratio: h,
	                minHeight: s
	            };
	        }
	        zs(t) {
	            const i = this.getMap(), e = i.getView(), s = i.getFitZoom(t), n = t.getCenter();
	            i.setView({
	                center: n,
	                zoom: s,
	                pitch: 0,
	                bearing: 0
	            });
	            const r = i.getExtent(), o = copy$5([], i.projViewMatrix);
	            return i.setView(e), {
	                mapExtent: r,
	                projViewMatrix: o
	            };
	        }
	        Bs(t) {
	            if (!ae[t]) throw new Error("invalid mask mode type!");
	            return ae[t];
	        }
	        Vs(t = 0) {
	            const i = this.getMap(), e = i.getGLRes();
	            return i.altitudeToPoint(t, e);
	        }
	    };
	}

	function ce(t, i, e = 0) {
	    if (!(t && i instanceof t$1.Coordinate)) return null;
	    const s = t.coordinateToPointAtRes(i, t.getGLRes());
	    return [ s.x, s.y, e ];
	}

	function ue(t) {
	    return class extends t {
	        clearMask() {
	            delete this.Ws.mask_colorExtent, delete this.Ws.mask_extent, delete this.Ws.mask_modeExtent, 
	            delete this.Ws.mask_hasFlatOut, delete this.Ws.mask_hasClipOut, delete this.Ws.mask_heightRatio, 
	            delete this.Ws.mask_heightOffset, this.qs && (this.qs.dispose(), delete this.qs), 
	            this.setToRedraw();
	        }
	        setMask(t, i, e, s, n) {
	            this.viewport || (this.viewport = {
	                x: 0,
	                y: 0,
	                width: () => this.canvas ? this.canvas.width : 1,
	                height: () => this.canvas ? this.canvas.height : 1
	            }), this.qs ? this.$s(t, i, e, s, n) : this.regl ? (this.qs = new rd(this.regl, this.viewport), 
	            this.$s(t, i, e, s, n)) : this.layer.once("contextcreate", () => {
	                this.qs = new rd(this.regl, this.viewport), this.$s(t, i, e, s, n);
	            }, this);
	        }
	        $s(t, i, e, s, n) {
	            this.qs.setExtentPositions(t);
	            const {colorExtent: r, modeExtent: h} = this.qs.render(e);
	            this.Ws = this.Ws || {}, this.Ws.mask_colorExtent = r, this.Ws.mask_extent = i, 
	            this.Ws.mask_modeExtent = h, this.Ws.mask_hasFlatOut = this.Xs(t, .4), this.Ws.mask_hasClipOut = this.Xs(t, .2), 
	            this.Ws.mask_heightRatio = s, this.Ws.mask_heightOffset = n, this.setToRedraw();
	        }
	        Xs(t, i) {
	            for (let e = 0; e < t.length; e++) if (t[e].maskMode === i) return 1;
	            return 0;
	        }
	        getMaskUniforms() {
	            return this.Ws;
	        }
	        getMaskDefines() {
	            return this.Ys || (this.Ys = {}), this.Ws && this.Ws.mask_colorExtent ? this.Ys.HAS_MASK_EXTENT = 1 : delete this.Ys.HAS_MASK_EXTENT, 
	            this.Ys;
	        }
	    };
	}

	"undefined" != typeof window && window.maptalks && (window.maptalks.GroupGLLayer = Vi);

	const getGlobal = function () {
	  if (typeof self !== 'undefined') { return self; }
	  if (typeof window !== 'undefined') { return window; }
	  if (typeof global !== 'undefined') { return global; }
	  throw new Error('unable to locate global object');
	};

	const globals = getGlobal();

	const transcoders = globals['gl_trans__coders'] = globals['gl_trans__coders'] || {};

	function inject(chunk) {
	    // 奇怪的变量名是为了避免与worker源代码中的变量名冲突
	    const fnString = chunk.toString();
	    const prefixIndex = fnString.indexOf('{') + 1;
	    const prefix = fnString.substring(0, prefixIndex);

	    const transcoders = globals['gl_trans__coders'] = globals['gl_trans__coders'] || {};
	    let injected = `${prefix}
    const _____getGlobal = ${getGlobal.toString()};
    const g___lobals = _____getGlobal()
    const tran_____scoders = g___lobals['gl_trans__coders'] = g___lobals['gl_trans__coders'] || {};`;
	    for (const p in transcoders) {
	        if (p === 'inject' || p === 'getTranscoder' || p === 'registerTranscoder') {
	            continue;
	        }
	        injected += 'tran_____scoders["' + p + '"] =' + transcoders[p].toString() + '\n;';
	    }
	    injected += '\n' + fnString.substring(prefix.length);
	    return injected;
	}
	transcoders['inject'] = inject;

	function getTranscoder(name/*, options*/) {
	    return transcoders[name];
	}

	function registerTranscoder(name, fn) {
	    transcoders[name] = fn;
	}

	transcoders.registerTranscoder = registerTranscoder;
	transcoders.getTranscoder = getTranscoder;

	const e = "${"; const code = `function(r){var t="undefined"!=typeof Float32Array?Float32Array:Array;function e(){var r=new t(3);return t!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r}function i(r,e,i){var n=new t(3);return n[0]=r,n[1]=e,n[2]=i,n}function n(){var r=new t(4);return t!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0),r[3]=1,r}e(),function(){var r,e=(r=new t(4),t!=Float32Array&&(r[0]=0,r[1]=0,r[2]=0,r[3]=0),r)}();var s;e(),i(1,0,0),i(0,1,0),n(),n(),s=new t(9),t!=Float32Array&&(s[1]=0,s[2]=0,s[3]=0,s[5]=0,s[6]=0,s[7]=0),s[0]=1,s[4]=1,s[8]=1;
/*!
   * @maptalks/gltf-loader v0.27.2
   * LICENSE : UNLICENSED
   * (c) 2016-2022 maptalks.org
   */
let a=0;!function(r){r[0]=0,r[1]=0,r[2]=0,r[3]=1}([]),"undefined"!=typeof TextDecoder&&new TextDecoder("utf-8");const o={get:function(r,t={}){t||(t={});const e=new AbortController,i=e.signal,n=function(r){for(let t=1;t<arguments.length;t++){const e=arguments[t];for(const t in e)r[t]=e[t]}return r}({},t);n.signal=i,n.method||(n.method="GET");const s=fetch(r,n).then(r=>{const e=this.U(r,t.responseType);return e.message?e:e.then(e=>"arraybuffer"===t.responseType?{data:e,cacheControl:r.headers.get("Cache-Control"),expires:r.headers.get("Expires"),contentType:r.headers.get("Content-Type")}:e).catch(r=>{if(!r.code||r.code!==DOMException.ABORT_ERR)throw r})}).catch(r=>{if(!r.code||r.code!==DOMException.ABORT_ERR)throw r});return s.xhr=e,s},U:(r,t)=>200!==r.status?{status:r.status,statusText:r.statusText,message:\`incorrect http request with status code(${e}r.status}): ${e}r.statusText}\`}:"arraybuffer"===t?r.arrayBuffer():"json"===t?r.json():r.text(),getArrayBuffer:(r,t={})=>(t||(t={}),t.responseType="arraybuffer",o.get(r,t)),getJSON:function(r,t={}){return t&&t.jsonp?o.jsonp(r):((t=t||{}).responseType="json",o.get(r,t))},jsonp:function(r){const t="_maptalks_jsonp_"+a++;r.match(/\\?/)?r+="&callback="+t:r+="?callback="+t;let e=document.createElement("script");return e.type="text/javascript",e.src=r,new Promise(r=>{window[t]=function(i){document.getElementsByTagName("head")[0].removeChild(e),e=null,delete window[t],r(i)},document.getElementsByTagName("head")[0].appendChild(e)})}};if("undefined"!=typeof TextDecoder&&new TextDecoder("utf-8"),"undefined"!=typeof OffscreenCanvas){let r;try{r=new OffscreenCanvas(2,2).getContext("2d")}catch(r){}}"undefined"!=typeof document&&document.createElement("canvas"),function(){function r(r){throw r}var t=void 0,e=!0,i=this;function n(r,e){var n,s=r.split("."),a=i;!(s[0]in a)&&a.execScript&&a.execScript("var "+s[0]);for(;s.length&&(n=s.shift());)s.length||e===t?a=a[n]?a[n]:a[n]={}:a[n]=e}var s="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array&&"undefined"!=typeof DataView;function a(t,e){this.index="number"==typeof e?e:0,this.i=0,this.buffer=t instanceof(s?Uint8Array:Array)?t:new(s?Uint8Array:Array)(32768),2*this.buffer.length<=this.index&&r(Error("invalid index")),this.buffer.length<=this.index&&this.f()}a.prototype.f=function(){var r,t=this.buffer,e=t.length,i=new(s?Uint8Array:Array)(e<<1);if(s)i.set(t);else for(r=0;r<e;++r)i[r]=t[r];return this.buffer=i},a.prototype.d=function(r,t,e){var i,n=this.buffer,s=this.index,a=this.i,o=n[s];if(e&&1<t&&(r=8<t?(l[255&r]<<24|l[r>>>8&255]<<16|l[r>>>16&255]<<8|l[r>>>24&255])>>32-t:l[r]>>8-t),8>t+a)o=o<<t|r,a+=t;else for(i=0;i<t;++i)o=o<<1|r>>t-i-1&1,8==++a&&(a=0,n[s++]=l[o],o=0,s===n.length&&(n=this.f()));n[s]=o,this.buffer=n,this.i=a,this.index=s},a.prototype.finish=function(){var r,t=this.buffer,e=this.index;return 0<this.i&&(t[e]<<=8-this.i,t[e]=l[t[e]],e++),s?r=t.subarray(0,e):(t.length=e,r=t),r};var o,c=new(s?Uint8Array:Array)(256);for(o=0;256>o;++o){for(var h=u=o,f=7,u=u>>>1;u;u>>>=1)h<<=1,h|=1&u,--f;c[o]=(h<<f&255)>>>0}var l=c;function y(r){this.buffer=new(s?Uint16Array:Array)(2*r),this.length=0}function d(r){var t,e,i,n,a,o,c,h,f,u,l=r.length,y=0,d=Number.POSITIVE_INFINITY;for(h=0;h<l;++h)r[h]>y&&(y=r[h]),r[h]<d&&(d=r[h]);for(t=1<<y,e=new(s?Uint32Array:Array)(t),i=1,n=0,a=2;i<=y;){for(h=0;h<l;++h)if(r[h]===i){for(o=0,c=n,f=0;f<i;++f)o=o<<1|1&c,c>>=1;for(u=i<<16|h,f=o;f<t;f+=a)e[f]=u;++n}++i,n<<=1,a<<=1}return[e,y,d]}function A(r,t){this.h=p,this.w=0,this.input=s&&r instanceof Array?new Uint8Array(r):r,this.b=0,t&&(t.lazy&&(this.w=t.lazy),"number"==typeof t.compressionType&&(this.h=t.compressionType),t.outputBuffer&&(this.a=s&&t.outputBuffer instanceof Array?new Uint8Array(t.outputBuffer):t.outputBuffer),"number"==typeof t.outputIndex&&(this.b=t.outputIndex)),this.a||(this.a=new(s?Uint8Array:Array)(32768))}y.prototype.getParent=function(r){return 2*((r-2)/4|0)},y.prototype.push=function(r,t){var e,i,n,s=this.buffer;for(e=this.length,s[this.length++]=t,s[this.length++]=r;0<e&&(i=this.getParent(e),s[e]>s[i]);)n=s[e],s[e]=s[i],s[i]=n,n=s[e+1],s[e+1]=s[i+1],s[i+1]=n,e=i;return this.length},y.prototype.pop=function(){var r,t,e,i,n,s=this.buffer;for(t=s[0],r=s[1],this.length-=2,s[0]=s[this.length],s[1]=s[this.length+1],n=0;!((i=2*n+2)>=this.length)&&(i+2<this.length&&s[i+2]>s[i]&&(i+=2),s[i]>s[n]);)e=s[n],s[n]=s[i],s[i]=e,e=s[n+1],s[n+1]=s[i+1],s[i+1]=e,n=i;return{index:r,value:t,length:this.length}};var w,p=2,b={NONE:0,r:1,k:p,N:3},v=[];for(w=0;288>w;w++)switch(!0){case 143>=w:v.push([w+48,8]);break;case 255>=w:v.push([w-144+400,9]);break;case 279>=w:v.push([w-256+0,7]);break;case 287>=w:v.push([w-280+192,8]);break;default:r("invalid literal: "+w)}function k(r,t){this.length=r,this.G=t}A.prototype.j=function(){var i,n,o,c,h=this.input;switch(this.h){case 0:for(o=0,c=h.length;o<c;){var f,u,l,y=n=s?h.subarray(o,o+65535):h.slice(o,o+65535),d=(o+=n.length)===c,A=t,w=t,b=this.a,k=this.b;if(s){for(b=new Uint8Array(this.a.buffer);b.length<=k+y.length+5;)b=new Uint8Array(b.length<<1);b.set(this.a)}if(f=d?1:0,b[k++]=0|f,l=65536+~(u=y.length)&65535,b[k++]=255&u,b[k++]=u>>>8&255,b[k++]=255&l,b[k++]=l>>>8&255,s)b.set(y,k),k+=y.length,b=b.subarray(0,k);else{for(A=0,w=y.length;A<w;++A)b[k++]=y[A];b.length=k}this.b=k,this.a=b}break;case 1:var m=new a(s?new Uint8Array(this.a.buffer):this.a,this.b);m.d(1,1,e),m.d(1,2,e);var U,E,T,F=g(this,h);for(U=0,E=F.length;U<E;U++)if(T=F[U],a.prototype.d.apply(m,v[T]),256<T)m.d(F[++U],F[++U],e),m.d(F[++U],5),m.d(F[++U],F[++U],e);else if(256===T)break;this.a=m.finish(),this.b=this.a.length;break;case p:var D,z,q,C,N,O,j,I,Z,S,$,_,V,B,L,P=new a(s?new Uint8Array(this.a.buffer):this.a,this.b),W=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],G=Array(19);for(D=p,P.d(1,1,e),P.d(D,2,e),z=g(this,h),j=M(O=x(this.L,15)),Z=M(I=x(this.K,7)),q=286;257<q&&0===O[q-1];q--);for(C=30;1<C&&0===I[C-1];C--);var H,R,Y,J,K,X,Q=q,rr=C,tr=new(s?Uint32Array:Array)(Q+rr),er=new(s?Uint32Array:Array)(316),ir=new(s?Uint8Array:Array)(19);for(H=R=0;H<Q;H++)tr[R++]=O[H];for(H=0;H<rr;H++)tr[R++]=I[H];if(!s)for(H=0,J=ir.length;H<J;++H)ir[H]=0;for(H=K=0,J=tr.length;H<J;H+=R){for(R=1;H+R<J&&tr[H+R]===tr[H];++R);if(Y=R,0===tr[H])if(3>Y)for(;0<Y--;)er[K++]=0,ir[0]++;else for(;0<Y;)(X=138>Y?Y:138)>Y-3&&X<Y&&(X=Y-3),10>=X?(er[K++]=17,er[K++]=X-3,ir[17]++):(er[K++]=18,er[K++]=X-11,ir[18]++),Y-=X;else if(er[K++]=tr[H],ir[tr[H]]++,3>--Y)for(;0<Y--;)er[K++]=tr[H],ir[tr[H]]++;else for(;0<Y;)(X=6>Y?Y:6)>Y-3&&X<Y&&(X=Y-3),er[K++]=16,er[K++]=X-3,ir[16]++,Y-=X}for(i=s?er.subarray(0,K):er.slice(0,K),S=x(ir,7),B=0;19>B;B++)G[B]=S[W[B]];for(N=19;4<N&&0===G[N-1];N--);for($=M(S),P.d(q-257,5,e),P.d(C-1,5,e),P.d(N-4,4,e),B=0;B<N;B++)P.d(G[B],3,e);for(B=0,L=i.length;B<L;B++)if(_=i[B],P.d($[_],S[_],e),16<=_){switch(B++,_){case 16:V=2;break;case 17:V=3;break;case 18:V=7;break;default:r("invalid code: "+_)}P.d(i[B],V,e)}var nr,sr,ar,or,cr,hr,fr,ur,lr=[j,O],yr=[Z,I];for(cr=lr[0],hr=lr[1],fr=yr[0],ur=yr[1],nr=0,sr=z.length;nr<sr;++nr)if(ar=z[nr],P.d(cr[ar],hr[ar],e),256<ar)P.d(z[++nr],z[++nr],e),or=z[++nr],P.d(fr[or],ur[or],e),P.d(z[++nr],z[++nr],e);else if(256===ar)break;this.a=P.finish(),this.b=this.a.length;break;default:r("invalid compression type")}return this.a};var m=function(){function t(t){switch(!0){case 3===t:return[257,t-3,0];case 4===t:return[258,t-4,0];case 5===t:return[259,t-5,0];case 6===t:return[260,t-6,0];case 7===t:return[261,t-7,0];case 8===t:return[262,t-8,0];case 9===t:return[263,t-9,0];case 10===t:return[264,t-10,0];case 12>=t:return[265,t-11,1];case 14>=t:return[266,t-13,1];case 16>=t:return[267,t-15,1];case 18>=t:return[268,t-17,1];case 22>=t:return[269,t-19,2];case 26>=t:return[270,t-23,2];case 30>=t:return[271,t-27,2];case 34>=t:return[272,t-31,2];case 42>=t:return[273,t-35,3];case 50>=t:return[274,t-43,3];case 58>=t:return[275,t-51,3];case 66>=t:return[276,t-59,3];case 82>=t:return[277,t-67,4];case 98>=t:return[278,t-83,4];case 114>=t:return[279,t-99,4];case 130>=t:return[280,t-115,4];case 162>=t:return[281,t-131,5];case 194>=t:return[282,t-163,5];case 226>=t:return[283,t-195,5];case 257>=t:return[284,t-227,5];case 258===t:return[285,t-258,0];default:r("invalid length: "+t)}}var e,i,n=[];for(e=3;258>=e;e++)i=t(e),n[e]=i[2]<<24|i[1]<<16|i[0];return n}(),U=s?new Uint32Array(m):m;function g(e,i){function n(t,e){var i,n,s,a,o=t.G,c=[],h=0;switch(i=U[t.length],c[h++]=65535&i,c[h++]=i>>16&255,c[h++]=i>>24,!0){case 1===o:n=[0,o-1,0];break;case 2===o:n=[1,o-2,0];break;case 3===o:n=[2,o-3,0];break;case 4===o:n=[3,o-4,0];break;case 6>=o:n=[4,o-5,1];break;case 8>=o:n=[5,o-7,1];break;case 12>=o:n=[6,o-9,2];break;case 16>=o:n=[7,o-13,2];break;case 24>=o:n=[8,o-17,3];break;case 32>=o:n=[9,o-25,3];break;case 48>=o:n=[10,o-33,4];break;case 64>=o:n=[11,o-49,4];break;case 96>=o:n=[12,o-65,5];break;case 128>=o:n=[13,o-97,5];break;case 192>=o:n=[14,o-129,6];break;case 256>=o:n=[15,o-193,6];break;case 384>=o:n=[16,o-257,7];break;case 512>=o:n=[17,o-385,7];break;case 768>=o:n=[18,o-513,8];break;case 1024>=o:n=[19,o-769,8];break;case 1536>=o:n=[20,o-1025,9];break;case 2048>=o:n=[21,o-1537,9];break;case 3072>=o:n=[22,o-2049,10];break;case 4096>=o:n=[23,o-3073,10];break;case 6144>=o:n=[24,o-4097,11];break;case 8192>=o:n=[25,o-6145,11];break;case 12288>=o:n=[26,o-8193,12];break;case 16384>=o:n=[27,o-12289,12];break;case 24576>=o:n=[28,o-16385,13];break;case 32768>=o:n=[29,o-24577,13];break;default:r("invalid distance")}for(i=n,c[h++]=i[0],c[h++]=i[1],c[h++]=i[2],s=0,a=c.length;s<a;++s)w[p++]=c[s];v[c[0]]++,k[c[3]]++,b=t.length+e-1,y=null}var a,o,c,h,f,u,l,y,d,A={},w=s?new Uint16Array(2*i.length):[],p=0,b=0,v=new(s?Uint32Array:Array)(286),k=new(s?Uint32Array:Array)(30),m=e.w;if(!s){for(c=0;285>=c;)v[c++]=0;for(c=0;29>=c;)k[c++]=0}for(v[256]=1,a=0,o=i.length;a<o;++a){for(c=f=0,h=3;c<h&&a+c!==o;++c)f=f<<8|i[a+c];if(A[f]===t&&(A[f]=[]),u=A[f],!(0<b--)){for(;0<u.length&&32768<a-u[0];)u.shift();if(a+3>=o){for(y&&n(y,-1),c=0,h=o-a;c<h;++c)d=i[a+c],w[p++]=d,++v[d];break}0<u.length?(l=E(i,a,u),y?y.length<l.length?(d=i[a-1],w[p++]=d,++v[d],n(l,0)):n(y,-1):l.length<m?y=l:n(l,0)):y?n(y,-1):(d=i[a],w[p++]=d,++v[d])}u.push(a)}return w[p++]=256,v[256]++,e.L=v,e.K=k,s?w.subarray(0,p):w}function E(r,t,e){var i,n,s,a,o,c,h=0,f=r.length;a=0,c=e.length;r:for(;a<c;a++){if(i=e[c-a-1],s=3,3<h){for(o=h;3<o;o--)if(r[i+o-1]!==r[t+o-1])continue r;s=h}for(;258>s&&t+s<f&&r[i+s]===r[t+s];)++s;if(s>h&&(n=i,h=s),258===s)break}return new k(h,t-n)}function x(r,t){var e,i,n,a,o,c=r.length,h=new y(572),f=new(s?Uint8Array:Array)(c);if(!s)for(a=0;a<c;a++)f[a]=0;for(a=0;a<c;++a)0<r[a]&&h.push(a,r[a]);if(e=Array(h.length/2),i=new(s?Uint32Array:Array)(h.length/2),1===e.length)return f[h.pop().index]=1,f;for(a=0,o=h.length/2;a<o;++a)e[a]=h.pop(),i[a]=e[a].value;for(n=function(r,t,e){function i(r){var e=d[r][A[r]];e===t?(i(r+1),i(r+1)):--l[e],++A[r]}var n,a,o,c,h,f=new(s?Uint16Array:Array)(e),u=new(s?Uint8Array:Array)(e),l=new(s?Uint8Array:Array)(t),y=Array(e),d=Array(e),A=Array(e),w=(1<<e)-t,p=1<<e-1;for(f[e-1]=t,a=0;a<e;++a)w<p?u[a]=0:(u[a]=1,w-=p),w<<=1,f[e-2-a]=(f[e-1-a]/2|0)+t;for(f[0]=u[0],y[0]=Array(f[0]),d[0]=Array(f[0]),a=1;a<e;++a)f[a]>2*f[a-1]+u[a]&&(f[a]=2*f[a-1]+u[a]),y[a]=Array(f[a]),d[a]=Array(f[a]);for(n=0;n<t;++n)l[n]=e;for(o=0;o<f[e-1];++o)y[e-1][o]=r[o],d[e-1][o]=o;for(n=0;n<e;++n)A[n]=0;for(1===u[e-1]&&(--l[0],++A[e-1]),a=e-2;0<=a;--a){for(c=n=0,h=A[a+1],o=0;o<f[a];o++)(c=y[a+1][h]+y[a+1][h+1])>r[n]?(y[a][o]=c,d[a][o]=t,h+=2):(y[a][o]=r[n],d[a][o]=n,++n);A[a]=0,1===u[a]&&i(a)}return l}(i,i.length,t),a=0,o=e.length;a<o;++a)f[e[a].index]=n[a];return f}function M(r){var t,e,i,n,a=new(s?Uint16Array:Array)(r.length),o=[],c=[],h=0;for(t=0,e=r.length;t<e;t++)o[r[t]]=1+(0|o[r[t]]);for(t=1,e=16;t<=e;t++)c[t]=h,h+=0|o[t],h<<=1;for(t=0,e=r.length;t<e;t++)for(h=c[r[t]],c[r[t]]+=1,i=a[t]=0,n=r[t];i<n;i++)a[t]=a[t]<<1|1&h,h>>>=1;return a}function T(t,e){switch(this.l=[],this.m=32768,this.e=this.g=this.c=this.q=0,this.input=s?new Uint8Array(t):t,this.s=!1,this.n=D,this.B=!1,!e&&(e={})||(e.index&&(this.c=e.index),e.bufferSize&&(this.m=e.bufferSize),e.bufferType&&(this.n=e.bufferType),e.resize&&(this.B=e.resize)),this.n){case F:this.b=32768,this.a=new(s?Uint8Array:Array)(32768+this.m+258);break;case D:this.b=0,this.a=new(s?Uint8Array:Array)(this.m),this.f=this.J,this.t=this.H,this.o=this.I;break;default:r(Error("invalid inflate mode"))}}var F=0,D=1,z={D:F,C:D};T.prototype.p=function(){for(;!this.s;){var i=Y(this,3);switch(1&i&&(this.s=e),i>>>=1){case 0:var n=this.input,a=this.c,o=this.a,c=this.b,h=n.length,f=t,u=o.length,l=t;switch(this.e=this.g=0,a+1>=h&&r(Error("invalid uncompressed block header: LEN")),f=n[a++]|n[a++]<<8,a+1>=h&&r(Error("invalid uncompressed block header: NLEN")),f===~(n[a++]|n[a++]<<8)&&r(Error("invalid uncompressed block header: length verify")),a+f>n.length&&r(Error("input buffer is broken")),this.n){case F:for(;c+f>o.length;){if(f-=l=u-c,s)o.set(n.subarray(a,a+l),c),c+=l,a+=l;else for(;l--;)o[c++]=n[a++];this.b=c,o=this.f(),c=this.b}break;case D:for(;c+f>o.length;)o=this.f({v:2});break;default:r(Error("invalid inflate mode"))}if(s)o.set(n.subarray(a,a+f),c),c+=f,a+=f;else for(;f--;)o[c++]=n[a++];this.c=a,this.b=c,this.a=o;break;case 1:this.o(G,R);break;case 2:var y,A,w,p,b=Y(this,5)+257,v=Y(this,5)+1,k=Y(this,4)+4,m=new(s?Uint8Array:Array)(O.length),U=t,g=t,E=t,x=t,M=t;for(M=0;M<k;++M)m[O[M]]=Y(this,3);if(!s)for(M=k,k=m.length;M<k;++M)m[O[M]]=0;for(y=d(m),U=new(s?Uint8Array:Array)(b+v),M=0,p=b+v;M<p;)switch(g=J(this,y),g){case 16:for(x=3+Y(this,2);x--;)U[M++]=E;break;case 17:for(x=3+Y(this,3);x--;)U[M++]=0;E=0;break;case 18:for(x=11+Y(this,7);x--;)U[M++]=0;E=0;break;default:E=U[M++]=g}A=d(s?U.subarray(0,b):U.slice(0,b)),w=d(s?U.subarray(b):U.slice(b)),this.o(A,w);break;default:r(Error("unknown BTYPE: "+i))}}return this.t()};var q,C,N=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],O=s?new Uint16Array(N):N,j=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],I=s?new Uint16Array(j):j,Z=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],S=s?new Uint8Array(Z):Z,$=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],_=s?new Uint16Array($):$,V=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],B=s?new Uint8Array(V):V,L=new(s?Uint8Array:Array)(288);for(q=0,C=L.length;q<C;++q)L[q]=143>=q?8:255>=q?9:279>=q?7:8;var P,W,G=d(L),H=new(s?Uint8Array:Array)(30);for(P=0,W=H.length;P<W;++P)H[P]=5;var R=d(H);function Y(t,e){for(var i,n=t.g,s=t.e,a=t.input,o=t.c,c=a.length;s<e;)o>=c&&r(Error("input buffer is broken")),n|=a[o++]<<s,s+=8;return i=n&(1<<e)-1,t.g=n>>>e,t.e=s-e,t.c=o,i}function J(t,e){for(var i,n,s=t.g,a=t.e,o=t.input,c=t.c,h=o.length,f=e[0],u=e[1];a<u&&!(c>=h);)s|=o[c++]<<a,a+=8;return(n=(i=f[s&(1<<u)-1])>>>16)>a&&r(Error("invalid code length: "+n)),t.g=s>>n,t.e=a-n,t.c=c,65535&i}function K(r){if("string"==typeof r){var t,e,i=r.split("");for(t=0,e=i.length;t<e;t++)i[t]=(255&i[t].charCodeAt(0))>>>0;r=i}for(var n,s=1,a=0,o=r.length,c=0;0<o;){o-=n=1024<o?1024:o;do{a+=s+=r[c++]}while(--n);s%=65521,a%=65521}return(a<<16|s)>>>0}function X(t,e){var i,n;switch(this.input=t,this.c=0,!e&&(e={})||(e.index&&(this.c=e.index),e.verify&&(this.M=e.verify)),i=t[this.c++],n=t[this.c++],15&i){case Q:this.method=Q;break;default:r(Error("unsupported compression method"))}0!=((i<<8)+n)%31&&r(Error("invalid fcheck flag:"+((i<<8)+n)%31)),32&n&&r(Error("fdict flag is not supported")),this.A=new T(t,{index:this.c,bufferSize:e.bufferSize,bufferType:e.bufferType,resize:e.resize})}T.prototype.o=function(r,t){var e=this.a,i=this.b;this.u=r;for(var n,s,a,o,c=e.length-258;256!==(n=J(this,r));)if(256>n)i>=c&&(this.b=i,e=this.f(),i=this.b),e[i++]=n;else for(o=I[s=n-257],0<S[s]&&(o+=Y(this,S[s])),n=J(this,t),a=_[n],0<B[n]&&(a+=Y(this,B[n])),i>=c&&(this.b=i,e=this.f(),i=this.b);o--;)e[i]=e[i++-a];for(;8<=this.e;)this.e-=8,this.c--;this.b=i},T.prototype.I=function(r,t){var e=this.a,i=this.b;this.u=r;for(var n,s,a,o,c=e.length;256!==(n=J(this,r));)if(256>n)i>=c&&(c=(e=this.f()).length),e[i++]=n;else for(o=I[s=n-257],0<S[s]&&(o+=Y(this,S[s])),n=J(this,t),a=_[n],0<B[n]&&(a+=Y(this,B[n])),i+o>c&&(c=(e=this.f()).length);o--;)e[i]=e[i++-a];for(;8<=this.e;)this.e-=8,this.c--;this.b=i},T.prototype.f=function(){var r,t,e=new(s?Uint8Array:Array)(this.b-32768),i=this.b-32768,n=this.a;if(s)e.set(n.subarray(32768,e.length));else for(r=0,t=e.length;r<t;++r)e[r]=n[r+32768];if(this.l.push(e),this.q+=e.length,s)n.set(n.subarray(i,i+32768));else for(r=0;32768>r;++r)n[r]=n[i+r];return this.b=32768,n},T.prototype.J=function(r){var t,e,i,n=this.input.length/this.c+1|0,a=this.input,o=this.a;return r&&("number"==typeof r.v&&(n=r.v),"number"==typeof r.F&&(n+=r.F)),2>n?e=(i=(a.length-this.c)/this.u[2]/2*258|0)<o.length?o.length+i:o.length<<1:e=o.length*n,s?(t=new Uint8Array(e)).set(o):t=o,this.a=t},T.prototype.t=function(){var r,t,e,i,n,a=0,o=this.a,c=this.l,h=new(s?Uint8Array:Array)(this.q+(this.b-32768));if(0===c.length)return s?this.a.subarray(32768,this.b):this.a.slice(32768,this.b);for(t=0,e=c.length;t<e;++t)for(i=0,n=(r=c[t]).length;i<n;++i)h[a++]=r[i];for(t=32768,e=this.b;t<e;++t)h[a++]=o[t];return this.l=[],this.buffer=h},T.prototype.H=function(){var r,t=this.b;return s?this.B?(r=new Uint8Array(t)).set(this.a.subarray(0,t)):r=this.a.subarray(0,t):(this.a.length>t&&(this.a.length=t),r=this.a),this.buffer=r},X.prototype.p=function(){var t,e=this.input;return t=this.A.p(),this.c=this.A.c,this.M&&((e[this.c++]<<24|e[this.c++]<<16|e[this.c++]<<8|e[this.c++])>>>0!==K(t)&&r(Error("invalid adler-32 checksum"))),t};var Q=8;function rr(r,t){this.input=r,this.a=new(s?Uint8Array:Array)(32768),this.h=tr.k;var e,i={};for(e in!t&&(t={})||"number"!=typeof t.compressionType||(this.h=t.compressionType),t)i[e]=t[e];i.outputBuffer=this.a,this.z=new A(this.input,i)}var tr=b;function er(r,t){var e,i,s,a;if(Object.keys)e=Object.keys(t);else for(i in e=[],s=0,t)e[s++]=i;for(s=0,a=e.length;s<a;++s)n(r+"."+(i=e[s]),t[i])}rr.prototype.j=function(){var t,e,i,n,a,o,c,h=0;switch(c=this.a,t=Q){case Q:e=Math.LOG2E*Math.log(32768)-8;break;default:r(Error("invalid compression method"))}switch(i=e<<4|t,c[h++]=i,t){case Q:switch(this.h){case tr.NONE:a=0;break;case tr.r:a=1;break;case tr.k:a=2;break;default:r(Error("unsupported compression type"))}break;default:r(Error("invalid compression method"))}return n=a<<6|0,c[h++]=n|31-(256*i+n)%31,o=K(this.input),this.z.b=h,h=(c=this.z.j()).length,s&&((c=new Uint8Array(c.buffer)).length<=h+4&&(this.a=new Uint8Array(c.length+4),this.a.set(c),c=this.a),c=c.subarray(0,h+4)),c[h++]=o>>24&255,c[h++]=o>>16&255,c[h++]=o>>8&255,c[h++]=255&o,c},n("Zlib.Inflate",X),n("Zlib.Inflate.prototype.decompress",X.prototype.p),er("Zlib.Inflate.BufferType",{ADAPTIVE:z.C,BLOCK:z.D}),n("Zlib.Deflate",rr),n("Zlib.Deflate.compress",(function(r,t){return new rr(r,t).j()})),n("Zlib.Deflate.prototype.compress",rr.prototype.j),er("Zlib.Deflate.CompressionType",{NONE:tr.NONE,FIXED:tr.r,DYNAMIC:tr.k})}.call(self);class c{constructor(r=257){this.gridSize=r;const t=r-1;if(t&t-1)throw new Error(\`Expected grid size to be 2^n+1, got ${e}r}.\`);this.numTriangles=t*t*2-2,this.numParentTriangles=this.numTriangles-t*t,this.indices=new Uint32Array(this.gridSize*this.gridSize),this.coords=new Uint16Array(4*this.numTriangles);for(let r=0;r<this.numTriangles;r++){let e=r+2,i=0,n=0,s=0,a=0,o=0,c=0;for(1&e?s=a=o=t:i=n=c=t;(e>>=1)>1;){const r=i+s>>1,t=n+a>>1;1&e?(s=i,a=n,i=o,n=c):(i=s,n=a,s=o,a=c),o=r,c=t}const h=4*r;this.coords[h+0]=i,this.coords[h+1]=n,this.coords[h+2]=s,this.coords[h+3]=a}}createTile(r){return new h(r,this)}}class h{constructor(r,t){const e=t.gridSize;if(r.length!==e*e)throw new Error(\`Expected terrain data of length ${e}e*e} (${e}e} x ${e}e}), got ${e}r.length}.\`);this.terrain=r,this.martini=t,this.errors=new Float32Array(r.length),this.update()}update(){const{numTriangles:r,numParentTriangles:t,coords:e,gridSize:i}=this.martini,{terrain:n,errors:s}=this;for(let a=r-1;a>=0;a--){const r=4*a,o=e[r+0],c=e[r+1],h=e[r+2],f=e[r+3],u=o+h>>1,l=c+f>>1,y=u+l-c,d=l+o-u,A=(n[c*i+o]+n[f*i+h])/2,w=l*i+u,p=Math.abs(A-n[w]);if(s[w]=Math.max(s[w],p),a<t){const r=(c+d>>1)*i+(o+y>>1),t=(f+d>>1)*i+(h+y>>1);s[w]=Math.max(s[w],s[r],s[t])}}}getMesh(r=0){const{gridSize:t,indices:e}=this.martini,{errors:i}=this;let n=0,s=0;const a=t-1;function o(a,c,h,f,u,l){const y=a+h>>1,d=c+f>>1;Math.abs(a-u)+Math.abs(c-l)>1&&i[d*t+y]>r?(o(u,l,a,c,y,d),o(h,f,u,l,y,d)):(e[c*t+a]=e[c*t+a]||++n,e[f*t+h]=e[f*t+h]||++n,e[l*t+u]=e[l*t+u]||++n,s++)}e.fill(0),o(0,0,a,a,a,0),o(a,a,0,0,0,a);const c=new Uint16Array(2*n),h=new Uint32Array(3*s);let f=0;function u(n,s,a,o,l,y){const d=n+a>>1,A=s+o>>1;if(Math.abs(n-l)+Math.abs(s-y)>1&&i[A*t+d]>r)u(l,y,n,s,d,A),u(a,o,l,y,d,A);else{const r=e[s*t+n]-1,i=e[o*t+a]-1,u=e[y*t+l]-1;c[2*r]=n,c[2*r+1]=s,c[2*i]=a,c[2*i+1]=o,c[2*u]=l,c[2*u+1]=y,h[f++]=r,h[f++]=i,h[f++]=u}}return u(0,0,a,a,a,0),u(a,a,0,0,0,a),{vertices:c,triangles:h}}getMeshWithSkirts(r=0){const{gridSize:t,indices:e}=this.martini,{errors:i}=this;let n=0,s=0;const a=t-1;let o,c,h=0;const f=[],u=[],l=[],y=[];function d(A,w,p,b,v,k){const m=A+p>>1,U=w+b>>1;Math.abs(A-v)+Math.abs(w-k)>1&&i[U*t+m]>r?(d(v,k,A,w,m,U),d(p,b,v,k,m,U)):(o=w*t+A,c=b*t+p,h=k*t+v,0===e[o]&&(0===A?f.push(n):A===a&&u.push(n),0===w?l.push(n):w===a&&y.push(n),e[o]=++n),0===e[c]&&(0===p?f.push(n):p===a&&u.push(n),0===b?l.push(n):b===a&&y.push(n),e[c]=++n),0===e[h]&&(0===v?f.push(n):v===a&&u.push(n),0===k?l.push(n):k===a&&y.push(n),e[h]=++n),s++)}e.fill(0),d(0,0,a,a,a,0),d(a,a,0,0,0,a);const A=2*(n+f.length+u.length+l.length+y.length),w=3*(s+2*(f.length-1)+2*(u.length-1)+2*(l.length-1)+2*(y.length-1)),p=new Uint16Array(A),b=new Uint32Array(w);let v=0;function k(n,s,a,o,c,h){const f=n+a>>1,u=s+o>>1;if(Math.abs(n-c)+Math.abs(s-h)>1&&i[u*t+f]>r)k(c,h,n,s,f,u),k(a,o,c,h,f,u);else{const r=e[s*t+n]-1,i=e[o*t+a]-1,f=e[h*t+c]-1;p[2*r]=n,p[2*r+1]=s,p[2*i]=a,p[2*i+1]=o,p[2*f]=c,p[2*f+1]=h,b[v++]=r,b[v++]=i,b[v++]=f}}k(0,0,a,a,a,0),k(a,a,0,0,0,a),f.sort((r,t)=>p[2*r+1]-p[2*t+1]),u.sort((r,t)=>p[2*t+1]-p[2*r+1]),l.sort((r,t)=>p[2*t]-p[2*r]),y.sort((r,t)=>p[2*r]-p[2*t]);let m,U,g,E,x=2*n,M=0;function T(r){M=r.length;for(let t=0;t<M-1;t++)m=r[t],U=r[t+1],g=x/2,E=(x+2)/2,p[x++]=p[2*m],p[x++]=p[2*m+1],b[v++]=m,b[v++]=g,b[v++]=U,b[v++]=g,b[v++]=E,b[v++]=U;p[x++]=p[2*r[M-1]],p[x++]=p[2*r[M-1]+1]}return T(f),T(u),T(l),T(y),{vertices:p,triangles:b,numVerticesWithoutSkirts:n,numTriangles:s}}}let f;const u=new OffscreenCanvas(514,514),l=u.getContext("2d",{willReadFrequently:!0}),y={},d=64,A=64,w=3,p=-1e3,b=.001,v=256,k=4,m=.002,U={cesium_request_token:{Accept:"application/json,*/*;q=0.01","Accept-Encoding":"gzip, deflate, br"},tianditu:{"Accept-Encoding":"gzip, deflate, br"},cesium:{"Accept-Encoding":"gzip, deflate, br",Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01"},mapbox:{Accept:"image/webp,*/*"}};let g=null;function E(r){const t=new DataView(r),e=new Uint8Array(t.byteLength);let i=0;for(;i<t.byteLength;)e[i]=t.getUint8(i,!0),i++;return function(r){const t=d,e=A,i=t+1,n=e+1,s=w,a=p,o=b,c=v,h=m,f=new Float32Array(i*n);let u=0;for(let l=0;l<i;l++){const i=l>=e?e-1:l;for(let e=0;e<n;e++){let n=0;const l=i*(4*t)+4*(e>=t?t-1:e);for(let t=0;t<s;t++)n=n*c+r[l+t];n=1*(n*o+a),n-=h,f[u]=n,u++}}return f}(function(r){const t=r,e=d,i=A,n=new Uint8Array(e*i*k);let s,a,o,c,h;for(let r=0;r<i;r++)for(let f=0;f<e;f++){c=parseInt(149*r/(i-1)),h=parseInt(149*f/(e-1)),a=2*(150*c+h),s=t[a]+256*t[a+1],(s>1e4||s<-2e3)&&(s=0),o=4*(r*e+f);const u=(s+1e3)/b,l=v;n[o]=u/(l*l),n[o+1]=(u-n[o]*l*l)/l,n[o+2]=u-n[o]*l*l-n[o+1]*l,n[o+3]=255}return n}(function(r){if(r.length<1e3)return;const t=new Zlib.Inflate(r);return t?t.decompress():void 0}(e)))}function x(r){return r>>1^-(1&r)}function M(r){let t=0;const e=3*Float64Array.BYTES_PER_ELEMENT,i=4*Float64Array.BYTES_PER_ELEMENT,n=3*Uint16Array.BYTES_PER_ELEMENT;let s=Uint16Array.BYTES_PER_ELEMENT;const a=new DataView(r);t+=e;const o=a.getFloat32(t,!0);t+=Float32Array.BYTES_PER_ELEMENT;const c=a.getFloat32(t,!0);t+=Float32Array.BYTES_PER_ELEMENT,t+=i,t+=e;const h=a.getUint32(t,!0);t+=Uint32Array.BYTES_PER_ELEMENT;const f=new Uint16Array(r,t,3*h);t+=h*n,h>65536&&(s=Uint32Array.BYTES_PER_ELEMENT);!function(r,t,e){const i=r.length;let n=0,s=0,a=0;for(let o=0;o<i;++o)n+=x(r[o]),s+=x(t[o]),r[o]=n,t[o]=s,e&&(a+=x(e[o]),e[o]=a)}(f.subarray(0,h),f.subarray(h,2*h),f.subarray(2*h,3*h)),t%s!=0&&(t+=s-t%s);const u=a.getUint32(t,!0);t+=Uint32Array.BYTES_PER_ELEMENT;const l=h>65536?new Uint32Array(r,t,3*u):new Uint16Array(r,t,3*u);let y=0;const d=l.length;for(let r=0;r<d;++r){const t=l[r];l[r]=y-t,0===t&&++y}const A={minimumHeight:o,maximumHeight:c,quantizedVertices:f,indices:l}.quantizedVertices,w=A.length/3,p=A.subarray(0,w),b=A.subarray(w,2*w),v=A.subarray(2*w,3*w),k=new Float32Array(3*w),m=new Float32Array(2*w);for(let r=0;r<w;++r){const t=p[r]/32767,e=b[r]/32767,i=(U=o,g=c,(1-(E=v[r]/32767))*U+E*g);m[2*r]=t,m[2*r+1]=1-e,k[3*r]=256*t,k[3*r+1]=256*-(1-e),k[3*r+2]=i}var U,g,E;return{positions:k,texcoords:m,triangles:l}}function T(r,t,e,i,n,s,a){"cesium"===e&&(t={"Accept-Encoding":"gzip, deflate, br",Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01",Authorization:"Bearer "+g}),function(r,t,e){const i={method:"GET",referrer:e,headers:t},n=o.getArrayBuffer(r,i),s=n.xhr;return y[r]=s,n.then(t=>(delete y[r],t))}(r,t,origin).then(r=>{if(!r||r.message)a({error:r||{canceled:!0}});else{const t=r.data;let o=null;if("tianditu"===e){o=E(t);const e=z(n,o,i);r.transferables.push(e.positions.buffer,e.texcoords.buffer,e.triangles.buffer),a({data:o,mesh:e},r.transferables)}else if("cesium"===e){o=M(t);const r=[o.positions.buffer,o.texcoords.buffer,o.triangles.buffer];a(o,r)}else"mapbox"===e&&(o=function(r){const t=new self.Blob([new Uint8Array(r)],{type:"image/png"});return self.createImageBitmap(t)}(t),o.then(r=>{const t=function(r){const{width:t,height:e}=r;return u.width=t,u.height=e,l.drawImage(r,0,0,t,e),l.getImageData(0,0,t,e)}(r),e=D(t,i);F(n,e,i,s,t,!0,a)}))}}).catch(t=>{delete y[r],a({error:t})})}function F(r,t,e,i,n,s,a){const o=z(r,t.data,e),c=[o.positions.buffer,o.texcoords.buffer,o.triangles.buffer],h={mesh:o};if(s)if(h.data=t,i){const r=D(n,n.width+1);h.data=r,c.push(r.data.buffer)}else c.push(t.data.buffer);a(h,c)}function D(r,t){const{data:e,width:i}=r;let n=1/0,s=-1/0;const a=new Float32Array(t*t),o=Math.round(i/t),c=t-1-1;for(let r=0;r<t;r++)for(let h=0;h<t;h++){const f=r+h*t;let u=0,l=0,y=r,d=h;y>=c&&(y=c),d>=c&&(d=c);for(let r=0;r<o;r++)for(let t=0;t<o;t++){const n=y*o+r+(d*o+t)*i,s=e[4*n],a=e[4*n+1],c=e[4*n+2];0===e[4*n+3]?l+=1:u+=.1*(256*s*256+256*a+c)-1e4}u/=o*o-l||1,u>s&&(s=u),u<n&&(n=u),a[f]=u}return{data:a,width:t,height:t,min:n,max:s}}function z(r,t,e){const i=new c(e).createTile(t).getMesh(r),{triangles:n,vertices:s}=i,a=[],o=[];for(let r=0;r<s.length/2;r++){const i=s[2*r],n=s[2*r+1];a.push(1*i),a.push(1*-n),a.push(t[n*e+i]),o.push(i/e),o.push(n/e)}return{positions:new Float32Array(a),texcoords:new Float32Array(o),triangles:n}}const q={};r.initialize=function(){},r.onmessage=function(r,t){const e=r.data;if("addLayer"===e.command||"removeLayer"===e.command)f=r.workerId,self.postMessage({type:"<response>",actorId:e.actorId,workerId:f,params:"ok",callback:r.callback});else if("createTerrainMesh"===e.command){const{error:r,terrainHeights:i,terrainWidth:n}=e.params;let s=i;i.width!==n&&(s=function(r,t){const{data:e,width:i}=r,n=q[t]=q[t]||new Float32Array(t*t);let s=1/0,a=-1/0;const o=i>t?Math.round(i/t):Math.round(t/i),c=t-1;for(let r=0;r<t;r++)for(let h=0;h<t;h++){const f=r+h*t;let u=0,l=r,y=h;if(l>=c&&(l=c),y>=c&&(y=c),i>t){for(let r=0;r<o;r++)for(let t=0;t<o;t++){u+=e[l*o+r+(y*o+t)*i]}u/=o*o||1}else{u=e[Math.floor(l/o)+Math.floor(y/o)*i]}u>a&&(a=u),u<s&&(s=u),n[f]=u}return{data:n,width:t,height:t,min:s,max:a}}(i,n)),F(r,s,n,null,null,!1,(r,e)=>{r.data=i,e.push(i.data.buffer),t(r.error,r,e)})}else"fetchTerrain"===e.command?function(r,t){const{url:e,origin:i,type:n,accessToken:s,terrainWidth:a,error:o,maxAvailable:c}=r,h=r.headers||U[n];if("tianditu"===n)T(e,h,n,a,o,c,t);else if("cesium"===n){const r="https://api.cesium.com/v1/assets/1/endpoint?access_token="+s;g?T(e,h,n,a,o,c,t):fetch(r,{responseType:"json",method:"GET",referrer:i,headers:{Accept:"application/json,*/*;q=0.01","Accept-Encoding":"gzip, deflate, br"}}).then(r=>r.json()).then(r=>{g=r.accessToken,T(e,h,n,a,o,c,t)})}else"mapbox"===n&&T(e,h,n,a,o,c,t)}(e.params,(r,e)=>{t(r.error,r,e)}):"abortTerrain"===e.command&&(i=e.params.url,y[i]&&(y[i].abort(),delete y[i]));var i}}`;

	t__namespace.registerWorkerAdapter('@maptalks/terrain', code);

	exports.GLContext = i;
	exports.GroundPainter = xt;
	exports.GroupGLLayer = Vi;
	exports.HeatmapProcess = oe;
	exports.HighlightUtil = re;
	exports.MaskLayerMixin = le;
	exports.MaskRendererMixin = ue;
	exports.createREGL = p$2;
	exports.glMatrix = common;
	exports.mat2 = mat2;
	exports.mat2d = mat2d;
	exports.mat3 = mat3;
	exports.mat4 = mat4;
	exports.quat = quat;
	exports.quat2 = quat2;
	exports.reshader = reshadergl;
	exports.transcoders = transcoders;
	exports.vec2 = vec2;
	exports.vec3 = vec3;
	exports.vec4 = vec4;

	Object.defineProperty(exports, '__esModule', { value: true });

	typeof console !== 'undefined' && console.log('@maptalks/gl v0.81.2');

}));
